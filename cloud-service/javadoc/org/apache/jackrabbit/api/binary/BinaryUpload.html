<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14) on Mon Dec 05 15:20:33 UTC 2022 -->
<title>BinaryUpload (The Adobe Experience Manager SDK 2022.11.9850.20221116T162329Z-220900)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-12-05">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="BinaryUpload (The Adobe Experience Manager SDK 2022.11.9850.20221116T162329Z-220900)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":6,"i2":6,"i3":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.jackrabbit.api.binary</a></div>
<h2 title="Interface BinaryUpload" class="title">Interface BinaryUpload</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre><a href="../../../../osgi/annotation/versioning/ProviderType.html" title="annotation in org.osgi.annotation.versioning">@ProviderType</a>
public interface <span class="typeNameLabel">BinaryUpload</span></pre>
<div class="block">Describes uploading a binary through HTTP requests in a single or multiple
 parts. This will be returned by
 <a href="../JackrabbitValueFactory.html#initiateBinaryUpload(long,int)"><code>JackrabbitValueFactory.initiateBinaryUpload(long, int)</code></a>. A high-level
 overview of the process can be found in <a href="../JackrabbitValueFactory.html" title="interface in org.apache.jackrabbit.api"><code>JackrabbitValueFactory</code></a>.

 <p>
 Note that although the API allows URI schemes other than "http(s)", the
 upload functionality is currently only defined for HTTP.

 <p>
 A caller usually needs to pass the information provided by this interface to
 a remote client that is in possession of the actual binary, who then has to
 upload the binary using HTTP according to the logic described below. A remote
 client is expected to support multi-part uploads as per the logic described
 below, in case multiple URIs are returned.

 <p>
 Once a remote client finishes uploading the binary data, the application must
 be notified and must then call
 <a href="../JackrabbitValueFactory.html#completeBinaryUpload(java.lang.String)"><code>JackrabbitValueFactory.completeBinaryUpload(String)</code></a> to complete the
 upload. This completion requires the exact upload token obtained from
 <a href="#getUploadToken()"><code>getUploadToken()</code></a>.

 <h2 id="upload.algorithm">Upload algorithm</h2>

 A remote client will have to follow this algorithm to upload a binary based
 on the information provided by this interface.

 <p>
 Please be aware that if the size passed to
 <a href="../JackrabbitValueFactory.html#initiateBinaryUpload(long,int)"><code>JackrabbitValueFactory.initiateBinaryUpload(long, int)</code></a> was an
 estimation, but the actual binary is larger, there is no guarantee the
 upload will be possible using all <a href="#getUploadURIs()"><code>getUploadURIs()</code></a> and the
 <a href="#getMaxPartSize()"><code>getMaxPartSize()</code></a>. In such cases, the application should restart the
 transaction using the correct size.

 <h3>Variables used</h3>
 <ul>
     <li><code>fileSize</code>: the actual binary size (must be known at this
     point)</li>
     <li><code>minPartSize</code>: the value from <a href="#getMinPartSize()"><code>getMinPartSize()</code></a></li>
     <li><code>maxPartSize</code>: the value from <a href="#getMaxPartSize()"><code>getMaxPartSize()</code></a></li>
     <li><code>numUploadURIs</code>: the number of entries in <a href="#getUploadURIs()"><code>getUploadURIs()</code></a></li>
     <li><code>uploadURIs</code>: the entries in <a href="#getUploadURIs()"><code>getUploadURIs()</code></a></li>
     <li><code>partSize</code>: the part size to be used in the upload (to be
     determined in the algorithm)</li>
 </ul>

 <h3>Steps</h3>
 <ol>
     <li>
         If <code>(fileSize / maxPartSize) &gt; numUploadURIs</code>, then the client
         cannot proceed and will have to request a new set of URIs with the
         right fileSize as <code>maxSize</code>.
     </li>
     <li>
         Calculate the <code>partSize</code> and the number of URIs to use.
         <br>
         The easiest way to do this is to use the <code>maxPartSize</code> as the
         value for <code>partSize</code>.  As long as the size of the actual binary
         upload is less than or equal to the size passed to
         <a href="../JackrabbitValueFactory.html#initiateBinaryUpload(long,int)"><code>JackrabbitValueFactory.initiateBinaryUpload(long, int)</code></a>, a
         non-null BinaryUpload object returned from that call means you are
         guaranteed to be able to upload the binary successfully, using the
         provided <code>uploadURIs</code>, so long as the value you use for
         <code>partSize</code> is <code>maxPartSize</code>.
         Note that it is not required to use of all the URIs provided in
         <code>uploadURIs</code> if not all URIs are required to upload the entire
         binary with the selected <code>partSize</code>.
         <br>
         However, there are some exceptions to consider:
         <ol>
             <li>
                 If <code>fileSize &lt; minPartSize</code>, then take the first
                 provided upload URI to upload the entire binary, with
                 <code>partSize = fileSize</code>.  Note that it is not required to
                 use all of the URIs provided in <code>uploadURIs</code>.
             </li>
             <li>
                 If <code>fileSize / partSize == numUploadURIs</code>, all part
                 URIs must to be used. The <code>partSize</code> to use for all
                 parts except the last would be calculated using:
                 <pre>partSize = (fileSize + numUploadURIs - 1) / numUploadURIs</pre>
                 It is also possible to simply use <code>maxPartSize</code> as the
                 value for <code>partSize</code> in this case, for every part
                 except the last.
             </li>
         </ol>
         Optionally, a client may select a different <code>partSize</code>,
         for example if the client has more information about the
         conditions of the network or other information that would
         make a different <code>partSize</code> preferable.  In this case a
         different value may be chosen, under the condition that all
         of the following are true:
         <ol>
             <li><code>partSize &gt;= minPartSize</code></li>
             <li><code>partSize &lt;= maxPartSize</code>
             (unless <code>maxPartSize = -1</code> meaning unlimited)</li>
             <li><code>partSize &gt; (fileSize / numUploadURIs)</code></li>
         </ol>
     </li>
     <li>
         Upload: segment the binary into <code>partSize</code>, for each segment
         take the next URI from <code>uploadURIs</code> (strictly in order),
         proceed with a standard HTTP PUT for each, and for the last part use
         whatever segment size is left.
     </li>
     <li>
         If a segment fails during upload, retry (up to a certain timeout).
     </li>
     <li>
         After the upload has finished successfully, notify the application,
         for example through a complete request, passing the <a href="#getUploadToken()"><code>upload token</code></a>, and the application will call <a href="../JackrabbitValueFactory.html#completeBinaryUpload(java.lang.String)"><code>JackrabbitValueFactory.completeBinaryUpload(String)</code></a> with the token.
         <br>
         The only timeout restrictions for calling
         <a href="../JackrabbitValueFactory.html#completeBinaryUpload(java.lang.String)"><code>JackrabbitValueFactory.completeBinaryUpload(String)</code></a> are those
         imposed by the cloud blob storage service on uploaded blocks.  Upload
         tokens themselves do not time out, which allows you to be very
         lenient in allowing uploads to complete, and very resilient in
         handling temporary network issues or other issues that might impact
         the uploading of one or more blocks.
         <br>
         In the case that the upload cannot be finished (for example, one or
         more segments cannot be uploaded even after a reasonable number of
         retries), do not call
         <a href="../JackrabbitValueFactory.html#completeBinaryUpload(java.lang.String)"><code>JackrabbitValueFactory.completeBinaryUpload(String)</code></a>.
         Instead, simply restart the upload from the beginning by calling
         <a href="../JackrabbitValueFactory.html#initiateBinaryUpload(long,int)"><code>JackrabbitValueFactory.initiateBinaryUpload(long, int)</code></a> when
         the situation preventing a successful upload has been resolved.
     </li>
 </ol>

 <h2>Example JSON view</h2>

 A JSON representation of this interface as passed back to a remote client
 might look like this:
 
 <pre>
 {
     "uploadToken": "aaaa-bbbb-cccc-dddd-eeee-ffff-gggg-hhhh",
     "minPartSize": 10485760,
     "maxPartSize": 104857600,
     "uploadURIs": [
         "http://server.com/upload/1",
         "http://server.com/upload/2",
         "http://server.com/upload/3",
         "http://server.com/upload/4"
     ]
 }
 </pre></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxPartSize()">getMaxPartSize</a></span>()</code></th>
<td class="colLast">
<div class="block">Return the largest possible part size in bytes.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMinPartSize()">getMinPartSize</a></span>()</code></th>
<td class="colLast">
<div class="block">Return the smallest possible part size in bytes.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>@NotNull java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUploadToken()">getUploadToken</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a token identifying this upload.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>@NotNull java.lang.Iterable&lt;java.net.URI&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUploadURIs()">getUploadURIs</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a list of URIs that can be used for uploading binary data
 directly to a storage location in one or more parts.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="getUploadURIs()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUploadURIs</h4>
<pre class="methodSignature">@NotNull
@NotNull java.lang.Iterable&lt;java.net.URI&gt;&nbsp;getUploadURIs()</pre>
<div class="block">Returns a list of URIs that can be used for uploading binary data
 directly to a storage location in one or more parts.

 <p>
 Remote clients must support multi-part uploading as per the
 <a href="#upload.algorithm">upload algorithm</a> described above. Clients
 are not necessarily required to use all of the URIs provided. A client
 may choose to use fewer, or even only one of the URIs. However, it must
 always ensure the part size is between <a href="#getMinPartSize()"><code>getMinPartSize()</code></a> and
 <a href="#getMaxPartSize()"><code>getMaxPartSize()</code></a>. These can reflect strict limitations of the
 storage provider.

 <p>
 Regardless of the number of URIs used, they must be consumed in sequence,
 without skipping any, and the order of parts the original binary is split
 into must correspond exactly with the order of URIs.

 <p>
 For example, if a client wishes to upload a binary in three parts and
 there are five URIs returned, the client must use the first URI to
 upload the first part, the second URI to upload the second part, and
 the third URI to upload the third part. The client is not required to
 use the fourth and fifth URIs. However, using the second URI to upload
 the third part may result in either an upload failure or a corrupted
 upload; likewise, skipping the second URI to use subsequent URIs may
 result in either an upload failure or a corrupted upload.

 <p>
 While the API supports multi-part uploading via multiple upload URIs,
 implementations are not required to support multi-part uploading. If the
 underlying implementation does not support multi-part uploading, a single
 URI will be returned regardless of the size of the data being uploaded.

 <p>
 <b>Security considerations:</b>

 <ul>
     <li>
         The URIs cannot be shared with other users. They must only be returned to
         authenticated requests corresponding to this session user or trusted system
         components.
     </li>
     <li>
         The URIs must not be persisted for later use and will typically be time limited.
     </li>
     <li>
         The URIs will only grant access to this particular binary.
     </li>
     <li>
         The client cannot infer any semantics from the URI structure and path names.
         It would typically include a cryptographic signature. Any change to the URIs will
         likely result in a failing request.
     </li>
 </ul></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Iterable of URIs that can be used for uploading directly to a
         storage location.</dd>
</dl>
</li>
</ul>
<a id="getMinPartSize()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinPartSize</h4>
<pre class="methodSignature">long&nbsp;getMinPartSize()</pre>
<div class="block">Return the smallest possible part size in bytes. If a consumer wants to
 choose a custom part size, it cannot be smaller than this value. This
 does not apply to the final part. This value will be equal or larger than
 zero.

 <p>
 Note that the API offers no guarantees that using this minimal part size
 is possible with the number of available <a href="#getUploadURIs()"><code>getUploadURIs()</code></a>. This
 might not be the case if the binary is too large. Please refer to the
 <a href="#upload.algorithm">upload algorithm</a> for the correct use of
 this value.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The smallest part size acceptable for multi-part uploads.</dd>
</dl>
</li>
</ul>
<a id="getMaxPartSize()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxPartSize</h4>
<pre class="methodSignature">long&nbsp;getMaxPartSize()</pre>
<div class="block">Return the largest possible part size in bytes. If a consumer wants to
 choose a custom part size, it cannot be larger than this value.
 If this returns -1, the maximum is unlimited.

 <p>
 The API guarantees that a client can split the binary of the requested
 size using this maximum part size and there will be sufficient URIs
 available in <a href="#getUploadURIs()"><code>getUploadURIs()</code></a>. Please refer to the
 <a href="#upload.algorithm">upload algorithm</a> for the correct use of
 this value.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maximum part size acceptable for multi-part uploads or -1
         if there is no limit.</dd>
</dl>
</li>
</ul>
<a id="getUploadToken()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getUploadToken</h4>
<pre class="methodSignature">@NotNull
@NotNull java.lang.String&nbsp;getUploadToken()</pre>
<div class="block">Returns a token identifying this upload. This is required to finalize the upload
 at the end by calling <a href="../JackrabbitValueFactory.html#completeBinaryUpload(java.lang.String)"><code>JackrabbitValueFactory.completeBinaryUpload(String)</code></a>.

 <p>
 The format of this string is implementation-dependent. Implementations must ensure
 that clients cannot guess tokens for existing binaries.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A unique token identifying this upload.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &copy; 2010 - 2022 Adobe. All Rights Reserved</small></p>
</footer>
</body>
</html>
