<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
	<head>
		<meta name="generator" content="HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 13), see www.w3.org">
		<meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8">
		<title>
			JCR - Java Content Repository Specification 1.0 (JSR-170)
		</title>
		<meta name="GENERATOR" content="NeoOffice 2.2 (Unix)">
		<meta name="AUTHOR" content="Peeter Piegaze">
		<meta name="CREATED" content="20050504;10220000">
		<meta name="CHANGEDBY" content="Peeter Piegaze">
		<meta name="CHANGED" content="20050510;15430000">
		<style type="text/css">
  body { margin: 20px; }
		  dl { margin-left: 0px; }
		  dd { margin-left: 0px; }
		  body > dl > dd { margin-left: 40px; }
		  #toc dt { margin-left: 40px; }
		  #toc dd { margin-left: 80px; }
		  ul, ol, table { margin-left: 80px;}
		</style>
		<style type="text/css">
body {
		color: #000000;
		}
		:link { color: #0000FF }
		:visited { color: #800080 }
		h5.c23 {font-family: Verdana}
		div.c22 {margin-left: 2em}
		span.c21 {color: #0000FF}
		span.c20 {color: #000000}
		p.c19 {font-family: Verdana; text-align: center}
		p.c18 {font-family: Arial}
		p.c17 {font-family: Arial Unicode MS, Arial}
		span.c16 {font-size: 120%}
		span.c15 {font-size: 70%}
		p.c14 {font-family: normal, Times New Roman}
		h4.c13 {color: #5E7CA4}
		p.c12 {font-family: Courier New}
		span.c11 {font-family: Courier New}
		span.c10 {font-size: 150%}
		span.c9 {color: #5E7CA4}
		span.c8 {font-family: Arial}
		p.c7 {color: #5E7CA4}
		span.c6 {color: #FFFFFF}
		p.c5 {font-family: Verdana}
		span.c4 {font-size: 80%}
		.c3 {color: #82A5D2}
		span.c2 {font-family: Verdana}
		span.c1 {font-size: 200%}
		h1 {font-size:20px;}
		h2 {font-size:18px;}
		</style>
	</head>
	<body dir="ltr">
		
			
				
					
						<h1 class="c3">
							Content Repository API for Java™ Technology Specification
						</h1>
					
					
						<p class="c5">
							<b>Java Specification Request 170<br></b> Version 1.0<br>
							11 May 2005
						</p>
					
				
			
		
		<div id="toc" dir="ltr">
			
				
					<br>
					<b>Content Repository API for Java™ Technology<br>
					Specification 1</b>
				
				
					<br>
					<b><a href="#section_1.">1 Preface 10</a></b>
				
				
					<p class="c7">
						<b><a href="#section_1.1.">1.1 Documents Included 10</a></b>
					</p>
				
				
					<br>
					<b><a href="#section_2.">2 Introduction 11</a></b>
				
				
					<p class="c7">
						<b><a href="#section_2.1.">2.1 Motivation 11</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_2.2.">2.2 Goals 11</a></b>
					</p>
				
				
					<br>
					<b><a href="#section_3.">3 Use Cases 13</a></b>
				
				
					<p class="c7">
						<b><a href="#section_3.1.">3.1 Swappability 13</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_3.2.">3.2 Resource Crunch (Personalization) 14</a></b>
					</p>
				
				
					<br>
					<b><a href="#section_4.">4 The Repository Model 16</a></b>
				
				
					<p class="c7">
						<b><a href="#section_4.1.">4.1 API Basics 17</a></b>
					</p>
				
				
					<p>
						<a href="#section_4.1.1.">4.1.1 Traversal Access 18</a>
					</p>
				
				
					<p>
						<a href="#section_4.1.2.">4.1.2 Direct Access 18</a>
					</p>
				
				
					<p>
						<a href="#section_4.1.3.">4.1.3 Writing to the Repository 19</a>
					</p>
				
				
					<p>
						<a href="#section_4.1.4.">4.1.4 Nodes, Properties and Items 22</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.2.">4.2 Compliance Levels 22</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.3.">4.3 Same–Name Siblings 23</a></b>
					</p>
				
				
					<p>
						<a href="#section_4.3.1.">4.3.1 Index Notation 23</a>
					</p>
				
				
					<p>
						<a href="#section_4.3.2.">4.3.2 Support for Same Name Siblings is Optional 24</a>
					</p>
				
				
					<p>
						<a href="#section_4.3.3.">4.3.3 Properties Cannot Have Same Name Siblings 24</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.4.">4.4 Orderable Child Nodes 24</a></b>
					</p>
				
				
					<p>
						<a href="#section_4.4.1.">4.4.1 Orderable Same Name Siblings 25</a>
					</p>
				
				
					<p>
						<a href="#section_4.4.2.">4.4.2 Non-orderable Child Nodes 25</a>
					</p>
				
				
					<p>
						<a href="#section_4.4.3.">4.4.3 Orderable Child Node Support is Optional 25</a>
					</p>
				
				
					<p>
						<a href="#section_4.4.4.">4.4.4 Properties are Never Orderable 25</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.5.">4.5 Namespaces 26</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.6.">4.6 Path Syntax 26</a></b>
					</p>
				
				
					<p>
						<a href="#section_4.6.1.">4.6.1 Names vs. Paths 27</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.7.">4.7 Properties 27</a></b>
					</p>
				
				
					<p>
						<a href="#section_4.7.1.">4.7.1 Multi-Value Properties 28</a>
					</p>
				
				
					<p>
						<a href="#section_4.7.2.">4.7.2 Reference, Path and Name Property Types 28</a>
					</p>
				
				
					<p>
						<a href="#section_4.7.3.">4.7.3 No Null Values 29</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.8.">4.8 Node Types 30</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.9.">4.9 Referenceable Nodes 30</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.10.">4.10 Workspaces 32</a></b>
					</p>
				
				
					<p>
						<a href="#section_4.10.1.">4.10.1 Single Workspace Repositories 32</a>
					</p>
				
				
					<p>
						<a href="#section_4.10.2.">4.10.2 Multiple Workspaces and Corresponding Nodes 33</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.11.">4.11 Versioning 36</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.12.">4.12 Metadata 39</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_4.13.">4.13 Hierarchical versus Direct Access 39</a></b>
					</p>
				
				
					<br>
					<b><a href="#section_5.">5 Example Implementations 41</a></b>
				
				
					<p class="c7">
						<b><a href="#section_5.1.">5.1 A File System-backed Content Repository 41</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_5.2.">5.2 A WebDAV-backed Content Repository 42</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_5.3.">5.3 Database-backed Content Repository 42</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_5.4.">5.4 XML-backed Content Repository 43</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_5.5.">5.5 Namespace Prefixes in the Examples 45</a></b>
					</p>
				
				
					<br>
					<b><a href="#section_6.">6 Level 1 Repository Features 47</a></b>
				
				
					<p class="c7">
						<b><a href="#section_6.1.">6.1 Accessing the Repository 47</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.1.1.">6.1.1 Repository 47</a>
					</p>
				
				
					<p>
						<a href="#section_6.1.2.">6.1.2 Credentials 50</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.2.">6.2 Reading Repository Content 51</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.2.1.">6.2.1 Session Read Methods 52</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.2.">6.2.2 Workspace Read Methods 55</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.3.">6.2.3 Node Read Methods 56</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.4.">6.2.4 Property Read Methods 60</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.5.">6.2.5 Property Types 64</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.6.">6.2.6 Property Type Conversion 70</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.7.">6.2.7 Value 71</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.8.">6.2.8 Item Read Methods 74</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.9.">6.2.9 Effect of Access Denial on Read 77</a>
					</p>
				
				
					<p>
						<a href="#section_6.2.10.">6.2.10 Example 77</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.3.">6.3 Namespaces 79</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.3.1.">6.3.1 Namespace Registry 79</a>
					</p>
				
				
					<p>
						<a href="#section_6.3.2.">6.3.2 Prefix Syntax 81</a>
					</p>
				
				
					<p>
						<a href="#section_6.3.3.">6.3.3 Session Namespace Remapping 81</a>
					</p>
				
				
					<p>
						<a href="#section_6.3.4.">6.3.4 Internal Storage of Names and Paths 83</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.4.">6.4 XML Mappings 83</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.4.1.">6.4.1 System View XML Mapping 83</a>
					</p>
				
				
					<p>
						<a href="#section_6.4.2.">6.4.2 Document View XML Mapping 86</a>
					</p>
				
				
					<p>
						<a href="#section_6.4.3.">6.4.3 Escaping of Names 90</a>
					</p>
				
				
					<p>
						<a href="#section_6.4.4.">6.4.4 Escaping of Values 91</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.5.">6.5 Exporting Repository Content 92</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.5.1.">6.5.1 Encoding 95</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.6.">6.6 Searching Repository Content 96</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.6.1.">6.6.1 XPath over Document View 96</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.2.">6.6.2 XPath and SQL 97</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.3.">6.6.3 Structure of a Query 97</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.4.">6.6.4 Adapting XPath to the Content Repository 105</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.5.">6.6.5 XPath Extensions 109</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.6.">6.6.6 XPath Grammar 113</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.7.">6.6.7 Search Scope 118</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.8.">6.6.8 Query API 118</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.9.">6.6.9 QueryManager 118</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.10.">6.6.10 The Query Object 119</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.11.">6.6.11 Persistent vs. Transient Queries 121</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.12.">6.6.12 Query Results 122</a>
					</p>
				
				
					<p>
						<a href="#section_6.6.13.">6.6.13 Permissions 123</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.7.">6.7 Node Types 123</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.7.1.">6.7.1 Node Type Configuration 124</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.2.">6.7.2 What Constitutes a Node Type 124</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.3.">6.7.3 Node Type Discovery in Level 1 125</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.4.">6.7.4 Primary and Mixin Node Types 125</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.5.">6.7.5 Special Properties jcr:primaryType and jcr:mixinTypes 126</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.6.">6.7.6 Property Definitions 126</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.7.">6.7.7 Child Node Definitions 127</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.8.">6.7.8 Inheritance Among Node Types 128</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.9.">6.7.9 Discovering available Node Types 128</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.10.">6.7.10 Discovering the Node Types of a Node 129</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.11.">6.7.11 Discovering the Definition of a Node Type 130</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.12.">6.7.12 ItemDefinition 132</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.13.">6.7.13 PropertyDefinition 134</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.14.">6.7.14 NodeDefinition 135</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.15.">6.7.15 Residual Definitions 136</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.16.">6.7.16 Value Constraints 136</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.17.">6.7.17 Automatic Item Creation 139</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.18.">6.7.18 Discovery of Constraints on Existing Items 140</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.19.">6.7.19 Predefined Node Types 141</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.20.">6.7.20 Node Type Definitions in Content 142</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.21.">6.7.21 Predefined Mixin Node Types 143</a>
					</p>
				
				
					<p>
						<a href="#section_6.7.22.">6.7.22 Predefined Primary Node Types 146</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.8.">6.8 System Node 163</a></b>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_6.9.">6.9 Access Control 163</a></b>
					</p>
				
				
					<p>
						<a href="#section_6.9.1.">6.9.1 JAAS 164</a>
					</p>
				
				
					<p>
						<a href="#section_6.9.2.">6.9.2 Checking Permissions 164</a>
					</p>
				
				
					<br>
					<b><a href="#section_7.">7 Level 2 Repository Features 166</a></b>
				
				
					<p class="c7">
						<b><a href="#section_7.1.">7.1 Writing Repository Content 166</a></b>
					</p>
				
				
					<p>
						<a href="#section_7.1.2.">7.1.2 Saving by UUID and Path 172</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.3.">7.1.3 Reflecting Item State 172</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.4.">7.1.4 Adding Nodes 176</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.5.">7.1.5 Adding and Writing Properties 179</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.6.">7.1.6 Removing Nodes and Properties 188</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.7.">7.1.7 Moving and Copying 190</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.8.">7.1.8 Updating and Cloning Nodes across Workspaces 196</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.9.">7.1.9 Referenceable Nodes 199</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.10.">7.1.10 Treatment of UUIDs 199</a>
					</p>
				
				
					<p>
						<a href="#section_7.1.11.">7.1.11 Ordering Child Nodes 201</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_7.2.">7.2 Adding and Deleting Namespaces 203</a></b>
					</p>
				
				
					<p>
						<a href="#section_7.2.1.">7.2.1 Visibility of Namespace Registry Changes 205</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_7.3.">7.3 Importing Repository Content 205</a></b>
					</p>
				
				
					<p>
						<a href="#section_7.3.1.">7.3.1 Import from System View 205</a>
					</p>
				
				
					<p>
						<a href="#section_7.3.2.">7.3.2 Import from Document View 205</a>
					</p>
				
				
					<p>
						<a href="#section_7.3.3.">7.3.3 Respecting Property Semantics 208</a>
					</p>
				
				
					<p>
						<a href="#section_7.3.4.">7.3.4 Determining Node Types 208</a>
					</p>
				
				
					<p>
						<a href="#section_7.3.5.">7.3.5 Determining Property Types 209</a>
					</p>
				
				
					<p>
						<a href="#section_7.3.6.">7.3.6 Workspace Import Methods 209</a>
					</p>
				
				
					<p>
						<a href="#section_7.3.7.">7.3.7 Session Import Methods 214</a>
					</p>
				
				
					<p>
						<a href="#section_7.3.8.">7.3.8 Importing jcr:root 219</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_7.4.">7.4 Assigning Node Types 220</a></b>
					</p>
				
				
					<p>
						<a href="#section_7.4.1.">7.4.1 The Special Properties jcr:primaryType and jcr:mixinTypes 220</a>
					</p>
				
				
					<p>
						<a href="#section_7.4.2.">7.4.2 Assigning a Primary Node Type 220</a>
					</p>
				
				
					<p>
						<a href="#section_7.4.3.">7.4.3 Assigning Mixin Node Types 221</a>
					</p>
				
				
					<p>
						<a href="#section_7.4.4.">7.4.4 Automatic Addition and Removal of Mixins 223</a>
					</p>
				
				
					<p>
						<a href="#section_7.4.5.">7.4.5 Serialization and Node Types 223</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_7.5.">7.5 Thread-Safety Requirements 224</a></b>
					</p>
				
				
					<br>
					<b><a href="#section_8.">8 Optional Repository Features 225</a></b>
				
				
					<p class="c7">
						<b><a href="#section_8.1.">8.1 Transactions 225</a></b>
					</p>
				
				
					<p>
						<a href="#section_8.1.1.">8.1.1 Container Managed Transactions: Sample Request Flow 227</a>
					</p>
				
				
					<p>
						<a href="#section_8.1.2.">8.1.2 User Managed Transactions: Sample Code 227</a>
					</p>
				
				
					<p>
						<a href="#section_8.1.3.">8.1.3 Save vs. Commit 228</a>
					</p>
				
				
					<p>
						<a href="#section_8.1.4.">8.1.4 Single Session Across Multiple Transactions 228</a>
					</p>
				
				
					<p>
						<a href="#section_8.1.5.">8.1.5 Mention of Transactions within this Specification 229</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_8.2.">8.2 Versioning 229</a></b>
					</p>
				
				
					<p>
						<a href="#section_8.2.1.">8.2.1 Versionable Nodes 230</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.2.">8.2.2 Version Storage 233</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.3.">8.2.3 The Base Version 242</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.4.">8.2.4 Initializing the Version History 242</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.5.">8.2.5 Check In 243</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.6.">8.2.6 Check Out 244</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.7.">8.2.7 Restoring a Version 245</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.8.">8.2.8 Restoring a Group of Versions 246</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.9.">8.2.9 Update 246</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.10.">8.2.10 Merge 246</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.11.">8.2.11 OnParentVersion Attribute 251</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.12.">8.2.12 The OnParentVersionAction Class 254</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.13.">8.2.13 Removal of Versions 254</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.14.">8.2.14 Versioning API 255</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.15.">8.2.15 Serialization of Version Storage 269</a>
					</p>
				
				
					<p>
						<a href="#section_8.2.16.">8.2.16 Versioning within a Transaction 269</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_8.3.">8.3 Observation 269</a></b>
					</p>
				
				
					<p>
						<a href="#section_8.3.1.">8.3.1 Event Listeners 271</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.2.">8.3.2 Listener Registration 271</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.3.">8.3.3 Observation Manager 272</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.4.">8.3.4 Event Production 273</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.5.">8.3.5 Event Filtering 274</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.6.">8.3.6 Event Bundles 274</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.7.">8.3.7 Interpretation of Events 274</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.8.">8.3.8 Deserializing Content 277</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.9.">8.3.9 External Mechanisms 277</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.10.">8.3.10 Location of Listeners 277</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.11.">8.3.11 Persistence of Event Listeners 277</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.12.">8.3.12 Vetoable Event Listeners 277</a>
					</p>
				
				
					<p>
						<a href="#section_8.3.13.">8.3.13 Exceptions 278</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_8.4.">8.4 Locking 278</a></b>
					</p>
				
				
					<p>
						<a href="#section_8.4.1.">8.4.1 Discovery of Lock Capabilities 278</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.2.">8.4.2 Lockable 278</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.3.">8.4.3 Shallow and Deep Locks 279</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.4.">8.4.4 Lock Owner 279</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.5.">8.4.5 Placing and Removing a Lock 279</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.6.">8.4.6 Lock Token 280</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.7.">8.4.7 Session-scoped and Open-scoped Locks 280</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.8.">8.4.8 Effect of a Lock 281</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.9.">8.4.9 Timing Out 282</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.10.">8.4.10 Locks and Transactions 282</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.11.">8.4.11 Locking Methods 283</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.12.">8.4.12 The Lock Object 285</a>
					</p>
				
				
					<p>
						<a href="#section_8.4.13.">8.4.13 Session Methods Related to the Lock Token 287</a>
					</p>
				
				
					<p class="c7">
						<b><a href="#section_8.5.">8.5 Searching Repository Content with SQL 287</a></b>
					</p>
				
				
					<p>
						<a href="#section_8.5.1.">8.5.1 The SQL Language 287</a>
					</p>
				
				
					<p>
						<a href="#section_8.5.2.">8.5.2 Database View 288</a>
					</p>
				
				
					<p>
						<a href="#section_8.5.3.">8.5.3 SQL EBNF 292</a>
					</p>
				
				
					<p>
						<a href="#section_8.5.4.">8.5.4 SQL Syntax in Detail 294</a>
					</p>
				
				
					<p>
						<a href="#section_8.5.5.">8.5.5 Query Results 297</a>
					</p>
				
			
		</div>
		
			
				<p>
					<br>
				</p>
			
		
		<p class="c5">
			<b>Acknowledgements</b>
		</p>
		
			
				
					
						
							
								<p class="c5">
									This specification is the collaborative product of
								</p>
								
									
										<p class="c5">
											<b>David Nuescheler</b> (specification lead, Day Software),
										</p>
									
									
										<p class="c5">
											<b>Peeter Piegaze</b> (author, Day Software),
										</p>
									
								
							
							
								<p class="c5">
									and other members of the JSR 170 expert group, including
								</p>
								
									
										<p class="c5">
											<b>Tim Anderson</b> (Intalio),
										</p>
									
									
										<p class="c5">
											<b>Gordon Bell</b> (Hummingbird),
										</p>
									
									
										<p class="c5">
											<b>Geoffery Clemm</b> (IBM),
										</p>
									
									
										<p class="c5">
											<b>David Choy</b> (IBM),
										</p>
									
									
										<p class="c5">
											<b>Jeff Collins</b> (Vignette),
										</p>
									
									
										<p class="c5">
											<b>Stefan Guggisberg</b> (Day Software),
										</p>
									
									
										<p class="c5">
											<b>Stefano Mazzocchi</b> (Apache Software Foundation),
										</p>
									
									
										<p class="c5">
											<b>James Myers</b> (Pacific Northwest National Laboratories),
										</p>
									
									
										<p class="c5">
											<b>James Owen</b> (BEA),
										</p>
									
									
										<p class="c5">
											<b>Franz Pfeifroth</b> (Fujitsu),
										</p>
									
									
										<p class="c5">
											<b>David Pitfield</b> (Oracle),
										</p>
									
									
										<p class="c5">
											<b>Corprew Reed</b> (FileNet),
										</p>
									
									
										<p class="c5">
											<b>Victor Spivak</b> (Documentum),
										</p>
									
									
										<p class="c5">
											<b>David B. Victor</b> (IBM),
										</p>
									
								
							
							
								<p class="c5">
									as well as many others who contributed with corrections and suggestions.
								</p>
							
						
					
				
			
		
		<p class="c5">
			<b>License</b>
		</p>
		
			
				
					
						
							
								<p class="c5">
									Day Management AG ("Licensor") is willing to license this specification to you ONLY UPON THE CONDITION THAT YOU ACCEPT ALL OF THE TERMS CONTAINED IN THIS LICENSE AGREEMENT ("Agreement"). Please read the terms and conditions of this Agreement carefully.
								</p>
							
							
								<p class="c5">
									<b>Content Repository for Java</b><sup><b>TM</b></sup> <b>Technology API Specification ("Specification")<br>
									Version: 1.0<br>
									Status: FCS<br>
									Release: 11 May 2005</b>
								</p>
							
							
								<p class="c5">
									Copyright 2005 Day Management AG<br>
									Barfüsserplatz 6, 4001 Basel, Switzerland.<br>
									All rights reserved.
								</p>
							
							
								<p class="c5">
									<b>NOTICE; LIMITED LICENSE GRANTS</b>
								</p>
							
							
								<p class="c5">
									<b>1. License for Purposes of Evaluation and Developing Applications</b>. Licensor hereby grants you a fully-paid, non-exclusive, non-transferable, worldwide, limited license (without the right to sublicense), under Licensor's applicable intellectual property rights to view, download, use and reproduce the Specification only for the purpose of internal evaluation. This includes developing applications intended to run on an implementation of the Specification provided that such applications do not themselves implement any portion(s) of the Specification.
								</p>
							
							
								<p class="c5">
									<b>2. License for the Distribution of Compliant Implementations</b>. Licensor also grants you a perpetual, non-exclusive, non-transferable, worldwide, fully paid-up, royalty free, limited license (without the right to sublicense) under any applicable copyrights or, subject to the provisions of subsection 4 below, patent rights it may have covering the Specification to create and/or distribute an Independent Implementation of the Specification that: (a) fully implements the Specification including all its required interfaces and functionality; (b) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented; and (c) passes the Technology Compatibility Kit (including satisfying the requirements of the applicable TCK Users Guide) for such Specification ("Compliant Implementation"). In addition, the foregoing license is expressly conditioned on your not acting outside its scope. No license is granted hereunder for any other purpose (including, for example, modifying the Specification, other than to the extent of your fair use rights, or distributing the Specification to third parties).
								</p>
							
							
								<p class="c5">
									<b>3. Pass-through Conditions</b>. You need not include limitations (a)-(c) from the previous paragraph or any other particular "pass through" requirements in any license You grant concerning the use of your Independent Implementation or products derived from it. However, except with respect to Independent Implementations (and products derived from them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a) grant or otherwise pass through to your licensees any licenses under Licensor's applicable intellectual property rights; nor (b) authorize your licensees to make any claims concerning their implementation's compliance with the Specification.
								</p>
							
							
								<p class="c5">
									<b>4. Reciprocity Concerning Patent Licenses</b>. With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is conditioned upon your offering on fair, reasonable and non-discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-transferable, worldwide license under Your patent rights that are or would be infringed by all technically feasible implementations of the Specification to develop, distribute and use a Compliant Implementation.
								</p>
							
							
								<p class="c5">
									<b>5. Definitions</b>. For the purposes of this Agreement: "Independent Implementation" shall mean an implementation of the Specification that neither derives from any of Licensor's source code or binary code materials nor, except with an appropriate and separate license from Licensor, includes any of Licensor's source code or binary code materials; "Licensor Name Space" shall mean the public class or interface declarations whose names begin with "java", "javax", "javax.jcr" or their equivalents in any subsequent naming convention adopted by Licensor through the Java Community Process, or any recognized successors or replacements thereof; and "Technology Compatibility Kit" or "TCK" shall mean the test suite and accompanying TCK User's Guide provided by Licensor which corresponds to the particular version of the Specification being tested.
								</p>
							
							
								<p class="c5">
									<b>6. Termination</b>. This Agreement will terminate immediately without notice from Licensor if you fail to comply with any material provision of or act outside the scope of the licenses granted above.
								</p>
							
							
								<p class="c5">
									<b>7. Trademarks</b>. No right, title, or interest in or to any trademarks, service marks, or trade names of Licensor is granted hereunder. Java is a registered trademark of Sun Microsystems, Inc. in the United States and other countries.
								</p>
							
							
								<p class="c5">
									<b>8. Disclaimer of Warranties</b>. The Specification is provided "AS IS". LICENSOR MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT (INCLUDING AS A CONSEQUENCE OF ANY PRACTICE OR IMPLEMENTATION OF THE SPECIFICATION), OR THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE. This document does not represent any commitment to release or implement any portion of the Specification in any product.
								</p>
							
							
								<p class="c5">
									The Specification could include technical inaccuracies or typographical errors. Changes are periodically added to the information therein; these changes will be incorporated into new versions of the Specification, if any. Licensor may make improvements and/or changes to the product(s) and/or the program(s) described in the Specification at any time. Any use of such changes in the Specification will be governed by the then-current license for the applicable version of the Specification.
								</p>
							
							
								<p class="c5">
									<b>9. Limitation of Liability</b>. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL LICENSOR BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO ANY FURNISHING, PRACTICING, MODIFYING OR ANY USE OF THE SPECIFICATION, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
								</p>
							
							
								<p class="c5">
									<b>10. Report</b>. If you provide Licensor with any comments or suggestions in connection with your use of the Specification ("Feedback"), you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Licensor a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose related to the Specification and future versions, implementations, and test suites thereof.
								</p>
							
						
					
				
			
		
		<h2>
			<a name="section_1." id="section_1."></a> 1 Preface
		</h2>
		
			
				
					
						
							
								<p class="c5">
									This is version 1.0 of the Content Repository API for Java Technology specification (Java Specification Request 170).
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_1.1." id="section_1.1."></a>1.1 Documents Included
		</h3>
		
			
				
					
						
							
								<p class="c5">
									The specification includes:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					This document in Adobe Portable Document Format<br>
					(<i>jsr170-1.0.pdf</i>).
				</p>
			</li>
			<li>
				<p class="c5">
					The Java source code for the API package <b>javax.jcr</b> and subpackages.
				</p>
			</li>
			<li>
				<p class="c5">
					A jar file of the API package <b>javax.jcr</b> and subpackages.
				</p>
			</li>
			<li>
				<p class="c5">
					The Javadoc produced from the <b>javax.jcr</b> and subpackages.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									In case of a discrepancy between this document and the Javadoc produced from the <b>javax.jcr</b> package, this document should be considered normative.
								</p>
							
						
					
				
			
		
		<h2>
			<a name="section_2." id="section_2."></a>2 Introduction
		</h2>
		<h3>
			<a name="section_2.1." id="section_2.1."></a>2.1 Motivation
		</h3>
		
			
				
					
						
							
								<p class="c5">
									As the number of vendors offering proprietary content repositories has increased, the need for a common programmatic interface to these repositories has become apparent. The aim of the Content Repository for Java Technology API specification is to provide such an interface and, in doing so, lay the foundations for a true industry-wide content infrastructure.
								</p>
							
							
								<p class="c5">
									Application developers and custom solution integrators will be able to avoid the costs associated with learning the particular API of each repository vendor. Instead, programmers will be able to develop content-based application logic independently of the underlying repository architecture or physical storage.
								</p>
							
							
								<p class="c5">
									Customers will also benefit by being able to exchange their underlying repositories without touching any of the applications built on top of them.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_2.2." id="section_2.2."></a>2.2 Goals
		</h3>
		
			
				
					
						
							
								<p class="c5">
									The guiding principles governing the design of the API are:
								</p>
							
							
								<p class="c5">
									<b>It should not be tied to any particular underlying architecture, data source or protocol.<br>
									<br></b> The API is, of course, essentially a set of Java interfaces, which can be implemented in a wide variety of ways. Hence, achieving this goal is not difficult in itself. The main challenge here is to allow enough flexibility in the API so that it can be used for both hierarchical and non-hierarchical repository models. This is done by providing for both <i>hierarchical, path-based addressing</i> of content items and <i>direct, UUID-based addressing</i>.
								</p>
							
							
								<p class="c5">
									<b>It should be easy to use from the programmer’s point of view.<br>
									<br></b> To this end, the API is designed to be as simple and straightforward as possible. In particular, it has a simple object model and concentrates on representing the core functionality of a content repository without venturing into areas that might be regarded as “content applications”.
								</p>
							
							
								<p class="c5">
									<b>It should allow for relatively easy implementation on top of as wide a variety of existing content repositories as possible.<br>
									<br></b> A concerted effort was made to ensure that it would be relatively easy to implement the API (especially at level 1, see below) on top of the repositories of most major vendors.
								</p>
							
							
								<p class="c5">
									<b>However, it should also standardize some more complex functionality needed by advanced content-related applications.<br>
									<br></b> Recognizing that a tension exists between this aim and the previous one, this specification has been split into two compliance levels as well as a set of optional features.<br>
									<br>
									Level 1 defines a read-only repository. This includes functionality for the reading of repository content, introspection of content-type definitions, basic support for namespaces, export of content to XML and searching. This functionality should meet the needs of presentation templates and basic portal applications comprising a large portion of the existing code-base of content-related applications. Level 1 is also designed to be easy to implement on top of any existing content repository.<br>
									<br>
									Level 2 additionally defines methods for writing content, assignment of types to content, further support for namespaces, and importing content from XML.
								</p>
							
							
								<p class="c5">
									Finally, a number of independently optional features are defined that a compliant repository may support. These are transactions, versioning, observation, access control, locking and additional support for searching.
								</p>
							
						
					
				
			
		
		<h2>
			<a name="section_3." id="section_3."></a> 3 Use Cases
		</h2>
		<h3>
			<a name="section_3.1." id="section_3.1."></a>3.1 Swappability
		</h3>
		
			
				
					
						
							
								<p class="c5">
									ENT Corporation, a large distributed enterprise, has different content management systems in different divisions. Their Knowledge Management (KM) team has developed an idea for better discovery of corporate assets across the various repositories.
								</p>
							
							
								<p class="c5">
									The team implements the application using the Content Repository for Java Technology API to the content management (CM) systems. As the KM team finds more CM systems across the enterprise, the application can easily harvest the new data as well as that from the existing systems.
								</p>
							
							
								<p class="c5">
									Additionally, the presentation templates that cover the corporate design guidelines for the organization have been developed based on this specification in a Java framework around JSP.
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p>
									<img src="jsr170-3_1.gif" name="graphics1" align="bottom" border="0" id="graphics1">
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									A year later, two divisions switch their CM vendors. As part of the migration process, the KM discovery application is tested against the new CMS in those divisions. Other than having its configuration file updated, the application works as before.
								</p>
							
							
								<p class="c5">
									Through their standardized interface these repositories allow simple migration of the content from the two old repositories to the new one; this means that the content can be converted from the source repository to the newly purchased destination repository through a simple export and import.
								</p>
							
							
								<p>
									<img src="jsr170-3_1-2.gif" name="Object1" align="bottom" id="Object1">
								</p>
							
							
								<p class="c5">
									Furthermore, all the content presentation templates developed against this specification keep working as before. In the case of ENT the development of this presentation logic was one of the major investments made when the intranet and the public Internet website were first developed. Being able to migrate this logic painlessly to work on top of the new repository is therefore of great benefit.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_3.2." id="section_3.2."></a> 3.2 Resource Crunch (Personalization)
		</h3>
		
			
				
					
						
							
								<p class="c5">
									PersonalizeIt Software Corp., a vendor of personalization and portal software, needs to gain access to meta-information and content that is aggregated and managed by content management systems.
								</p>
							
							
								<p class="c5">
									Since, historically, the CM market has been quite diverse, PersonalizeIt has had to integrate into many different proprietary APIs. This meant that PersonalizeIt had to spend a large amount of time familiarizing their developers with these APIs and had to maintain compatibility with all the different APIs as the various CM vendors' products evolved.
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p>
									<img src="jsr170-3_2.gif" name="graphics2" align="bottom" border="0" id="graphics2">
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									Since the adoption of this specification, PersonalizeIt offers a standard interface to compliant repositories. Therefore, they no longer have to maintain dozens of proprietary integrations and can concentrate on their core competency.
								</p>
							
							
								<p>
									<img src="jsr170-3_2-2.gif" name="graphics3" align="bottom" border="0" id="graphics3">
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p>
									<a name="_Name_Spaces_1"></a><a name="_Name_Spaces"></a><a name="section_6.4.1.1._Implementations" id="section_6.4.1.1._Implementations"></a><br>
									<br>
								</p>
							
						
					
				
			
		
		<h2>
			<a name="section_4." id="section_4."></a>4 The Repository Model
		</h2>
		
			
				
					
						
							
								<p class="c5">
									A content repository consists of one or more <i>workspaces</i>, each of which contains a tree of <i>items</i>. An item is either a <i>node</i> or a <i>property</i>. Each node may have zero or more child nodes and zero or more child properties. There is a single root node per workspace, which has no parent. All other nodes have one parent. Properties have one parent (a node) and cannot have children; they are the leaves of the tree. All of the actual content in the repository is stored within the values of the properties.
								</p>
							
							
								<p>
									<img src="jsr170-4.gif" align="left" hspace="12"><br clear="left">
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									In the diagram above, we see the single root node of some workspace with child nodes <b>a</b>, <b>b</b> and <b>c</b>, each of which have further child nodes or properties. For example, the node <b>a</b> has two child nodes, <b>d</b> and <b>e</b>. Node <b>e</b>, in turn, has two properties, <b>j</b> and <b>k</b>. The property <b>j</b> contains an image (a picture of a rabbit) and <b>k</b> contains a floating-point number (<b>6.022 × 10</b><b><sup>23</sup></b>). Similarly, the property <b>i</b> contains a boolean value (<b>true</b>), the property <b>g</b> contains a string (“<b>Once upon a time...</b>”) and the property <b>h</b> contains an integer (<b>-25</b>).
								</p>
							
							
								<p class="c5">
									Any item in the hierarchy can be identified by an <i>absolute path</i>. For example, the path <b>/</b> refers to the root node and the path <b>/a/d/i</b> refers to the property with value <b>true</b>. Absolute paths always begin with a <b>/</b> character.
								</p>
							
							
								<p class="c5">
									A <i>relative path</i> specifies a node or property relative to another location within the hierarchy. For example, relative to node <b>/a</b> in the above diagram, the path to the property with value <b>true</b> is <b>d/i</b>. The Unix-style path segments “<b>.</b>” and “<b>..</b>” (meaning respectively, “this” and “parent”) are also supported so that, relative to <b>/a</b>, the property containing the value <b>–25</b> would be <b>../c/h</b>. Relative paths are distinguished from absolute paths by having <i>no</i> leading <b>/</b> character.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.1." id="section_4.1."></a>4.1 API Basics
		</h3>
		
			
				
					
						
							
								<p class="c5">
									The repository as a whole is represented by a <b>Repository</b> object<sup><a class="sdfootnoteanc" name="sdfootnote1anc" href="#sdfootnote1sym" id="sdfootnote1anc"><sup>1</sup></a></sup>. A client connects to the repository by calling <b>Repository.login</b> optionally specifying a workspace name and a <b>Credentials</b> object<sup><a class="sdfootnoteanc" name="sdfootnote2anc" href="#sdfootnote2sym" id="sdfootnote2anc"><sup>2</sup></a></sup>. The client then receives a <b>Session</b> object tied to the specified workspace.
								</p>
							
							
								<p class="c5">
									How the <b>Repository</b> object is actually acquired is beyond the scope of this specification. However, one possibility, as shown below, is to use JNDI, though this depends entirely on the implementation. Similarly, the specifics of acquiring the <b>Credentials</b> object are also not specified. Below we show one possibility: using the class <b>SimpleCredentials</b> included in the specification. Implementations may provide their own <b>Credentials</b> classes as well.
								</p>
							
							
								<p class="c12">
									<i>// Get the Repository object</i>
								</p>
							
							
								<p class="c12">
									<b>InitialContext ctx = ...</b>
								</p>
							
							
								<p class="c12">
									<b>Repository repository = (Repository)ctx.lookup("myrepo");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Get a Credentials object</i>
								</p>
							
							
								<p class="c12">
									<b>Credentials credentials =<br>
									new SimpleCredentials("MyName",<br>
									"MyPassword".toCharArray());</b>
								</p>
							
							
								<p class="c12">
									<i>// Get a Session</i>
								</p>
							
							
								<p class="c12">
									<b>Session mySession =<br>
									repository.login(credentials, "MyWorkspace");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<br>
									Through the <b>Session</b> object the client can access any node or property in that tree of the workspace to which the <b>Session</b> is tied. The API provides methods for both traversing the tree step by step and for directly accessing a particular item.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.1.1." id="section_4.1.1."></a>4.1.1 Traversal Access
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Traversal access typically begins with
								</p>
							
							
								<p class="c5">
									<b>Node Session.getRootNode()</b>.
								</p>
							
							
								<p class="c5">
									From the returned root node, successive levels of child nodes can be accessed with
								</p>
							
							
								<p class="c5">
									<b>Node Node.getNode(String relPath)</b>,
								</p>
							
							
								<p class="c5">
									which takes a relative path (so it can skip down or up multiple levels as well). There is also a similar method for accessing properties,
								</p>
							
							
								<p class="c5">
									<b>Property Node.getProperty(String relPath)</b>.
								</p>
							
							
								<p class="c5">
									The data stored in the property can be accessed either directly with methods like
								</p>
							
							
								<p class="c5">
									<b>String Property.getString()</b>,
								</p>
							
							
								<p class="c5">
									or in the form of a type-neutral wrapper, the <b>Value</b> object, using
								</p>
							
							
								<p class="c5">
									<b>Value Property.getValue()</b>.
								</p>
							
							
								<p class="c5">
									The actual data can then be retrieved with, for example,
								</p>
							
							
								<p class="c5">
									<b>String Value.getString()</b>.
								</p>
							
							
								<p class="c5">
									Here is an example code snippet:
								</p>
							
							
								<p class="c12">
									<i>// Get the root node</i>
								</p>
							
							
								<p class="c12">
									<b>Node root = mySession.getRootNode();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Traverse to the node you want</i>
								</p>
							
							
								<p class="c12">
									<b>Node myNode = root.getNode("a/e");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Retrieve a property of myNode</i>
								</p>
							
							
								<p class="c12">
									<b>Property myProperty = myNode.getProperty("k");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Get the value of the property</i>
								</p>
							
							
								<p class="c12">
									<b>Value myValue = myProperty.getValue();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Convert the value to the desired type</i>
								</p>
							
							
								<p class="c12">
									<b>double myDouble = myValue.getDouble();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// The variable myDouble will contain the</i>
								</p>
							
							
								<p class="c12">
									<i>// value 6.022 x 10^23</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.1.2." id="section_4.1.2."></a>4.1.2 Direct Access
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The most important direct access method is
								</p>
							
							
								<p class="c5">
									<b>Item Session.getItem(String abspath)</b>.
								</p>
							
							
								<p class="c5">
									This method takes an absolute path and is used to jump directly to the indicated item (node or property):
								</p>
							
							
								<p class="c12">
									<i>// Directly get the property with</i>
								</p>
							
							
								<p class="c12">
									<i>// the value of Avogadro's Number</i>
								</p>
							
							
								<p class="c12">
									<i>// (i.e., 6.022 x 10^23)</i>
								</p>
							
							
								<p class="c12">
									<b>Property myProperty =<br>
									(Property)mySession.getItem("/a/e/k");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Directly convert to a double</i>
								</p>
							
							
								<p class="c12">
									<b>double myDouble = myProperty.getDouble();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// The variable myDouble will contain the</i>
								</p>
							
							
								<p class="c12">
									<i>// value 6.022 x 10^23</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<br>
									Another direct access method (though for nodes only, not properties) is,
								</p>
							
							
								<p class="c5">
									<b>Node Session.getNodeByUUID(String uuid)</b>.
								</p>
							
							
								<p class="c5">
									This method can be used to access those nodes that have Universally Unique Identifiers (see 4.9 Referenceable Nodes):
								</p>
							
							
								<p class="c12">
									<i>// Assuming that the node /a/e is referenceable</i>
								</p>
							
							
								<p class="c12">
									<i>// and has UUID 1111 2222 3333 4444, we get it</i>
								</p>
							
							
								<p class="c12">
									<b>Node myNode =<br>
									mySession.getNodeByUUID("</b>1111 2222 3333 4444<b>");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// and then get the property and convert it to a double</i>
								</p>
							
							
								<p class="c12">
									<b>double myDouble = myNode.getProperty("k").getDouble();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// The variable myDouble will contain the</i>
								</p>
							
							
								<p class="c12">
									<i>// value 6.022 x 10^23</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.1.3." id="section_4.1.3."></a> 4.1.3 Writing to the Repository
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If the repository is level 2 compliant (see <a href="#section_4.2.">4.2</a> <i>Compliance Levels</i>) then, having acquired a session, the client can write to the repository by adding or removing nodes and properties or changing the values of properties.
								</p>
							
							
								<p class="c5">
									For example, the client can retrieve a node, add a child node to it and add a property to that child node:
								</p>
							
							
								<p class="c12">
									<i>// Retrieve a node</i>
								</p>
							
							
								<p class="c12">
									<b>Node myNode = (Node) mySession.</b><b>getItem</b><b>("/a/e");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Add a child node</i>
								</p>
							
							
								<p class="c12">
									<b>Node newNode = myNode.addNode("n");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Add a property</i>
								</p>
							
							
								<p class="c12">
									<b>newNode.setProperty("x", "Hello");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Persist the changes</i>
								</p>
							
							
								<p class="c12">
									<b>mySession.save();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									The node <b>myNode</b> has the path <b>/a/e</b>, so the new node will have path <b>/a/e/n</b> and the new property will have the path <b>/a/e/n/x</b> and the string value “<b>Hello</b>”.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.1.3.1." id="section_4.1.3.1."></a>4.1.3.1 Removing Items
		</h4>
		
			
				
					
						
							
								<p class="c5">
									To erase an item, the method <b>Item.remove()</b> is used. For example, continuing from the above code segment, the following code,
								</p>
							
							
								<p class="c12">
									<i>// Remove the node /a/e (and its subtree)</i>
								</p>
							
							
								<p class="c12">
									<b>myNode.remove();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Persist the changes</i>
								</p>
							
							
								<p class="c12">
									<b>mySession.save();</b>
								</p>
							
							
								<p class="c5">
									<br>
									would result in the node at <b>/a/e</b> (and its child node <b>/a/e/n</b>) being deleted.
								</p>
							
							
								<p class="c5">
									In the case of <b>Properties</b>, an alternative to <b>remove</b> is to set the property to <b>null</b>. This can be done in two ways, by calling <b>setValue</b> with <b>null</b> on the property itself, or by calling <b>setProperty</b> with the property name and a <b>null</b> value on the property's parent node:
								</p>
							
							
								<p class="c12">
									<i>// Assume we have node /m and two</i>
								</p>
							
							
								<p class="c12">
									<i>// properties /m/p and /m/q</i>
								</p>
							
							
								<p class="c12">
									<b>Node m = (Node) mySession.getItem("/m");</b>
								</p>
							
							
								<p class="c12">
									<b>Property p = m.getProperty("p");</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>//Remove p by calling setValue on p itself</i>
								</p>
							
							
								<p class="c12">
									<b>p.setValue((Value)null);</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>//Remove q by calling setProperty on q's parent node</i>
								</p>
							
							
								<p class="c12">
									<b>m.setProperty("q", (Value)null);</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i>// Persist the changes</i>
								</p>
							
							
								<p class="c12">
									<b>mySession.save();</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<br>
									See <a href="#section_4.7.3.">4.7.3</a> <i>No Null Values.</i>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.1.3.2." id="section_4.1.3.2."></a>4.1.3.2 Transient Storage in the Session
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Notice the use of the method <b>Session.save</b> in the above examples. This method is needed because changes made through most methods of <b>Session</b>, <b>Node</b><sup><b><a class="sdfootnoteanc" name="sdfootnote3anc" href="#sdfootnote3sym" id="sdfootnote3anc"><sup>3</sup></a></b></sup> or <b>Property</b> are not immediately reflected in the persistent workspace. The changes are held in transient storage associated with the <b>Session</b> object until they are either persisted (using <b>Session.save</b> or <b>Item.save</b>) or discarded (using <b>Session.refresh(false)</b> or <b>Item.refresh(false)</b>).
								</p>
							
							
								<p class="c5">
									Changes not yet saved or discarded are called <i>pending changes</i>. Pending changes are immediately visible through the session that made them but are not visible through other sessions accessing the same workspace.
								</p>
							
							
								<p class="c5">
									<b>Session.save</b> validates and, if validation succeeds, persists all pending changes currently stored in the <b>Session</b> object, making them visible to other sessions (though this only applies if the <b>save</b> is not within the scope of a transaction, see <a href="#section_4.1.3.3.">4.1.3.3</a> <i>Transactions</i>, below). Conversely, <b>Session.refresh(false)</b> discards all pending changes currently stored in the <b>Session</b>.
								</p>
							
							
								<p class="c5">
									For more fine-grained control over which changes are persisted or discarded, the methods <b>Item.save</b> and <b>Item.refresh</b> are also provided. <b>Item.save</b> saves all pending changes in the <b>Session</b> that apply to that particular item or its subtree. Analogously, <b>Item.refresh(false)</b> discards all pending changes that apply to that item or its subtree. See <a href="#section_7.1.">7.1</a> <i>Writing Repository Content</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.1.3.3." id="section_4.1.3.3."></a>4.1.3.3 Transactions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Throughout this document, any discussion of “persistence of changes upon <b>save</b>” or “immediate persistence of changes through methods that do not require <b>save</b>” refers to cases in which the <b>save</b> is performed <i>outside the scope of a transaction</i>.
								</p>
							
							
								<p class="c5">
									<i>Within the scope of a transaction,</i> <b><i>save</i></b> <i>and other methods that act directly on the persistent workspace will</i> not <i>make changes visible to other sessions; this will only occur when the transaction is committed.</i>
								</p>
							
							
								<p class="c5">
									However, even within the scope of a transaction, <b>save</b> still performs validation and, if successful, clears pending changes from the <b>Session</b>. As well, <b>refresh(false)</b> still clears pending changes from the <b>Session</b>.
								</p>
							
							
								<p class="c5">
									When a transaction commits, it persists only those changes that have been saved; it does <i>not</i> automatically <b>save</b> pending changes <i>and then</i> commit them as well. After a commit, pending changes remain in the <b>Session</b> and may be saved and committed later. Note that support for transactions is optional. See <a href="#section_8.1.">8.1</a> <i>Transactions</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.1.4." id="section_4.1.4."></a> 4.1.4 Nodes, Properties and Items
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Because nodes and properties have some common functionality, common methods are defined in the interface <b>Item</b>, to which the sub-interfaces <b>Node</b> and <b>Property</b> add further methods. The following diagram summarizes the basic relationships between the interfaces.
								</p><img src="jsr170-4_1_4.png" name="Frame4" alt="Frame4" id="Frame4">
							
							
								<p class="c5">
									This UML diagram indicates that <b>Property</b> and <b>Node</b> are subinterfaces of <b>Item</b>. A single <b>Property</b> has one and only one parent <b>Node</b>. A <b>Node</b> can have either zero parents (only if it is the root node) or one parent. A <b>Node</b> can have any number of child <b>Item</b> objects (i.e., either <b>Property</b> or <b>Node</b> objects).
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.2." id="section_4.2."></a>4.2 Compliance Levels
		</h3>
		
			
				
					
						
							
								<p class="c5">
									This specification is divided into two compliance levels and a set of additional optional features which repositories of either level may support. Level 1 provides for read functions and level 2 adds additional write functions. The functional division is as follows:
								</p>
							
							
								<p class="c5">
									<b>Level 1 includes:</b>
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Retrieval and traversal of nodes and properties
				</p>
			</li>
			<li>
				<p class="c5">
					Reading the values of properties
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					Transient namespace remapping
				</p>
			</li>
			<li>
				<p class="c5">
					Export to XML/SAX
				</p>
			</li>
			<li>
				<p class="c5">
					Query facility with XPath syntax
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					Discovery of available node types
				</p>
			</li>
			<li>
				<p class="c5">
					Discovery of access control permissions
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									<b>Level 2 adds</b>:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Adding and removing nodes and properties
				</p>
			</li>
			<li>
				<p class="c5">
					Writing the values of properties
				</p>
			</li>
			<li>
				<p class="c5">
					Persistent namespace changes
				</p>
			</li>
			<li>
				<p class="c5">
					Import from XML/SAX
				</p>
			</li>
			<li>
				<p class="c5">
					Assigning node types to nodes
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									<b>Optional:</b>
								</p>
							
							
								<p class="c5">
									<i>Any combination of the following features may be added to an implementation of either level.</i>
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Transactions
				</p>
			</li>
			<li>
				<p class="c5">
					Versioning
				</p>
			</li>
			<li>
				<p class="c5">
					Observation (Events)
				</p>
			</li>
			<li>
				<p class="c5">
					Locking
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					SQL syntax for query
				</p>
			</li>
		</ul>
		<h3>
			<a name="section_4.3." id="section_4.3."></a>4.3 Same–Name Siblings
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A particular node <i>may</i>, in some cases, have <i>same-name siblings</i>, that is, other nodes that share its parent and have the same name. Whether a particular node allows this depends on the <i>child-node definition</i> that applies to it (this definition is part of the node type of that node’s parent, see section <a href="#section_6.7.">6.7</a> <i>Node Types</i>).
								</p>
							
							
								<p class="c5">
									The standard method for retrieving a set of such nodes is <b>Node.getNodes(String namePattern)</b> which returns an iterator over all the child nodes of the calling node that have the specified pattern (by making <b>namePattern</b> just a name, without wildcards, we can get all the nodes with that exact name, see section <a href="#section_6.2.3.">6.2.3</a> <i>Node Read Methods</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.3.1." id="section_4.3.1."></a>4.3.1 Index Notation
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A particular node within a same-name sibling group can be addressed by embedding an array-like notation within the path. For example the path <b>/a/b[2]/c[3]</b> specifies the third child node called <b>c</b> of the second child node called <b>b</b> of the node <b>a</b> below the root.
								</p>
							
							
								<p class="c5">
									The indexing of same-name siblings begins at <b>1</b>, not <b>0</b>. This practice stems from the need to allow XPath-based queries on the repository (see <a href="#section_6.6.">6.6</a> <i>Searching Repository Content</i>).
								</p>
							
							
								<p class="c5">
									However, as opposed to the semantics of XPath, a name in a content repository path that does not explicitly specify an index implies an index of <b>1</b>. For example, <b>/a/b/c</b> is equivalent to <b>/a[1]/b[1]/c[1]</b>.
								</p>
							
							
								<p class="c5">
									The indexing is based on the order in which child nodes are returned in the iterator acquired through <b>Node.getNodes()</b>.
								</p>
							
							
								<p class="c5">
									Same-name siblings are indexed by their position relative to each other in this larger ordered set. For example, the order of child nodes returned by a <b>getNodes</b> on some parent might be:
								</p>
							
							
								<p class="c5">
									<b>[A, B, C, A, D]</b>
								</p>
							
							
								<p class="c5">
									In this case, <b>A[1]</b> refers the first node in the list and <b>A[2]</b> refers to the fourth node in the list.
								</p>
							
							
								<p class="c5">
									Note that regardless of whether orderable child nodes are supported in general (see <a href="#section_4.4.">4.4</a> <i>Orderable Child Nodes</i>), the relative ordering of a set of same name sibling nodes must be persistent; it cannot change arbitrarily between read method calls or between sessions. This requirement stems from the fact that the path of a node must not change arbitrarily, and in the case of a same-name sibling, its position relative to its co-named siblings defines part of its path.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.3.2." id="section_4.3.2."></a> 4.3.2 Support for Same Name Siblings is Optional
		</h4>
		
			
				
					
						
							
								<p class="c5">
									As mentioned, whether or not a particular node allows multiple child items with the same name is governed by the <i>node type</i> of that particular node. See <a href="#section_6.7.">6.7</a> <i>Node Types</i>.
								</p>
							
							
								<p class="c5">
									Though there is a required set of node types that every compliant repository must support, none of these required node types allow same-name siblings and any further node types available in a particular repository are implementation-specific. Therefore, it is possible for a repository to disallow same-name siblings altogether by restricting the set of available node types.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.3.3." id="section_4.3.3."></a> 4.3.3 Properties Cannot Have Same Name Siblings
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Properties cannot have sibling properties of the same name. However, they may have multiple values. See <a href="#section_4.7.1.">4.7.1</a>, <i>Multi-Value Properties</i>, below.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.4." id="section_4.4."></a>4.4 Orderable Child Nodes
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Some nodes may support client-controlled ordering of their child nodes. Whether a particular node preserves the order of its child nodes is governed by its node type. See <a href="#section_6.7.">6.7</a> <i>Node Types</i>.
								</p>
							
							
								<p class="c5">
									If a node supports orderable child nodes, the order of its child nodes, as reflected in the iterator acquired through <b>Node.getNodes()</b> can be controlled by the client using the method <b>Node.orderBefore</b>. The order of child nodes is persisted upon <b>save</b> of the parent node.
								</p>
							
							
								<p class="c5">
									When a child node is added to a node that supports orderable child nodes it is added to the end of the list. It can then be re-ordered using the above method.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.4.1." id="section_4.4.1."></a> 4.4.1 Orderable Same Name Siblings
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If the parent node supports orderable child nodes <i>and</i> same-name siblings then the same-name sibling child nodes will be orderable by the application just like an other child nodes. For example, given the following initial ordering of child nodes,
								</p>
							
							
								<p class="c5">
									<b>[A, B, C, A, D]</b>
								</p>
							
							
								<p class="c5">
									a call to
								</p>
							
							
								<p class="c5">
									<b>orderBefore("A[2]","A[1]")</b>
								</p>
							
							
								<p class="c5">
									will cause the child node currently called <b>A[2]</b> to be moved to the position before the child node currently called <b>A[1]</b>, the resulting order will be:
								</p>
							
							
								<p class="c5">
									<b>[A, A, B, C, D]</b>
								</p>
							
							
								<p class="c14">
									where the first <b>A</b> is the one that was formerly after <b>C</b> and the second <b>A</b> is the one that was formerly at the head of the list.
								</p>
							
							
								<p class="c5">
									Note, however, that after the completion of this operation <i>the indices of the two nodes have now switched</i>, due to their new positions relative to each other. What was formerly <b>A[2]</b> is now <b>A[1]</b> and what was formerly <b>A[1]</b> is now <b>A[2]</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.4.2." id="section_4.4.2."></a> 4.4.2 Non-orderable Child Nodes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a node does not support orderable child nodes this means that it is left up to the implementation to maintain the order of child nodes. Applications should not, in this case, depend on the order of child nodes returned by <b>Node.getNodes</b>, as it may change at any time. The only exception to this rule is that same-name siblings must maintain their relative order across read method invocations and across sessions.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.4.3." id="section_4.4.3."></a> 4.4.3 Orderable Child Node Support is Optional
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Like same name siblings, support for orderable child nodes depends on the range of node types available in a particular repository. Orderable child nodes are not mandated by any required node types, and any additional node types are implementation-specific. Therefore, orderable child node support is, in effect, optional.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.4.4." id="section_4.4.4."></a> 4.4.4 Properties are Never Orderable
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Properties are never client orderable, the order in which properties are returned by <b>Node.getProperties</b> is always maintained by the implementation and can change at any time.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.5." id="section_4.5."></a>4.5 Namespaces
		</h3>
		
			
				
					
						
							
								<p class="c5">
									The name of a node or property may have a <i>prefix</i>, delimited by a single '<b>:</b>' (colon) character that indicates the <i>namespace</i> of the item.
								</p>
							
							
								<p class="c5">
									Namespacing in a content repository is patterned after namespacing in XML. As in XML, the prefix is actually shorthand for the full namespace, which is a URI. URIs are used as namespaces in order to minimize naming collisions. Every compliant (level 1 or 2) repository has a namespace registry. The namespace registry always contains at least the following built-in namespace prefixes:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>jcr</b> Reserved for items defined within built-in node types.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					<b>nt</b> Reserved for the names of built-in primary node types.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>mix</b> Reserved for the names of built-in mixin node types.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>xml</b> Reserved for reasons of compatibility with XML.
				</p>
			</li>
			<li>
				<p>
					“” (the empty prefix) This indicates the default namespace.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									In level 1 repositories the prefix assigned to an existing registered namespace (a URI) may be temporarily over-ridden by another prefix within the scope of a particular <b>Session</b>. Level 2 repositories have, additionally, the capability to add, remove and change the set of namespaces (URIs) stored in the namespace registry (excluding the built-in namespaces). See section <a href="#section_6.3.">6.3</a>, <i>Namespaces</i>, for more details.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.6." id="section_4.6."></a>4.6 Path Syntax
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A syntactically valid path is:
								</p>
							
							
								<p class="c12">
									path ::= properpath ['/']
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									properpath ::= abspath | relpath
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									abspath ::= '/' relpath
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									relpath ::= pathelement | relpath '/' pathelement
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									pathelement ::= name | name '[' number ']' | '..' | '.'
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									number ::= /* An integer &gt; 0 */
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									name ::= simplename | prefixedname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									simplename ::= onecharsimplename |
								</p>
							
							
								<p class="c12">
									twocharsimplename |
								</p>
							
							
								<p class="c12">
									threeormorecharname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									prefixedname ::= prefix ':' localname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									localname ::= onecharlocalname |
								</p>
							
							
								<p class="c12">
									twocharlocalname |
								</p>
							
							
								<p class="c12">
									threeormorecharname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									onecharsimplename ::= (* Any Unicode character except:<br>
									'.', '/', ':', '[', ']', '*',<br>
									''', '"', '|' or any whitespace
								</p>
							
							
								<p class="c12">
									character *)
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									twocharsimplename ::= '.' onecharsimplename |
								</p>
							
							
								<p class="c12">
									onecharsimplename '.' |
								</p>
							
							
								<p class="c12">
									onecharsimplename onecharsimplename
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									onecharlocalname ::= nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									twocharlocalname ::= nonspace nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									threeormorecharname ::= nonspace string nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									prefix ::= (* Any valid XML Name *)
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									string ::= char | string char
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									char ::= nonspace | ' '
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									nonspace ::= (* Any Unicode character except:<br>
									'/', ':', '[', ']', '*',<br>
									''', '"', '|' or any whitespace
								</p>
							
							
								<p class="c12">
									character *)
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.6.1." id="section_4.6.1."></a>4.6.1 Names vs. Paths
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A “name” in this specification is a path element <i>without any square-bracket index</i>. For example, <b>myapp:paragraph</b> is a <i>name</i> and a valid <i>relative path</i> (of depth 1) whereas, <b>myapp:paragraph[3]</b> is not a name, it is only a relative path.
								</p>
							
							
								<p class="c5">
									Names and paths are not simply strings with certain syntax. They have special semantics in that they respect the namespace mappings of the current <b>Session</b> (see <a href="#section_6.3.">6.3</a> <i>Namespaces</i>). The special property types <b>NAME</b> and <b>PATH</b> are provided to enable the storage of these values in the repository in a namespace-sensitive way (see <a href="#section_6.2.5.">6.2.5</a> <i>Property Types</i> as well as <a href="#section_4.7.">4.7</a> <i>Properties</i>, immediately below).
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.7." id="section_4.7."></a>4.7 Properties
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Every property is of one of the following types:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>PropertyType.STRING</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.BINARY</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.DATE</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.LONG</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.DOUBLE</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.BOOLEAN</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.NAME</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.PATH</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PropertyType.REFERENCE</b>
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Methods are provided to read (in level 1) and write (in level 2) the values of properties to and from the appropriate native Java types (i.e. <b>PropertyType.STRING</b> values can be read and written as <b>java.lang.String</b> objects, <b>PropertyType.LONG</b> values into Java <b>long</b> variables, and so on).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.7.1." id="section_4.7.1."></a>4.7.1 Multi-Value Properties
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In some cases, a property may have more than one value. A property that may have more than one value is referred to as a multi-valued property (regardless of whether it currently has one or more than one value).
								</p>
							
							
								<p class="c5">
									Whether a particular property is a multi-valued property is governed by the property definition applicable to it, which is determined by the node type of the property's parent node.
								</p>
							
							
								<p class="c5">
									The values within a multi-valued property are ordered.
								</p>
							
							
								<p class="c5">
									Accessing the values of such a property is done with the method <b>Property.getValues</b>, which returns an array of <b>Value</b> objects that contains the values in their prescribed order.
								</p>
							
							
								<p class="c5">
									Accessing a multi-valued property with <b>Property.getValue</b>, or a single-value property with <b>Property.getValues</b> will throw a <b>ValueFormatException</b>.
								</p>
							
							
								<p class="c5">
									The values stored within a multi-valued property are all of the same type.
								</p>
							
							
								<p class="c5">
									As with single-value properties, there is no such thing as a <b>null</b> value. If a value within a multi-value property is set to <b>null</b>, this is equivalent to removing that value from the value array. In such a case the array is automatically compacted: shifting the indexes of those values with indexes greater than that of the removed value by -1.
								</p>
							
							
								<p class="c5">
									Note that this <i>does</i> mean that a multi-value property can have <i>no values</i> (i.e., be an empty array), whereas a single-value property either has a (non-null) value or does not exist.
								</p>
							
							
								<p class="c5">
									See <a href="#section_7.1.5.">7.1.5</a> <i>Adding and Writing Properties</i> for more details.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.7.2." id="section_4.7.2."></a> 4.7.2 Reference, Path and Name Property Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Three of the property types listed above have special semantics: <b>REFERENCE</b>, <b>PATH</b> and <b>NAME</b>.
								</p>
							
							
								<p class="c5">
									<b>NAME</b> properties are used for storing strings that are namespace-qualified, such as the names of node types or the names of repository items. A <b>NAME</b> property can be thought of as a namespace-aware <b>STRING</b>. It is set like a string (for example, <b>setProperty("aNodeType", "nt:file")</b>). However, the prefix is automatically mapped to its current URI and the value is stored using that full namespace URI. When the property is later read the mapping is reversed and if the URI in question has been remapped that remapping is reflected in the returned value.
								</p>
							
							
								<p class="c5">
									A <b>PATH</b> property represents a path in a workspace (either relative or absolute) and therefore can also be used to refer to items elsewhere in the workspace. However, the <b>PATH</b> property does not enforce referential integrity; in other words it can point to a location where no item currently exists. Like a <b>NAME</b> property, a <b>PATH</b> is also namespace-aware in that its apparent value when read will always reflect the current prefix to URI mapping.
								</p>
							
							
								<p class="c5">
									A <b>REFERENCE</b> property is used to provide a named reference to a node elsewhere in the workspace. The value of the property is the UUID of the node to which it refers. Consequently, only a <i>referenceable node</i> can be the target of a <b>REFERENCE</b> property (see <a href="#section_4.9.">4.9</a> <i>Referenceable Nodes</i>). <b>REFERENCE</b> properties have the additional semantic feature of maintaining referential integrity by preventing the removal of any node that is currently the target of a reference property. To remove a node that is the target of a <b>REFERENCE</b>, one must first remove the <b>REFERENCE</b>. The check for referential integrity is done when an attempt is made to persist the removal of a node (that is, either on <b>save</b>, or, if the change was made within a transaction, on <i>commit</i>; in any case, the check is not done immediately on <b>remove</b>). The method <b>Node.getReferences()</b> can be used to find all <b>REFERENCE</b> properties that refer to a particular node. The method <b>Node.setProperty(String name, Node value)</b> can be used to set the value of a <b>REFERENCE</b> property to the UUID of the specified node.
								</p>
							
							
								<p class="c5">
									In versioning repositories the version storage is exposed in the workspace tree as a protected subtree below <b>jcr:system/jcr:versionStorage</b> (see <a href="#section_8.2.2.">8.2.2</a> <i>Version Storage</i>). Within this subtree, the referential integrity requirement is lifted for <b>REFERENCE</b> properties stored as part of the frozen state of a version (see <a href="#section_8.2.2.9.">8.2.2.9</a> <i>Reference Properties within a Version</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.7.3." id="section_4.7.3."></a>4.7.3 No Null Values
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Every property must have a value. The range of property states does not include having a “null value”, or “no value”. Setting a property to “null” is equivalent to removing that property. In the case of multi-value properties, the setting of a particular value within the array to null results in the removal of that value and the compacting of the array. As a result it <i>is</i> possible to have a multi-value property with no values (an empty array). See <a href="#section_7.1.5.">7.1.5</a> <i>Adding and Writing Properties</i>.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.8." id="section_4.8."></a>4.8 Node Types
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Every node <i>must</i> have one and only one <i>primary node type</i>. The primary node type defines the names, types and other characteristics of the properties and child nodes that a node is allowed (or required) to have. Every node has a special property called <b>jcr:primaryType</b> that records the name of its primary node type.
								</p>
							
							
								<p class="c5">
									In addition to its primary node type, a node <i>may</i> also have one or more <i>mixin types</i>. These are node type definitions that can mandate extra characteristics (i.e., more child nodes, properties and their respective names and types) for a particular node in addition to those enforced by its primary node type. When a node is assigned a mixin node type, it acquires a special multi-value property called <b>jcr:mixinTypes</b> that records its mixin node types.
								</p>
							
							
								<p class="c5">
									Level 1 of the specification provides methods for discovering the node types of existing nodes, and for discovering and reading the definitions of node types available in the repository.
								</p>
							
							
								<p class="c5">
									Level 2 of the specification provides methods for assigning primary and mixin node types to nodes.
								</p>
							
							
								<p class="c5">
									The specification does not attempt to provide methods for defining, creating or managing primary or mixin node types.
								</p>
							
							
								<p class="c5">
									This specification also provides a set of predefined primary and mixin node types; some required and some optional. See <a href="#section_6.7.">6.7</a> <i>Node Types</i>.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.9." id="section_4.9."></a>4.9 Referenceable Nodes
		</h3>
		
			
				
					
						
							
								<p class="c5">
									The concept of the <i>referenceable node</i> is foundational to many features of the repository, including <i>multiple workspaces</i> and <i>versioning</i>. The following principles define the characteristics and functioning of referenceable nodes:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					A repository <i>may</i> support <i>referenceable</i> <i>nodes</i>. To do this the repository must support the mixin type <b>mix:referenceable</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>mix:referenceable</b> type has the effect of enforcing, on any node to which it is assigned, the presence of a property called <b>jcr:uuid</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>jcr:uuid</b> property is a protected, auto-created, mandatory property. This means that it is created and administered by the system and can only be read (but not changed or deleted) by the client.
				</p>
			</li>
			<li>
				<p class="c5">
					The job of the <b>jcr:uuid</b> property is to expose the universally unique identifier (UUID) of its node.
				</p>
			</li>
			<li>
				<p class="c5">
					The UUID of a referenceable node is assigned on node creation (or at least on node persistence) by the system itself.
				</p>
			</li>
			<li>
				<p class="c5">
					In a given workspace, there is never more than one node with a given UUID, though there may be nodes that are not <b>mix:referenceable</b> and so do not have UUIDs at all.
				</p>
			</li>
			<li>
				<p class="c5">
					If a node that is not <b>mix:referenceable</b> happens to have a property called <b>jcr:uuid</b>, then this property has no special significance (Note that adding such a property is not recommended: In general, the <b>jcr</b> prefix should be reserved for items defined within the specification, though this restriction may not be enforced by the implementation).
				</p>
			</li>
			<li>
				<p class="c5">
					A repository implementation may make its workspace root nodes <b>mix:referenceable</b>. If so, then the root node of <i>all</i> workspaces must be referenceable, and all must have the <i>same</i> UUID.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Some implementations may allow or even require every node to have a UUID, and hence be <b>mix:referenceable</b>. In some cases however, especially where this API is implemented on top of an existing datastore, the provision of UUIDs for every node may be impractical. For this reason, an implementation is free to enforce whatever policies it wishes regarding where within a workspace tree referenceable nodes may be created or existing nodes extended with an assignment of <b>mix:referenceable</b> (in fact, this stems from the more general principle that an implementation is free to enforce such policies on the assignment of primary and mixin node types in general).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.9.1.1." id="section_4.9.1.1."></a>4.9.1.1 When UUIDs are Assigned
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In some client-server implementations the assignment of a permanent UUID may be done on the server. In these cases it is not practical for a newly created referenceable node to be given a UUID upon creation. Rather, it makes more sense for the UUID to be assigned upon <b>save</b> of that node. In such cases a “dummy UUID” may be assigned on creation of a new node while the real UUID assignment takes place later, upon <b>save</b>. Applications should not, therefore, rely on the UUID of a node before that node is saved for the first time.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.9.1.2." id="section_4.9.1.2."></a>4.9.1.2 Reference Properties
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Being referenceable allows a node to be the target of a property of <b>PropertyType.REFERENCE</b>. A <b>REFERENCE</b> property stores the UUID of an existing node in the same workspace and it enforces referential integrity (see <a href="#section_6.2.5.4.">6.2.5.4</a> <i>Reference</i>). An exception to the referential integrity rule is made for <b>REFERENCE</b> properties stored as part of frozen version state in the version storage (see <a href="#section_8.2.2.9.">8.2.2.9</a> <i>Reference Properties within a Version</i>).
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.10." id="section_4.10."></a>4.10 Workspaces
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A content repository is composed of a number of <i>workspaces</i>. Each workspace contains a single rooted tree of items. In the simplest case a repository will consist of just one workspace. In more complex cases a repository will consist of more than one workspace.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.10.1." id="section_4.10.1."></a> 4.10.1 Single Workspace Repositories
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A repository with only a single workspace consists of a single tree of nodes and properties. The example at the beginning of this section (<a href="#_Level_1section_6.1.1.">4</a> <i>The Repository Model</i>) describes a single workspace repository.
								</p>
							
							
								<p class="c5">
									Since a given workspace contains at most one node with a given UUID, in this case, there is at most one node with a given UUID <i>in the repository as a whole</i>.
								</p>
							
							
								<p class="c5">
									The following diagram depicts a single workspace repository:
								</p>
							
							
								<p>
									<img src="jsr170-4_10_1.gif"><br>
									<br>
								</p>
							
							
								<p class="c5">
									The small circles represent nodes. The arrows point from parent to child and are labeled with the name of the child. The name of the root node is actually the empty string though, for clarity, it is indicated here with the string “<i>[root]</i>”. The numbers within the nodes represent the UUIDs of the nodes. For example, the UUID of the root node <b>/</b> is <i>00</i> and the UUID of <b>/a/d</b> is <i>03</i>. The node <b>/a/c</b> is not referenceable and therefore does not have a UUID.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.10.2." id="section_4.10.2."></a> 4.10.2 Multiple Workspaces and Corresponding Nodes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In repositories that have multiple workspaces, a node in one workspace may have <i>corresponding nodes</i> in other workspaces. A node's corresponding node is defined as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					A node's corresponding nodes are those with the same <i>correspondence identifier</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					The correspondence identifier of a referenceable node is its UUID.
				</p>
			</li>
			<li>
				<p class="c5">
					The correspondence identifier of a non-referenceable node with at least one referenceable ancestor is the pair consisting of the UUID of its nearest referenceable ancestor and its relative path from that ancestor.
				</p>
			</li>
			<li>
				<p class="c5">
					The correspondence identifier of a non-referenceable node with no referenceable ancestor is its absolute path.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Recall also that (as stated in 4.9 Referenceable Nodes) if a repository has a workspace with a referenceable root node then <i>all</i> its workspaces must have referenceable root nodes <i>and</i> those root nodes must all have the same UUID.
								</p>
							
							
								<p class="c5">
									Apart from having the same correspondence identifier, corresponding nodes need have nothing else in common. They can have entirely different properties and child nodes, for example.
								</p>
							
							
								<p class="c5">
									While a node <i>may</i> have a corresponding node in another workspace, it is not <i>required</i> to.
								</p>
							
							
								<p class="c5">
									Note that there is still at most one node with a given UUID per workspace.
								</p>
							
							
								<p class="c5">
									The <b>update</b> method,
								</p>
							
							
								<p class="c5">
									<b>Node.update(String srcWorkspace)</b>
								</p>
							
							
								<p class="c5">
									causes <b>this</b> node and its subtree to be replaced by a clone of this nodes corresponding node and its subtree in <b>srcWorkspace</b>.
								</p>
							
							
								<p class="c5">
									For more details on corresponding nodes and the update method see <a href="#section_7.1.8.">7.1.8</a> <i>Updating and Cloning Nodes across Workspaces</i>.
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.10.2.1." id="section_4.10.2.1."></a>4.10.2.1 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following diagram shows a schematic of a two-workspace repository.
								</p>
							
							
								<p>
									<img src="jsr170-4_10_2_1.png">
								</p>
							
							
								<p class="c5">
									Here we see two workspaces, <b>WS</b><b><sub>1</sub></b> and <b>WS</b><b><sub>2</sub></b>. The dotted lines indicate corresponding nodes. For example, the node <b>/a</b> in <b>WS</b><b><sub>1</sub></b> corresponds to <b>/m</b> in <b>WS</b><b><sub>2</sub></b> because both have a UUID of <i>01.</i> Similarly, <b>/b</b> in <b>WS1</b> corresponds with <b>/b</b> in <b>WS2</b>. In these cases, because the nodes are referenceable, their paths and names are not relevant in determining their correspondence.
								</p>
							
							
								<p class="c5">
									On the other hand, <b>/a/c</b> in <b>WS</b><b><sub>1</sub></b> corresponds with <b>/m/c</b> in <b>WS</b><b><sub>2</sub></b> because they have the same relative path (namely, <b>c</b>) from their nearest referenceable corresponding ancestors (namely, <b>/a</b> and <b>/m</b> in <b>WS</b><b><sub>1</sub></b> and <b>WS</b><b><sub>2</sub></b> respectively).
								</p>
							
							
								<p class="c5">
									Note there can also be nodes (such as <b>/a/d</b> in <b>WS</b><b><sub>1</sub></b>) that exist in one workspace but not in the other.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.11." id="section_4.11."></a>4.11 Versioning
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Support for versioning is an optional feature. The versioning system is built on top of the system of workspaces and referenceable nodes described above.
								</p>
							
							
								<p class="c5">
									In a repository that supports versioning, a workspace may contain both <i>versionable</i> and <i>nonversionable</i> nodes. A node is versionable if and only if it has been assigned the <i>mixin type</i> <b>mix:versionable</b>, otherwise it is nonversionable. Repositories that do not support versioning will simply not provide this mixin type, whereas repositories that do support versioning must provide it. The type <b>mix:versionable</b> is a subtype of <b>mix:referenceable</b>, so if a node is versionable it is automatically also referenceable and thus has a UUID.
								</p>
							
							
								<p class="c5">
									Being versionable means that at any given time the node's state can be saved for possible future recovery. This saved state is called a <i>version</i> and the action of saving it is called <i>checking in</i>.
								</p>
							
							
								<p class="c5">
									Versions exist as part of a <i>version history</i>. Within a version history, the versions form a <i>version graph</i> that describes the predecessor/successor relations among versions of a particular versionable node.
								</p>
							
							
								<p class="c5">
									Version histories and their contained versions are stored in version storage. There is one version storage per repository, though it is exposed in each workspace as a special protected subtree below the node <b>/jcr:system/jcr:versionStorage</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_4.11.1.1." id="section_4.11.1.1."></a>4.11.1.1 Relation Between Nodes and Version Histories
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The relationship between nodes and version histories is built on the notion of correspondence via UUID. The details are as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Each set of corresponding versionable nodes (nodes with the same UUID) share the same version history.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					In a given workspace, there is at most one versionable node per version history (this follows directly from the fact that there is at most one node from each correspondence set per workspace).
				</p>
			</li>
			<li>
				<p class="c5">
					Given a particular workspace, there may be version histories for which that particular workspace does not contain a corresponding versionable node.
				</p>
			</li>
			<li>
				<p class="c5">
					A workspace may contain nonversionable nodes, which, of course, never have corresponding version histories.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					When a new versionable node is created (i.e., the first instance in the repository as whole) a version history for that node is automatically created in version storage.
				</p>
			</li>
			<li>
				<p class="c5">
					If a versionable node is cloned to another workspace, it maintains the same UUID and the new corresponding versionable node remains associated with the original's version history.
				</p>
			</li>
			<li>
				<p class="c5">
					Note that since all versionable nodes are by definition referenceable, there is no need to include the qualification involving relative paths to the nearest versionable node (or root node) as in the discussion of <b>update</b>, above.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_4.11.1.2." id="section_4.11.1.2."></a>4.11.1.2 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following diagram illustrates a possible repository architecture.
								</p>
							
							
								<p>
									<img src="jsr170-4_11_1_2.png">
								</p>
							
							
								<p class="c5">
									This diagram shows a repository that supports versioning and contains two workspaces. The version storage is represented by the area in the bottom. It contains a version history for each versionable node in the repository. The versionable nodes in the workspaces are shown in various shadings. The nonversionable nodes are shown in white.
								</p>
							
							
								<p class="c5">
									All versionable nodes are referenceable, though not all referenceable nodes are versionable (for example the node <i>03</i> in <b>WS</b><b><sub>1</sub></b> is referenceable, because it has a UUID, but it is not versionable). Both <b>WS</b><b><sub>1</sub></b> and <b>WS</b><b><sub>2</sub></b> also contain nonreferenceable nodes (the nodes <b>c</b> below <i>01</i>).
								</p>
							
							
								<p class="c5">
									In the diagram the version histories are represented by stacked circles of differing shades. Each versionable node shares its version history with its corresponding node in the other workspace.
								</p>
							
							
								<p class="c5">
									At any given time a particular workspace may hold nodes based on various versions stored in version storage. In the diagram, <b>WS</b><sub><b>1</b></sub> holds nodes based on the “light gray” version of the nodes <i>00</i>, <i>01</i> and <i>02</i>. <b>WS</b><sub><b>2</b></sub>, in contrast, has nodes based on the “dark gray” version of <i>00</i>, the “light gray” version of <i>01</i> and the “dotted” version of <i>02</i>.
								</p>
							
							
								<p class="c5">
									Note that for the purposes of illustration, each version history is depicted as containing three versions. This is a simplification; in an actual system the version histories of distinct nodes may differ. Furthermore, in this picture, parent child relations within the version storage are not shown. See <a href="#section_8.2.">8.2</a> <i>Versioning</i> for a more detailed description.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.12." id="section_4.12."></a>4.12 Metadata
		</h3>
		
			
				
					
						
							
								<p class="c5">
									All content in the repository is ultimately accessed through properties (that is, objects that implement the <b>Property</b> interface). The API does not distinguish between “real” content and meta-content.
								</p>
							
							
								<p class="c5">
									Such a separation would only duplicate the entire API, since one would probably want to provide the same functionality for handling both meta-content and primary content. The distinction is in any case only meaningful at the level of the application, not the repository. Any particular application built on top of a compliant repository may, of course, choose which content is to be considered “meta”, and which primary.
								</p>
							
							
								<p class="c5">
									However, the API does provide the concept of the <i>primary child item.</i> Any one of a node’s child items may be specified as its primary child item. This item can be directly accessed (without knowing its name) with the method <b>Node.getPrimaryItem()</b>. The primary item of a particular node (if it has one) is declared in its node type.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_4.13." id="section_4.13."></a> 4.13 Hierarchical versus Direct Access
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Though this specification provides a hierarchical, tree-based view of content, it is also compatible with repository implementations that are not primarily hierarchy-based.
								</p>
							
							
								<p class="c5">
									Though such implementations must still expose a hierarchical structure, the flexibility of this specification ensures that this need not be a particularly restrictive requirement. The following strategies, amongst others, can be adopted by implementations that are not primarily hierarchical:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The exposed hierarchy can be almost flat. A very shallow tree consisting of a root node with a large set of child nodes or properties is a valid arrangement. The names of the nodes may be identical with the UUIDs of the nodes.
				</p>
			</li>
			<li>
				<p class="c5">
					There is no requirement that a particular hierarchical view of the repository be in any way “primary”. Through the use of <b>REFERENCE</b> properties feature, many orthogonal hierarchical views of the same underlying content are supported. This does away with the notion that there is a single canonical hierarchy. See, for example, <a href="#section_6.7.22.7.">6.7.22.7</a> <i>nt:linkedFile</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					Hierarchical navigation is only one possible way to access the repository. The specification also supports a search query interface (see <a href="#section_6.6.">6.6</a> <i>Searching Repository Content</i>). In addition, direct access via node UUID is also provided (see <a href="#section_6.2.1.">6.2.1</a> <i>Session Read Methods)</i>.
				</p>
			</li>
		</ul>
		<h2>
			<a name="section_5." id="section_5."></a>5 Example Implementations
		</h2>
		<h3>
			<a name="section_5.1." id="section_5.1."></a> 5.1 A File System-backed Content Repository
		</h3>
		
			
				
					
						
							
								<p class="c5">
									An obvious implementation of a content repository is as a layer on top of a conventional file system.
								</p>
							
							
								<p class="c5">
									Consider, for example, a file system with the following layout:
								</p>
							
							
								<p class="c12">
									<b>content/</b>
								</p>
							
							
								<p class="c12">
									<b>newpaintings/</b>
								</p>
							
							
								<p class="c12">
									<b>bigredstripe.gif</b>
								</p>
							
							
								<p class="c12">
									<b>bigredstripe.desc</b>
								</p>
							
							
								<p class="c12">
									<b>oldpaintings/</b>
								</p>
							
							
								<p class="c12">
									<b>sistinechapel.gif</b>
								</p>
							
							
								<p class="c12">
									<b>sistinechapel.desc</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									Here is a possible mapping of this file structure to the content repository:
								</p>
								
									
										
											
												
													
														
															
																
																	
																		
																			
																				
																					
																						
																							
																								<p class="c12">
																									<b>Node</b>
																								</p>
																							
																							
																								<p class="c12">
																									<b>Property = "..."</b>
																								</p>
																							
																						
																					
																				
																			
																		
																	
																
															
														
													
												
											
										
									
								
							
						
					
				
			
		
		<table border="1" cellpadding="7" cellspacing="0">
			
			
			<tr valign="top">
				<td>
					<p class="c12">
						<b>content/</b>
					</p>
				</td>
				<td>
					<p class="c12">
						<b>/</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>newpaintings/</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>newpaintings</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>bigredstripe.gif</b>
					</p>
				</td>
				<td>
					<p>
						│ ├─<b>bigredstripe.gif</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>(creation date of the file)</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>jcr:created = "2001-01-01T00:00:00.000Z"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>&lt;binary data&gt;</i></b>
					</p>
				</td>
				<td>
					
						
							<br>
							│ │ └─<b>jcr:content</b>
						
						
							<br>
							│ │ └─<b>myapp:data = &lt;binary data&gt;</b>
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>bigredstripe.desc</b>
					</p>
				</td>
				<td>
					<p>
						│ └─<b>bigredstripe.desc</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>(creation date of the file)</b>
					</p>
				</td>
				<td>
					<p>
						│ ├─<b>jcr:created = "2001-01-02T00:00:00.000Z"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>"An excellent example..."</b>
					</p>
				</td>
				<td>
					
						
							<br>
							│ └─<b>jcr:content</b>
						
						
							<br>
							│ └─<b>myapp:data = "An excellent..."</b>
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>oldpaintings/</b>
					</p>
				</td>
				<td>
					<p>
						└─<b>oldpaintings</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>sistinechapel.gif</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>sistinechapel.gif</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>(creation date of the file)</b>
					</p>
				</td>
				<td>
					<p>
						│ ├─<b>jcr:created = "2001-01-03T00:00:00.000Z"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>&lt;binary data&gt;</i></b>
					</p>
				</td>
				<td>
					
						
							<br>
							│ └─<b>jcr:content</b>
						
						
							<br>
							│ └─<b>myapp:data = &lt;binary data&gt;</b>
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>sistinechapel.desc</b>
					</p>
				</td>
				<td>
					<p>
						└─<b>sistinechapel.desc</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>(creation date of the file)</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>jcr:created = "2001-01-04T00:00:00.000Z"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>"Not bad."</b>
					</p>
				</td>
				<td>
					
						
							<br>
							└─<b>jcr:content</b>
						
						
							<br>
							└─<b>myapp:data = "Not bad."</b>
						
					
				</td>
			</tr>
		</table>
		
			
				
					
						
							
								<p class="c5">
									<br>
									In this example, both directories and files are mapped to nodes. Nodes that represent files have a <b>jcr:created</b> property and a <b>jcr:content</b> node. The <b>jcr:content</b> node in turn has a single <b>myapp:data</b> property that holds the actual contents of the corresponding file (note that the nodes representing the files <b>bigredstripe.gif</b> and so forth, are of node type <b>nt:file</b>; see <a href="#section_6.7.22.6.">6.7.22.6</a> <i>nt:file</i>).
								</p>
							
							
								<p class="c5">
									A variation on the above arrangement is to reflect the directory structure directly but combine the file pairs (the picture and the description text) into a single node:
								</p>
								
									
										
											
												
													
														
															
																
																	
																		
																			
																				
																					
																						
																							
																								<p class="c12">
																									<b>Node/</b>
																								</p>
																							
																							
																								<p class="c12">
																									<b>Property = "..."</b>
																								</p>
																							
																						
																					
																				
																			
																		
																	
																
															
														
													
												
											
										
									
								
							
						
					
				
			
		
		<table border="1" cellpadding="7" cellspacing="0">
			
			
			<tr valign="top">
				<td>
					<p class="c12">
						<b>content/</b>
					</p>
				</td>
				<td>
					<p class="c12">
						<b>/</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>newpaintings/</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>newpaintings</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>bigredstripe.gif</b>
					</p>
				</td>
				<td>
					<p>
						│ └─<b>bigredstripe</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>(creation date of .gif or .desc</b>
						
						
							<br>
							<b>whichever was first)</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ ├─<b>jcr:created = "2001-05-03T00:00:00.000Z"</b>
						
						
							<br>
							│ │
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>&lt;binary data&gt;</i></b>
					</p>
				</td>
				<td>
					
						
							<br>
							│ └─<b>jcr:content</b>
						
						
							<br>
							│ ├─<b>myapp:image = &lt;binary data&gt;</b>
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>bigredstripe.desc</b>
						
						
							<br>
							<b>"An excellent example</b>
						
						
							<br>
							<b>of stripeism."</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ └─<b>myapp:desc = "An excellent example</b>
						
						
							<br>
							│ <b>of stripeism."</b>
						
						
							<br>
							│
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>oldpaintings/</b>
					</p>
				</td>
				<td>
					<p>
						└─<b>oldpaintings</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>sistinechapel.gif</b>
					</p>
				</td>
				<td>
					<p>
						└─<b>sistinechapel</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>(creation date of .gif or .desc</b>
						
						
							<br>
							<b>whichever was first)</b>
						
					
				</td>
				<td>
					
						
							<br>
							├─<b>jcr:created = "2001-06-04T00:00:00.000Z"</b>
						
						
							<br>
							│
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>&lt;binary data&gt;</i></b>
					</p>
				</td>
				<td>
					
						
							<br>
							└─<b>jcr:content</b>
						
						
							<br>
							├─<b>myapp:image = &lt;binary data&gt;</b>
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>sistinechapel.desc</b>
						
						
							<br>
							<b>"Not bad."</b>
						
					
				</td>
				<td>
					<p>
						└─<b>myapp:desc = "Not bad."</b>
					</p>
				</td>
			</tr>
		</table>
		
			
				
					
						
							
								<p class="c5">
									<br>
									In this example, there is no longer a one-to-one correspondence between file and hierarchy node (though as above, nodes of type <b>nt:file</b> combined with application-specific content node types are used).
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_5.2." id="section_5.2."></a> 5.2 A WebDAV-backed Content Repository
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Consider a repository with some arbitrary underlying implementation structure (file system, database) but which exposes its content via a WebDAV interface.
								</p>
							
							
								<p class="c5">
									In such a case, the implementer might choose to implement this specification not directly on top of the underlying system but on top of the existing WebDAV layer.
								</p>
							
							
								<p class="c5">
									The mapping from the exposed WebDAV structure to the repository hierarchy can be done quite directly using a mapping similar to that described above in the file system example.
								</p>
							
							
								<p class="c5">
									In addition to this, all supplemental information of a WebDAV resource, such as properties, locking information, etc. can be mapped to repository properties.
								</p>
							
						
					
				
			
		
		<table border="1" cellpadding="7" cellspacing="0">
			
			
			<tr valign="top">
				<td>
					<p>
						<br>
					</p>
				</td>
				<td>
					<p class="c12">
						<b>/</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>/newpaintings/</b>
					</p>
				</td>
				<td>
					<p>
						└─<b>newpaintings</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>bigredstripe.gif</b>
					</p>
				</td>
				<td>
					<p>
						└─<b>bigredstripe.gif</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>&lt;PROPFIND/newpaintings/bigredstripe.gif&gt;</i></b>
					</p>
				</td>
				<td>
					<p>
						│
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>DAV:displayname</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>myapp:name = "Big Red Stripe"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>DAV:creationdate</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>jcr:created = "2001-05-03<br>
						│ T00:00:00.000Z"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<br>
					</p>
				</td>
				<td>
					<p>
						└─<b>jcr:content</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>DAV:getlastmodified</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>jcr:lastModified = "2001-05-03<br>
						│ T00:00:00.000Z"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>DAV:getcontenttype</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>jcr:mimeType = "image/gif"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>&lt;GET /newpaintings/bigredstripe.gif&gt;</i></b>
					</p>
				</td>
				<td>
					<p>
						└─<b>jcr:data = &lt;binary data&gt;</b>
					</p>
				</td>
			</tr>
		</table>
		
			
				
					
						
							
								<p class="c5">
									<br>
									In this example, the file <b>bigredstripe.gif</b> is represented by a subtype of <b>nt:file</b> and the <b>jcr:content</b> subnode is of type <b>nt:resource</b>.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_5.3." id="section_5.3."></a> 5.3 Database-backed Content Repository
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A compliant repository can also be implemented on top of a database. Consider again the following repository structure:
								</p>
							
							
								<p class="c12">
									<b>Node/</b>
								</p>
							
							
								<p class="c12">
									<b>Property = "..."</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<b>/</b>
								</p>
							
							
								<p>
									├─<b>newpaintings</b>
								</p>
							
							
								<p>
									│ └─<b>bigredstripe</b>
								</p>
							
							
								<p>
									│ ├─<b>jcr:created = "2001-05-03T00:00:00.000Z"</b>
								</p>
							
							
								<p>
									│ │
								</p>
							
							
								<p>
									│ └─<b>jcr:content</b>
								</p>
							
							
								<p>
									│ ├─<b>myapp:image = &lt;binary data&gt;</b>
								</p>
							
							
								<p>
									│ └─<b>myapp:desc = "An excellent example</b>
								</p>
							
							
								<p>
									│ <b>of stripeism."</b>
								</p>
							
							
								<p>
									│
								</p>
							
							
								<p>
									└─<b>oldpaintings</b>
								</p>
							
							
								<p>
									└─<b>sistinechapel</b>
								</p>
							
							
								<p>
									├─<b>jcr:created = "2001-06-04T00:00:00.000Z"</b>
								</p>
							
							
								<p>
									│
								</p>
							
							
								<p>
									└─<b>jcr:content</b>
								</p>
							
							
								<p>
									├─<b>myapp:image = &lt;binary data&gt;</b>
								</p>
							
							
								<p>
									└─<b>myapp:desc = "Not bad."</b>
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									One possible implementation is to use four tables, a <b>NODES</b> table and three <b>XXXX_</b><b>PROPERTIES</b> tables, one for each of the three property types used in the example:
								</p>
							
						
					
					
						<p class="c12">
							<b>NODES</b>
						</p>
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							
							<tr valign="top">
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>name</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>id</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>parent_id</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>&lt;jcr:root&gt;</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>0</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>0</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>newpaintings</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>1</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>0</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>bigredstripe</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>2</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>1</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>jcr:content</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>3</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>2</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>oldpaintings</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>4</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>0</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>sistinechapel</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>5</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>4</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>jcr:content</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>6</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>5</b>
									</p>
								</td>
							</tr>
						</table>
					
					
						<p>
							<br>
						</p>
					
					
						<p class="c12">
							<b>DATE_PROPERTIES</b>
						</p>
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							
							<tr valign="top">
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>name</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>value</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>parent_id</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>jcr:created</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>2001-05-03T00:00:00.000Z</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>2</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>jcr:created</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>2001-06-04T00:00:00.000Z</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>5</b>
									</p>
								</td>
							</tr>
						</table>
					
					
						<p>
							<br>
						</p>
					
					
						<p class="c12">
							<b>TEXT_PROPERTIES</b>
						</p>
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							
							<tr valign="top">
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>name</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>value</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>parent_id</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>myapp:desc</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>An excellent...</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>3</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>myapp:desc</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>Not bad.</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>6</b>
									</p>
								</td>
							</tr>
						</table>
					
					
						<p>
							<br>
						</p>
					
					
						<p class="c12">
							<b>BLOB_PROPERTIES</b>
						</p>
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							
							<tr valign="top">
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>name</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>value</b>
									</p>
								</td>
								<td bgcolor="#A6A6A6">
									<p class="c12">
										<b>parent_id</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>myapp:image</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>&lt;BLOB&gt;</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>3</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>myapp:image</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>&lt;BLOB&gt;</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>6</b>
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_5.4." id="section_5.4."></a> 5.4 XML-backed Content Repository
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Another possible implementation is as a layer on top of a file system where that file system contains structured content in the form of XML files.
								</p>
							
							
								<p class="c5">
									Let’s say that the file system looks like this:
								</p>
							
							
								<p class="c12">
									<b>/</b>
								</p>
							
							
								<p class="c12">
									<b>products.xml</b>
								</p>
							
							
								<p class="c12">
									<b>people.xml</b>
								</p>
							
							
								<p class="c12">
									<b>services.xml</b>
								</p>
							
							
								<p class="c12">
									<b>products/</b>
								</p>
							
							
								<p class="c12">
									<b>rhombus.xml</b>
								</p>
							
							
								<p class="c12">
									<b>...</b>
								</p>
							
							
								<p class="c12">
									<b>people/</b>
								</p>
							
							
								<p class="c12">
									<b>...</b>
								</p>
							
							
								<p class="c12">
									<b>services/</b>
								</p>
							
							
								<p class="c12">
									<b>...</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									And <b>products.xml</b> looks like this:
								</p>
							
							
								<p class="c12">
									&lt;?xml version="1.0" encoding="UTF-8"?&gt;
								</p>
							
							
								<p class="c12">
									&lt;content&gt;
								</p>
							
							
								<p class="c12">
									&lt;title&gt;Our Products&lt;/title&gt;
								</p>
							
							
								<p class="c12">
									&lt;lead&gt;Geometrixx is proud to offer...&lt;/lead&gt;
								</p>
							
							
								<p class="c12">
									&lt;paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;text&gt;Geometrixx is the industry leader...&lt;/text&gt;
								</p>
							
							
								<p class="c12">
									&lt;image&gt;/9j/4AAQSkZJRgABAQ...&lt;/image&gt;
								</p>
							
							
								<p class="c12">
									&lt;/paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;text&gt;We have recently...&lt;/text&gt;
								</p>
							
							
								<p class="c12">
									&lt;image&gt;/9j/4AAQSkZJRgABAQ...&lt;/image&gt;
								</p>
							
							
								<p class="c12">
									&lt;/paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;/content&gt;
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									And similarly, <b>rhombus.xml</b> looks like this:
								</p>
							
							
								<p class="c12">
									&lt;?xml version="1.0" encoding="UTF-8"?&gt;
								</p>
							
							
								<p class="c12">
									&lt;content&gt;
								</p>
							
							
								<p class="c12">
									&lt;title&gt;Rhombus: The shape of things to come!&lt;/title&gt;
								</p>
							
							
								<p class="c12">
									&lt;price&gt;123.00&lt;/price&gt;
								</p>
							
							
								<p class="c12">
									&lt;lead&gt;Here at Geometrixx...&lt;/lead&gt;
								</p>
							
							
								<p class="c12">
									&lt;paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;text&gt;The rhombus is a very special shape...&lt;/text&gt;
								</p>
							
							
								<p class="c12">
									&lt;image&gt;/9j/4AAQSkZJRgABAQ...&lt;/image&gt;
								</p>
							
							
								<p class="c12">
									&lt;/paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;text&gt;Some say a square is...&lt;/text&gt;
								</p>
							
							
								<p class="c12">
									&lt;image&gt;/9j/4AAQSkZJRgABAQ...&lt;/image&gt;
								</p>
							
							
								<p class="c12">
									&lt;/paragraph&gt;
								</p>
							
							
								<p class="c12">
									&lt;/content&gt;
								</p>
							
							
								<p class="c5">
									<br>
									One way of mapping this to a content repository would be:
								</p>
								
									
										
											
												
													
														
															
																
																	
																		<p class="c12">
																			<b>Node</b>
																		</p>
																	
																	
																		<p class="c12">
																			<b>Property = "Some value"</b>
																		</p>
																	
																
															
														
													
												
											
										
									
								
							
						
					
				
			
		
		<table border="1" cellpadding="7" cellspacing="0">
			
			
			<tr valign="top">
				<td>
					<p class="c12">
						<b>/</b>
					</p>
				</td>
				<td>
					<p class="c12">
						<b><i>[root]</i></b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>products.xml</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>products</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>[creation date of the file]</i></b>
					</p>
				</td>
				<td>
					<p>
						│ ├─<b>jcr:created = "2001-01-01T..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>&lt;?xml version=”1.0”...?&gt;</b>
						
						
							<br>
							<b>&lt;content&gt;</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ ├─<b>jcr:content</b>
						
						
							<br>
							│ │ │
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;title&gt;Our Products&lt;/title&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:title = "Our Products"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;lead&gt;Geometrixx is...&lt;/lead&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:lead = "Geometrixx is..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;paragraph&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:paragraph[1]</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;text&gt;Geometrixx is...&lt;/text&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ │ ├─<b>myapp:text = "Geometrixx is..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;image&gt;/9j/4AAQ...&lt;/image&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ │ └─<b>myapp:image = &lt;binary data&gt;</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;/paragraph&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ │
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;paragraph&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ └─<b>myapp:paragraph[2]</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;text&gt;We have...&lt;/text&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:text = "We have..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;image&gt;/9j/4AAQ...&lt;/image&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ └─<b>myapp:image = &lt;binary data&gt;</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>&lt;/paragraph&gt;</b>
						
						
							<br>
							<b>&lt;/content&gt;</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ │
						
						
							<br>
							│ │
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>products/</b>
					</p>
				</td>
				<td>
					<p>
						│ │
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>rhombus.xml</b>
					</p>
				</td>
				<td>
					<p>
						│ ├─<b>rhombus</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<i><b>[creation date of the file]</b></i>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>jcr:created = "2002-06-01T..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>&lt;?xml version=“1.0“...?&gt;</b>
						
						
							<br>
							<b>&lt;content&gt;</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ │ └─<b>jcr:content</b>
						
						
							<br>
							│ │ │
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;title&gt;Rhombus:...&lt;/title&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:title = "Rhombus:..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;price&gt;123.00&lt;/price&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:price = "123.00"</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;lead&gt;Here at...&lt;/lead&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:lead = "Here at..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;paragraph&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:paragraph[1]</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;text&gt;The rhombus...&lt;/text&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ │ ├─<b>myapp:text = "The rhombus..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;image&gt;/9j/4A...&lt;/image&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ │ └─<b>myapp:image = <i>[binary data]</i></b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;/paragraph&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ │
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;paragraph&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ └─<b>myapp:paragraph[2]</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;text&gt;Some say...&lt;/text&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>myapp:text = "Some say..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>&lt;image&gt;/9j/4A...&lt;/image&gt;</b>
					</p>
				</td>
				<td>
					<p>
						│ │ └─<b>myapp:image = &lt;binary data&gt;</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>&lt;/paragraph&gt;</b>
						
						
							<br>
							<b>&lt;/content&gt;</b>
						
						
							<br>
							<b>...</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ │
						
						
							<br>
							│ │
						
						
							<br>
							│ <b>...</b>
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>people.xml</b>
					</p>
				</td>
				<td>
					<p>
						├─<b>people</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>[creation date of the file]</i></b>
					</p>
				</td>
				<td>
					<p>
						│ ├─<b>jcr:created = "2001-01-01T..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>&lt;?xml version=“1.0“...?&gt;</b>
						
						
							<br>
							<b>&lt;content&gt;</b>
						
						
							<br>
							<b>...</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ ├─<b>jcr:content</b>
						
						
							<br>
							│ │ │
						
						
							<br>
							│ │ <b>...</b>
						
					
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>people/</b>
					</p>
				</td>
				<td>
					<p>
						│ │
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b>fred.xml</b>
					</p>
				</td>
				<td>
					<p>
						│ ├─<b>fred</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c12">
						<b><i>[creation date of the file]</i></b>
					</p>
				</td>
				<td>
					<p>
						│ │ ├─<b>jcr:created = "2001-12-01T..."</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					
						
							<br>
							<b>&lt;?xml version=“1.0“...?&gt;</b>
						
						
							<br>
							<b>...</b>
						
					
				</td>
				<td>
					
						
							<br>
							│ │ ├─<b>jcr:content</b>
						
						
							<br>
							<b>...</b>
						
					
				</td>
			</tr>
		</table>
		
			
				
					
						
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									This example demonstrates the use of a <i>fine-grained content model</i> where the mapping to a node-property structure extends from the folder and file level into the internal structure of the XML document.
								</p>
							
							
								<p class="c5">
									<i>Note that this example is just one possible mapping; it is not meant to imply that this is the only mapping between the repository and XML (see, for example, 6.4 XML Mappings).</i>
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_5.5." id="section_5.5."></a> 5.5 Namespace Prefixes in the Examples
		</h3>
		
			
				
					
						
							
								<p class="c5">
									In the above examples, we use colon-delimited <i>prefixes</i> for naming certain nodes and properties. The nodes and properties fall into three categories:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>Nodes and properties common to all applications:</b> In the example these include <b>jcr:content</b> and <b>jcr:created</b>. This naming convention is enforced by the node types built into the repository. For example, in <a href="#section_5.1.">5.1</a>, the node <b>bigstripe.gif</b> is mapped to a node of type <b>nt:file</b>, and that node type requires the node to have a property named <b>jcr:created</b> and a child node named <b>jcr:content</b> (see <a href="#section_6.7.">6.7</a> <i>Node Types</i>).
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Nodes and properties specific to the application:</b> In the examples we use <b>myapp</b>. These names could be enforced by application-specific node types.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Nodes and properties with names taken from existing resources:</b> These include the file and directory names <b>products</b> and <b>rhombus</b> in example <a href="#section_5.4.">5.4</a>. Since in these examples these names are taken directly from the underlying resources, they happen not to be namespaced. In general however, a mapping to namespaced names could just as well be used.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									For more details see <a href="#section_6.3.">6.3</a> <i>Namespaces</i>.
								</p>
							
						
					
				
			
		
		<h2>
			<a name="section_6." id="section_6."></a>6 Level 1 Repository Features
		</h2>
		
			
				
					
						
							
								<p class="c5">
									The following section explains level 1 of the API on a functional basis. For an explanation organized on an interface-by-interface basis, see the accompanying Javadoc.
								</p>
							
							
								<p class="c5">
									Level 1 defines a <i>read-only</i> repository. This encompasses the following functionality:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Retrieval and traversal of nodes and properties
				</p>
			</li>
			<li>
				<p class="c5">
					Reading the values of properties
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					Transient namespace remapping
				</p>
			</li>
			<li>
				<p class="c5">
					Export to XML/SAX
				</p>
			</li>
			<li>
				<p class="c5">
					Query facility with XPath syntax
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					Discovery of available node types
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Where a level 2 repository (or a repository supporting an optional feature, such as versioning) would differ from a purely level 1 repository, the relevant difference is noted.
								</p>
							
							
								<p class="c5">
									Since level 2 is a superset of level 1, anything required for level 1 compliance is automatically required for level 2 (see <a href="#section_4.2.">4.2</a> <i>Compliance Levels</i>). Thus, this section applies to level 2 implementations as well.
								</p>
							
							
								<p class="c5">
									Note that in the discussion below, reference to a “level 1 repository” means a repository that implements <i>only</i> level 1 features.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.1." id="section_6.1."></a>6.1 Accessing the Repository
		</h3>
		
			
				
					
						
							
								<p class="c5">
									The point of entry is the <b>Repository</b> object, which will typically be acquired through the Java Naming and Directory (JNDI) API.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.1.1." id="section_6.1.1."></a>6.1.1 Repository
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The naming service lookup (or whatever mechanism is used) will return an object implementing the <b>Repository</b> interface.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Repository</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Session</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>login(Credentials&nbsp;credentials,<br>
										String workspaceName)</b>
									</p>
									<p class="c5">
										Authenticates the user using the supplied <b>credentials</b>. If <b>workspaceName</b> is recognized as the name of an existing workspace in the repository and authorization to access that workspace is granted, then a new <b>Session</b> object is returned. The format of the string <b>workspaceName</b> depends upon the implementation.
									</p>
									<p class="c5">
										If <b>credentials</b> is <b>null</b>, it is assumed that authentication is handled by a mechanism external to the repository itself (for example, through the JAAS framework) and that the repository implementation exists within a context (for example, an application server) that allows it to handle authorization of the request for access to the specified workspace. See <a href="#section_8.4.">8.4</a> <i>Access Control</i> for more details.
									</p>
									<p class="c5">
										If <b>workspaceName</b> is <b>null</b>, a default workspace is automatically selected by the repository implementation. This may, for example, be the “home workspace” of the user whose credentials were passed, though this is entirely up to the configuration and implementation of the repository. Alternatively, this may be a “null workspace” that serves only to provide the method <b>Workspace.getAccessibleWorkspaceNames</b>, allowing the client to select from among available “real” workspaces (see <a href="#section_6.2.2.">6.2.2</a> <i>Workspace Read Methods</i>).
									</p>
									<p class="c5">
										If authentication or authorization for the specified workspace fails, a <b>LoginException</b> is thrown.
									</p>
									<p class="c5">
										If <b>workspaceName</b> is not recognized, a <b>NoSuchWorkspaceException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Session</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>login(Credentials credentials)</b>
									</p>
									<p class="c5">
										Equivalent to <b>login(credentials, null)</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Session</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>login(String workspaceName)</b>
									</p>
									<p class="c5">
										Equivalent to <b>login(null, workspaceName)</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Session</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>login()</b>
									</p>
									<p class="c5">
										Equivalent to <b>login(null, null)</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDescriptorKeys()</b>
									</p>
									<p class="c5">
										Returns a string array holding all descriptor keys available for this implementation. This set must contain at least the built-in keys defined by the string constants in this interface (see below). Used in conjunction with <b>Repository.getDescriptor(String name)</b> to query information about this repository implementation.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDescriptor(String key)</b>
									</p>
									<p class="c5">
										Returns the descriptor for the specified key. Used to query information about this repository implementation. The set of available keys can be found by calling <b>getDescriptorKeys</b>. If the specified key is not found, <b>null</b> is returned.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.1.1.1." id="section_6.1.1.1."></a>6.1.1.1 Repository Descriptors
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The methods <b>Repository.getDescriptorKeys</b> and <b>Repository.getDescriptor</b> can be used to query information about the particular repository implementation. The required names are defined as string constants of the <b>Repository</b> interface. They are:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Descriptor Key<br>
										(String Constant)</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>Information Returned</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SPEC_VERSION_DESC</b>
									</p>
								</td>
								<td>
									<p class="c5">
										For this specification the value of this descriptor is “<b>1.0</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SPEC_NAME_DESC</b>
									</p>
								</td>
								<td>
									<p class="c5">
										For this specification the value of this descriptor is “<b>Content Repository for Java Technology API</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>REP_VENDOR_DESC</b>
									</p>
								</td>
								<td>
									<p class="c5">
										The name of the vendor of this repository implementation.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>REP_VENDOR_URL_DESC</b>
									</p>
								</td>
								<td>
									<p class="c5">
										The URL of the repository vendor.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>REP_NAME_DESC</b>
									</p>
								</td>
								<td>
									<p class="c5">
										The name of this repository implementation.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>REP_VERSION_DESC</b>
									</p>
								</td>
								<td>
									<p class="c5">
										The version of this repository implementation.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>LEVEL_1_SUPPORTED</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports all level 1 features. This descriptor should always be “<b>true</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>LEVEL_2_SUPPORTED</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports all level 2 features. This descriptor will be either “<b>true</b>” or “<b>false</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>OPTION_TRANSACTIONS_SUPPORTED</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports transactions. This descriptor will be either “<b>true</b>” or “<b>false</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>OPTION_VERSIONING_SUPPORTED</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports versioning. This descriptor will be either “<b>true</b>” or “<b>false</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>OPTION_OBSERVATION_SUPPORTED</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports observation. This descriptor will be either “<b>true</b>” or “<b>false</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>OPTION_LOCKING_SUPPORTED</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports locking. This descriptor will be either “<b>true</b>” or “<b>false</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>OPTION_QUERY_SQL_SUPPORTED</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports queries using the SQL language. This descriptor will be either “<b>true</b>” or “<b>false</b>”.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>QUERY_XPATH_POS_INDEX</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation supports index position notation for same-name siblings within XPath queries. This descriptor will be either “<b>true</b>” or “<b>false</b>”. See <a href="#section_6.6.4.1.">6.6.4.1</a> <i>Adapting XPath to the Content Repository::Same-Name Siblings</i> for more details.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>QUERY_XPATH_DOC_ORDER</b>
									</p>
								</td>
								<td>
									<p class="c5">
										Indicates whether this implementation returns the results of XPath queries in document order. This descriptor will be either “<b>true</b>” or “<b>false</b>”. See <a href="#section_6.6.4.2.">6.6.4.2</a> <i>Adapting XPath to the Content Repository::Document Order</i>.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<br>
									Implementations may add additional descriptors.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.1.1.2." id="section_6.1.1.2."></a>6.1.1.2 Thread Safety of Repository Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									An implementation is required to provide thread-safe implementations of all the methods of the <b>Repository</b> interface. Note that this requirement is of more relevance in a level 2 implementation than a pure level 1 implementation. See <a href="#section_7.5.">7.5</a> <i>Thread-Safety Requirements</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.1.2." id="section_6.1.2."></a>6.1.2 Credentials
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The credentials that are passed must implement the empty marker interface <b>Credentials</b>.
								</p>
							
							
								<p class="c5">
									The implementer may either provide its own custom implementation or use the provided <b>SimpleCredentials</b> class. This class provides a minimal standard method for authenticating against a repository (i.e., using a user ID and password). Additional attributes may be used by the repository, for example, to set a token that can then be passed back and forth once authentication has been completed (thus enabling later authorization without re-authentication).
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										SimpleCredentials</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>SimpleCredentials(String userID, char[] password)</b>
									</p>
									<p class="c5">
										Create a new <b>SimpleCredentials</b> object, given a user ID and password. Note that the given password is cloned before it is stored in the new <b>SimpleCredentials</b> object. This should avoid the risk of having unnecessary references to password data lying around in memory.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getUserID()</b>
									</p>
									<p class="c5">
										Gets the user ID.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>char[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPassword()</b>
									</p>
									<p class="c5">
										Returns the password. Note that this method returns a reference to the password. It is the caller's responsibility to zero out the password information after it is no longer needed.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setAttribute(String name, Object value)</b>
									</p>
									<p class="c5">
										Stores an attribute in this credentials instance.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>removeAttribute(String name)</b>
									</p>
									<p class="c5">
										Removes an attribute from this credentials instance.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Object</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAttribute(String name)</b>
									</p>
									<p class="c5">
										Returns the value of the named attribute as an <b>Object</b>, or <b>null</b> if no attribute of the given name exists.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAttributeNames()</b>
									</p>
									<p class="c5">
										Returns the names of the attributes available to this credentials instance. This method returns an empty array if the credentials instance has no attributes available to it.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.2." id="section_6.2."></a> 6.2 Reading Repository Content
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Reading repository content involves accessing nodes (either directly or by traversing the hierarchy step by step) and reading the values of properties.
								</p>
							
							
								<p class="c5">
									The <b>Session</b> object returned by <b>Repository.login</b> encapsulates both the authorization settings of a particular user (as determined by the <b>Credentials</b> object) and a binding to the workspace specified by the <b>workspaceName</b> passed on <b>login</b>.
								</p>
							
							
								<p class="c5">
									Each <b>Session</b> object is associated one-to-one with a <b>Workspace</b> object. The <b>Workspace</b> object represents a “view” of an actual repository workspace entity as seen through the authorization settings of its associated <b>Session</b>.
								</p>
							
							
								<p class="c5">
									There is an important distinction between the <b>Workspace</b> object instance associated with a particular <b>Session</b> and the actual workspace entity in the repository. If multiple <b>Session</b>s access a particular workspace each will have its own <b>Workspace</b> object, even though all of these <b>Workspace</b> objects may represent the same actual workspace entity in the repository. In other words, a <b>Workspace</b> object corresponds to a <i>view</i> of a particular workspace entity, and that view is determined by the <b>Session</b> associated with the <b>Workspace</b> object.
								</p>
							
							
								<p class="c5">
									On the other hand, each <b>Session</b> object represents a separate session entity. Two or more <b>Session</b> instances can exist for the same <b>Credentials</b> and the same <b>workspaceName</b> but still have different states.
								</p>
							
							
								<p class="c5">
									Since <b>Session</b> and <b>Workspace</b> instances are always associated one-to-one, combining them into a single object might seem logical. However, the distinction between the two objects comes into play in level 2 implementations, where writing to the repository can occur in two ways, either through transient storage (associated with the <b>Session</b> object) or directly to the persistent layer (associated with the <b>Workspace</b> object). It is primarily to differentiate these two modes of writing that the distinction between the two objects is maintained. See <a href="#section_4.1.3.2.">4.1.3.2</a> <i>Transient Storage in the Session</i> and <a href="#section_7.1.">7.1</a> <i>Writing Repository Content</i> for more details.
								</p>
							
							
								<p class="c5">
									In a level 1 repository the distinction between <b>Session</b> and <b>Workspace</b> objects does not play a significant role. It exists simply for the sake of compatibility with level 2.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.1." id="section_6.2.1."></a>6.2.1 Session Read Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following are the methods of <b>Session</b> associated with accessing information about a repository and for accessing content from this <b>Session</b>'s workspace. <b>Session</b> has other methods as well. In a level 1-only implementation, these other methods will either do nothing or throw an exception. See and <a href="#section_7.1.">7.1</a> <i>Writing Repository Content</i>.
								</p>
							
							
								<p class="c5">
									The most important methods exposed by Session are those that provide access to the Items in the workspace tree: typically the user would begin by calling <b>Session.getRootNode()</b>, which returns the root node of the workspace. From this the user can traverse the workspace tree. It is also possible to directly access a node in the workspace with <b>Session.getNodeByUUID</b> or <b>Session.getItem</b>.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Repository</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getRepository()</b>
									</p>
									<p class="c5">
										Returns the <b>Repository</b> object through which this <b>Session</b> was acquired.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getUserID()</b>
									</p>
									<p class="c5">
										Gets the user ID associated with this <b>Session</b>. How the user ID is set is up to the implementation, it may be a string passed in as part of the credentials or it may be a string acquired in some other way. This method is free to return an “anonymous user ID” or <b>null</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAttributeNames()</b>
									</p>
									<p class="c5">
										Returns the names of the attributes set in this session as a result of the <b>Credentials</b> that were used to acquire it. Not all <b>Credentials</b> implementations will contain attributes (though, for example, <b>SimpleCredentials</b> does allow for them). This method returns an empty array if the <b>Credentials</b> instance did not provide attributes.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Object</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAttribute(String name)</b>
									</p>
									<p class="c5">
										Returns the value of the named attribute as an <b>Object</b>, or <b>null</b> if no attribute of the given name exists. See <b>Session.getAttributeNames</b>, above.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Workspace</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getWorkspace()</b>
									</p>
									<p class="c5">
										Returns the <b>Workspace</b> attached to this <b>Session</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Node</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getRootNode()</b>
									</p>
									<p class="c5">
										Returns the root node of the workspace, <b>/</b>. This node is the main access point to the content of the workspace.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Item</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getItem(String absPath)</b>
									</p>
									<p class="c5">
										Returns the item at the specified absolute path in the workspace.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if no item at <b>absPath</b> exists.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>itemExists(String absPath)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if an item exists at <b>absPath</b> and this <b>Session</b> has read access to it; otherwise returns <b>false</b>. Also returns <b>false</b> if the specified <b>absPath</b> is malformed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Node</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNodeByUUID(String uuid)</b>
									</p>
									<p class="c5">
										Returns the node specified by the given UUID. Only applies to nodes that expose a UUID, in other words, those of mixin node type <b>mix:referenceable</b>.
									</p>
									<p class="c5">
										An <b>ItemNotFoundException</b> is thrown if no item with the specified UUID exists.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Session</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>impersonate(Credentials c)</b>
									</p>
									<p class="c5">
										Returns a new <b>Session</b> in accordance with the specified (new) <b>Credentials</b>. Allows the current user to “impersonate” another using incomplete or relaxed credentials requirements (perhaps including a user name but no password, for example), assuming that this <b>Session</b> gives them that permission.
									</p>
									<p class="c5">
										The new <b>Session</b> is tied to a new <b>Workspace</b> instance. In other words, <b>Workspace</b> instances are not re-used. However, the <b>Workspace</b> instance returned represents the same actual persistent workspace entity in the repository as is represented by the <b>Workspace</b> object tied to this <b>Session</b>.
									</p>
									<p class="c5">
										A <b>LoginException</b> is thrown if this session does not have sufficient permissions to perform the operation.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>logout()</b>
									</p>
									<p class="c5">
										Releases all resources associated with this <b>Session</b>. This method should be called when a <b>Session</b> is no longer needed.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isLive()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this <b>Session</b> object is usable by the client. A usable <b>Session</b> object is one that is neither logged-out, timed-out nor in any other way disconnected from the repository.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.2.2." id="section_6.2.2."></a>6.2.2 Workspace Read Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In a level 1 repository the <b>Workspace</b> object serves only to encapsulate a number of methods for accessing either information about the <b>Workspace</b> or classes that provide further repository functions. The following are the level 1 methods of <b>Workspace</b>. <b>Workspace</b> has other methods as well, though in a level 1-only implementation these will either do nothing or throw an exception.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Workspace</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Session</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getSession()</b>
									</p>
									<p class="c5">
										Returns the <b>Session</b> object through which this <b>Workspace</b> object was acquired.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getName()</b>
									</p>
									<p class="c5">
										Returns the name of the actual persistent workspace represented by this <b>Workspace</b> object. This is the name used in <b>Repository.login</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>QueryManager</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getQueryManager()</b>
									</p>
									<p class="c5">
										Returns the <b>QueryManager</b>, through which search methods are accessed. See <a href="#section_6.6.">6.6</a> <i>Searching Repository Content</i>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NamespaceRegistry</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNamespaceRegistry()</b>
									</p>
									<p class="c5">
										Returns the <b>NamespaceRegistry</b> object, which can be used to access the mapping between prefixes and namespaces. See <a href="#section_6.3.">6.3</a> <i>Namespaces</i>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeTypeManager</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>getNodeTypeManager()</b>
									</p>
									<p class="c5">
										Returns the <b>NodeTypeManager</b>, which is used to access information about which node types are available in the repository. There is one node type registry per repository, therefore the <b>NodeTypeManager</b> is not workspace-specific; it provides introspection methods for the global, repository-wide set of available node types. See <a href="#section_6.7.">6.7</a> <i>Node Types</i>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAccessibleWorkspaceNames()</b>
									</p>
									<p class="c5">
										Returns an string array containing the names of all workspaces in this repository that are accessible to this user, given the <b>Credentials</b> that were used to get the <b>Session</b> to which this <b>Workspace</b> is tied.
									</p>
									<p class="c5">
										In order to access one of the listed workspaces, the user performs another <b>Repository.login</b>, specifying the name of the desired workspace, and receives a new <b>Session</b> object.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.2.3." id="section_6.2.3."></a>6.2.3 Node Read Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following are the level 1 methods of <b>Node</b>. They are used for getting the child nodes and properties of a node. The <b>Node</b> interface has other methods as well, though in a level 1-only implementation they will either do nothing or throw an exception.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Node</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNode(String&nbsp;relPath)</b>
									</p>
									<p class="c5">
										Returns the node at <b>relPath</b> relative to this node.
									</p>
									<p class="c5">
										If <b>relPath</b> contains a path element that refers to a node with same-name sibling nodes without explicitly including an index using the array-style notation (<b>[x]</b>), then the index <b>[1]</b> is assumed (See <a href="#section_4.3.">4.3</a> <i>Same-Name Siblings</i> ).
									</p>
									<p class="c5">
										Within the scope of a single <b>Session</b> object, if a node has been acquired with <b>getNode</b>, any subsequent call of <b>getNode</b> reacquiring the same node must return a <b>Node</b> object reflecting the same state as the earlier <b>Node</b> object. Whether this object is actually the same <b>Node</b> instance, or simply one wrapping the same state, is up to the implementation. See <a href="#section_7.1.3.1.">7.1.3.1</a> <i>Re-using Item Objects</i>.
									</p>
									<p class="c5">
										If no node exists at <b>relPath</b> a <b>PathNotFoundException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNodes()</b>
									</p>
									<p class="c5">
										Returns all child nodes of this node. Does <i>not</i> include properties of this node. The same reacquisition semantics apply as with <b>getNode</b>. If this node has no child nodes, then an empty iterator is returned.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNodes(String namePattern)</b>
									</p>
									<p class="c5">
										Gets all child nodes of this node that match <b>namePattern</b>. The pattern may be a full name or a partial name with one or more wildcard characters ("<b>*</b>"), or a disjunction (using the “<b>|</b>” character to represent logical OR) of these. For example,
									</p>
									<p class="c5">
										<b>N.getNodes("jcr:* | myapp:report | my doc")</b>
									</p>
									<p class="c5">
										would return a <b>NodeIterator</b> holding all child nodes of <b>N</b> that are either called '<b>myapp:report</b>', begin with the prefix '<b>jcr:</b>' or are called '<b>my doc</b>'.
									</p>
									<p class="c5">
										Note that leading and trailing whitespace <i>around</i> a | character is ignored, but whitespace <i>within</i> a disjunct forms part of the pattern to be matched.
									</p>
									<p class="c5">
										The EBNF for <b>namePattern</b> is:
									</p>
									<p class="c5">
										namePattern ::= disjunct {'|' disjunct}<br>
										disjunct ::= name [':' name]<br>
										name ::= '*' |<br>
										['*'] fragment {'*' fragment}['*']<br>
										fragment ::= char {char}<br>
										char ::= nonspace | ' '<br>
										nonspace ::= (* Any Unicode character except:<br>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'/', ':', '[', ']', '*',<br>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;''', '"', '|' or any whitespace<br>
										character *)
									</p>
									<p class="c5">
										The pattern is matched against the names (not the paths) of the immediate child nodes of this node.
									</p>
									<p class="c5">
										If this node has no matching child nodes, then an empty iterator is returned.
									</p>
									<p class="c5">
										The same reacquisition semantics apply as with <b>getNode</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getProperty(String&nbsp;relPath)</b>
									</p>
									<p class="c5">
										Get the property at <b>relPath</b> relative to this node. The same reacquisition semantics apply as with <b>getNode</b>.
									</p>
									<p class="c5">
										If no property exists at <b>relPath</b> a <b>PathNotFoundException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>PropertyIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getProperties()</b>
									</p>
									<p class="c5">
										Gets all properties of this node. Does <i>not</i> include child <i>nodes</i> of this node. The same reacquisition semantics apply as with <b>getNode</b>. If this node has no properties, then an empty iterator is returned.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>PropertyIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getProperties(String namePattern)</b>
									</p>
									<p class="c5">
										Gets all properties of this node that match <b>namePattern</b>. The pattern may be a full name or a partial name with one or more wildcard characters ("<b>*</b>"), or a disjunction (using the “<b>|</b>” character to represent logical OR) of these. For example,
									</p>
									<p class="c5">
										<b>N.getProperties("jcr:* | myapp:name | my doc")</b>
									</p>
									<p class="c5">
										would return a <b>PropertyIterator</b> holding all properties of <b>N</b> that are either called '<b>myapp:name</b>', begin with the prefix '<b>jcr:</b>' or are called '<b>my doc</b>'.
									</p>
									<p class="c5">
										Note that leading and trailing whitespace <i>around</i> a disjunct is ignored, but whitespace <i>within</i> a disjunct forms part of the pattern to be matched.
									</p>
									<p class="c5">
										The EBNF for <b>namePattern</b> is:
									</p>
									<p class="c5">
										namePattern ::= disjunct {'|' disjunct}<br>
										disjunct ::= name [':' name]<br>
										name ::= '*' |<br>
										['*'] fragment {'*' fragment}['*']<br>
										fragment ::= char {char}<br>
										char ::= nonspace | ' '<br>
										nonspace ::= (* Any Unicode character except:<br>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'/', ':', '[', ']', '*',<br>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;''', '"', '|' or any whitespace<br>
										character *)
									</p>
									<p class="c5">
										The pattern is matched against the names (not the paths) of the immediate child properties of this node.
									</p>
									<p class="c5">
										If this node has no matching properties, then an empty iterator is returned.
									</p>
									<p class="c5">
										The same reacquisition semantics apply as with <b>getNode</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Item</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPrimaryItem()</b>
									</p>
									<p class="c5">
										The primary node type (see <a href="#section_6.7.">6.7</a> <i>Node Types</i>) of this node may specify one child item (child node or property) of this node as the <i>primary child item</i>. This method returns that item.
									</p>
									<p class="c5">
										The same reacquisition semantics apply as with <b>getNode</b>.
									</p>
									<p class="c5">
										If this node has no primary child item, either because none is declared in the node type or because a declared primary item is not present on this node instance, then this method throws an <b>ItemNotFoundException</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>getUUID()</b>
									</p>
									<p class="c5">
										Returns the UUID of this node as recorded in the node's <b>jcr:uuid</b> property. This method only works on nodes of mixin node type <b>mix:referenceable</b>.
									</p>
									<p class="c5">
										On nonreferenceable nodes, this method throws an <b>UnsupportedRepositoryOperationException</b>. To avoid throwing an exception to determine whether a node has a UUID, a call to <b>isNodeType("mix:referenceable")</b> can be made.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>getIndex()</b>
									</p>
									<p class="c5">
										This method returns the index of this node within the ordered set of its same-name sibling nodes. This index is the one used to address same-name siblings using the square-bracket notation, e.g., <b>/a[3]/b[4]</b>. Note that the index always starts at <b>1</b> (not <b>0</b>), for compatibility with XPath. As a result, for nodes that do not have same-name-siblings, this method will always return <b>1</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>PropertyIterator</b>
									</p>
								</td>
								<td>
									<p class="c12">
										<b>getReferences()</b>
									</p>
									<p class="c5">
										Returns all <b>REFERENCE</b> properties that refer to this node.
									</p>
									<p class="c5">
										Some level 2 implementations may only return properties that have been saved (in a transactional setting this includes both those properties that have been saved but not yet committed, as well as properties that have been committed). Other level 2 implementations may additionally return properties that have been added within the current <b>Session</b> but are not yet saved.
									</p>
									<p class="c5">
										In implementations that support versioning, this method does not return <b>REFERENCE</b> properties that are part of the frozen state of a version in version storage.
									</p>
									<p class="c5">
										If this node has no references, an empty iterator is returned.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasNode(String relPath)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if a node exists at <b>relPath</b> and <b>false</b> otherwise.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasNodes()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node has one or more child nodes. Returns <b>false</b> otherwise.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasProperty(String relPath)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if a property exists at <b>relPath</b> and <b>false</b> otherwise.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasProperties()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node has one or more properties. Returns <b>false</b> otherwise.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.2.4." id="section_6.2.4."></a>6.2.4 Property Read Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following are the level 1 methods of <b>Property</b>. They are used for reading a property. The <b>Property</b> interface has other methods as well, though in a level 1-only implementation they will either do nothing or throw an exception.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Property</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getValue()</b>
									</p>
									<p class="c5">
										Returns the value of this property as a <b>Value</b> object.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										The object returned is a copy of the stored value and is immutable.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getValues()</b>
									</p>
									<p class="c5">
										Returns an array of all the values of this property. This method is used to access multi-value properties.
									</p>
									<p class="c5">
										If the property is single-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										The array returned is a copy of the stored values, so changes to it are not reflected in internal storage.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getString()</b>
									</p>
									<p class="c5">
										Returns a <b>String</b> representation of the value of this property. A shortcut for <b>Property.getValue().getString()</b>. See <a href="#section_6.2.7.">6.2.7</a> <i>Value</i>.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										If the value of this property cannot be converted to a <b>String</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>InputStream</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getStream()</b>
									</p>
									<p class="c5">
										Returns an <b>InputStream</b> representation of the value of this property. A shortcut for <b>Property.getValue().getStream()</b>. See <a href="#section_6.2.7.">6.2.7</a> <i>Value</i>.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>long</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLong()</b>
									</p>
									<p class="c5">
										Returns a <b>long</b> representation of the value of this property. A shortcut for <b>Property.getValue().getLong()</b>. See <a href="#section_6.2.7.">6.2.7</a> <i>Value</i>.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										If the value of this property cannot be converted to a <b>long</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>double</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDouble()</b>
									</p>
									<p class="c5">
										Returns a <b>double</b> representation of the value of this property. A shortcut for <b>Property.getValue().getDouble()</b>. See <a href="#section_6.2.7.">6.2.7</a> <i>Value</i>.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										If the value of this property cannot be converted to a <b>double</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Calendar</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDate()</b>
									</p>
									<p class="c5">
										Returns a <b>Calendar</b> representation of the value of this property. A shortcut for <b>Property.getValue().getDate()</b> See <a href="#section_6.2.7.">6.2.7</a> <i>Value</i>.
									</p>
									<p class="c5">
										The object returned is a copy of the stored value, so changes to it are not reflected in internal storage.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										If the value of this property cannot be converted to a <b>Calendar</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getBoolean()</b>
									</p>
									<p class="c5">
										Returns a <b>boolean</b> representation of the value of this property. A shortcut for <b>Property.getValue().getBoolean()</b>. See <a href="#section_6.2.7.">6.2.7</a> <i>Value</i>.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										If the value of this property cannot be converted to a <b>boolean</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Item</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNode()</b>
									</p>
									<p class="c5">
										If this property is of type <b>REFERENCE</b> this method returns the <b>Node</b> to which this property refers.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										If this property cannot be converted to a reference, then a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If this property is a <b>REFERENCE</b> property but is currently part of the frozen state of a version in version storage, this method will throw a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>long</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLength()</b>
									</p>
									<p class="c5">
										Returns the length of the value of this property in bytes if the value is a <b>PropertyType.BINARY</b>, otherwise it returns the number of characters needed to display the value in its string form as defined in 6.2.6 Property Type Conversion<i>.</i>
									</p>
									<p class="c5">
										Returns <b>–1</b> if the implementation cannot determine the length of the value.
									</p>
									<p class="c5">
										If this property is multi-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>long[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLengths()</b>
									</p>
									<p class="c5">
										Returns an array holding the lengths of the values of this (multi-value) property in bytes if the values are <b>PropertyType.BINARY</b>, otherwise it returns the number of characters needed to display each value in its string form as defined in 6.2.6 Property Type Conversion). The order of the length values corresponds to the order of the values in the property.
									</p>
									<p class="c5">
										Returns a <b>–1</b> in the appropriate position if the implementation cannot determine the length of a value.
									</p>
									<p class="c5">
										If this property is single-valued, this method throws a <b>ValueFormatException</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getType()</b>
									</p>
									<p class="c5">
										Returns the type of this <b>Property</b>. The type returned is that which was set at property creation. Note that for some property <b>p</b>, the type returned by <b>p.getType()</b> may differ from the type returned by <b>p.getDefinition.getRequiredType()</b> only in the case where the latter returns <b>UNDEFINED</b>. The type of a property instance is never <b>UNDEFINED</b> (it must always have some actual type). See <a href="#section_6.2.5.">6.2.5</a> <i>Property Types</i> and <a href="#section_6.7.18.">6.7.18</a> <i>Discovery of Constraints on Existing Items</i>.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.2.5." id="section_6.2.5."></a>6.2.5 Property Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The class <b>PropertyType</b> defines integer constants for the available property types as well as for their standardized type names (used in serialization) and two methods for converting back and forth between name and integer value:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>PropertyType</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>STRING</b>
									</p>
									<p class="c17">
										The <b>STRING</b> property type is used to store strings. It has the same characteristics as the Java <b>String</b> class.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>BINARY</b>
									</p>
									<p class="c5">
										<b>BINARY</b> properties are used to store binary data.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>LONG</b>
									</p>
									<p class="c5">
										The <b>LONG</b> property type is used to store integers. It has the same characteristics as the Java primitive type <b>long</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>DOUBLE</b>
									</p>
									<p class="c5">
										The <b>DOUBLE</b> property type is used to store floating point numbers. It has the same characteristics as the Java primitive type <b>double</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>BOOLEAN</b>
									</p>
									<p class="c5">
										The <b>BOOLEAN</b> property type is used to store boolean values. It has the same characteristics as the Java primitive type <b>boolean</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>DATE</b>
									</p>
									<p class="c5">
										The <b>DATE</b> property type is used to store time and date information. See <a href="#section_6.2.5.1.">6.2.5.1</a> <i>Date</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>NAME</b>
									</p>
									<p class="c5">
										A <b>NAME</b> is a pairing of a <i>namespace</i> and a <i>local name</i>. When read, the namespace is mapped to the current prefix. See <a href="#section_6.2.5.2.">6.2.5.2</a> <i>Name</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>PATH</b>
									</p>
									<p class="c5">
										A <b>PATH</b> property is an ordered list of <i>path elements</i>. A path element is a <b>NAME</b> with an optional index. When read, the <b>NAME</b>s within the path are mapped to their current prefix. A path may be absolute or relative. See <a href="#section_6.2.5.3.">6.2.5.3</a> <i>Path</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>REFERENCE</b>
									</p>
									<p class="c5">
										A <b>REFERENCE</b> property stores the UUID of a referenceable node (one having type <b>mix:referenceable</b>), which must exist within the same workspace or session as the <b>REFERENCE</b> property. A <b>REFERENCE</b> property enforces this referential integrity by preventing (in level 2 implementations) the removal of its target node. See <a href="#section_6.2.5.4.">6.2.5.4</a> <i>Reference</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>UNDEFINED</b>
									</p>
									<p class="c5">
										This constant can be used within a property definition (see <a href="#section_6.7.6.">6.7.6</a> <i>Property Definitions</i>) to specify that the property in question may be of any type. However, it cannot be the actual type of any property instance. For example it will never be returned by <b>Property.getType</b> and (in level 2 implementations) it cannot be assigned as the type when creating a new property.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										String
									</p>
								</td>
								<td>
									<p class="c5">
										<b>TYPENAME_STRING == "String"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_BINARY == "Binary"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_LONG == "Long"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_DOUBLE == "Double"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_DATE == "Date"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_BOOLEAN == "Boolean"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_NAME == "Name"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_PATH == "Path"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_REFERENCE == "Reference"</b>
									</p>
									<p class="c5">
										<b>TYPENAME_UNDEFINED == "Undefined"</b>
									</p>
									<p class="c5">
										These constants define the standard string forms of the property types. These are used, for example, when serializing content to XML. See <a href="#section_6.4.">6.4</a> <i>XML Mappings</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										String
									</p>
								</td>
								<td>
									<p class="c5">
										<b>nameFromValue(int type)</b>
									</p>
									<p class="c5">
										Returns the standard name of the given property type, specified by its integer value.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										int
									</p>
								</td>
								<td>
									<p class="c5">
										<b>valueFromName(String name)</b>
									</p>
									<p class="c5">
										Returns the integer value of the given property type, specified by its standard name.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.5.1." id="section_6.2.5.1."></a>6.2.5.1 Date
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The text format of dates must follow the following ISO 8601:2000-compliant format:
								</p>
							
							
								<p class="c5">
									<b><i>sYYYY</i></b><b>-</b><b><i>MM</i></b><b>-</b><b><i>DD</i></b><b>T</b><b><i>hh</i></b><b>:</b><b><i>mm</i></b><b>:</b><b><i>ss</i></b><b>.</b><b><i>sssTZD</i></b>
								</p>
							
							
								<p class="c5">
									where:
								</p>
							
							
								<p class="c5">
									<b>sYYYY</b> Four-digit year with optional leading positive (‘<b>+</b>’) or negative (‘<b>-</b>’) sign. A negative sign indicates a year BCE. The absence of a sign or the presence of a positive sign indicates a year CE (for example, <b>-0055</b> would indicate the year 55 BCE, while <b>+1969</b> and <b>1969</b> indicate the year 1969 CE).
								</p>
							
							
								<p class="c5">
									<b>MM</b> Two-digit month (01 = January, etc.)
								</p>
							
							
								<p class="c5">
									<b>DD</b> Two-digit day of month (01 through 31)
								</p>
							
							
								<p class="c5">
									<b>hh</b> Two digits of hour (00 through 23)
								</p>
							
							
								<p class="c5">
									<b>mm</b> Two digits of minute (00 through 59)
								</p>
							
							
								<p class="c5">
									<b>ss.sss</b> Seconds, to three decimal places (00.000<br>
									through 59.999)
								</p>
							
							
								<p class="c5">
									<b>TZD</b> Time zone designator (either <i>Z</i> for Zulu, i.e. UTC, or<br>
									<i>+hh:mm</i> or <i>-hh:mm</i>, i.e. an offset from UTC)
								</p>
							
							
								<p class="c5">
									Note that the <b>"T"</b> separating the date from the time and the separators <b>"-"</b> and <b>":"</b> appear literally in the string. See <b><a href="http://www.w3.org/TR/NOTE-datetime">http://www.w3.org/TR/NOTE-datetime</a></b> for more information.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.5.2." id="section_6.2.5.2."></a>6.2.5.2 Name
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A <b>NAME</b> is a pairing of a <i>namespace</i> and a <i>local name</i>. It must be handled internally in such a way that when read through the API the namespace is mapped to the current prefix. For example, if at the time of reading the current prefix to URI mapping is:
								</p>
							
							
								<p class="c5">
									<b>myapp -&gt; http://mycorp.com/myapp</b>
								</p>
							
							
								<p class="c5">
									then a <b>NAME</b> with fully qualified form
								</p>
							
							
								<p class="c5">
									<i>{http://mycorp.com/myapp}</i><b>myItem</b>
								</p>
							
							
								<p class="c5">
									would be returned as the string:
								</p>
							
							
								<p class="c5">
									<b>myapp:myItem</b>
								</p>
							
							
								<p class="c5">
									If the namespace were later remapped to
								</p>
							
							
								<p class="c5">
									<b>yourapp -&gt; http://mycorp.com/myapp</b>
								</p>
							
							
								<p class="c5">
									then the value returned would be the string
								</p>
							
							
								<p class="c12">
									<b>yourapp:myItem</b>
								</p>
							
							
								<p class="c5">
									Note however, that how the <b>NAME</b> value is stored internally is up to the implementation, as long as dynamic remapping is supported.
								</p>
							
							
								<p class="c5">
									<b>NAME</b> properties are used for recording values such as node type names (see <a href="#section_6.7.5.">6.7.5</a> <i>Special Properties jcr:primaryType and jcr:mixinTypes</i>) that must respect namespace mappings.
								</p>
							
							
								<p class="c5">
									Upon <b>save</b>, a <b>NAME</b> property is validated according to two criteria:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The prefix specified (if any) must be currently mapped to a registered namespace (see <a href="#section_6.3.">6.3</a> <i>Namespaces</i>).
				</p>
			</li>
			<li>
				<p class="c5">
					The syntax of the string specified must conform to the following EBNF:
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c12">
									name ::= simplename | prefixedname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									simplename ::= onecharsimplename |
								</p>
							
							
								<p class="c12">
									twocharsimplename |
								</p>
							
							
								<p class="c12">
									threeormorecharname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									prefixedname ::= prefix ':' localname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									localname ::= onecharlocalname |
								</p>
							
							
								<p class="c12">
									twocharlocalname |
								</p>
							
							
								<p class="c12">
									threeormorecharname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									onecharsimplename ::= (* Any Unicode character except:<br>
									'.', '/', ':', '[', ']', '*',<br>
									''', '"', '|' or any whitespace
								</p>
							
							
								<p class="c12">
									character *)
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									twocharsimplename ::= '.' onecharsimplename |
								</p>
							
							
								<p class="c12">
									onecharsimplename '.' |
								</p>
							
							
								<p class="c12">
									onecharsimplename onecharsimplename
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									onecharlocalname ::= nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									twocharlocalname ::= nonspace nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									threeormorecharname ::= nonspace string nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									prefix ::= (* Any valid XML Name *)
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									string ::= char | string char
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									char ::= nonspace | ' '
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									nonspace ::= (* Any Unicode character except:<br>
									'/', ':', '[', ']', '*',<br>
									''', '"', '|' or any whitespace
								</p>
							
							
								<p class="c12">
									character *)
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.5.3." id="section_6.2.5.3."></a>6.2.5.3 Path
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A <b>PATH</b> property is an ordered list of <i>path elements</i>. A path element is a <b>NAME</b> plus an with optional index. When read, the fully qualified <b>NAME</b>s within the path are mapped to their current prefix and the result is returned as a string. A path may be absolute or relative. For example, given the namespace mapping
								</p>
							
							
								<p class="c5">
									<b>myapp -&gt; http://mycorp.com/myapp</b>
								</p>
							
							
								<p class="c5">
									a <b>PATH</b> property value with fully qualified form
								</p>
								
									
										<p class="c5">
											<b>/</b><i>{</i><i>http://mycorp.com/myapp</i><i>}</i><b>document[1]/<br></b> <i>{</i><i>http://mycorp.com/myapp</i><i>}</i><b>paragraph[3]</b>
										</p>
									
								
							
							
								<p class="c5">
									would be returned as the string
								</p>
							
							
								<p class="c5">
									<b>/myapp:document/myapp:paragraph[3]</b>
								</p>
							
							
								<p class="c5">
									If the namespace were later remapped to
								</p>
							
							
								<p class="c5">
									<b>yourapp -&gt; http://mycorp.com/myapp</b>
								</p>
							
							
								<p class="c5">
									then the value returned would be the string
								</p>
							
							
								<p class="c5">
									<b>/yourapp:document/yourapp:paragraph[3]</b>
								</p>
							
							
								<p class="c5">
									Note however, that how the <b>PATH</b> value is stored internally is up to the implementation, as long as dynamic remapping is supported.
								</p>
							
							
								<p class="c5">
									A common use for <b>PATH</b> properties is likely to be the storage of paths to other items in the workspace. However the repository does not enforce referential integrity (unlike in the case of <b>REFERENCE</b> properties, see <a href="#section_6.2.5.4.">6.2.5.4</a> <i>Reference</i>); a <b>PATH</b> property may specify a location where no item exists.
								</p>
							
							
								<p class="c5">
									Upon <b>save</b>, a <b>PATH</b> property is validated according to two criteria:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					All prefixes specified must be currently mapped to registered namespaces (see <a href="#section_6.3.">6.3</a> <i>Namespaces</i>).
				</p>
			</li>
			<li>
				<p class="c5">
					The syntax of the string specified must conform to the following EBNF:
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c12">
									path ::= properpath ['/']
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									properpath ::= abspath | relpath
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									abspath ::= '/' relpath
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									relpath ::= pathelement | relpath '/' pathelement
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									pathelement ::= name | name '[' number ']' | '..' | '.'
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									number ::= /* An integer &gt; 0 */
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									name ::= simplename | prefixedname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									simplename ::= onecharsimplename |
								</p>
							
							
								<p class="c12">
									twocharsimplename |
								</p>
							
							
								<p class="c12">
									threeormorecharname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									prefixedname ::= prefix ':' localname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									localname ::= onecharlocalname |
								</p>
							
							
								<p class="c12">
									twocharlocalname |
								</p>
							
							
								<p class="c12">
									threeormorecharname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									onecharsimplename ::= (* Any Unicode character except:<br>
									'.', '/', ':', '[', ']', '*',<br>
									''', '"', '|' or any whitespace
								</p>
							
							
								<p class="c12">
									character *)
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									twocharsimplename ::= '.' onecharsimplename |
								</p>
							
							
								<p class="c12">
									onecharsimplename '.' |
								</p>
							
							
								<p class="c12">
									onecharsimplename onecharsimplename
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									onecharlocalname ::= nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									twocharlocalname ::= nonspace nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									threeormorecharname ::= nonspace string nonspace
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									prefix ::= (* Any valid XML Name *)
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									string ::= char | string char
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									char ::= nonspace | ' '
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									nonspace ::= (* Any Unicode character except:<br>
									'/', ':', '[', ']', '*',<br>
									''', '"', '|' or any whitespace
								</p>
							
							
								<p class="c12">
									character *)
								</p>
							
							
								<p class="c5">
									<br>
									Note that the method <b>Property.getNode()</b> which resolves a <b>REFERENCE</b> property and returns the referenced node <i>does not work</i> with <b>PATH</b> properties (see <a href="#section_6.2.5.4.">6.2.5.4</a> <i>Reference</i>). <b>PATH</b> properties may point to properties (not just referenceable nodes) or to nothing at all. In order to use a <b>PATH</b> to retrieve an item, the <b>PATH</b>'s value must be retrieved and then used in a regular <b>getItem</b>, <b>getNode</b> or <b>getProperty</b> call.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.5.4." id="section_6.2.5.4."></a>6.2.5.4 Reference
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A <b>REFERENCE</b> property stores the UUID of a referenceable node (one having type <b>mix:referenceable</b>). The referential integrity of <b>REFERENCE</b> properties must be guaranteed.
								</p>
							
							
								<p class="c5">
									In level 2 implementations, enforcement of referential integrity means that when a node is <b>remove</b>d, a check must be done to ensure that no <b>REFERENCE</b> properties in the workspace still refer to nodes in the subtree to be removed. This check is done when an attempt is made to persist the removal of a node (that is, either on <b>save</b>, or, if the change was made within a transaction, on <i>commit</i>; in any case, the check is not done immediately on <b>remove</b>). If any references to a node in the subtree to be removed exist, a <b>ReferentialIntegrityException</b> is thrown.
								</p>
							
							
								<p class="c5">
									An exception is made to the referential integrity rule when the <b>REFERENCE</b> property in question is part of the frozen state of a version stored in version storage. In that case the frozen <b>REFERENCE</b> property may hold the UUID of a node that is no longer in the workspace (see <a href="#section_8.2.2.9.">8.2.2.9</a> <i>Reference Properties within a Version</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.6." id="section_6.2.6."></a> 6.2.6 Property Type Conversion
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a read or write of a property is performed with an access method or value of a different type than the property, an attempt will be made to automatically convert between types using the principles described in the following table:
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<table border="1" cellpadding="1" cellspacing="0" rules="GROUPS">
			<colgroup>
				
			</colgroup>
			<colgroup>
				
				
				
				
				
				
				
				
				
			</colgroup>
			<tbody>
				<tr>
					<td valign="bottom" bgcolor="#33CCCC">
						<p class="c18">
							<i><b>From</b></i>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<i><b>To</b></i>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99"></td>
					<td valign="bottom" bgcolor="#FFCC99"></td>
					<td valign="bottom" bgcolor="#FFCC99"></td>
					<td valign="bottom" bgcolor="#FFCC99"></td>
					<td valign="bottom" bgcolor="#FFCC99"></td>
					<td valign="bottom" bgcolor="#FFCC99">
						
							
								
									
										
											
												<p>
													<br>
												</p>
											
										
									
								
							
						
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						
							
								
									
										
											
												<p>
													<br>
												</p>
											
										
									
								
							
						
					</td>
					<td valign="top" bgcolor="#FFCC99">
						
							
								
									
										
											
												<p>
													<br>
												</p>
											
										
									
								
							
						
					</td>
				</tr>
				<tr>
					<td valign="top" bgcolor="#33CCCC">
						<p>
							<br>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>String</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Binary</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Date</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Double</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Long</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Boolean</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Name</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Path</b>
						</p>
					</td>
					<td valign="bottom" bgcolor="#FFCC99">
						<p class="c18">
							<b>Reference</b>
						</p>
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>String</b>
						</p>
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						<p class="c18">
							UTF-8
						</p>
					</td>
					<td>
						<p class="c18">
							ISO 8601:2000. Throw on format error.
						</p>
					</td>
					<td>
						
							
								<br>
								java.lang.<br>
								Double.<br>
								valueOf(String)
							
							
								<br>
								(base 10 conversion)
							
						
					</td>
					<td>
						
							
								<br>
								java.lang.<br>
								Long.<br>
								valueOf(String)
							
							
								<br>
								(base 10 conversion)
							
						
					</td>
					<td>
						<p class="c18">
							java.lang.<br>
							Boolean.<br>
							valueOf(String)
						</p>
					</td>
					<td>
						<p class="c18">
							Throw on format error.
						</p>
					</td>
					<td>
						<p class="c18">
							Throw on format error.
						</p>
					</td>
					<td>
						<p class="c18">
							Throw on format error.
						</p>
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Binary</b>
						</p>
					</td>
					<td>
						<p class="c18">
							UTF-8.<br>
							If binary is not UTF-8 behavior is implementation-specific
						</p>
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Date</b>
						</p>
					</td>
					<td>
						<p class="c18">
							ISO 8601:2000
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						<p class="c18">
							Milliseconds since 1970-01-01T00:00:00Z. Throw on out-of- range.
						</p>
					</td>
					<td>
						<p class="c18">
							Milliseconds since 1970-01-01T00:00:00Z. Throw on out-of- range.
						</p>
					</td>
					<td>
						
							
								<br>
								Throws ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Double</b>
						</p>
					</td>
					<td>
						
							
								<br>
								java.lang.<br>
								Double.<br>
								toString()
							
							
								<br>
								(base 10 conversion)
							
						
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							Milliseconds since 1970-01-01T00:00:00Z
						</p>
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						<p class="c18">
							Standard Java conversion
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Long</b>
						</p>
					</td>
					<td>
						
							
								<br>
								java.lang.<br>
								Long.toString()
							
							
								<br>
								(base 10 conversion)
							
						
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						<p class="c18">
							Milliseconds since 1970-01-01T00:00:00Z
						</p>
					</td>
					<td>
						<p class="c18">
							Standard Java conversion
						</p>
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Boolean</b>
						</p>
					</td>
					<td>
						<p class="c18">
							java.lang.<br>
							Boolean.<br>
							toString()
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Name</b>
						</p>
					</td>
					<td>
						<p class="c18">
							Direct
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						<p class="c18">
							Name becomes relative path
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Path</b>
						</p>
					</td>
					<td>
						<p class="c18">
							Direct
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						<p class="c18">
							If Path is relative and one element long and has no index, convert directly, other wise throw ValueFormat Exception
						</p>
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
				</tr>
			</tbody>
			<tbody>
				<tr valign="top">
					<td bgcolor="#33CCCC">
						<p class="c18">
							<b>Reference</b>
						</p>
					</td>
					<td>
						<p class="c18">
							Direct
						</p>
					</td>
					<td>
						<p class="c18">
							via String
						</p>
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td>
						
							
								<br>
								Throw ValueFormat
							
							
								<br>
								Exception
							
						
					</td>
					<td bgcolor="#A6A6A6">
						<p>
							<br>
						</p>
					</td>
				</tr>
			</tbody>
		</table>
		<h4>
			<a name="section_6.2.7." id="section_6.2.7."></a>6.2.7 Value
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Value</b> interface represents the value of a property. The methods of the <b>Value</b> interface are:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Value</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getString()</b>
									</p>
									<p class="c5">
										Returns a <b>String</b> representation of this value.
									</p>
									<p class="c5">
										If this value cannot be converted to a <b>String</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If <b>getStream</b> has previously been called on this <b>Value</b> instance, an <b>IllegalStateException</b> is thrown. In this case, a new <b>Value</b> instance must be acquired in order to successfully call <b>getString</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>InputStream</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getStream()</b>
									</p>
									<p class="c5">
										Returns an <b>InputStream</b> representation of this value. Uses the standard conversion to binary.
									</p>
									<p class="c5">
										If a non-stream <b>get</b> method has previously been called on this <b>Value</b> instance, an <b>IllegalStateException</b> is thrown. In this case, a new <b>Value</b> instance must be acquired in order to successfully call <b>getStream</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>long</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLong()</b>
									</p>
									<p class="c5">
										Returns a <b>long</b> representation of this value.
									</p>
									<p class="c5">
										If this value cannot be converted to a <b>long</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If <b>getStream</b> has previously been called on this <b>Value</b> instance, an <b>IllegalStateException</b> is thrown. In this case a new <b>Value</b> instance must be acquired in order to successfully call <b>getLong</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>double</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDouble()</b>
									</p>
									<p class="c5">
										Returns a <b>double</b> representation of this value.
									</p>
									<p class="c5">
										If this value cannot be converted to a <b>double</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If <b>getStream</b> has previously been called on this <b>Value</b> instance, an <b>IllegalStateException</b> is thrown. In this case a new <b>Value</b> instance must be acquired in order to successfully call <b>getDouble</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Calendar</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDate()</b>
									</p>
									<p class="c5">
										Returns a <b>Calendar</b> representation of this value.
									</p>
									<p class="c5">
										The object returned is a copy of the stored value, so changes to it are not reflected in internal storage.
									</p>
									<p class="c5">
										If this value cannot be converted to a <b>Calendar</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If <b>getStream</b> has previously been called on this <b>Value</b> instance, an <b>IllegalStateException</b> is thrown. In this case a new <b>Value</b> instance must be acquired in order to successfully call <b>getDate</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getBoolean()</b>
									</p>
									<p class="c5">
										Returns a <b>boolean</b> representation of this value.
									</p>
									<p class="c5">
										If this value cannot be converted to a <b>boolean</b>, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If <b>getStream</b> has previously been called on this <b>Value</b> instance, an <b>IllegalStateException</b> is thrown. In this case a new <b>Value</b> instance must be acquired in order to successfully call <b>getBoolean</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getType()</b>
									</p>
									<p class="c5">
										Returns the type of this value. See <a href="#section_6.2.5.">6.2.5</a> <i>Property Types</i>. The type returned is that which was set at property creation.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<br>
									Implementations of <b>Value</b> must observe the following behavioral restrictions:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					A <b>Value</b> object can be read using type-specific <b>get</b> methods. These methods are divided into two groups:
				</p>
				<ul>
					<li>
						<p class="c5">
							The non-stream <b>get</b> methods <b>getString()</b>, <b>getDate()</b>, <b>getLong()</b>, <b>getDouble()</b> and <b>getBoolean()</b>.
						</p>
					</li>
					<li>
						<p class="c5">
							<b>getStream()</b>.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					Once a <b>Value</b> object has been read once using <b>getStream()</b>, all subsequent calls to <b>getStream()</b> will return the same stream object. This may mean, for example, that the stream returned is fully or partially consumed. In order to get a fresh stream the <b>Value</b> object must be reacquired via <b>Property.getValue()</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Once a <b>Value</b> object has been read once using <b>getStream()</b>, any subsequent call to any of the non-stream <b>get</b> methods will throw an <b>IllegalStateException</b>. In order to successfully invoke a non-stream <b>get</b> method the <b>Value</b> must be reacquired via <b>Property.getValue()</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Once a <b>Value</b> object has been read once using a non-stream <b>get</b> method, any subsequent call to <b>getStream()</b> will throw an <b>IllegalStateException</b>. In order to successfully invoke <b>getStream()</b> the <b>Value</b> must be reacquired via <b>Property.getValue()</b>.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.2.7.1." id="section_6.2.7.1."></a>6.2.7.1 Creating New Value Instances
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In level 2 repositories, new <b>Value</b> instances are created using the <b>ValueFactory</b> object acquired through <b>Session.getValueFactory</b>. (see 7.1 Writing Repository Content and 7.1.5.3 Creating Value Objects).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.7.2." id="section_6.2.7.2."></a>6.2.7.2 Equality Conditions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Two <b>Value</b> instances, <b>v1</b> and <b>v2</b>, are considered equal if and only if
								</p>
							
							
								<p class="c5">
									<b>v1.getType() == v2.getType()</b> and
								</p>
							
							
								<p class="c5">
									<b>v1.getString().equals(v2.getString())</b>.
								</p>
							
							
								<p class="c5">
									Actually comparing two <b>Value</b> instances by converting them to string form may not be practical in some cases (for example, if the values are large binaries). Consequently, the above is intended as a normative definition of <b>Value</b> equality, but not as a procedural test. It is assumed that implementations will have an efficient means of determining equality that conforms with the above definition.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.7.3." id="section_6.2.7.3."></a>6.2.7.3 Value Length
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Determining the length of a <b>Value</b> can be done through the <b>Property</b> interface by calling <b>Property.getLength</b> or <b>getLengths</b> (the former for single value properties, the latter for multi-value properties). These length-reporting methods are found on <b>Property</b> and not on <b>Value</b> because determining the length of a value is typically more useful if done <i>before</i> loading the value into local memory as a <b>Value</b> object (of course, whether to do such late-loading is an implementation-level issue, but it is likely to be a common approach). As well, in many implementations determining the length of some values may require access to the <b>Workspace</b> object and in many cases <b>Value</b> objects will not hold such reference (whereas <b>Property</b> objects will). See <a href="#section_6.2.4.">6.2.4</a> <i>Property Read Methods</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.8." id="section_6.2.8."></a>6.2.8 Item Read Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Item</b> interface also contains a number of other methods, inherited by both <b>Node</b> and <b>Property</b>. The following methods provide access to and information about nodes and properties. <b>Item</b> also has other methods applicable to level 2. In a level 1-only implementation they will either do nothing or throw an exception.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Item</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPath()</b>
									</p>
									<p class="c5">
										Returns the absolute path to this item.
									</p>
									<p class="c5">
										If the path includes items that are same name sibling nodes or multi-value properties then those elements in the path will include the appropriate “square bracket” index notation (for example, <b>/a/b[3]/c</b>).
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getName()</b>
									</p>
									<p class="c5">
										Returns the name of this item. The name is the last item in the path, minus any square-bracket index that may exist. If this item is the root node of the workspace (i.e., if <b>this.getDepth() == 0</b>), an empty string will be returned.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Item</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAncestor(int depth)</b>
									</p>
									<p class="c5">
										Returns the ancestor of the specified depth below the root. An ancestor of depth <b>x</b> is the <b>Item</b> that is <b>x</b> levels down along the path from the root node to <i>this</i> <b>Item</b>.
									</p>
									<ul>
										<li>
											<p class="c5">
												<b>depth = 0</b> returns the root node.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>depth = 1</b> returns the child of the root node along the path to <i>this</i> <b>Item</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>depth = 2</b> returns the grandchild of the root node along the path to <i>this</i> <b>Item</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												And so on to <b>depth = n</b>, where <b>n</b> is the depth of <i>this</i> <b>Item</b>, which returns <i>this</i> <b>Item</b> itself. If <b>depth &gt; n</b> is specified then an <b>ItemNotFoundException</b> is thrown.
											</p>
										</li>
									</ul>
									<p class="c5">
										An <b>ItemNotFoundException</b> will be thrown if <b>depth &lt; 0</b> or <b>depth &gt; n</b> where <b>n</b> is the is the depth of this item along the path returned by <b>getPath()</b>.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the current session does not have sufficient access permissions to retrieve the specified node.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Node</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getParent()</b>
									</p>
									<p class="c5">
										Returns the parent of this <b>Item</b>.
									</p>
									<p class="c5">
										An <b>ItemNotFoundException</b> is thrown if there is no parent node. This only happens if this item is the root node of a workspace.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the current session does not have sufficient access permissions to retrieve the parent of this item.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDepth()</b>
									</p>
									<p class="c5">
										Returns the depth below the root node of <i>this</i> <b>Item</b> (counting <i>this</i> <b>Item</b> itself):
									</p>
									<ul>
										<li>
											<p class="c12">
												The root node returns <b>0</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												A property or child node of the root node returns <b>1</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												A property or child node of a child node of the root returns <b>2</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												And so on to <i>this</i> <b>Item</b>.
											</p>
										</li>
									</ul>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Session</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getSession()</b>
									</p>
									<p class="c5">
										Returns the <b>Session</b> through which this <b>Item</b> was acquired.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isNode()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this <b>Item</b> is a <b>Node</b>; returns <b>false</b> if this <b>Item</b> is a <b>Property</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isSame(Item otherItem)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this <b>Item</b> object (the Java object instance) represents the same actual repository item as the object <b>otherItem</b>.
									</p>
									<p class="c5">
										This method does not compare the <i>states</i> of the two items. For example, if two <b>Item</b> objects representing the same actual repository item have been retrieved through two different sessions and one has been modified, then this method will still return <b>true</b> when comparing these two objects. Note that if two <b>Item</b> objects representing the same repository item are retrieved through the <i>same</i> session they will always reflect the same state (see <a href="#section_7.1.3.">7.1.3</a> <i>Reflecting Item State</i>) so comparing state is not an issue.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>accept(ItemVisitor visitor)</b>
									</p>
									<p class="c5">
										Accepts an <b>ItemVisitor</b> and calls the appropriate <b>visit</b> method according to whether <i>this</i> <b>Item</b> is a <b>Node</b> or a <b>Property</b>.
									</p>
									<p class="c5">
										This method provides support for the <i>visitor</i> design pattern. It takes an <b>Item</b><b>Visitor</b> object that must implement two methods: <b>visit(Node node)</b> and <b>visit(Property property)</b>. Depending on whether this <b>Item</b> is a <b>Node</b> or a <b>Property</b> one of the visit methods is called with this <b>Item</b> as the parameter.
									</p>
									<p class="c5">
										The API also provides the abstract class <b>TraversingItemVisitor</b> implementing <b>ItemVisitor</b>, which automatically traverses the hierarchy calling <b>accept</b> at each node and property. It provides the methods <b>entering</b> and <b>leaving</b> that can be overridden in a subclass to perform custom operations.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.2.9." id="section_6.2.9."></a> 6.2.9 Effect of Access Denial on Read
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If a particular repository restricts the read access of a particular user (see 6.9 Access Control), then the nodes and properties to which that user does not have read access will simply not appear to exist. For example, the nodes returned on <b>N.getNodes</b> will not include subnodes of <b>N</b> to which the user in question does not have read access. In other words lack of read access to an item blocks access to both information about the <i>content</i> of that item and information about the <i>existence</i> of the item.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.2.10." id="section_6.2.10."></a>6.2.10 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following section gives some examples of how node access and property read operations are performed. In order to provide some context for the examples, we return to our earlier example of a repository structured like this:
								</p>
							
							
								<p class="c12">
									<b>Node</b>
								</p>
							
							
								<p class="c12">
									<b>Property = "Some Value"</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<i><b>[root]</b></i>
								</p>
							
							
								<p>
									└─<b>products</b>
								</p>
							
							
								<p>
									├─<b>jcr:created = "2001-01-01T..."</b>
								</p>
							
							
								<p>
									├─<b>jcr:content</b>
								</p>
							
							
								<p>
									│ ├─<b>myapp:title = "Our Products..."</b>
								</p>
							
							
								<p>
									│ ├─<b>myapp:lead = "Geometrixx is proud..."</b>
								</p>
							
							
								<p>
									│ ├─<b>myapp:paragraph[1]</b>
								</p>
							
							
								<p>
									│ │ ├─<b>myapp:text = "Geometrixx is..."</b>
								</p>
							
							
								<p>
									│ │ └─ <b>myapp:image = <i>[binary data]</i></b>
								</p>
							
							
								<p>
									│ └─<b>myapp:paragraph[2]</b>
								</p>
							
							
								<p>
									│ ├─ <b>myapp:text = "We have..."</b>
								</p>
							
							
								<p>
									│ └─ <b>myapp:image = <i>[binary data]</i></b>
								</p>
							
							
								<p>
									└─<b>rhombus</b>
								</p>
							
							
								<p>
									├─<b>jcr:created = "2002-06-01T"</b>
								</p>
							
							
								<p>
									└─<b>jcr:content</b>
								</p>
							
							
								<p>
									├─<b>myapp:title = "Rhombus:..."</b>
								</p>
							
							
								<p>
									├─<b>myapp:price = "123.00"</b>
								</p>
							
							
								<p>
									├─<b>myapp:lead = "Here at..."</b>
								</p>
							
							
								<p>
									├─<b>myapp:paragraph[1]</b>
								</p>
							
							
								<p>
									│ ├─<b>myapp:text = "The rhombus..."</b>
								</p>
							
							
								<p>
									│ └─<b>myapp:image = <i>[binary data]</i></b>
								</p>
							
							
								<p>
									└─<b>myapp:paragraph[2]</b>
								</p>
							
							
								<p>
									├─<b>myapp:text = "Some say..."</b>
								</p>
							
							
								<p>
									└─<b>myapp:image = <i>[binary data]</i></b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									Assuming that the programmer has called:
								</p>
							
							
								<p class="c12">
									<b>Session session = ...</b>
								</p>
							
							
								<p class="c12">
									<b>Node root = session.getRootNode();</b>
								</p>
							
							
								<p class="c5">
									<br>
									From the root node, one can access any node or property in the workspace. For example,
								</p>
							
							
								<p class="c12">
									<b>Node n1 = root.getNode("products");</b>
								</p>
							
							
								<p class="c12">
									<b>Node n2 = n1.getNode("rhombus");</b>
								</p>
							
							
								<p class="c12">
									<b>Node n3 = n2.getNode("jcr:content");</b>
								</p>
							
							
								<p class="c12">
									<b>Node n4 = n3.getNode("myapp:paragraph[2]");</b>
								</p>
							
							
								<p class="c12">
									<b>Property p = n4.getProperty("myapp:text");</b>
								</p>
							
							
								<p class="c12">
									<b>Value v = p.getValue();</b>
								</p>
							
							
								<p class="c12">
									<b>String s = v.getString();</b>
								</p>
							
							
								<p class="c12">
									<b>System.out.println(s);</b>
								</p>
							
							
								<p class="c5">
									<br>
									would print, <b>"Some say..."</b> to standard output. Alternatively, more convenient direct access is also possible,
								</p>
							
							
								<p class="c12">
									<b>Property p = root.getProperty("products/rhombus/<br>
									jcr:content/myapp:paragraph[2]/myapp:text");</b>
								</p>
							
							
								<p class="c12">
									<b>System.out.println(p.getString());</b>
								</p>
							
							
								<p class="c5">
									<br>
									Here we use a relative path from the root to access a property deep in the hierarchy.
								</p>
							
							
								<p class="c5">
									As well, traversal of the hierarchy is easily done. For example, given the following method,
								</p>
							
							
								<p class="c12">
									<b>public void traverse(Node n, int level)<br>
									throws RepositoryException {</b>
								</p>
							
							
								<p class="c12">
									<b>String name = (n.getDepth() == 0) ? "/" : n.getName();</b>
								</p>
							
							
								<p class="c12">
									<b>System.out.println(makeIndent(level) + name);</b>
								</p>
							
							
								<p class="c12">
									<b>for (PropertyIterator i = n.getProperties();<br>
									i.hasNext();) {</b>
								</p>
							
							
								<p class="c12">
									<b>Property p = i.nextProperty();</b>
								</p>
							
							
								<p class="c12">
									<b>System.out.println(makeIndent(level + 1) +<br>
									p.getName() + " = \"" +<br>
									p.getString() + "\"");</b>
								</p>
							
							
								<p class="c12">
									<b>}</b>
								</p>
							
							
								<p class="c12">
									<b>for (NodeIterator i = n.getNodes(); i.hasNext();) {</b>
								</p>
							
							
								<p class="c12">
									<b>Node nn = i.nextNode();</b>
								</p>
							
							
								<p class="c12">
									<b>traverse(nn, level + 1);</b>
								</p>
							
							
								<p class="c12">
									<b>}</b>
								</p>
							
							
								<p class="c12">
									<b>}</b>
								</p>
							
							
								<p class="c5">
									<br>
									the call,
								</p>
							
							
								<p class="c12">
									<b>traverse(root, 0);</b>
								</p>
							
							
								<p class="c5">
									<br>
									would print out something like the following:
								</p>
							
							
								<p class="c12">
									/
								</p>
							
							
								<p class="c12">
									<b>products</b>
								</p>
							
							
								<p class="c12">
									<b>jcr:created = "2001-01-01T..."</b>
								</p>
							
							
								<p class="c12">
									<b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:title = "Our Products..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:lead = "Geometrixx is proud..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:paragraph[1]</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:text = "Geometrixx is..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:image = ""</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:paragraph[2]</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:text = "We have..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:image = ""</b>
								</p>
							
							
								<p class="c12">
									<b>rhombus</b>
								</p>
							
							
								<p class="c12">
									<b>jcr:created = "2002-06-01T..."</b>
								</p>
							
							
								<p class="c12">
									<b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:title = "Rhombus:..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:price = "123.00"</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:lead = "Here at..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:paragraph[1]</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:text = "The rhombus..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:image = ""</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:paragraph[2]</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:text = "Some say..."</b>
								</p>
							
							
								<p class="c12">
									<b>myapp:image = ""</b>
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.3." id="section_6.3."></a>6.3 Namespaces
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A compliant content repository provides support for the namespacing of item and node type names. Namespacing serves to prevent naming collisions among items and node types that come from different sources or application domains. The namespace system is modelled after <i>XML Namespaces</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.3.1." id="section_6.3.1."></a>6.3.1 Namespace Registry
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Each repository has a single, persistent namespace registry represented by the <b>NamespaceRegistry</b> object, accessed via <b>Workspace.getNamespaceRegistry()</b>. The following describes the methods of <b>NamespaceRegistry</b> supported in level 1. <b>NamespaceRegistry</b> also has other methods that are supported in level 2. In level 1 repositories these methods either do nothing or throw an exception. See <a href="#section_7.2.">7.2</a> <i>Adding and Deleting Namespaces</i> for more details.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>NamespaceRegistry</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPrefixes()</b>
									</p>
									<p class="c5">
										Returns an array holding all currently registered prefixes.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getURIs()</b>
									</p>
									<p class="c5">
										Returns an array holding all currently registered URIs.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getURI(String prefix)</b>
									</p>
									<p class="c5">
										Returns the URI to which the given <b>prefix</b> is mapped. If a mapping with the specified <b>prefix</b> does not exist, a <b>NamespaceException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPrefix(String uri)</b>
									</p>
									<p class="c5">
										Returns the prefix which is mapped to the given <b>uri</b>. If a mapping with the specified <b>uri</b> does not exist, a <b>NamespaceException</b> is thrown
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<br>
									A registered prefix can be used in the name of any node or property in the repository. The prefix serves as shorthand for the URI to which it is mapped. Because the space of URIs is universally managed, the combination of the per-repository namespace and the larger URI namespace can be used to provide universal uniqueness of node or property names. Of course, just as in the case of XML namespaces, ensuring this universal uniqueness requires applications to map their application-specific prefixes to URIs that are uniquely identified with that particular application.
								</p>
							
							
								<p class="c5">
									The namespace registry always contains at least the following built-in mappings:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>jcr -&gt; http://www.jcp.org/jcr/1.0</b><br>
					Reserved for items defined within built-in node types. For example <b>jcr:content</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>nt -&gt; http://www.jcp.org/jcr/nt/1.0<br></b>Reserved for the names of built-in primary node types.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>mix -&gt; http://www.jcp.org/jcr/mix/1.0<br></b>Reserved for the names of built-in mixin node types.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>xml</b> <b>-&gt; http://www.w3.org/XML/1998/namespace</b><br>
					Reserved for reasons of compatibility with XML. This prefix should not be used by clients of the API in the names of normal nodes or properties, since doing so will cause problems on export to XML.
				</p>
			</li>
			<li>
				<p>
					“” (the empty prefix) <b>-&gt;</b> “” (the empty URI)<br>
					This makes the <i>default namespace</i> the <i>empty URI</i>. In effect this means that a name without a prefix is identical in both its prefixed form and in its fully qualified form (i.e. when it is stored internally as <i>URI plus local name</i>). See <a href="#section_6.3.3.">6.6.1</a> <i>Internal Storage of Names and Values</i>.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									In a level 1 repository there is no provision for adding new namespaces to the registry (or deleting namespaces from it), this functionality is part of level 2 (see <a href="#section_7.2.">7.2</a> <i>Adding and Deleting Namespaces</i>). However, a level 1 implementation may provide any number of built-in namespaces, in addition to the five required ones listed above. As well, level 1 supports the temporary assignment of new prefixes to existing namespaces within the scope of a particular <b>Session</b> (see immediately below).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.3.2." id="section_6.3.2."></a>6.3.2 Prefix Syntax
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A prefix can be any valid XML name. Note that the local name for an item (the part after the colon) might not be a valid XML name (the space of valid content repository local names is a superset of the space of XML names), however the set of possible content repository prefixes is identical to the set of possible XML prefixes.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.3.3." id="section_6.3.3."></a> 6.3.3 Session Namespace Remapping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Any registered namespace can be temporarily remapped to a new prefix within the scope of a particular <b>Session</b>.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setNamespacePrefix(String prefix, String uri)</b>
									</p>
									<p class="c5">
										Within the scope of this <b>Session</b>, remaps a persistently registered namespace URI to the new <b>prefix</b>. The remapping only affects operations done through this session. To clear all remappings, the client must acquire a new <b>Session</b>.
									</p>
									<p class="c5">
										A prefix that is currently already mapped to some URI (either persistently in the repository <b>NamespaceRegistry</b> or transiently within this <b>Session</b>) cannot be remapped to a new URI using this method, since this would make any content stored using the old URI unreadable. An attempt to do this will throw a <b>NamespaceException</b>.
									</p>
									<p class="c5">
										As well, a <b>NamespaceException</b> will be thrown if an attempt is made to remap an existing namespace URI to a prefix beginning with the characters “<b>xml</b>” (in any combination of case).
									</p>
									<p class="c5">
										A <b>NamespaceException</b> will also be thrown if the specified <b>uri</b> is not among those registered in the <b>NamespaceRegistry</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNamespacePrefixes()</b>
									</p>
									<p class="c5">
										Returns all prefixes currently set for this <b>Session</b>. This includes all those registered in the <b>NamespaceRegistry</b> but <i>not temporarily over-ridden</i> by a <b>Session.setNamespacePrefix,</b> plus those currently set locally by <b>Session.setNamespacePrefix</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNamespaceURI(String prefix)</b>
									</p>
									<p class="c5">
										Returns the URI to which the given <b>prefix</b> is mapped as currently set in this <b>Session</b>.
									</p>
									<p class="c5">
										A <b>NamespaceException</b> is thrown if the specified <b>prefix</b> is unknown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNamespacePrefix(String uri)</b>
									</p>
									<p class="c5">
										Returns the prefix to which the given URI is mapped as currently set in this <b>Session</b>.
									</p>
									<p class="c5">
										A <b>NamespaceException</b> is thrown if the specified <b>uri</b> is unknown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.3.3.1." id="section_6.3.3.1."></a>6.3.3.1 Using Session Namespace Remapping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									One use case for session-based namespace remapping occurs in the context of an XPath or SQL query (see <a href="#section_6.6.">6.6</a> <i>Searching Repository Content</i> and 8.58.5 Searching Repository Content with SQL).
								</p>
							
							
								<p class="c5">
									Queries often include literal names that have namespace prefixes. When attempting to use a stored query (or one obtained from some external source) whose prefixes do not match those currently used in the repository, dynamic remapping of namespaces in the session allows the temporary session mapping to be adapted to whatever prefixes are used in the query statement.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.3.3.2." id="section_6.3.3.2."></a>6.3.3.2 Scope of Session Namespace Remapping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									All methods that take paths or names as arguments use the current <b>Session</b> namespace mappings to interpret those paths and names. This includes not just methods of <b>Session</b>, <b>Item</b>, <b>Node</b> and <b>Property</b> but also methods of the <b>Workspace</b> object. Since each <b>Workspace</b> object is associated one-to-one with a particular <b>Session</b> object, the object has access to the namespace mapping currently in effect on that <b>Session</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.3.4." id="section_6.3.4."></a> 6.3.4 Internal Storage of Names and Paths
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Note that the names of nodes and properties must be stored internally in such a way that when accessed they will reflect the current namespace mapping. One way of achieving this is to store them internally using fully qualified names and, upon access, dynamically produce the correct prefixed name or path based on the current mapping. Other mechanisms may also be used to achieve the same result.
								</p>
							
							
								<p class="c5">
									Similarly, all properties of type <b>NAME</b> or <b>PATH</b> must also dynamically reflect the current mapping. All accesses to the values of these properties should shield the client from the raw fully-qualified name and translate the value using the currently mapped prefix (see <a href="#section_6.2.5.2.">6.2.5.2</a> <i>Name</i> and <a href="#section_6.2.5.3.">6.2.5.3</a> <i>Path</i>).
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.4." id="section_6.4."></a>6.4 XML Mappings
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Level 1 supports two mappings of the content repository data model to XML. The mappings are called the <i>system view</i> and the <i>document view</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.4.1." id="section_6.4.1."></a>6.4.1 System View XML Mapping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The system view mapping provides a complete serialization of workspace content to XML without loss of information. In level 1 this allows the complete content of a workspace to be exported (see <a href="#section_6.5.">6.5</a> <i>Exporting Repository Content</i>). In level 2, this also allows for roundtripping of content to XML and back again through export and import (see <a href="#section_7.3.">7.3</a> <i>Importing Repository Content</i>).
								</p>
							
							
								<p class="c5">
									Given a subtree of a workspace, the resulting system view is determined as follows:
								</p>
							
						
					
				
			
		
		<ol>
			<li>
				<p class="c5">
					The relevant namespace mapping from the repository <b>NamespaceRegistry</b> is included as XML namespace declarations in the top-most XML element (though the <b>xml</b> namespace is excluded, since its presence would be redundant). Additionally a namespace mapping is included that maps to <b>http://www.jcp.org/jcr/sv/1.0</b>, for example <b>xmlns:sv="http://www.jcp.org/jcr/sv/1.0"</b>. In what follows it is assumed that the prefix used is <b>sv</b>, though any prefix is allowed as long as it is mapped to the URI above.
				</p>
			</li>
			<li>
				<p class="c5">
					Each content repository node becomes an XML element <b>&lt;sv:node&gt;</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Each content repository property becomes an XML element <b>&lt;sv:property&gt;</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The name of each content repository node or property becomes the value of the <b>sv:name</b> attribute of the corresponding <b>&lt;sv:node&gt;</b> or <b>&lt;sv:property&gt;</b> element.
				</p>
			</li>
			<li>
				<p class="c5">
					If the root node of a workspace is included in the serialized subtree, it receives the special name <b>jcr:root</b> (instead of the empty string).
				</p>
			</li>
			<li>
				<p class="c5">
					The property type of each content repository property is recorded in the <b>sv:type</b> attribute of the corresponding <b>&lt;sv:property&gt;</b> element, using the standard string forms for property type names as returned by the method <b>PropertyType.nameFromValue</b> (i.e., “<b>String</b>”, “<b>Binary</b>”, “<b>Date</b>”, “<b>Boolean</b>”, “<b>Double</b>”, “<b>Long</b>”, “<b>Name</b>”, “<b>Path</b>” and “<b>Reference</b>”).
				</p>
			</li>
			<li>
				<p class="c5">
					The value of each non-<b>BINARY</b> content repository property is converted to string form (according to <a href="#section_6.2.6.">6.2.6</a> <i>Property Type Conversion</i>). BINARY values are Base64 encoded. In both cases the resulting string is included as XML text within an <b>&lt;sv:value&gt;</b> element within the <b>&lt;sv:property&gt;</b> element. Entity references are used to escape characters which should not be included as literals within XML text (see <a href="#section_6.4.4.">6.4.4</a> <i>Escaping of Values</i>).
				</p>
			</li>
			<li>
				<p class="c5">
					A multi-value property is converted to an <b>&lt;sv:property&gt;</b> element containing multiple <b>&lt;sv:value&gt;</b> elements. The order of the <b>&lt;sv:value&gt;</b> elements reflects the order of the value array returned by <b>Property.getValues</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The hierarchy of the content repository nodes and properties is reflected in the hierarchy of the corresponding XML elements.
				</p>
			</li>
			<li>
				<p class="c5">
					Within an <b>&lt;sv:node&gt;</b> element all <b>&lt;sv:property&gt;</b> subelements must occur before the first <b>&lt;sv:node&gt;</b> subelement.
				</p>
			</li>
			<li>
				<p class="c5">
					The first two <b>&lt;sv:property&gt;</b> elements within an <b>&lt;sv:node&gt;</b> element must be the <b>jcr:primaryType</b> and <b>jcr:mixinTypes</b> (in that order) properties of the node in question.
				</p>
			</li>
			<li>
				<p class="c5">
					In the case of referenceable nodes, the third <b>&lt;sv:property&gt;</b> element in the <b>&lt;sv:node&gt;</b> element must be <b>jcr:uuid</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The order of the <b>&lt;sv:node&gt;</b> subelements of a parent <b>&lt;sv:node&gt;</b> must reflect the order in which the corresponding child nodes are returned by <b>Node.getNodes()</b>.
				</p>
			</li>
		</ol>
		<h4>
			<a name="section_6.4.1.1." id="section_6.4.1.1."></a>6.4.1.1 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A subtree with the following structure:
								</p>
							
							
								<p class="c12">
									<b>Node</b>
								</p>
							
							
								<p class="c12">
									<b>Property = "value"</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<b>myapp:document</b>
								</p>
							
							
								<p>
									├─<b>jcr:primaryType = "mynt:document"</b>
								</p>
							
							
								<p>
									├─<b>myapp:title = "JSR 170"</b>
								</p>
							
							
								<p>
									├─<b>myapp:lead = "Content Repository"</b>
								</p>
							
							
								<p>
									└─<b>myapp:body</b>
								</p>
							
							
								<p>
									├─<b>jcr:primaryType = "mynt:body"</b>
								</p>
							
							
								<p>
									└─<b>myapp:paragraph</b>
								</p>
							
							
								<p>
									├─<b>jcr:primaryType = "mynt:paragraph"</b>
								</p>
							
							
								<p>
									├─<b>myapp:title = "Node Types"</b>
								</p>
							
							
								<p>
									└─<b>myapp:text = "An important feature..."</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									where the source repository's namespace registry holds the mappings (in addition to the built-in ones):
								</p>
							
							
								<p class="c5">
									<b>myapp -&gt; http://mycorp.com/myapp</b>
								</p>
							
							
								<p class="c5">
									and
								</p>
							
							
								<p class="c5">
									<b>mynt -&gt; http://mycorp.com/mynt</b>
								</p>
							
							
								<p class="c5">
									would appear in the system view as:
								</p>
							
						
					
				
			
			
				<br>
				&lt;?xml version="1.0" encoding="UTF-8"?&gt;
			
			
				<br>
				&lt;sv:node xmlns:jcr="http://www.jcp.org/jcr/1.0"
			
			
				<br>
				xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
			
			
				<br>
				xmlns:mix="http://www.jcp.org/jcr/mix/1.0"<br>
				xmlns:sv="http://www.jcp.org/jcr/sv/1.0"
			
			
				<br>
				xmlns:myapp="http://mycorp.com/myapp"
			
			
				<br>
				xmlns:mynt="http://mycorp.com/mynt"
			
			
				<br>
				sv:name="myapp:document"&gt;
			
			
				<br>
				&lt;sv:property sv:name="jcr:primaryType" sv:type="Name"&gt;
			
			
				<br>
				&lt;sv:value&gt;mynt:document&lt;/sv:value&gt;
			
			
				<br>
				&lt;/sv:property&gt;
			
			
				<br>
				&lt;sv:property sv:name="myapp:title" sv:type="String"&gt;
			
			
				<br>
				&lt;sv:value&gt;JSR 170&lt;/sv:value&gt;
			
			
				<br>
				&lt;/sv:property&gt;
			
			
				<br>
				&lt;sv:property sv:name="myapp:lead" sv:type="String"&gt;
			
			
				<br>
				&lt;sv:value&gt;Content Repository&lt;/sv:value&gt;
			
			
				<br>
				&lt;/sv:property&gt;
			
			
				<br>
				&lt;sv:node sv:name="myapp:body"&gt;
			
			
				<br>
				&lt;sv:property sv:name="jcr:primaryType" sv:type="Name"&gt;
			
			
				<br>
				&lt;sv:value&gt;mynt:body&lt;/sv:value&gt;
			
			
				<br>
				&lt;/sv:property&gt;
			
			
				<br>
				&lt;sv:node sv:name="myapp:paragraph"&gt;
			
			
				<br>
				&lt;sv:property sv:name="jcr:primaryType" sv:type="Name"&gt;
			
			
				<br>
				&lt;sv:value&gt;mynt:paragraph&lt;/sv:value&gt;
			
			
				<br>
				&lt;/sv:property&gt;
			
			
				<br>
				&lt;sv:property sv:name="myapp:title" sv:type="String"&gt;
			
			
				<br>
				&lt;sv:value&gt;Node Types&lt;/sv:value&gt;
			
			
				<br>
				&lt;/sv:property&gt;
			
			
				<br>
				&lt;sv:property sv:name="myapp:text" sv:type="String"&gt;
			
			
				<br>
				&lt;sv:value&gt;An important feature...&lt;sv:value&gt;
			
			
				<br>
				&lt;/sv:property&gt;
			
			
				<br>
				&lt;/sv:node&gt;
			
			
				<br>
				&lt;/sv:node&gt;
			
			
				<br>
				&lt;/sv:node&gt;
			
			
				
					
						
							
								<p class="c5">
									<i><br>
									Note that in the above, the XML has been formatted for readability. The actual XML stream might not have any extraneous whitespace between elements or attributes.</i>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.4.2." id="section_6.4.2."></a> 6.4.2 Document View XML Mapping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The document view is designed to be more human-readable than the system view, though it achieves this at the expense of completeness.
								</p>
							
							
								<p class="c5">
									In level 1 the document view is used as the format for the virtual XML stream against which an XPath query is run (see <a href="#section_6.6.">6.6</a> <i>Searching Repository Content</i>). As well, in level 1, export to document view format is supported (see <a href="#section_6.5.">6.5</a> <i>Exporting Repository Content</i>). In level 2, document view also allows for the import of arbitrary XML (see <a href="#section_7.3.2.">7.3.2</a> <i>Import from Document View</i>).
								</p>
							
							
								<p class="c5">
									The document view mapping in fact consists of a family of related mappings whose precise features vary according to the context in which it is used (export, import or XPath query) and which optional features are supported by the particular implementation in question.
								</p>
							
							
								<p class="c5">
									The next section describes the general structure of the document view mapping and then moves on to explain the special cases, context-related differences and optional features. With respect to context-related differences, the description below addresses XPath and export. A discussion of document view in the context of import can be found in the above-mentioned section <a href="#section_7.3.2.">7.3.2</a> <i>Import from Document View</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.4.2.1." id="section_6.4.2.1."></a>6.4.2.1 General Structure
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Given a subtree of a workspace, the general form of the document view is determined as follows:
								</p>
							
						
					
				
			
		
		<ol>
			<li>
				<p class="c5">
					The relevant mappings from the repository namespace registry are rendered as a set of namespace declarations in the top-most XML element (though the <b>xml</b> namespace is excluded, since its presence would be redundant).
				</p>
			</li>
			<li>
				<p class="c5">
					Each content repository node <b>N</b> becomes an XML element of the same name, <b>N</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Each child node <b>C</b> of <b>N</b> becomes a subelement <b>C</b> of XML element <b>N</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The order of the subelements of element <b>N</b> must reflect the order in which the corresponding child nodes are returned by <b>Node.getNodes</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Each property <b>P</b> of node <b>N</b> becomes an XML attribute <b>P</b> of XML element <b>N</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The value of each property <b>P</b> is converted to string form according to the standard conversion (see <a href="#section_6.2.6.">6.2.6</a> <i>Property Type Conversion</i>) and becomes the value of the XML attribute <b>P</b>. Entity references are used to escape characters which should not be included as literals within attribute values (see <a href="#section_6.4.4.">6.4.4</a> <i>Escaping of Values</i>).
				</p>
			</li>
		</ol>
		
			
				
					
						
							
								<p class="c5">
									The following sections describe the exceptions to the above general rules.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.4.2.2." id="section_6.4.2.2."></a>6.4.2.2 Workspace Root
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If the root node of a workspace is included within the scope of the serialization, then that node is mapped to an XML element with the name <b>jcr:root</b>. This convention is required because XML elements cannot have empty-string names, whereas a workspace root node, by definition, has the empty string as its name.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.4.2.3." id="section_6.4.2.3."></a>6.4.2.3 XML Text
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In level 2, on document view import XML text is converted to the special node/property structure <b>jcr:xmltext/jcr:xmlcharacters</b> (see <a href="#section_7.3.2.">7.3.2</a> <i>Import from Document View</i>). When this structure is mapped back to XML the following rules apply.
								</p>
							
							
								<p class="c5">
									If a child node of <b>N</b> called <b>jcr:xmltext</b> is encountered and that <b>jcr:xmltext</b> node has one and only one child item and that item is a single-valued property called <b>jcr:xmlcharacters</b>, then the treatment of that <b>jcr:xmltext</b> depends on the context within which the document view is being used:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>Export</b>: In the context of export, the <b>jcr:xmltext</b> node is not converted into an XML element. Instead, the value of the <b>jcr:xmlcharacters</b> property becomes text within the body of the XML element <b>N</b>. Entity references are used to escape characters which should not be included as literals within XML text (see <a href="#section_6.4.4.">6.4.4</a> <i>Escaping of Values</i>) however, escaping of whitespace is not performed (see 6.4.2.5 Multi-value Properties). Note also that two or more <b>jcr:xmltext</b> nodes adjacent within the ordering of a child node set will have the values of their respective <b>jcr:xmlcharacters</b> concatenated into a single resulting XML text node.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>XPath</b>: In the context of an XPath query <b>jcr:xmltext</b> nodes and <b>jcr:xmlcharacters</b> properties are treated just like any other nodes and properties, appearing as elements and attributes, respectively, within the virtual document view stream against which XPath queries are run. See <a href="#section_6.6.4.12.">6.6.4.12</a> <i>text() Node Test</i> for more details.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.4.2.4." id="section_6.4.2.4."></a>6.4.2.4 Invalid Item Names
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If the name of a content repository item <b>I</b> is not a valid XML element or attribute name (as the case may be) then how it is handled depends upon the context in which the document view is being used:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>Export</b>: In the context of export, the repository may either ignore the item in question or employ the escaping scheme described below (see <a href="#section_6.4.3.">6.4.3</a> <i>Escaping Names</i>). Which approach taken is up to the implementation.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>XPath</b>: In the context of an XPath query, the escaping scheme described below (see <a href="#section_6.4.3.">6.4.3</a> <i>Escaping Names</i>) <i>must</i> be used in the virtual document view XML stream against which the query is run. Consequently, the same escaping scheme must be used within any XPath statement that refers to the item <b>I</b>.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.4.2.5." id="section_6.4.2.5."></a>6.4.2.5 Multi-value Properties
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If a multi-value property <b>P</b> is encountered, then its treatment depends on the context within which the document view is being used:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>Export</b>: In the context of export, the repository may either ignore the multi-value property or serialize it as an attribute whose value is an XML Schema list type<sup><a class="sdfootnoteanc" name="sdfootnote4anc" href="#sdfootnote4sym" id="sdfootnote4anc"><sup>4</sup></a></sup> (i.e., a whitespace-delimited list of strings). If the latter approach is taken then:
				</p>
				<ul>
					<li>
						<p class="c5">
							Each value in the property is converted to a string according to standard conversion, see <a href="#section_6.2.6.">6.2.6</a> <i>Property Type Conversion</i>. If the multi-value property contains no values, then it is serialized as an empty string.
						</p>
					</li>
					<li>
						<p class="c5">
							All literal whitespace within each string is escaped, as well as any characters that should not be included as literals in any case, see <a href="#section_6.4.4.">6.4.4</a> <i>Escaping of Values</i>.
						</p>
					</li>
					<li>
						<p class="c5">
							The final attribute value is constructed by concatenating the resulting strings, with the addition of the space delimiter, into a single string. The order of concatenation must be the same as the order in which the values appear in the <b>Value</b> array returned by <b>Property.getValues</b>.
						</p>
					</li>
					<li>
						<p class="c5">
							Furthermore, if multi-value property serialization is supported, then a mechanism must be adopted whereby upon re-import the distinction between multi- and single- value properties is not lost, see <a href="#section_6.4.4.">6.4.4</a> <i>Escaping of Values</i>.
						</p>
					</li>
					<li>
						<p class="c5">
							Note that this escaping of space literals does not apply to the value of <b>jcr:xmltext/jcr:xmlcharacters</b> when it is converted to XML text. In that case only the standard XML entity escaping is required, regardless of whether multi-value property serialization is supported (see 6.4.2.3 XML Text and <a href="#section_6.4.4.">6.4.4</a> <i>Escaping of Values</i>).
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					<b>XPath</b>: In the context of an XPath query, the value array of property <b>P</b> is mapped to a pseudo list type attribute value. We call it a <i>pseudo</i> list type because space delimiters are not used and consequently space literals within individual values are not escaped, nor are the five special characters (<b>&amp;</b>, <b>&lt;</b>, <b>&gt;</b> ,<b>'</b> and <b>"</b>) that would normally be escaped using predefined entity references. This is possible because the XML stream in the XPath context is virtual and therefore it need never be actually serialized. However, tests against multi-value properties in XPath <i>using general comparison</i> operators act as they would if the multi-value property <i>were</i> a list-type attribute, except that spaces and any of the five special characters occurring within value literals in the XPath statement are not escaped (see <a href="#section_6.6.4.10.">6.6.4.10</a> <i>Searching Multi-value Properties</i>).
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.4.2.6." id="section_6.4.2.6."></a>6.4.2.6 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Given the same subtree and namespace settings as used in the system view example (see <a href="#section_6.4.1.1.">6.4.1.1</a> <i>Example</i>), the document view would look like this (note that the following example assumes that multi-value property serialization is not supported and therefore escaping of space literals is not done (see <a href="#section_6.4.4.">6.4.4</a> <i>Escaping of Values</i>):
								</p>
							
						
					
				
			
			
				<br>
				&lt;?xml version="1.0" encoding="UTF-8"?&gt;
			
			
				<br>
				&lt;myapp:document xmlns:jcr="http://www.jcp.org/jcr/1.0"
			
			
				<br>
				xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
			
			
				<br>
				xmlns:mix="http://www.jcp.org/jcr/mix/1.0"<br>
				xmlns:myapp="http://mycorp.com/myapp"
			
			
				<br>
				xmlns:mynt="http://mycorp.com/mynt"
			
			
				<br>
				jcr:primaryType="mynt:document"&gt;
			
			
				<br>
				myapp:title="JSR 170"
			
			
				<br>
				myapp:lead="Content Repository"&gt;
			
			
				<br>
				&lt;myapp:body jcr:primaryType="mynt:body"&gt;
			
			
				<br>
				&lt;myapp:paragraph jcr:primaryType="mynt:paragraph"
			
			
				<br>
				myapp:title="Node Types"
			
			
				<br>
				myapp:text="An important feature..."/&gt;
			
			
				<br>
				&lt;/myapp:body&gt;
			
			
				<br>
				&lt;/myapp:document&gt;
			
			
				
					
						
							
								<p class="c5">
									<br>
									<i>Note that in the above, the XML has been formatted for readability. The actual XML stream might not have any extraneous whitespace between elements or attributes.</i>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.4.3." id="section_6.4.3."></a>6.4.3 Escaping of Names
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Not every item name is a valid XML name. In particular, even though a content repository prefix is always a valid XML prefix, the content repository local name (the part after the colon, or the whole name, if there is no prefix) may not be a valid XML name. For example, a content repository name may contain spaces, whereas XML names cannot.
								</p>
							
							
								<p class="c5">
									Consequently, for document view serialization, each content repository name is converted to a valid XML name (as defined by XML 1.0) by translating invalid characters into escaped numeric entity encodings<sup><a class="sdfootnoteanc" name="sdfootnote5anc" href="#sdfootnote5sym" id="sdfootnote5anc"><sup>5</sup></a></sup>.
								</p>
							
							
								<p class="c5">
									The escape character is the underscore (“_”). Any invalid character is escaped as <b>_x</b><b><i>HHHH</i></b><b>_</b>, where <b><i>HHHH</i></b> is the four-digit hexadecimal UTF-16 code for the character. When producing escape sequences the implementation should use lowercase letters for the hex digits <b>a</b>-<b>f</b>. When unescaping, however, both upper and lowercase alphabetic hexadecimal characters must be recognized.
								</p>
							
							
								<p class="c5">
									Escaping and unescaping is done by parsing the name from left to right.
								</p>
							
							
								<p class="c5">
									The underscore character (“_”), when appearing as literal, is itself escaped if it is followed by <b><i>xHHHH</i></b> where <b><i>H</i></b> is one of the following characters: <b>0123456789abcdefABCDEF</b>.
								</p>
							
							
								<p class="c5">
									So, for example,
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p>
					“<b>My Documents</b>” is converted to “<b>My_x0020_Documents</b>”,
				</p>
			</li>
			<li>
				<p>
					“<b>My_Documents</b>” is not encoded,
				</p>
			</li>
			<li>
				<p>
					“<b>My_x0020Documents</b>” is not encoded either,
				</p>
			</li>
			<li>
				<p class="c5">
					but “<b>My_x0020_Documents</b>” is encoded as “<b>My_x005f_x0020_Documents</b>”.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.4.4." id="section_6.4.4."></a>6.4.4 Escaping of Values
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a non-<b>BINARY</b> value is serialized during either system view or document view export, it is first converted to string form using standard value conversion, see <a href="#section_6.2.6.">6.2.6</a> <i>Property Type Conversion</i> (<b>BINARY</b> values are encoded using Base64).
								</p>
							
							
								<p class="c5">
									Within the resulting string, any occurrence of one of the five characters corresponding to the five <i>predefined entity references</i> in XML, ampersand (<b>&amp;</b>), less-than symbol (<b>&lt;</b>), greater-than symbol (<b>&gt;</b>), apostrophe (<b>'</b>), and quotation mark (<b>"</b>) must be escaped as <b>&amp;amp;</b>, <b>&amp;lt;</b>, <b>&amp;gt;</b>, <b>&amp;apos;</b> and <b>&amp;quot;</b>, respectively.
								</p>
							
							
								<p class="c5">
									In document view serialization, if the property being serialized is multi-valued (or if the implementation chooses to encode spaces in single value properties too, see below) then the value or values must be further encoded by escaping any occurrence of one of the four whitespace characters: space, tab, carriage return and line feed. The scheme used to encode these characters is the same as that described in <a href="#section_6.4.3.">6.4.3</a> <i>Escaping of Names</i>. Note that in this restricted context, applying those escaping rules amounts to the following: a space becomes <b>_x0020_</b>, a tab becomes <b>_x0009_</b>, a carriage return becomes <b>_x000D_</b>, a line feed becomes <b>_x000A_</b> and any underscore (<b>_</b>) that occurs as the first character of a sequence that could be misinterpreted as an escape sequence becomes <b>_x005f_</b>.
								</p>
							
							
								<p class="c5">
									Finally, in document view export, the value of the attribute representing a multi-value property is constructed by concatenating the results of the above escaping into a space-delimited list.
								</p>
							
							
								<p class="c5">
									In document view export (though not in system view), if multi-value property serialization is supported (see <a href="#section_6.4.2.5.">6.4.2.5</a> <i>Multi-value Properties</i>) then a mechanism must be adopted whereby upon re-import the distinction between multi- and single- value properties is not lost. One option is that escaping of space literals must be applied to the value of all single-value properties as well, Another option is that when an XML document is imported in document view, each attribute is assumed to be a single-value property unless out-of-band information defines it to be multi-valued (for example, if the applicable node type defines the property as multi-valued or the XML document is associated with a schema definition that indicates that the attribute is a list value).
								</p>
							
							
								<p class="c5">
									Note that the value of a <b>jcr:xmlcharacters</b> property used to represent XML text (see 6.4.2.3 XML Text) is not space-escaped, regardless of the prevailing multi-value property serialization policy.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.5." id="section_6.5."></a> 6.5 Exporting Repository Content
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Level 1 supports the export of repository content to both system view XML and document view XML. The XML can be output either in as a stream or as SAX events.
								</p>
							
							
								<p class="c5">
									The export methods are found in the <b>Session</b> object:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>exportSystemView(String absPath,<br>
										ContentHandler contentHandler,<br>
										boolean skipBinary,<br>
										boolean noRecurse)</b>
									</p>
									<p class="c5">
										Serializes the node (and if <b>noRecurse</b> is <b>false</b>, the whole subtree) at <b>absPath</b> into a series of SAX events by calling the methods of the supplied <b>org.xml.sax.ContentHandler</b>. The resulting XML is in the <i>system view</i> form. Note that <b>absPath</b> must be the path of a node, not a property.
									</p>
									<p class="c5">
										If <b>skipBinary</b> is <b>true</b> then any properties of <b>PropertyType.BINARY</b> will be serialized as if they are empty. That is, the existence of the property will be serialized, but its content will not appear in the serialized output (the <b>&lt;sv:value&gt;</b> element will have no content). Note that in the case of multi-value <b>BINARY</b> properties, the number of values in the property will be reflected in the serialized output, though they will all be empty. If <b>skipBinary</b> is <b>false</b> then the actual value(s) of each <b>BINARY</b> property is recorded using Base64 encoding.
									</p>
									<p class="c5">
										If <b>noRecurse</b> is <b>true</b> then only the node at <b>absPath</b> and its properties, but not its child nodes, are serialized. If <b>noRecurse</b> is <b>false</b> then the entire subtree rooted at <b>absPath</b> is serialized.
									</p>
									<p class="c5">
										If the user lacks read access to some subsection of the specified tree that section simply does not get serialized, since, from the user's point of view it is not there.
									</p>
									<p class="c5">
										The serialized output will reflect the state of the current workspace as modified by the state of this <b>Session</b>. This means that pending changes (regardless of whether they are valid according to node type constraints) and the current session-mapping of namespaces are reflected in the output.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if no node exists at <b>absPath</b>.
									</p>
									<p class="c5">
										A <b>SAXException</b> is thrown if an error occurs while feeding events to the <b>ContentHandler</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>exportSystemView(String absPath,<br>
										OutputStream out,<br>
										boolean skipBinary,<br>
										boolean noRecurse)</b>
									</p>
									<p class="c5">
										Serializes the node (and if <b>noRecurse</b> is <b>false</b>, the whole subtree) at <b>absPath</b> into an XML stream and outputs it through the supplied <b>OutputStream</b>. The resulting XML is in the <i>system view</i> form. Note that <b>absPath</b> must be the path of a node, not a property.
									</p>
									<p class="c5">
										If <b>skipBinary</b> is <b>true</b> then any properties of <b>PropertyType.BINARY</b> will be serialized as if they are empty. That is, the existence of the property will be serialized, but its content will not appear in the serialized output (the <b>&lt;sv:value&gt;</b> element will have no content). Note that in the case of multi-value <b>BINARY</b> properties, the number of values in the property will be reflected in the serialized output, though they will all be empty. If <b>skipBinary</b> is <b>false</b> then the actual value(s) of each <b>BINARY</b> property is recorded using Base64 encoding.
									</p>
									<p class="c5">
										If <b>noRecurse</b> is <b>true</b> then only the node at <b>absPath</b> and its properties, but not its child nodes, are serialized. If <b>noRecurse</b> is <b>false</b> then the entire subtree rooted at <b>absPath</b> is serialized.
									</p>
									<p class="c5">
										If the user lacks read access to some subsection of the specified tree that section simply does not get serialized, since, from the user's point of view it is not there.
									</p>
									<p class="c5">
										The serialized output will reflect the state of the current workspace as modified by the state of this <b>Session</b>. This means that pending changes (regardless of whether they are valid according to node type constraints) and the current session-mapping of namespaces are reflected in the output.
									</p>
									<p class="c5">
										The output XML will be encoded in UTF-8.
									</p>
									<p class="c5">
										An <b>IOException</b> is thrown if an I/O error occurs.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if no node exists at <b>absPath</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>exportDocumentView(String absPath,<br>
										ContentHandler contentHandler,<br>
										boolean skipBinary,<br>
										boolean noRecurse)</b>
									</p>
									<p class="c5">
										Serializes the node (and if <b>noRecurse</b> is <b>false</b>, the whole subtree) at <b>absPath</b> into a series of SAX events by calling the methods of the supplied <b>org.xml.sax.ContentHandler</b>. The resulting XML is in the <i>document view</i> form. Note that <b>absPath</b> must be the path of a node, not a property.
									</p>
									<p class="c5">
										If <b>skipBinary</b> is <b>true</b> then any properties of <b>PropertyType.BINARY</b> will be serialized as if they are empty. That is, the existence of the property will be serialized, but its content will not appear in the serialized output (the value of the attribute will be empty). If <b>skipBinary</b> is <b>false</b> then the actual value(s) of each <b>BINARY</b> property is recorded using Base64 encoding.
									</p>
									<p class="c5">
										If <b>noRecurse</b> is <b>true</b> then only the node at <b>absPath</b> and its properties, but not its child nodes, are serialized. If <b>noRecurse</b> is <b>false</b> then the entire subtree rooted at <b>absPath</b> is serialized.
									</p>
									<p class="c5">
										If the user lacks read access to some subsection of the specified tree that section simply does not get serialized, since, from the user's point of view it is not there.
									</p>
									<p class="c5">
										The serialized output will reflect the state of the current workspace as modified by the state of this <b>Session</b>. This means that pending changes (regardless of whether they are valid according to node type constraints) and the current session-mapping of namespaces are reflected in the output.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if no node exists at <b>absPath</b>.
									</p>
									<p class="c5">
										A <b>SAXException</b> is thrown if an error occurs while feeding events to the <b>ContentHandler</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>exportDocumentView(String absPath,<br>
										OutputStream out,<br>
										boolean skipBinary,<br>
										boolean noRecurse)</b>
									</p>
									<p class="c5">
										Serializes the node (and if <b>noRecurse</b> is <b>false</b>, the whole subtree) at <b>absPath</b> into an XML stream and outputs it through the supplied <b>OutputStream</b>. The resulting XML is in the <i>document view</i> form. Note that <b>absPath</b> must be the path of a node, not a property.
									</p>
									<p class="c5">
										If <b>skipBinary</b> is <b>true</b> then any properties of <b>PropertyType.BINARY</b> will be serialized as if they are empty. That is, the existence of the property will be serialized, but its content will not appear in the serialized output (the value of the attribute will be empty). If <b>skipBinary</b> is <b>false</b> then the actual value(s) of each <b>BINARY</b> property is recorded using Base64 encoding.
									</p>
									<p class="c5">
										If <b>noRecurse</b> is <b>true</b> then only the node at <b>absPath</b> and its properties, but not its child nodes, are serialized. If <b>noRecurse</b> is <b>false</b> then the entire subtree rooted at <b>absPath</b> is serialized.
									</p>
									<p class="c5">
										If the user lacks read access to some subsection of the specified tree that section simply does not get serialized, since, from the user's point of view it is not there.
									</p>
									<p class="c5">
										The serialized output will reflect the state of the current workspace as modified by the state of this <b>Session</b>. This means that pending changes (regardless of whether they are valid according to node type constraints) and the current session-mapping of namespaces are reflected in the output.
									</p>
									<p class="c5">
										The output XML will be encoded in UTF-8.
									</p>
									<p class="c5">
										An <b>IOException</b> is thrown if an I/O error occurs.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if no node exists at <b>absPath</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.5.1." id="section_6.5.1."></a>6.5.1 Encoding
		</h4>
		
			
				
					
						
							
								<p class="c5">
									XML streams produced by export must be encoded in UTF-8.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.6." id="section_6.6."></a> 6.6 Searching Repository Content
		</h3>
		
			
				
					
						
							
								<p class="c5">
									In level 1, support for the XPath syntax is required. Optionally, a repository may support the SQL syntax (see <a href="#section_8.5.">8.5</a> <i>Searching Repository Content with SQL</i>). Implementations may also support additional languages.
								</p>
							
							
								<p class="c5">
									XPath is a search language originally designed for selecting elements from an XML document. Since a workspace, like an XML document, can be viewed as a tree structure, XPath provides a convenient syntax for searching workspace content. The main prerequisite for providing XPath querying is to establish an XML mapping of the workspace tree. Having already established two such mappings (system and document view) for purposes of serialization and deserialization, we simply re-use one of them, the document view, as the basis against which an XPath query is run (see <a href="#section_6.4.2.">6.4.2</a> <i>Document View XML Mapping</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.1." id="section_6.6.1."></a> 6.6.1 XPath over Document View
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When an XPath query is executed, the XPath expression specified is applied to the document view of the workspace being searched.
								</p>
							
							
								<p class="c5">
									For example, consider a workspace with the following structure (based on the earlier example in Section <a href="#section_6.4.1.1.">6.4.1.1</a>, with the addition of a top-most root node):
								</p>
							
						
					
				
			
			
				<br>
				&lt;?xml version="1.0" encoding="UTF-8"?&gt;
			
			
				<br>
				&lt;jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
			
			
				<br>
				xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
			
			
				<br>
				xmlns:mix="http://www.jcp.org/jcr/mix/1.0"<br>
				xmlns:myapp="http://mycorp.com/myapp"
			
			
				<br>
				xmlns:mynt="http://mycorp.com/mynt"
			
			
				<br>
				jcr:primaryType="nt:unstructured"&gt;
			
			
				<br>
				&lt;myapp:document jcr:primaryType="mynt:document"&gt;
			
			
				<br>
				myapp:title="JSR 170"
			
			
				<br>
				myapp:lead="Content Repository"&gt;
			
			
				<br>
				&lt;myapp:body jcr:primaryType="mynt:body"&gt;
			
			
				<br>
				&lt;myapp:paragraph jcr:primaryType="mynt:paragraph"
			
			
				<br>
				myapp:title="Node Types"
			
			
				<br>
				myapp:text="An important feature..."/&gt;
			
			
				<br>
				&lt;/myapp:body&gt;
			
			
				<br>
				&lt;/myapp:document&gt;
			
			
				<br>
				&lt;/jcr:root&gt;
			
			
				
					
						
							
								<p class="c5">
									<br>
									<i>Note that in the above, the XML has been formatted for readability. The actual XML stream might not have any extraneous whitespace between elements or attributes.</i>
								</p>
							
							
								<p class="c5">
									In this case, to find the node called <b>myapp:paragraph</b>, the following XPath expression would be used:
								</p>
							
							
								<p class="c5">
									<b>//element(*, mynt:paragraph)[@myapp:title="Node Types"]</b>
								</p>
							
							
								<p class="c5">
									This query will return the node at the repository workspace path (as opposed to an XPath):
								</p>
							
							
								<p class="c5">
									<b>/myapp:document/myapp:body/myapp:paragraph</b>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.2." id="section_6.6.2."></a>6.6.2 XPath and SQL
		</h4>
		
			
				
					
						
							
								<p class="c5">
									XPath 2.0 forms the basis of the querying syntax in level 1. All compliant repository implementations must support this search syntax. However, implementations that use a relational database as an underlying datastore will typically be limited in the range of XPath queries that they can efficiently support. Such implementations will find support for the optional SQL syntax a more natural fit (see <a href="#section_8.5.">8.5</a> <i>Searching Repository Content with SQL</i>).
								</p>
							
							
								<p class="c5">
									Therefore, in order to ensure that database-backed implementations are not unnecessarily burdened by compliance requirements, only a subset of XPath is required. This subset is defined as the set of XPath statements that can be translated to and from SQL at parse-time of the query.
								</p>
							
							
								<p class="c5">
									This arrangement allows database-backed repositories to implement search natively with SQL but still comply with the minimal XPath requirement by translating XPath queries to SQL.
								</p>
							
							
								<p class="c5">
									On the other hand, implementations that are natively hierarchical and therefore capable of supporting XPath functionality beyond the minimum requirement are free to do so.
								</p>
							
							
								<p class="c5">
									As mentioned, support for SQL is optional. But because the minimal set of XPath features is driven by the semantic range of SQL, a knowledge of the mapping between the two aids greatly in understanding that minimal feature set XPath. The following sections summarize that mapping.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.3." id="section_6.6.3."></a>6.6.3 Structure of a Query
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A query, whether XPath or SQL, specifies a subset of nodes within a workspace, called the <i>result set</i>. The result set constitutes all the nodes in the workspace that meet the constraints stated in the query. The constraints fall into three categories:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<i>Type constraint</i>: This limits the returned nodes to a particular primary node type (and possibly, additionally limits the nodes to those with particular mixin node types).
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					<i>Property constraint</i>: This limits the returned nodes to those with particular properties having particular values.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					<i>Path constraint</i>: This limits the returned nodes to those within certain subtrees in the workspace.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									A query result is returned in two parallel forms: an iterator over the result set of nodes and a table where each row corresponds to a node in the result set. The query statement also defines aspects of how these two return objects are structured through two presentation specifiers:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<i>Column specifier</i>: This specifies the set of properties that will form the columns of the returned table.
				</p>
			</li>
			<li>
				<p class="c5">
					<i>Ordering specifier</i>: This defines the order of the nodes in the iterator and rows in the table.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									The following sections describe in more detail how each of these five elements are expressed, both in XPath and in SQL, and how these affect the content and presentation of the query result.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.3.1." id="section_6.6.3.1."></a>6.6.3.1 Column Specifier
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The column specifier of a query is the part of the statement that specifies which properties are to be returned as columns in the result table. Support is only required for single-value, non-residual properties that are declared in or inherited by the node types specified in the <i>type constraint</i>. It is optional to allow specification of residual properties as columns.
								</p>
							
							
								<p class="c5">
									If no column specifier is given, then at least the default set of columns will be returned. The default set is defined as all single-value, non-residual properties declared in or inherited by the node types specified in the type constraint. It is optional to return columns for residual properties.
								</p>
							
							
								<p class="c5">
									In both cases (an explicitly specified set of columns, or the default set) the pseudo-property <b>jcr:path</b> will always be returned as a column. <b>jcr:path</b> is a special column that does not correspond to any actual property, it holds the normalized absolute path for the node represented by each row (see 8.5.2.2 Pseudo-property jcr:path).
								</p>
							
							
								<p class="c5">
									As well, a score column will also be included, though it is not required that its contents always be meaningful. Note also that this column may be labeled simply <b>jcr:score</b> or it may be labeled with the signature and parameters of the <b>jcr:score(...)</b> function used in XPath. Additional score-related columns may be also returned by implementations that support multiple <b>jcr:score(...)</b> functions with varying parameters (see 8.5.2.4 Pseudo-property<i>,</i> 6.6.5.2 jcr:contains Function, and 8.5.4.5 CONTAINS).
								</p>
							
							
								<p class="c5">
									If columns are explicitly specified then the order in which they are specified in the query is the order in which they will appear in the table. If no columns are explicitly specified then the order in which they appear is implementation-specific.
								</p>
							
							
								<p class="c5">
									The <i>column specifier</i> has no effect on the content or form of the <b>NodeIterator</b> view of the query result.
								</p>
							
							
								<p class="c5">
									<b>XPath</b>: In XPath the mechanism of the column specifier is not specified, though one possible approach is to interpret as the column specifier the last location step when it uses the attribute axis; in other words, when content repository properties (XML attributes in document view) are selected in the last location step. If this approach is taken then, for example, multiple properties are selected with a union.
								</p>
							
							
								<p class="c5">
									Another possible approach is to define an XPath function that specifies the desired columns. This specification, however, does not attempt to define or limit the possible options.
								</p>
							
							
								<p class="c5">
									<b>SQL</b>: In SQL the column specifier is the <b>SELECT</b> clause. To select the default column set the <b>*</b> is used.
								</p>
							
							
								<p class="c5">
									Examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									
										
											
												
													
														
															<p class="c5">
																<b>SQL</b>
															</p>
														
													
												
											
										
									
								</td>
								<td>
									<p class="c5">
										<b>XPath</b> (one suggested approach)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM nt:base
									</p>
								</td>
								<td>
									<p class="c5">
										//*
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT my:title<br>
										FROM my:type
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)/@my:title
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT my:title, my:text<br>
										FROM my:type
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)/<br>
										(@my:title | @my:text)
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.3.2." id="section_6.6.3.2."></a>6.6.3.2 Type Constraint
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A type constraint specifies the common primary node type of the returned nodes, plus, possibly, additional mixin types that they also must have. Type constraints are inheritance-sensitive in that specifying a constraint of node type <b>X</b> will include all nodes explicitly declared to be type <b>X</b>, as well as all nodes of subtypes of <b>X</b>.
								</p>
							
							
								<p class="c5">
									Implementations are required to support constraints of one primary type. It is optional to support constraints based on multiple primary node types (this would, in any case, only be applicable to implementations that supported multiple inheritance of node types). It is also optional to support constraints on (one or more) mixin node types.
								</p>
							
							
								<p class="c5">
									Note however, that property constraints can always be used to test <i>declared</i> types (that is, a non-inheritance-sensitive test), by testing the values of the properties <b>jcr:primaryType</b> and <b>jcr:mixinType</b>.(see 6.6.3.3 Property Constraint).
								</p>
							
							
								<p class="c5">
									<b>XPath</b>: In XPath the <b>element</b> test is used to test against node type. It is optional to support <b>element</b> tests on location steps other than the last.
								</p>
							
							
								<p class="c5">
									<b>SQL</b>: In SQL the type constraint is expressed in the <b>FROM</b> clause.
								</p>
							
							
								<p class="c5">
									Examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									
										
											
												
													
														
															<p class="c5">
																<b>SQL</b>
															</p>
														
													
												
											
										
									
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path LIKE '/nodes[%]/%'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/nodes//<br>
										element(*, my:type)
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.3.3." id="section_6.6.3.3."></a>6.6.3.3 Property Constraint
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A query may specify further constraints on the result nodes by way of property constraints.
								</p>
							
							
								<p class="c5">
									<b>XPath</b>: In XPath a predicate that tests attributes on the last location step forms the property constraint expression. Predicates on any other location step are optional.
								</p>
							
							
								<p class="c5">
									<b>SQL</b>: In SQL the <b>WHERE</b> clause forms the constraint expression.
								</p>
							
							
								<p class="c5">
									Examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE my:title='JSR 170'
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)<br>
										[@my:title = 'JSR 170']
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									In order to ensure mutual translatability between XPath and SQL we only require support for the XPath general comparison operators (<b>=</b>, <b>!=</b>, <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>). In SQL the semantics of these operators must be the same as they are for XPath. The only difference is that in XPath the not-equal operator is <b>!=</b>, while in SQL it is <b>&lt;&gt;</b>.
								</p>
							
							
								<p class="c5">
									The term “general comparison” comes from XPath terminology. The significance of requiring support for XPath general comparison, and their equivalents in SQL, lies in the way that these operators behave with multi-value properties. See 6.6.4.10 Searching Multi-value Properties for details.
								</p>
							
							
								<p class="c5">
									Additionally, support for <b>jcr:like()</b> (<b>LIKE</b> in SQL) and <b>jcr:contains</b> (<b>CONTAINS</b> in SQL) is required (though the range of this requirement is qualified below).
								</p>
							
							
								<p class="c5">
									Since not all property types can be meaningfully compared using all operators the following describes the minimal set of comparison support required for each property type:
								</p>
							
							
								<p class="c5">
									<b>STRING</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>), <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>, <b>jcr:like()</b>(<b>LIKE</b>)
								</p>
							
							
								<p class="c5">
									<b>LONG</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>), <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>
								</p>
							
							
								<p class="c5">
									<b>DOUBLE</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>), <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>
								</p>
							
							
								<p class="c5">
									<b>DATE</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>), <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>
								</p>
							
							
								<p class="c5">
									<b>NAME</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>)
								</p>
							
							
								<p class="c5">
									<b>PATH</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>), (additionally, in SQL, <b>LIKE</b> is used against the <b>jcr:path</b> pseudo-property to define path constraints, see 6.6.3.4 Path Constraint)
								</p>
							
							
								<p class="c5">
									<b>REFERENCE</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>)
								</p>
							
							
								<p class="c5">
									<b>BOOLEAN</b>: <b>=</b>, <b>!=</b> (<b>&lt;&gt;</b>)
								</p>
							
							
								<p class="c5">
									<b>BINARY</b>: <i>(none)</i>
								</p>
							
							
								<p class="c5">
									The <b>jcr:like</b> function in XPath corresponds to the <b>LIKE</b> operator in SQL. See <a href="#section_6.6.5.1.">6.6.5.1</a> <i>jcr:like Function</i> and <a href="#section_8.5.4.4.">8.5.4.4</a> <i>LIKE</i>.
								</p>
							
							
								<p class="c5">
									Support for the <b>jcr:contains()</b> (<b>CONTAINS()</b> in SQL) function is not required for any property types in particular. It is however required to work <i>at the node level</i>. In that case it applies to those properties of the node for which the implementation maintains an index. Which properties those are is an implementation issue. See 6.6.5.2 jcr:contains Function and 8.5.4.5 CONTAINS.
								</p>
							
							
								<p class="c5">
									Support for comparing <b>jcr:score</b> in a SQL <b>WHERE</b> clause or <b>jcr:score(...)</b> in a XPath predicate is not required.
								</p>
							
							
								<p class="c5">
									In XPath support is only required for comparisons of the form <b>&lt;property&gt;&lt;op&gt;&lt;literalvalue&gt;</b> and <b>&lt;literalvalue&gt;&lt;op&gt;&lt;property&gt;</b>. For example, support for <b>[@p = "hello"]</b> and <b>["hello" = @p]</b> (and so forth for each operator) is required. Support for <b>[@p = @q]</b> (and so forth for each operator) is not required.
								</p>
							
							
								<p class="c5">
									Examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title = 'JSR 170'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title = 'JSR 170'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title &lt;&gt; 'JSR 170'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title != 'JSR 170'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title &lt; 'JSR 170'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title &lt; 'JSR 170'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title &lt;= 'JSR 170'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title &lt;= 'JSR 170'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title &gt; 'JSR 170'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title &gt; 'JSR 170'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title &gt;= 'JSR 170'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title &gt;= 'JSR 170'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title = 'JSR 170' AND my:author = 'David'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title = 'JSR 170' and @my:author = 'David'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title = 'JSR 170' OR<br>
										my:title = 'JSR-170'
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title = 'JSR 170' or<br>
										@my:title = 'JSR-170'
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										NOT (my:title = 'JSR 170')
									</p>
								</td>
								<td>
									<p class="c5">
										not(@my:title &gt;= 'JSR 170')
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title IS NOT NULL
									</p>
								</td>
								<td>
									<p class="c5">
										@my:title
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title IS NULL
									</p>
								</td>
								<td>
									<p class="c5">
										not(@my:title)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										my:title LIKE 'JSR 170%'
									</p>
								</td>
								<td>
									<p class="c5">
										jcr:like(@my:title,<br>
										'JSR 170%')
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										CONTAINS(*, 'JSR 170')
									</p>
								</td>
								<td>
									<p class="c5">
										jcr:contains(., 'JSR 170')
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.3.4." id="section_6.6.3.4."></a>6.6.3.4 Path Constraint
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The path constraint restricts the result node to a scope specified by a path expression. The following path constraints must be supported:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Exact
				</p>
			</li>
			<li>
				<p class="c5">
					Child nodes
				</p>
			</li>
			<li>
				<p class="c5">
					Descendants
				</p>
			</li>
			<li>
				<p>
					Descendants or self<br><br>
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									<b>XPath</b>: In XPath the location steps specify the path constraint.
								</p>
							
							
								<p class="c5">
									<b>SQL</b>: In SQL the path constraint occurs as an ANDed test within the WHERE clause of the pseudo-property <b>jcr:path</b> using either the = operator or the LIKE operator.
								</p>
							
							
								<p class="c5">
									<i>Exact</i> path constraint examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path LIKE '/some[%]/nodes[%]'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some/<br>
										element(nodes, my:type)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path = '/some/nodes'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some[1]/element(nodes, my:type)[1]
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									<i>Child nodes</i> path constraint examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path LIKE '/some[%]/nodes[%]/%' AND NOT jcr:path LIKE '/some[%]/nodes[%]/%/%'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some/nodes/<br>
										element(*, my:type)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path LIKE '/some/nodes/%'<br>
										AND NOT jcr:path LIKE '/some/nodes/%/%'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some[1]/nodes[1]/<br>
										element(*, my:type)
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									<i>Descendants</i> path constraint examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path LIKE '/some[%]/nodes[%]/%'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some/nodes//<br>
										element(*, my:type)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path LIKE '/some/nodes/%'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some[1]/nodes[1]//<br>
										element(*, my:type)
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									<i>Descendants or self</i> path constraint examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path LIKE '/some[%]/nodes[%]' OR jcr:path LIKE '/some[%]/nodes[%]/%'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some/nodes//<br>
										element(*, my:type)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE jcr:path = '/some/nodes' OR jcr:path LIKE '/some/nodes/%'
									</p>
								</td>
								<td>
									<p class="c5">
										/jcr:root/some[1]/nodes[1]//<br>
										element(*, my:type)
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.3.5." id="section_6.6.3.5."></a>6.6.3.5 Ordering Specifier
		</h4>
		
			
				
					
						
							
								<p class="c5">
									This part of the query statement specifies the ordering of the result nodes according to the natural ordering of the values of one or more properties of the result nodes. If no order specification is supplied in the query statement, implementations may support document order on the result nodes (see 6.6.4.2 Document Order).
								</p>
							
							
								<p class="c5">
									In both XPath and SQL, ordering is specified by a special clause that lists one or more property names and, for each, whether the order is to be ascending or descending. If neither ascending nor descending is specified after a property name (or <b>jcr:score(...)</b> function), the default is ascending.
								</p>
							
							
								<p class="c5">
									Implementations must support ordering on <b>jcr:score</b> (in SQL just the name is used, see 8.5.2.4 Pseudo-property) or <b>jcr:score(...)</b> (in XPath, the function form is used, though the number of parameters depends on the implementation, see 6.6.5.3 jcr:score function).
								</p>
							
							
								<p class="c5">
									Support for ordering on <b>PATH</b> and <b>NAME</b> properties is not required. If it is supported then the collation sequence for these types is implementation specific.
								</p>
							
							
								<p class="c5">
									<b>XPath</b>: A subset of the order by clause specified in XQuery 1.0 is used to implement the order specification in XPath. If the order modifier (<b>ascending</b> or <b>descending</b>) is missing, the ordering defaults to <b>ascending</b>. See 6.6.5.5 order by Clause.
								</p>
							
							
								<p class="c5">
									<b>SQL</b>:The order by clause implements the order specification in SQL. If the order modifier (<b>ASC</b> meaning ascending or <b>DESC</b>, meaning descending) is missing, the ordering defaults to <b>ASC</b>. See 8.5.4.6 ORDER BY.
								</p>
							
							
								<p class="c5">
									Examples:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPath</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										ORDER BY my:title
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)<br>
										order by @my:title
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										ORDER BY my:date DESC, my:title ASC
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)<br>
										order by @my:date descending, @my:title ascending
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										SELECT *<br>
										FROM my:type<br>
										WHERE<br>
										CONTAINS(*, 'jcr') ORDER BY jcr:score DESC
									</p>
								</td>
								<td>
									<p class="c5">
										//element(*, my:type)<br>
										[jcr:contains(., 'jcr')]<br>
										order by jcr:score() descending
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<p>
			<br>
			<br>
		</p>
		<h4>
			<a name="section_6.6.4." id="section_6.6.4."></a> 6.6.4 Adapting XPath to the Content Repository
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following presents a feature-by-feature discussion of the minimal requirements. As well, some of the more common possible extensions are mentioned. For those common extensions, a discovery mechanism is provided in the form of additional descriptor keys whose value (“<b>true</b>” or “<b>false</b>”) indicates whether the feature in question is supported (see <a href="#section_6.1.1.1.">6.1.1.1</a> <i>Repository Descriptors</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.1." id="section_6.6.4.1."></a>6.6.4.1 Same-Name Siblings
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The syntax used to address same-name sibling nodes in a workspace path is purposely similar to the XPath abbreviated syntax for addressing sibling XML elements with the same name, i.e., the "square bracket index notation" where the first sibling is indicated by <b>[1]</b> (not <b>[0]</b>) the second by <b>[2]</b> and so forth.
								</p>
							
							
								<p class="c5">
									However, because some implementations (those built on an underlying relational model, for example) may find it difficult to support querying on the basis of node position, this feature is optional. <b>Repository.getDescriptor(</b><b>QUERY_XPATH_POS_INDEX</b><b>)</b> returning “<b>true</b>” indicates that the index position notation for same-name siblings is supported for XPath query.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.2." id="section_6.6.4.2."></a>6.6.4.2 Document Order
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The results returned by an XPath query <i>may</i> reflect the document order of the elements returned if no <b>order by</b> clause is specified (see 6.6.3.5 Ordering Specifier, above).
								</p>
							
							
								<p class="c5">
									Support for this is optional, since some implementations (notably, database-backed ones) will not have a notion of document order.
								</p>
							
							
								<p class="c5">
									If document order searching is supported, then the context functions related to document order, <b>last()</b> and <b>position()</b>, must also be supported.
								</p>
							
							
								<p class="c5">
									<b>Repository.getDescriptor(</b><b>QUERY_XPATH_DOC_ORDER</b><b>)</b> returning “<b>true</b>” indicates that document order searching is supported.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.3." id="section_6.6.4.3."></a>6.6.4.3 Context Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The context node of an XPath query is the XML node relative to which the query expression is evaluated.
								</p>
							
							
								<p class="c5">
									A relative XPath statement (one that does not have a leading <b>/</b>) will be interpreted relative to the root node of the workspace, which, in the XML document view is the top-most XML element, <b>&lt;jcr:root&gt;</b>. This means that one should not include <b>jcr:root</b> as the first segment in a relative XPath statement, since that element is already the default context node.
								</p>
							
							
								<p class="c5">
									An absolute XPath (one with a leading <b>/</b>), in contrast, will be interpreted relative to a position one level above <b>&lt;jcr:root&gt;</b>. This means that an absolute XPath must either begin with <b>//</b> or with <b>/jcr:root</b> in order to match anything at all.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.4." id="section_6.6.4.4."></a>6.6.4.4 Mapping Property Types to XML Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following table outlines the mapping between property types to XML Schema types.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c19">
										<b>Property Type</b>
									</p>
								</td>
								<td>
									<p class="c19">
										<b>XML Schema Type</b>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p class="c5">
										String
									</p>
								</td>
								<td valign="top">
									<p class="c5">
										xs:string
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Binary
									</p>
								</td>
								<td>
									<p class="c5">
										xs:base64Binary
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Double
									</p>
								</td>
								<td>
									<p class="c5">
										xs:double
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Long
									</p>
								</td>
								<td>
									<p class="c5">
										xs:long
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Boolean
									</p>
								</td>
								<td>
									<p class="c5">
										xs:boolean
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Date
									</p>
								</td>
								<td>
									<p class="c5">
										xs:dateTime
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Path
									</p>
								</td>
								<td>
									<p class="c5">
										xs:string
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Name
									</p>
								</td>
								<td>
									<p class="c5">
										xs:string
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										Reference
									</p>
								</td>
								<td>
									<p class="c5">
										xs:IDREF
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.4.5." id="section_6.6.4.5."></a>6.6.4.5 Abbreviated Syntax
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Only support for the abbreviated syntax of XPath is required.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.6." id="section_6.6.4.6."></a>6.6.4.6 Axes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									As part of a location path, the only axes for which support is required are:
								</p>
								
									
										<p class="c5">
											<b>child</b> (in abbreviated syntax this is the default axis, represented simply by <b>/</b>, the location path separator).
										</p>
									
									
										<p class="c5">
											<b>descendant-or-self</b> (abbreviated syntax: <b>//</b>).
										</p>
									
									
										<p class="c5">
											<b>attribute</b> (abbreviated syntax: <b>@</b>).
										</p>
									
								
							
							
								<p class="c5">
									Support for the other axes is not required.
								</p>
							
							
								<p class="c5">
									See 6.6.3.3 Property Constraint and 6.6.3.4 Path Constraint, above.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.7." id="section_6.6.4.7."></a>6.6.4.7 Predicates
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Support for predicates in the last step of the location path is required. For example, the following query would be supported:
								</p>
							
							
								<p class="c5">
									Find all employees who have a secretary and an assistant property:<br>
									<b>//element(*, employee)[@secretary and @assistant]</b>
								</p>
							
							
								<p class="c5">
									See 6.6.3.3 Property Constraint, above.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.8." id="section_6.6.4.8."></a>6.6.4.8 Boolean Functions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The boolean functions <b>not()</b>, <b>true()</b> and <b>false()</b> are required.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.9." id="section_6.6.4.9."></a>6.6.4.9 Escaping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The names of elements and attributes (corresponding to nodes and properties, respectively) within an XPath statement must correspond to the form in which they (notionally) appear in the document view. This means that spaces (and any other non-XML characters) within names must be encoded according to the rules described in <a href="#section_6.4.3.">6.4.3</a> <i>Escaping of Names</i>.
								</p>
							
							
								<p class="c5">
									The values of attributes, on the other hand, are not escaped in the XPath usage of document view (as opposed to the export usage, see 6.4.2.5 Multi-value Properties<i>,</i> 6.4.4 Escaping of Values and <i>6.6.4.10</i> Searching Multi-value Properties). As a result, string literals in XPath predicates that test those attribute values are not escaped either. They may contain whitespace as well as the characters ampersand (<b>&amp;</b>), less-than (<b>&lt;</b>), greater-than (<b>&gt;</b>), quotation mark (") and apostrophe (<b>'</b>). In XPath the entity references that would be used within an XML document (<b>&amp;lt;</b>, <b>&amp;gt;</b> etc..) are not used. However, the apostrophe (<b>'</b>) and quotation mark(<b>"</b>) must be escaped according to the standard rules of XPath with regard to string literals: If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.<sup><a class="sdfootnoteanc" name="sdfootnote6anc" href="#sdfootnote6sym" id="sdfootnote6anc"><sup>6</sup></a></sup>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.10." id="section_6.6.4.10."></a>6.6.4.10 Searching Multi-value Properties
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Searching of multi-value properties with XPath is supported by mapping multi-value properties to XML attributes of the <i>list type</i> and employing the XPath feature of <i>general comparisons</i>.
								</p>
							
							
								<p class="c5">
									XML Schema supports attributes having types. Among those is one called the list type<sup><a class="sdfootnoteanc" name="sdfootnote7anc" href="#sdfootnote7sym" id="sdfootnote7anc"><sup>7</sup></a></sup>. This type specifies that white space within an attribute value serves as the delimiter between individual list items.
								</p>
							
							
								<p class="c5">
									Additionally, XPath distinguishes between two types of comparison operators: general comparisons (<b>=</b>, <b>!=</b>, <b>&lt;</b>, <b>&gt;</b>, <b>&lt;=</b> and <b>&gt;=</b>) and value comparisons (<b>eq</b>, <b>ne</b>, <b>lt</b>, <b>le</b>, <b>gt</b>, and <b>ge</b>). General comparisons, when applied to a list type attribute value, will return <b>true</b> if the specified relation (equal, not equal, greater-than, etc.) evaluates to <b>true</b> for <i>at least one</i> of the values of in the list. Value comparisons test the entire attribute value as a single unit. In cases where an attribute only has one value, the general and value comparisons are identical.
								</p>
							
							
								<p class="c5">
									In the virtual XML document against which XPath queries are run, multi-value properties will be mapped to XML attributes with values in a form <i>similar</i> to the XML list type.
								</p>
							
							
								<p class="c5">
									However, since the XML document is virtual, it need never be actually serialized. As a result, we do not need to specify white space as the delimiter. Doing so would require that white space that occurs within a value of a multi-value property be escaped when converted to document view, which would in turn require use of awkward escaping characters within XPath queries that tested for such values.
								</p>
							
							
								<p class="c5">
									Instead, we simply specify that tests against multi-value properties <i>using general comparison</i> operators act as they would if the multi-value property <i>were</i> a list type attribute, except that spaces within individual values used within the test are not escaped. For example:<br>
									<br>
									<b>/x/y[@p = 'hello']<br>
									<br></b> would return all nodes with path <b>/x/y</b> that have a property <b>p</b> which has <i>at least one</i> value <b>"hello"</b>.
								</p>
							
							
								<p class="c5">
									Note that multi-value properties in document view will be handled differently for purposes of export (see <a href="#section_6.4.2.">6.4.2</a> <i>Document View XML Mapping)</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.11." id="section_6.6.4.11."></a>6.6.4.11 Comparison Operators
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In XPath only support for the general comparison operators (<b>=</b>, <b>!=</b>, <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>) is required. See 6.6.3.3 Property Constraint, above.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.12." id="section_6.6.4.12."></a>6.6.4.12 <i>text()</i> Node Test
		</h4>
		
			
				
					
						
							
								<p class="c5">
									As discussed in <a href="#section_7.3.2.">7.3.2</a> <i>Import from Document View</i> and <a href="#section_6.4.2.3.">6.4.2.3</a> <i>XML Text</i>, document view import converts XML text nodes into the special structure <b>jcr:xmltext/jcr:xmlcharacters</b>, importing the actual text into the value of the <b>jcr:xmlcharacters</b> property.
								</p>
							
							
								<p class="c5">
									In the virtual XML document against which XPath is run, this structure appears as an element and attribute. For example:
								</p>
							
							
								<p class="c5">
									<b>&lt;limerick&gt;<br>
									&lt;jcr:xmltext jcr:xmlcharacters="There once was a..."/&gt;<br>
									&lt;/limerick&gt;</b>
								</p>
							
							
								<p class="c5">
									However, as a convenience, the XPath <b>text()</b> node test <i>may</i> be supported in such a way as to make the text also simultaneously visible to XPath in its original form, as an XML text node:
								</p>
							
							
								<p class="c5">
									<b>&lt;limerick&gt;There once was a...&lt;/limerick&gt;</b>
								</p>
							
							
								<p class="c5">
									If the <b>text()</b> node test is supported, the result is simply that <b>text()</b> becomes equivalent to <b>jcr:xmltext</b> as a node test within an XPath statement. For example, the XPaths <b>/jcr:root/limerick/jcr:xmltext</b> and <b>/jcr:root limerick/text()</b> would be equivalent.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.4.13." id="section_6.6.4.13."></a>6.6.4.13 <i>element()</i> Node Test
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>element()</b> node test defined in XPath 2.0 is used to select nodes of a particular primary node type. For example:
								</p>
							
							
								<p class="c5">
									<b>//element(*, nt:file)</b>
								</p>
							
							
								<p class="c5">
									would select all nodes of primary node type <b>nt:file</b>. This includes all node of subtypes of <b>nt:file</b> as well.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.5." id="section_6.6.5."></a>6.6.5 XPath Extensions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									XPath in content repositories also defines a small number of functions and one syntactic addition (the order-by clause). Content repository-related functions are prefixed with <b>jcr:</b>.
								</p>
							
							
								<p class="c5">
									Note that the function signatures below are expressed in XPath terminology. In particular, the reference to the type <i>element()</i> means an XML element, which corresponds to a repository node. Similarly, the type <i>attribute()</i> refers to an XML attribute, which corresponds to a repository property and <i>node()</i> refers to an XML node which corresponds to a repository item (that is, a repository node or property).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.5.1." id="section_6.6.5.1."></a>6.6.5.1 jcr:like Function
		</h4>
		
			
				
					
						
							
								<p class="c5">
									This function is based on the <b>LIKE</b> predicate found in SQL. Support for this function is required, as described in 6.6.3.3 Property Constraint.
								</p>
							
							
								<p class="c5">
									<b>jcr:like(</b><i>$property as attribute(),<br>
									$pattern as xs:string</i><b>)</b> <i>as xs:boolean</i>
								</p>
							
							
								<p class="c5">
									For example, the query “Find all <b>para</b>s in <b>document</b> whose title property includes the substring ‘Java’ ”, is expressed as:
								</p>
							
							
								<p class="c5">
									<b>/jcr:root/document/para[jcr:like(@title,'%Java%')]</b>
								</p>
							
							
								<p class="c5">
									As in SQL, the character ‘%’ represents any string of zero or more characters, and the character ‘_’ (underscore) represents any single character. Any literal use of these two characters must be escaped with a backslash (“<b>\</b>”). Consequently, any literal instance of a backslash must also be escaped, resulting in a double backslash (“<b>\\</b>”).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.5.2." id="section_6.6.5.2."></a>6.6.5.2 jcr:contains Function
		</h4>
		
			
				
					
						
							
								<p class="c5">
									<b>jcr:contains(</b><i>$scope as node()</i><b>,<br></b> <i>$exp as xs:string</i><b>)</b> <i>as xs:boolean</i>
								</p>
							
							
								<p class="c5">
									This function is used to embed a statement in a full-text search language. It is functionally equivalent to the SQL CONTAINS function (for level 2 implementations) described in <a href="#section_8.5.4.5.">8.5.4.5</a> <i>CONTAINS.</i>
								</p>
							
							
								<p class="c5">
									The first parameter defines the scope of the contains predicate. It can be either “<b>.</b>” (meaning this node, i.e., the node-set defined by the current location step) or it can be an XML attribute name (and therefore a content repository property), for example <b>@my:property</b>, specifying a particular property of the node-set defined by the current location step). If the scope is “<b>.</b>” then all properties of the current node set for which the implementation maintains an index are searched. If a specific property is specified then only the value of that property is searched (if the property is not indexed then the function will return false).
								</p>
							
							
								<p class="c5">
									As described in 6.6.3.3 Property Constraint, support for the <b>jcr:contains()</b> function is required to work <i>at the node level</i> in those repositories which support full text searching. In other words only support for “<b>.</b>” is required. Support for property specific full-text search is optional.
								</p>
							
							
								<p class="c5">
									The EBNF for the second parameter is:
								</p>
							
							
								<p class="c12">
									searchexp ::= [-]term {whitespace [OR]<br>
									whitespace [-]term}
								</p>
							
							
								<p class="c12">
									term ::= word | '"' word {whitespace word} '"'
								</p>
							
							
								<p class="c12">
									word ::= <i>/* A string containing no whitespace */</i>
								</p>
							
							
								<p class="c12">
									whitespace ::= <i>/* A string of only whitespace*/</i>
								</p>
							
							
								<p class="c5">
									<br>
									At minimum, all implementations must support the <i>simple search-engine syntax</i> defined by <i>exp</i> in the EBNF above. This syntax is based on the syntax of search engines like Google.
								</p>
							
							
								<p class="c5">
									The semantics of the simple search expression are as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Terms separated by whitespace are implicitly <b>AND</b>ed together.
				</p>
			</li>
			<li>
				<p class="c5">
					Terms may also be <b>OR</b>ed with explicit use of the <b>OR</b> keyword.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>AND</b> has higher precedence than <b>OR</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Terms may be excluded by prefixing with a <b>–</b> (minus sign) character. This means that the result set <i>must not</i> contain the excluded term.
				</p>
			</li>
			<li>
				<p class="c5">
					A term may be either a single word or a phrase delimited by double quotes (<b>"</b>).
				</p>
			</li>
			<li>
				<p class="c5">
					The entire text search expression (<b>searchexp</b> in the EBNF, above) <i>must be</i> delimited by single quotes (<b>'</b>).
				</p>
			</li>
			<li>
				<p class="c5">
					Within the <b>searchexp</b> literal instances of single quote (“<b>'</b>”), double quote (“<b>"</b>”) and hyphen (“<b>-</b>”) must be escaped with a backslash (“<b>\</b>”). Backslash itself must therefore also be escaped, ending up as double backslash (“<b>\\</b>”).
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									For example, the query “Find all nodes with some property that contains the text ‘JSR 170’ ” is expressed as:
								</p>
							
							
								<p class="c12">
									<b>//*[jcr:contains(., 'JSR 170')]</b>
								</p>
							
							
								<p class="c5">
									the optionally supported query “Find all nodes with a property called <b>myapp:title</b> that contain the text ‘JSR 170’ ” is expressed as:
								</p>
							
							
								<p class="c12">
									<b>//*[jcr:contains(@myapp:title, 'JSR 170')]</b>
								</p>
							
							
								<p class="c5">
									The relevance score for each node may be returned in (one or more) score columns (<b>jcr:score</b> or <b>jcr:score(...)</b>) however the details of how the score is calculated are implementation-specific (see 8.5.2.4 Pseudo-property<i>,</i> 6.6.5.2 jcr:contains Function and 8.5.4.5 CONTAINS).
								</p>
							
							
								<p class="c5">
									An implementation may choose to support other embedded full-text search languages other than the simple search engine style shown here.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.5.3." id="section_6.6.5.3."></a>6.6.5.3 jcr:score function
		</h4>
		
			
				
					
						
							
								<p class="c5">
									<b>jcr:score(...)</b> <i>as xs:decimal</i>
								</p>
							
							
								<p class="c5">
									As described in 6.6.3.1 Column Specifier, a score value is returned for each row the result table. However, how this value is calculated is left up to the implementation. It is not required that its contents always be meaningful.
								</p>
							
							
								<p class="c5">
									The XPath function <b>jcr:score(...)</b> is provided to enable queries to specify score calculation parameters in those implementations that support it.
								</p>
							
							
								<p class="c5">
									The <b>jcr:score(...)</b> function must therefore be supported, but the number and meaning of its parameters is left up to the implementation. The <b>jcr:score(...)</b> function can be used in either the columns specifier of the query, or the order specifier. It is also possible (though not required) that implementations support multiple <b>jcr:score(...)</b> functions within a single query.
								</p>
							
							
								<p class="c5">
									The column within which the score information is returned may be labeled simply <b>jcr:score</b> or it may be labeled with the signature and parameters of the <b>jcr:score(...)</b> function used. Additional score-related columns may be also returned by implementations that support multiple <b>jcr:score(...)</b> functions with varying parameters (see 8.5.2.4 Pseudo-property<i>,</i> 6.6.5.2 jcr:contains Function, and 8.5.4.5 CONTAINS).
								</p>
							
							
								<p class="c5">
									Support for comparing <b>jcr:score(...)</b> in a predicate is not required.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.5.4." id="section_6.6.5.4."></a>6.6.5.4 jcr:deref Function
		</h4>
		
			
				
					
						
							
								<p class="c5">
									This function is used follow a <b>REFERENCE</b> property into the target reference. Support for this function is optional.
								</p>
							
							
								<p class="c5">
									<b>jcr:deref(</b><i>$source as attribute()</i>,<br> <i>$node-test as xs:string</i><b>)</b> <i>as element()*</i>
								</p>
							
							
								<p class="c5">
									The first argument is an XML attribute that represents a <b>REFERENCE</b> property.
								</p>
							
							
								<p class="c5">
									The second argument is a node test which is a string to match the target node name. The function returns a node sequence of all target nodes matching the node-test. An error is raised if the reference cannot be resolved.
								</p>
							
							
								<p class="c5">
									For example, suppose there is a property of type <b>REFERENCE</b> called <b>myapp:author</b> which refers to a node representing the author of this document. A query expression to find the person’s last name property would be:
								</p>
							
							
								<p class="c5">
									<b>/jcr:root/myapp:myDoc/<br>
									jcr:deref(@myapp:author, 'myapp:person')/address</b>
								</p>
							
							
								<p class="c5">
									The dereference expression above evaluates to one or more nodes which has the name <b>myapp:person</b>. Subsequently a child node of each, representing the person’s address, is selected.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.5.5." id="section_6.6.5.5."></a>6.6.5.5 order by Clause
		</h4>
		
			
				
					
						
							
								<p class="c5">
									As described in 6.6.3.5 Ordering Specifier, it may be desirable to sort the result of an XPath query into either ascending or descending order based on the value of a property. This is done by adding the order by clause to a location path expression. The additions to the syntax of the XPath location clause are as follows:
								</p>
							
						
					
				
			
			
				<table border="0" cellpadding="7" cellspacing="0">
					
					
					
					<tr valign="top">
						<td>
							<p class="c12">
								JCRXPathExpr
							</p>
						</td>
						<td>
							<p class="c12">
								::=
							</p>
						</td>
						<td>
							<p class="c5">
								(XPath OrderByClause?)?
							</p>
						</td>
					</tr>
					<tr valign="top">
						<td>
							<p class="c12">
								OrderByClause
							</p>
						</td>
						<td>
							<p class="c12">
								::=
							</p>
						</td>
						<td>
							<p class="c5">
								"order by" OrderSpecList
							</p>
						</td>
					</tr>
					<tr valign="top">
						<td>
							<p class="c12">
								OrderSpecList
							</p>
						</td>
						<td>
							<p class="c12">
								::=
							</p>
						</td>
						<td>
							<p class="c5">
								OrderSpec ("," OrderSpec)*
							</p>
						</td>
					</tr>
					<tr valign="top">
						<td>
							<p class="c12">
								OrderSpec
							</p>
						</td>
						<td>
							<p class="c12">
								::=
							</p>
						</td>
						<td>
							<p class="c5">
								("@" AttributeName OrderModifier) |<br>
								(ScoreFunction OrderModifer)
							</p>
						</td>
					</tr>
					<tr valign="top">
						<td>
							<p class="c12">
								OrderModifier
							</p>
						</td>
						<td>
							<p class="c12">
								::=
							</p>
						</td>
						<td>
							<p class="c5">
								("ascending" | "descending")?
							</p>
						</td>
					</tr>
					<tr valign="top">
						<td>
							<p class="c5">
								ScoreFunction
							</p>
						</td>
						<td>
							<p class="c12">
								::=
							</p>
						</td>
						<td>
							<p class="c5">
								"jcr:score(" ParamList ")"
							</p>
						</td>
					</tr>
					<tr valign="top">
						<td>
							<p class="c12">
								ParamList
							</p>
						</td>
						<td>
							<p class="c12">
								::=
							</p>
						</td>
						<td>
							<p class="c5">
								<i>/* zero or more comma separated parameters */</i>
							</p>
						</td>
					</tr>
				</table>
				
					
						
							
								<p class="c5">
									<br>
									For example, the query to find all nodes of type <b>car</b> where the <b>color</b> is “<b>green</b>” and sort them by price in ascending order, the following query might be used:
								</p>
							
							
								<p class="c5">
									<b>//element(*, car)[@brand='green'] order by @price ascending</b>
								</p>
							
							
								<p class="c5">
									Note that if neither <b>ascending</b> nor <b>descending</b> are explicitly specified the default behavior is <b>ascending</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.6." id="section_6.6.6."></a>6.6.6 XPath Grammar
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following grammar defines the required subset of XPath. Text in Courier New indicates parts of standard XPath 2.0 that are required. Text in <strike>Courier New strikethrough</strike> indicates parts of standard XPath 2.0 that are not required.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.6.1." id="section_6.6.6.1."></a>6.6.6.1 Named Terminals
		</h4>
		<table border="0" cellpadding="1" cellspacing="0">
			
			
			
			
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ExprComment" id="prod-xpath-ExprComment"></a>[1]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ExprComment
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						"(:" (ExprCommentContent | ExprComment)* ":)"
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ExprCommentContent" id="prod-xpath-ExprCommentContent"></a>[2]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ExprCommentContent
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Char
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-IntegerLiteral" id="prod-xpath-IntegerLiteral"></a>[3]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						IntegerLiteral
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Digits
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-DecimalLiteral" id="prod-xpath-DecimalLiteral"></a>[4]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						DecimalLiteral
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						("." Digits) | (Digits "." [0-9]*)
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-DoubleLiteral" id="prod-xpath-DoubleLiteral"></a>[5]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						DoubleLiteral
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						(("." Digits) | (Digits ("." [0-9]*)?)) ("e" | "E") ("+" | "-")? Digits
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-StringLiteral" id="prod-xpath-StringLiteral"></a>[6]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						StringLiteral
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						('"' (('"' '"') | [^"])* '"') | ("'" (("'" "'") | [^'])* "'")
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-SchemaGlobalTypeName" id="prod-xpath-SchemaGlobalTypeName"></a>[7]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>SchemaGlobalTypeName</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>"type" "(" QName ")"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-SchemaGlobalContext" id="prod-xpath-SchemaGlobalContext"></a>[8]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>SchemaGlobalContext</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>QName | SchemaGlobalTypeName</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-SchemaContextStep" id="prod-xpath-SchemaContextStep"></a>[9]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>SchemaContextStep</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>QName</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-Digits" id="prod-xpath-Digits"></a>[10]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Digits
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						[0-9]+
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-NCName" id="prod-xpath-NCName"></a>[11]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						NCName
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						[http://www.w3.org/TR/REC-xml-names/#NT-NCName]
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-VarName" id="prod-xpath-VarName"></a>[12]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>VarName</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>QName</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-QName" id="prod-xpath-QName"></a>[13]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						QName
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						[http://www.w3.org/TR/REC-xml-names/#NT-QName]
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-Char" id="prod-xpath-Char"></a>[14]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Char
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						[http://www.w3.org/TR/REC-xml#NT-Char]
					</p>
				</td>
			</tr>
		</table>
		<h4>
			<a name="section_6.6.6.2." id="section_6.6.6.2."></a>6.6.6.2 Non-Terminals
		</h4>
		<table border="0" cellpadding="1" cellspacing="0">
			
			
			
			
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-XPath" id="prod-xpath-XPath"></a>[15]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						XPath
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Expr?
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-Expr" id="prod-xpath-Expr"></a>[16]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Expr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						ExprSingle <strike>("," ExprSingle)*</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ExprSingle" id="prod-xpath-ExprSingle"></a>[17]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ExprSingle
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						<strike>ForExpr<br>
						| QuantifiedExpr<br>
						| IfExpr<br></strike>| OrExpr
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ForExpr" id="prod-xpath-ForExpr"></a>[18]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>ForExpr</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>SimpleForClause "return" ExprSingle</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-SimpleForClause" id="prod-xpath-SimpleForClause"></a>[19]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>SimpleForClause</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"for" "$"&gt; VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)*</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-QuantifiedExpr" id="prod-xpath-QuantifiedExpr"></a>[20]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>QuantifiedExpr</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p class="c5">
						<strike>(&lt;"some" "$"&gt; | &lt;"every" "$"&gt;) VarName "in" ExprSingle ("," "$" <a href="http://www.w3.org/TR/xpath20/#prod-xpath-VarName">VarName</a> "in" ExprSingle)* "satisfies" ExprSingle</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-IfExpr" id="prod-xpath-IfExpr"></a>[21]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>IfExpr</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"if" "("&gt; Expr ")" "then" ExprSingle "else" ExprSingle</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-OrExpr" id="prod-xpath-OrExpr"></a>[22]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						OrExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						AndExpr ( "or" AndExpr )*
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AndExpr" id="prod-xpath-AndExpr"></a>[23]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						AndExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						InstanceofExpr ( "and" InstanceofExpr )*
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-InstanceofExpr" id="prod-xpath-InstanceofExpr"></a>[24]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						InstanceofExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						TreatExpr <strike>( &lt;"instance" "of"&gt; SequenceType )?</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-TreatExpr" id="prod-xpath-TreatExpr"></a>[25]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						TreatExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						CastableExpr <strike>( &lt;"treat" "as"&gt; SequenceType )?</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-CastableExpr" id="prod-xpath-CastableExpr"></a>[26]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						CastableExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						CastExpr <strike>( &lt;"castable" "as"&gt; SingleType )?</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-CastExpr" id="prod-xpath-CastExpr"></a>[27]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						CastExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						ComparisonExpr <strike>( &lt;"cast" "as"&gt; SingleType )?</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ComparisonExpr" id="prod-xpath-ComparisonExpr"></a>[28]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ComparisonExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						RangeExpr ( (<strike>ValueComp</strike><br>
						| GeneralComp<br>
						| <strike>NodeComp</strike>) RangeExpr )?
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-RangeExpr" id="prod-xpath-RangeExpr"></a>[29]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						RangeExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						AdditiveExpr <strike>( "to" AdditiveExpr )?</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AdditiveExpr" id="prod-xpath-AdditiveExpr"></a>[30]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						AdditiveExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						MultiplicativeExpr ( ("+" | "-") MultiplicativeExpr )*
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-MultiplicativeExpr" id="prod-xpath-MultiplicativeExpr"></a>[31]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						MultiplicativeExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						UnaryExpr <strike>( ("*" | "div" | "idiv" | "mod") UnaryExpr )*</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-UnaryExpr" id="prod-xpath-UnaryExpr"></a>[32]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						UnaryExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						("-" | "+")* UnionExpr
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-UnionExpr" id="prod-xpath-UnionExpr"></a>[33]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						UnionExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						IntersectExceptExpr ( ("union" | "|") IntersectExceptExpr )*<br>
						<br> <i>/* Note that support for a UnionExpr of attributes in the last location step is optional*/</i>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-IntersectExceptExpr" id="prod-xpath-IntersectExceptExpr"></a>[34]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						IntersectExceptExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						ValueExpr <strike>( ("intersect" | "except") ValueExpr )*</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ValueExpr" id="prod-xpath-ValueExpr"></a>[35]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ValueExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						PathExpr
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-PathExpr" id="prod-xpath-PathExpr"></a>[36]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						PathExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						("/" RelativePathExpr?)<br>
						| ("//" RelativePathExpr)<br>
						| RelativePathExpr
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-RelativePathExpr" id="prod-xpath-RelativePathExpr"></a>[37]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						RelativePathExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						StepExpr (("/" | "//") StepExpr)*
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-StepExpr" id="prod-xpath-StepExpr"></a>[38]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						StepExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						AxisStep | FilterStep
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AxisStep" id="prod-xpath-AxisStep"></a>[39]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						AxisStep
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						(ForwardStep | <a href="http://www.w3.org/TR/xpath20/#prod-xpath-ReverseStep"><strike>ReverseStep</strike></a>) Predicates
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-FilterStep" id="prod-xpath-FilterStep"></a>[40]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						FilterStep
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						PrimaryExpr Predicates
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ContextItemExpr" id="prod-xpath-ContextItemExpr"></a>[41]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ContextItemExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						"."
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-PrimaryExpr" id="prod-xpath-PrimaryExpr"></a>[42]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						PrimaryExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						Literal | <strike>VarRef |</strike> ParenthesizedExpr | ContextItemExpr | FunctionCall
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-VarRef" id="prod-xpath-VarRef"></a>[43]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>VarRef</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>"$" VarName</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-Predicates" id="prod-xpath-Predicates"></a>[44]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Predicates
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						("[" Expr "]")*
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-GeneralComp" id="prod-xpath-GeneralComp"></a>[45]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						GeneralComp
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						"=" | "!=" | "&lt;" | "&lt;=" |<br>
						"&gt;" | "&gt;="
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ValueComp" id="prod-xpath-ValueComp"></a>[46]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>ValueComp</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-NodeComp" id="prod-xpath-NodeComp"></a>[47]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>NodeComp</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>"is" | "&lt;&lt;" | "&gt;&gt;"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ForwardStep" id="prod-xpath-ForwardStep"></a>[48]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ForwardStep
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						<strike>(ForwardAxis NodeTest) |</strike> AbbrevForwardStep
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ReverseStep" id="prod-xpath-ReverseStep"></a>[49]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>ReverseStep</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>(ReverseAxis NodeTest) | AbbrevReverseStep</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AbbrevForwardStep" id="prod-xpath-AbbrevForwardStep"></a>[50]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						AbbrevForwardStep
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						"@"? NodeTest
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AbbrevReverseStep" id="prod-xpath-AbbrevReverseStep"></a>[51]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>AbbrevReverseStep</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>".."</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ForwardAxis" id="prod-xpath-ForwardAxis"></a>[52]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>ForwardAxis</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"child" "::"&gt;<br>
						| &lt;"descendant" "::"&gt;<br>
						| &lt;"attribute" "::"&gt;<br>
						| &lt;"self" "::"&gt;<br>
						| &lt;"descendant-or-self" "::"&gt;<br>
						| &lt;"following-sibling" "::"&gt;<br>
						| &lt;"following" "::"&gt;<br>
						| &lt;"namespace" "::"&gt;</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ReverseAxis" id="prod-xpath-ReverseAxis"></a>[53]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>ReverseAxis</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"parent" "::"&gt;<br>
						| &lt;"ancestor" "::"&gt;<br>
						| &lt;"preceding-sibling" "::"&gt;<br>
						| &lt;"preceding" "::"&gt;<br>
						| &lt;"ancestor-or-self" "::"&gt;</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-NodeTest" id="prod-xpath-NodeTest"></a>[54]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						NodeTest
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						KindTest | NameTest
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-NameTest" id="prod-xpath-NameTest"></a>[55]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						NameTest
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						QName <strike>| Wildcard</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-Wildcard" id="prod-xpath-Wildcard"></a>[56]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>Wildcard</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>"*"<br>
						| &lt;NCName ":" "*"&gt;<br>
						| &lt;"*" ":" NCName&gt;</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-Literal" id="prod-xpath-Literal"></a>[57]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						Literal
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						NumericLiteral | StringLiteral
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-NumericLiteral" id="prod-xpath-NumericLiteral"></a>[58]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						NumericLiteral
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						IntegerLiteral | DecimalLiteral | DoubleLiteral
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ParenthesizedExpr" id="prod-xpath-ParenthesizedExpr"></a>[59]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ParenthesizedExpr
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						"(" Expr? ")"
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-FunctionCall" id="prod-xpath-FunctionCall"></a>[60]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						FunctionCall
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						&lt;QName "("&gt; (ExprSingle ("," ExprSingle)*)? ")"
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-SingleType" id="prod-xpath-SingleType"></a>[61]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>SingleType</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>AtomicType "?"?</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-SequenceType" id="prod-xpath-SequenceType"></a>[62]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>SequenceType</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>(ItemType OccurrenceIndicator?)<br>
						| &lt;"empty" "(" ")"&gt;</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AtomicType" id="prod-xpath-AtomicType"></a>[63]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>AtomicType</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>QName</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ItemType" id="prod-xpath-ItemType"></a>[64]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>ItemType</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>AtomicType | KindTest | &lt;"item" "(" ")"&gt;</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-KindTest" id="prod-xpath-KindTest"></a>[65]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						KindTest
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						<strike>DocumentTest<br></strike>| ElementTest<br>
						| <strike>AttributeTest<br>
						| PITest<br>
						| CommentTest<br>
						| TextTest<br>
						| AnyKindTest</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ElementTest" id="prod-xpath-ElementTest"></a>[66]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ElementTest
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c5">
						&lt;"element" "("&gt; <strike>((SchemaContextPath ElementName)</strike><br>
						| (ElementNameOrWildcard ("," TypeNameOrWildcard <strike>"nillable"?</strike>)?))? ")"
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AttributeTest" id="prod-xpath-AttributeTest"></a>[67]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>AttributeTest</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"attribute" "("&gt; ((SchemaContextPath AttributeName)<br>
						| (AttribNameOrWildcard ("," TypeNameOrWildcard)?))? ")"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ElementName" id="prod-xpath-ElementName"></a>[68]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ElementName
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						QName
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AttributeName" id="prod-xpath-AttributeName"></a>[69]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						AttributeName
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						QName
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-TypeName" id="prod-xpath-TypeName"></a>[70]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						TypeName
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						QName
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-ElementNameOrWildcard" id="prod-xpath-ElementNameOrWildcard"></a>[71]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ElementNameOrWildcard
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						ElementName | "*"
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AttribNameOrWildcard" id="prod-xpath-AttribNameOrWildcard"></a>[72]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>AttribNameOrWildcard</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>AttributeName | "*"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-TypeNameOrWildcard" id="prod-xpath-TypeNameOrWildcard"></a>[73]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						TypeNameOrWildcard
					</p>
				</td>
				<td>
					<p>
						&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p class="c12">
						TypeName | "*"
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-PITest" id="prod-xpath-PITest"></a>[74]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>PITest</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"processing-instruction" "("&gt; (NCName | StringLiteral)? ")"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-DocumentTest" id="prod-xpath-DocumentTest"></a>[75]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>DocumentTest</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"document-node" "("&gt; ElementTest? ")"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-CommentTest" id="prod-xpath-CommentTest"></a>[76]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>CommentTest</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"comment" "("&gt; ")"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-TextTest" id="prod-xpath-TextTest"></a>[77]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>TextTest</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"text" "("&gt; ")"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-AnyKindTest" id="prod-xpath-AnyKindTest"></a>[78]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>AnyKindTest</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;"node" "("&gt; ")"</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-SchemaContextPath" id="prod-xpath-SchemaContextPath"></a>[79]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>SchemaContextPath</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&lt;SchemaGlobalContext "/"&gt; &lt;SchemaContextStep "/"&gt;*</strike>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p>
						<a name="prod-xpath-OccurrenceIndicator" id="prod-xpath-OccurrenceIndicator"></a>[80]&nbsp;&nbsp;&nbsp;
					</p>
				</td>
				<td>
					<p>
						<strike>OccurrenceIndicator</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</strike>
					</p>
				</td>
				<td>
					<p>
						<strike>"?" | "*" | "+"</strike>
					</p>
				</td>
			</tr>
		</table>
		<h4>
			<a name="section_6.6.6.3." id="section_6.6.6.3."></a>6.6.6.3 Notes on the Grammar
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Required function support ([42] and [60] above) is limited to the functions described in <a href="#section_6.6.5.">6.6.5</a> <i>XPath Extensions</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.7." id="section_6.6.7."></a>6.6.7 Search Scope
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A query searches the persistent workspace associated with the current session. It does not search any pending changes that may be recorded on the session but not yet saved.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.8." id="section_6.6.8."></a>6.6.8 Query API
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The query facility in a content repository is accessed through the <b>QueryManager</b> object. The <b>Workspace</b> interface provides access to the <b>QueryManager</b> object:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Workspace</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										QueryManager
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getQueryManager()</b>
									</p>
									<p class="c5">
										Returns the <b>QueryManager</b>, through which search methods are accessed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.9." id="section_6.6.9."></a>6.6.9 QueryManager
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>QueryManager</b> object provides methods for creating queries, retrieving saved queries and for discovering supported query languages:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.query.<br>
										<b>QueryManager</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										Query
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createQuery(String statement,<br>
										String language)</b>
									</p>
									<p class="c5">
										Creates a new query by specifying the query <b>statement</b> itself and the <b>language</b> in which the query is stated. If the query <b>statement</b> is syntactically invalid, given the language specified, an <b>InvalidQueryException</b> is thrown. The <b>language</b> parameter must be a string from among those returned by <b>QueryManager.getSupportedQueryLanguages()</b>; if it is not, then an <b>InvalidQueryException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Query</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getQuery(Node node)</b>
									</p>
									<p class="c5">
										Retrieves an existing persistent query. If <b>node</b> is not a valid persisted query (that is, a node of type <b>nt:query</b>), an <b>InvalidQueryException</b> is thrown.
									</p>
									<p class="c5">
										Persistent queries are created by first using <b>QueryManager.createQuery</b> to create a <b>Query</b> object and then calling <b>Query.save</b> to persist the query to a location in the workspace.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getSupportedQueryLanguages()</b>
									</p>
									<p class="c5">
										Returns an array of strings identifying the supported query languages. In level 1 this set must include the string represented by the constant <b>Query.XPATH</b>. If SQL is supported it must additionally include <b>Query.SQL</b>. An implementation of either level may also support other languages.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.10." id="section_6.6.10."></a>6.6.10 The Query Object
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A new query is created by calling <b>QueryManager.createQuery</b>. The returned <b>Query</b> object has the following methods:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.query.<br>
										<b>Query</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>QueryResult</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>execute()</b>
									</p>
									<p class="c5">
										Executes this query and returns a <b>QueryResult</b> object.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getStatement()</b>
									</p>
									<p class="c5">
										Returns the statement defined for this query.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLanguage()</b>
									</p>
									<p class="c5">
										Returns the language set for this query. This will be one of the strings returned by <b>QueryManager.getSupportedQueryLanguages()</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getStoredQueryPath()</b>
									</p>
									<p class="c5">
										If this is a <b>Query</b> that has been stored using <b>Query.storeAsNode</b> (regardless of whether it has been <b>save</b>d yet) or retrieved using <b>QueryManager.getQuery</b>, then this method returns the path of the <b>nt:query</b> node that stores the query.
									</p>
									<p class="c5">
										If this is a transient query (that is, a <b>Query</b> object created with <b>QueryManager.createQuery</b> and not yet stored), then this method throws an <b>ItemNotFoundException</b>.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>storeAsNode(String absPath)</b>
									</p>
									<p class="c5">
										Creates a node representing this <b>Query</b> in content.
									</p>
									<p class="c5">
										In a level 1 repository this method throws an <b>UnsupportedRepositoryOperationException</b>.
									</p>
									<p class="c5">
										In a level 2 repository it creates a node of type <b>nt:query</b> at <b>absPath</b> and returns that node.
									</p>
									<p class="c5">
										In order to persist the newly created node, a <b>save</b> must be performed that includes <i>the parent</i> of this new node within its scope. In other words, either a <b>Session.save</b> or an <b>Item.save</b> on the parent or higher-degree ancestor of <b>absPath</b> must be performed.
									</p>
									<p class="c5">
										In the context of this method the <b>absPath</b> provided must not have an index on its final element. If it does then a <b>RepositoryException</b> is thrown.
									</p>
									<p class="c5">
										Strictly speaking, the parameter is actually a absolute path to the parent node of the node to be added, appended with the name desired for the new node. It does not specify a position within the child node ordering (if such ordering is supported). If ordering is supported by the node type of the parent node then the new node is appended to the end of the child node list.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> will be thrown either immediately (by this method), or on <b>save</b>, if an item at the specified path already exists and same-name siblings are not allowed. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the specified path implies intermediary nodes that do not exist. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if adding the node would violate a node type or implementation-specific constraint or if an attempt is made to add a node as the child of a property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the node to which the new child is being added is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the addition of the node. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										String
									</p>
								</td>
								<td>
									<p class="c5">
										<b>XPATH</b>
									</p>
									<p class="c5">
										A string constant representing the XPath query language applied to the <i>document</i> view XML mapping of the workspace.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										String
									</p>
								</td>
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
									<p class="c5">
										A string constant representing the SQL query language applied to the <i>database view</i> of the workspace. Support for this language is optional. See <a href="#section_8.5.">8.5</a> <i>Searching Repository Content with SQL</i>.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.11." id="section_6.6.11."></a> 6.6.11 Persistent vs. Transient Queries
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a new <b>Query</b> object is first created with <b>QueryManager.createQuery</b> it is a <i>transient query</i>. If the repository is level 2 compliant and supports the node type <b>nt:query</b>, then a transient query can be stored in content by calling <b>Query.storeAsNode(String absPath)</b>. This creates an <b>nt:query</b> node at the specified path (a <b>save</b> on the parent of the new node is required to persist the stored query). Retrieving a stored query is done by passing the <b>nt:query</b> node to <b>QueryManager.getQuery(Node node)</b>.
								</p>
							
							
								<p class="c5">
									Note that the actual query statement stored within a persistent query (that is, the value of the property <b>jcr:statement</b>, for example, “<b>//*[@jcr:primaryType='nt:file']</b>” or “<b>SELECT * FROM nt:base WHERE jcr:primaryType='nt:file'</b>”) is <i>namespace-fragile</i> in that it is stored as a literal string with the namespaces in prefix form. As a result, if the stored query is run in a context where a prefix it references has been remapped, the query will not produce the same result as it would have before the remapping. It is left up to the application to ensure that appropriate mappings are in place (either using temporary <b>Session</b> remapping or persistent <b>NamespaceRegistry</b> changes) when a stored query is executed.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.6.12." id="section_6.6.12."></a>6.6.12 Query Results
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Once a query has been defined, it can be executed. The method <b>Query.execute()</b> returns a <b>QueryResult</b>.
								</p>
							
							
								<p class="c5">
									The results returned always respect the access restrictions of the current session. In other words if the current session does not have read permissions to a particular item, then that item will not be included in the result set even if it would otherwise constitute a match.
								</p>
							
							
								<p class="c5">
									As mentioned, all queries are run against the persistent state of a workspace, pending changes stored in the <b>Session</b> are not searched. However, when an item is accessed from within a <b>QueryResult</b> object, the state of the item returned will obey the same semantics as if it were retrieved using a normal <b>Node.getNode</b> or <b>Node.getProperty</b>, in other words the item state will reflect any pending changes currently stored in the session. As a result, it is possible that a property returned as a match will not reflect the value that caused it to <i>be</i> a match (i.e., its persistent state). Applications can clear the <b>Session</b> (either through <b>save</b> or <b>refresh(false)</b>) before running a query in order to avoid such discrepancies.
								</p>
							
							
								<p class="c5">
									The <b>QueryResult</b> is returned in two formats: as a table with property names as the column names and a set of rows of values and as a list of nodes. See 6.6.3 Structure of a Query for details of how the various aspects of these two views are governed by the query. The methods below provide access to the two views:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.query.<br>
										<b>QueryResult</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getColumnNames()</b>
									</p>
									<p class="c5">
										Returns an array of all the column names in the table view of this result set.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>RowIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getRows()</b>
									</p>
									<p class="c5">
										Returns an iterator over the <b>Row</b>s of the result table. If an <b>ORDER BY</b> clause was specified in the query, then the order of the returned rows in the iterator will reflect the order specified in that clause. If no items match, an empty iterator is returned.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>NodeIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNodes()</b>
									</p>
									<p class="c5">
										Returns an iterator over all nodes that match the query. If an <b>ORDER BY</b> clause was specified in the query, then the order of the returned nodes in the iterator will reflect the order specified in that clause. If no nodes match, an empty iterator is returned.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.query.<br>
										<b>Row</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Value[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getValues()</b>
									</p>
									<p class="c5">
										Returns an array of all the values in the same order as the column names returned by <b>QueryResult.getColumnNames()</b>.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getValue(String propertyName)</b>
									</p>
									<p class="c5">
										Returns the value of the indicated property in this <b>Row</b>.
									</p>
									<p class="c5">
										If <b>propertyName</b> is not among the column names of the query result table, an <b>ItemNotFoundException</b> is thrown.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.6.13." id="section_6.6.13."></a>6.6.13 Permissions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The results returned by a search are, of course, subject to the same restrictions as any access to the repository via a particular session. In other words, a search will only return results from those sections of the repository for which the initiating session has the appropriate permissions.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.7." id="section_6.7."></a>6.7 Node Types
		</h3>
		
			
				
					
						
							
								<p class="c5">
									An important feature of many repositories is the ability to distinguish the entities stored in the repository by <i>type</i>. In a content repository, this is done by assigning <i>node types</i> to nodes.
								</p>
							
							
								<p class="c5">
									Level 1 specifies methods for the following node type-related functions:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Discovering the primary and mixin node types of an existing node.
				</p>
			</li>
			<li>
				<p class="c5">
					Discovering which node types are supported in a particular repository.
				</p>
			</li>
			<li>
				<p class="c5">
					Discovering the definition of a supported node type.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					Discovering the constraints placed on an existing node or property due to the node type of its parent.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Level 2 additionally specifies methods for:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Assigning a primary node type to a node on node creation.
				</p>
			</li>
			<li>
				<p class="c5">
					Assigning additional (optional) mixin node types.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									In this section we explain the level 1 node type functionality, see <a href="#section_7.4.">7.4</a> <i>Assigning Node Types</i> for level 2 node type functions. In some cases node type-related information accessible through the discovery methods will only be relevant to a level 2 implementation. Where this is the case, it is mentioned in the discussion below.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.1." id="section_6.7.1."></a>6.7.1 Node Type Configuration
		</h4>
		
			
				
					
						
							
								<p class="c5">
									This specification does not attempt to define methods for defining, creating or managing node types. The wide range of approaches used to type entities in existing repositories makes it difficult to define a single mechanism for node type configuration. Therefore, this aspect of node type functionality is left up to the individual implementation. This specification limits itself to defining node type assignment and discovery.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.2." id="section_6.7.2."></a> 6.7.2 What Constitutes a Node Type
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In a compliant repository, a node type defines which child nodes and properties a node may (or must) have. In order to provide a set of discovery methods for node type information, the range of that information must be defined. To this end, this specification stipulates that every node type has the following attributes:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<i><b>Name</b></i>: Every node type registered with the repository has a unique name. The naming conventions for node types are the same as for items (i.e., they may have a colon delimited prefix). All predefined primary node types are, for example, prefixed with <b>nt</b>. Predefined mixin types are prefixed with <b>mix</b>. See <a href="#section_6.7.19.">6.7.19</a> <i>Predefined Node Types</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					<i><b>Supertypes</b></i>: A primary node type (with the exception of <b>nt:base</b>) <i>must</i> extend another node type (or more than one node type, if the implementation supports multiple inheritance). A mixin node type <i>may</i> extend another node type. <a href="#section_6.7.8.">6.7.8</a> <i>Inheritance Among Node Types</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					<i><b>Mixin status:</b></i> A node type may be either primary or mixin. This status is part of the node type’s definition. See <a href="#section_6.7.4.">6.7.4</a> <i>Primary and Mixin Node Types</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					<i><b>Orderable child nodes status:</b></i> A primary node type may specify that child nodes are <i>client-orderable</i>. If this status is set to <b>true</b>, then all nodes of that node type <i>must</i> support the method <b>Node.orderBefore</b>. If this status is set to <b>false</b>, then nodes of that node type <i>may</i> support this method. Only primary node types control a node's status in this regard. This setting on a mixin node type will not have any effect on the node. See <a href="#section_7.1.10.">7.1.10</a> <i>Ordering Child Nodes</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					<i><b>Property definitions:</b></i> A node type contains a set of definitions specifying the properties that nodes of this node type are allowed (or required) to have and the characteristics of those properties.
				</p>
			</li>
			<li>
				<p class="c5">
					<i><b>Child node definitions:</b></i> A node type contains a set of definitions specifying the child nodes that nodes of this node type are allowed (or required) to have and the characteristics of those child nodes (including, in turn, <i>their</i> node types).
				</p>
			</li>
			<li>
				<p class="c5">
					<i><b>Primary Item Name:</b></i> A node type may specify one child item (property or node) as the primary item. This indicator is used by the method <b>Node.getPrimaryItem()</b>. See <a href="#section_6.2.3.">6.2.3</a> <i>Node Read Methods</i>.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.7.3." id="section_6.7.3."></a> 6.7.3 Node Type Discovery in Level 1
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Note that in a level 1 implementation clients will not be able to re-order, add or remove nodes or change properties in any case. However, the orderable-status, property definitions and child node definitions may still provide information related to write-capabilities that a level 1 implementation cannot in practice perform through this API.
								</p>
							
							
								<p class="c5">
									This might be the case, for example, if a particular node-type happens to be shared with a level 2 repository. In general, the node type discovery methods will reflect the definition of the node type, regardless of the level of repository in which the node type happens to be found.
								</p>
							
							
								<p class="c5">
									For this reason, the descriptions in this section often refer to write-related issues that will only be applicable in a level 2 repository.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.4." id="section_6.7.4."></a> 6.7.4 Primary and Mixin Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In a content repository, every node has one and only one primary node type. This node type defines, as mentioned, a set of restrictions on the child items of the node.
								</p>
							
							
								<p class="c5">
									In addition to its single primary node type, a node <i>may</i> also have any number of mixin node types assigned to it. A mixin type is similar to a primary type in that its definition has the same parameters. It differs, though, in that it provides <i>additional features</i> to a node, beyond those defined in the node type proper.
								</p>
							
							
								<p class="c5">
									Furthermore, while a primary node type can be “instantiated” as a node (i.e., that node’s structure is fully defined by its primary node type) this is not the case with mixin types. A mixin type cannot serve, by itself, to define the structure of a node; it just adds properties and child node requirements to a node that already has a primary node type.
								</p>
							
							
								<p class="c5">
									A particular supported node type is either a primary type or a mixin type; it cannot be both.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.5." id="section_6.7.5."></a> 6.7.5 Special Properties jcr:primaryType and jcr:mixinTypes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A node's primary node type must be stored in content as a <b>NAME</b> property of that node called <b>jcr:primaryType</b>. Similarly, any mixin node types assigned to it must be recorded in the multi-value <b>NAME</b> property <b>jcr:mixinTypes</b>.
								</p>
							
							
								<p class="c5">
									Note that the mixin node types listed in the <b>jcr:mixinTypes</b> property are those that have been <i>explicitly assigned</i> (using <b>Node.addMixin</b>) to a node. It does not include mixin types that may be among the supertypes of a node's primary type.
								</p>
							
							
								<p class="c5">
									These properties are used to persist node type information across serialization/deserialization cycles. See <a href="#section_7.4.5.">7.4.5</a> <i>Serialization and Node Types</i>. Both of these properties are protected; they cannot be removed or changed by the application using the API. The <b>jcr:primaryType</b> and <b>jcr:mixinTypes</b> properties are specified in the predefined primary node type <b>nt:base</b>, which is the supertype of all other primary node types (be they defined by this specification or implementation or application specific).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.6." id="section_6.7.6."></a>6.7.6 Property Definitions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Each property definition contains the following information:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The <i><b>name</b></i> of the property to which this definition applies.
				</p>
			</li>
			<li>
				<p class="c5">
					The required <i><b>type</b></i> of the property (though it may be specified as <b>UNDEFINED</b>).
				</p>
			</li>
			<li>
				<p class="c5">
					The <i><b>value constraints</b></i> on the property. That is, what range of possible values may be assigned to this property.
				</p>
			</li>
			<li>
				<p class="c5">
					The <i><b>default value</b></i> that the property will have if it is auto-created.
				</p>
			</li>
			<li>
				<p class="c5">
					Whether this property will be <i><b>auto-created</b></i> when its parent node is created. Only properties with a default value can be auto-created.
				</p>
			</li>
			<li>
				<p class="c5">
					Whether the property is <i><b>mandatory</b></i>. A mandatory property is one that must exist. If a node of a type that specifies a mandatory property is created then any attempt to <b>save</b> that node without adding the mandatory property will fail. Since single-value properties either have a value or do not exist (there being no concept of the null value) this implies that a mandatory single-value property must have a value. A mandatory multi-value property on the other hand may have zero or more values.
				</p>
			</li>
			<li>
				<p class="c5">
					The <i><b>onParentVersion</b></i> status of the property. This specifies what happens to this property if a new version of its parent node is checked-in.
				</p>
			</li>
			<li>
				<p class="c5">
					Whether the property is <i><b>protected</b></i>. A protected property is one which cannot be modified or removed (except by removing its parent) directly through this API but which may be modified or removed by the repository implementation itself.
				</p>
			</li>
			<li>
				<p class="c5">
					Whether this property can have <i><b>multiple values</b></i>, meaning that it stores an array of values, not just one. Note that this “multiple values” flag is special in that a given node type may have two property definitions that are identical in every respect except for the their “multiple values” status. For example, a node type can specify two string properties both called <b>X</b>, one of which is multi-valued and the other that is not. An example of such a node type is <b>nt:unstructured</b> (see <a href="#section_6.7.22.4.">6.7.22.4</a> <i>nt:unstructured</i>).
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.7.7." id="section_6.7.7."></a>6.7.7 Child Node Definitions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Similarly, each child node definition contains the following information:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The <i><b>name</b></i> of the child node to which this definition applies.
				</p>
			</li>
			<li>
				<p class="c5">
					The <i><b>required primary node types</b></i> for this child node. That is, the primary node types that this child node must have. This attribute is capable of listing more than one node type to accommodate those implementations that support multiple inheritance of primary node types.
				</p>
			</li>
			<li>
				<p class="c5">
					The <i><b>default primary node type</b></i> for this child node. This is the primary node type automatically assigned if no node type information is specified when the node is created.
				</p>
			</li>
			<li>
				<p class="c5">
					Whether this child node will be <i><b>auto-created</b></i> when its parent node is created.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					Whether the child node is <i><b>mandatory</b></i>. A mandatory child node is one that <i>must exist</i>. If a mandatory child node is missing from a parent node then <b>save</b> on the parent node will fail.
				</p>
			</li>
			<li>
				<p class="c5">
					The <i><b>onParentVersion</b></i> status of the child node. This specifies what to do with the child node if its parent node is versioned.
				</p>
			</li>
			<li>
				<p class="c5">
					Whether the child node is <i><b>protected</b></i>. A protected node is one which cannot be modified (have child items added to it or removed from it) or be removed (except by removing its parent) by the client of this API but which may be modified or removed by the repository implementation itself.
				</p>
			</li>
			<li>
				<p class="c5">
					Whether this child node can have <i><b>same-name siblings</b></i>, meaning that the parent node can have more than one child node of this name.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.7.8." id="section_6.7.8."></a> 6.7.8 Inheritance Among Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A node type may have one (or in some implementations, more than one) <i>supertype</i>. A subtype inherits the property and child node definitions of its supertype(s) (and possibly other attributes) and may declare further property or child node definitions.
								</p>
							
							
								<p class="c5">
									Configuring the inheritance hierarchy of node types available within a particular repository is outside the scope of this specification. For this reason the specification does not define how conflicts between multiple super types are resolved or exactly which attributes of a node type (other than its child node and property definitions) are inherited by its subtypes. For example, the question of whether the orderable child nodes setting of a node type is inherited by its subtypes is left up to the particular implementation. See also, <a href="#section_6.7.22.2.">6.7.22.2</a> <i>Additions to the Hierarchy</i>.
								</p>
							
							
								<p class="c5">
									Some repositories may support multiple inheritance of node types. As a result, the methods for discovering node type information must allow for the possibility that a node type has more than one supertype. See <a href="#section_6.7.11.">6.7.11</a> <i>Discovering the Definition of a Node Type</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.9." id="section_6.7.9."></a> 6.7.9 Discovering available Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Discovery of which node types are available in a content repository is done through the <b>NodeTypeManager</b> object, which is acquired via the <b>Workspace.</b> Recall from earlier in the specification:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Workspace</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeTypeManager</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNodeTypeManager()</b>
									</p>
									<p class="c5">
										Returns the <b>NodeTypeManager</b> object through which available node types are discovered. There is one node type registry per repository, therefore the <b>NodeTypeManager</b> is not workspace-specific; it provides introspection methods for the global, repository-wide set of available node types.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<br>
									The <b>NodeTypeManager</b> provides the following methods:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.nodetype.<b><br>
										NodeTypeManager</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNodeType(String nodeTypeName)</b>
									</p>
									<p class="c5">
										Returns the <b>NodeType</b> specified by <b>nodeTypeName</b>. If no node type by that name is registered, a <b>NoSuchNodeTypeException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType<br>
										Iterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAllNodeTypes()</b>
									</p>
									<p class="c5">
										Returns all available node types, primary and mixin.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType<br>
										Iterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPrimaryNodeTypes()</b>
									</p>
									<p class="c5">
										Returns all available primary node types.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType<br>
										Iterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getMixinNodeTypes()</b>
									</p>
									<p class="c5">
										Returns all available mixin types. If none are available, an empty iterator is returned.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.7.10." id="section_6.7.10."></a> 6.7.10 Discovering the Node Types of a Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Methods are provided for determining the node types of existing nodes:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPrimaryNodeType()</b>
									</p>
									<p class="c5">
										Returns the primary node type assigned to this node. Which <b>NodeType</b> is returned when this method is called on the root node of a workspace is up to the implementation, though the returned type must, of course, be consistent with the child nodes and properties of the root node.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getMixinNodeTypes()</b>
									</p>
									<p class="c5">
										Returns an array of <b>NodeType</b> objects representing the mixin node types assigned to this node. This includes only those mixin types explicitly assigned to this node, and therefore listed in the property <b>jcr:mixinTypes</b>. It does not include mixin types inherited through the addition of supertypes to the primary type hierarchy. See <a href="#section_6.7.22.2.">6.7.22.2</a> <i>Additions to the Hierarchy</i>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isNodeType(String nodeTypeName)</b>
									</p>
									<p class="c5">
										Returns true if this node is of the specified primary node type or mixin type, or a subtype thereof. Returns <b>false</b> otherwise.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.7.11." id="section_6.7.11."></a> 6.7.11 Discovering the Definition of a Node Type
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>NodeType</b> object represents a primary or mixin node type available in the repository.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.nodetype.<br>
										<b>NodeType</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getName()</b>
									</p>
									<p class="c5">
										Returns the name of the node type.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isMixin()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this is a mixin type; returns <b>false</b> if it is primary.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasOrderableChildNodes()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if nodes of this type must support orderable child nodes; returns <b>false</b> otherwise. If a node type returns <b>true</b> on a call to this method, then all nodes of that node type <i>must</i> support the method <b>Node.orderBefore</b>. If a node type returns <b>false</b> on a call to this method, then nodes of that node type <i>may</i> support <b>Node.orderBefore</b>. Only the primary node type of a node controls that node's status in this regard. This setting on a mixin node type will not have any effect on the node. See <a href="#section_7.1.11.">7.1.11</a> <i>Ordering Child Nodes</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPrimaryItemName()</b>
									</p>
									<p class="c5">
										Returns the name of the primary item (one of the child items of the nodes of this node type). If this node has no primary item, then this method returns <b>null</b>. This indicator is used by the method <b>Node.getPrimaryItem()</b>. See <a href="#section_6.2.3.">6.2.3</a> <i>Node Read Methods</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getSupertypes()</b>
									</p>
									<p class="c5">
										Returns all supertypes of this node type in the node type inheritance hierarchy. For primary types apart from <b>nt:base</b>, this list will always include at least <b>nt:base</b>. For mixin types, there is no required supertype.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDeclaredSupertypes()</b>
									</p>
									<p class="c5">
										Returns the <i>direct</i> supertypes of this node type in the node type inheritance hierarchy, that is, those actually declared in this node type. In single-inheritance systems, this will always be an array of size 0 or 1. In systems that support multiple inheritance of node types this array may be of size greater than 1.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isNodeType(String nodeTypeName)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node type is <b>nodeTypeName</b> or a subtype of <b>nodeTypeName</b>, otherwise returns <b>false</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>PropertyDefinition[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPropertyDefinitions()</b>
									</p>
									<p class="c5">
										Returns an array containing the property definitions of this node type. This includes both those property definitions actually declared in this node type and those inherited from the supertypes of this type.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>PropertyDefinition[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDeclaredPropertyDefinitions()</b>
									</p>
									<p class="c5">
										Returns an array containing the property definitions actually declared in this node type.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeDefinition[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getChildNodeDefinitions()</b>
									</p>
									<p class="c5">
										Returns an array containing the child node definitions of this node type. This includes both those child node definitions actually declared in this node type and those inherited from the supertypes of this node type.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeDefinition[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDeclaredChildNodeDefinitions()</b>
									</p>
									<p class="c5">
										Returns an array containing the child node definitions actually declared in this node type.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>canSetProperty(String propertyName,<br>
										Value value)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if setting <b>propertyName</b> to <b>value</b> is allowed by this node type. Otherwise returns <b>false</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>canSetProperty(String propertyName,<br>
										Value[] values)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if setting <b>propertyName</b> to <b>values</b> is allowed by this node type. Otherwise returns <b>false</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>canAddChildNode(String childNodeName)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node type allows the addition of a child node called <b>childNodeName</b> without specific node type information (that is, given the definition of this parent node type, the child node name is sufficient to determine the intended child node type). Returns <b>false</b> otherwise.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>canAddChildNode(String childNodeName,<br>
										String nodeTypeName)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node type allows the addition of a child node called <b>childNodeName</b> of node type <b>nodeTypeName</b>. Returns <b>false</b> otherwise.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>canRemoveItem(String itemName)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if removing the child item called <b>itemName</b> is allowed by this node type. Returns <b>false</b> otherwise.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.7.12." id="section_6.7.12."></a>6.7.12 ItemDefinition
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>ItemDefinition</b> is the super-interface of <b>PropertyDefinition</b> and <b>NodeDefinition</b>. It encapsulates the methods common to both.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.nodetype.<br>
										<b>ItemDefinition</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDeclaringNodeType()</b>
									</p>
									<p class="c5">
										Gets the node type that contains the declaration of this <b>ItemDefinition</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getName()</b>
									</p>
									<p class="c5">
										Gets the name of the item to which this definition applies. If “<b>*</b>”, then this <b>ItemDefinition</b> defines a <i>residual set</i> of child items. That is, it defines the characteristics of all those child items with names <i>apart from the names explicitly used in other item definitions</i>. See <a href="#section_6.7.15.">6.7.15</a> <i>Residual Definitions</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isAutoCreated()</b>
									</p>
									<p class="c5">
										Reports whether the item is to be automatically created when its parent node is created. If <b>true</b> then this <b>ItemDefinition</b> will necessarily <i>not</i> be a residual set definition but will specify an actual item name (in other words <b>getName()</b> will not return “<b>*</b>”). See <a href="#section_6.7.15.">6.7.15</a> <i>Residual Definitions</i>).
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isMandatory()</b>
									</p>
									<p class="c5">
										Reports whether the item is mandatory. A mandatory item is one that, if its parent node exists, must also exist.
									</p>
									<p class="c5">
										This means that a mandatory single-value property must have a value (since there is no such thing a <b>null</b> value). In the case of multi-value properties this means that the property must exist, though it can have zero or more values.
									</p>
									<p class="c5">
										An attempt (in a level 2 implementation) to <b>save</b> a node that has a mandatory child item without first creating that child item will throw a <b>ConstraintViolationException</b> on <b>save</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getOnParentVersion()</b>
									</p>
									<p class="c5">
										Gets the <b>OnParentVersion</b> status of the property. This governs what occurs (in implementations that support versioning) when the parent node of this item is checked-in. See <a href="#section_8.2.">8.2</a> <i>Versioning</i>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isProtected()</b>
									</p>
									<p class="c5">
										Reports whether the child item is protected. In level 2 implementations, a protected item is one that cannot be removed (except by removing its parent) or modified directly through this API (that is, <b>Item.remove</b>, <b>Node.addNode</b>, <b>Node.setProperty</b> and <b>Property.setValue</b>).
									</p>
									<p class="c5">
										A protected node may be removed or modified (in a level 2 implementation), however, through some mechanism not defined by this specification or as a side-effect of operations other than the standard write methods of the API.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.13." id="section_6.7.13."></a>6.7.13 PropertyDefinition
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>PropertyDefinition</b> represents a property definition. It inherits all the method of <b>ItemDefinition</b> and adds the following:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.nodetype.<br>
										<b>PropertyDefinition</b> <b>extends ItemDefinition</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getRequiredType()</b>
									</p>
									<p class="c5">
										Gets the required type of the property. One of <b>STRING</b>, <b>BINARY</b>, <b>DATE</b>, <b>LONG</b>, <b>DOUBLE</b>, <b>NAME</b>, <b>PATH</b>, <b>REFERENCE</b>, <b>BOOLEAN</b> or <b>UNDEFINED</b>. See <a href="#section_6.2.5.">6.2.5</a> <i>Property Types</i><b>.</b> If <b>UNDEFINED</b>, then this property may be of any type.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getValueConstraints()</b>
									</p>
									<p class="c5">
										Gets the array of constraint strings. This array of strings describes the constraints that exist on values of the property. Reporting of value constraints is <i>optional</i>. An implementation may return <b>null</b>, indicating that value constraint information is unavailable (though a constraint may still exist). Note that to indicate a <b>null</b> value for this attribute in a node type definition that is stored in content, the <b>jcr:valueConstraints</b> property is simply removed (since <b>null</b> values for properties are not allowed, see <a href="#section_6.7.20.">6.7.20</a> <i>Node Type Definitions in Content</i>).
									</p>
									<p class="c5">
										Returning an empty array, on the other hand, indicates that constraint information is available and that no constraints are placed on the value of the property.
									</p>
									<p class="c5">
										If a non-empty array is returned then it is interpreted as a disjunctive set of constraints (i.e. the value must meet at least one of the constraints). The interpretation of the constraint strings themselves differs according to the type of the property. See <a href="#section_6.7.16.">6.7.16</a> <i>Value Constraints</i> for details.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDefaultValues()</b>
									</p>
									<p class="c5">
										Gets the default value(s) of the property. These are the values (or value) that the property defined by this <b>PropertyDefinition</b> will be assigned if it is automatically created (that is, if <b>isAutoCreated()</b> returns <b>true</b>).
									</p>
									<p class="c5">
										This method returns an array of <b>Value</b> objects. If the property is multi-valued, then this array represents the full set of values that the property will be assigned upon being auto-created. Note that this could be the empty array. If the property is single-valued, then the array returned will be of size 1.
									</p>
									<p class="c5">
										If <b>null</b> is returned, then the property has no fixed default value. This does not exclude the possibility that the property still assumes some value automatically, but that value may be parameterized (for example, “the current date”) and hence not expressible as a single fixed value. In particular, this <i>must</i> be the case if <b>isAutoCreated</b> returns <b>true</b> and this method returns <b>null</b>.
									</p>
									<p class="c5">
										Note that to indicate a <b>null</b> value for this attribute in a node type definition that is stored in content, the <b>jcr:defaultValues</b> property is simply removed (since <b>null</b> values for properties are not allowed, see <a href="#section_6.7.20.">6.7.20</a> <i>Node Type Definitions in Content</i>).
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isMultiple()</b>
									</p>
									<p class="c5">
										Reports whether this property can have multiple values. Note that the <b>isMultiple</b> flag is special in that a given node type may have two property definitions that are identical in every respect except for the their <b>isMultiple</b> status. For example, a node type can specify two string properties both called <b>X</b>, one of which is multi-valued and the other not. An example of such a node type is <b>nt:unstructured</b> (see <a href="#section_6.7.22.4.">6.7.22.4</a> <i>nt:unstructured</i>).
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.7.14." id="section_6.7.14."></a>6.7.14 NodeDefinition
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>NodeDefinition</b> represents a child node definition. It inherits all the methods of <b>ItemDefinition</b> and adds the following:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.nodetype.<br>
										<b>NodeDefinition</b> extends ItemDefinition
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getRequiredPrimaryTypes()</b>
									</p>
									<p class="c5">
										Gets the minimum set of primary node types that the child node must have. Returns an array to support those implementations with multiple inheritance. This method never returns an empty array. If this node definition places no requirements on the primary node type, then this method will return an array containing only the <b>NodeType</b> object representing <b>nt:base</b>, which is the base of all primary node types and therefore constitutes the least restrictive node type requirement. Note that any particular node instance still has only one assigned primary node type, but in multiple-inheritance-supporting implementations the <b>RequiredPrimaryTypes</b> attribute can be used to restrict that assigned node type to be a subtype of <i>all</i> of a specified set of node types.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeType</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDefaultPrimaryType()</b>
									</p>
									<p class="c5">
										Gets the default node type that will be assigned to the child node if it is created without an explicitly specified node type. This node type must be a subclass of (or the same class as) the node type(s) returned by <b>getRequiredPrimaryTypes</b>.
									</p>
									<p class="c5">
										If <b>null</b> is returned this indicates that no default primary type is specified and that therefore an attempt to create this node without specifying a node type will throw a <b>ConstraintViolationException</b>. Note that to indicate a <b>null</b> value for this attribute in a node type definition that is stored in content, the <b>jcr:defaultPrimaryType</b> property is simply removed (since null values for properties are not allowed, see <a href="#section_6.7.20.">6.7.20</a> <i>Node Type Definitions in Content</i>).
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>allowsSameNameSiblings()</b>
									</p>
									<p class="c5">
										Reports whether this child node can have same-name siblings. In other words, whether the parent node can have more than one child node of this name.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_6.7.15." id="section_6.7.15."></a>6.7.15 Residual Definitions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When the <b>name</b> attribute (i.e., that returned by <b>getName()</b>) of a <b>PropertyDefinition</b> or <b>NodeDefinition</b> is “<b>*</b>”, this indicates that the definition is a <i>residual definition</i>.
								</p>
							
							
								<p class="c5">
									A residual definition defines the characteristics of all properties (if it is a <b>PropertyDefinition</b>) or child nodes (if it is a <b>NodeDefinition</b>) <i>apart than those explicitly named in other property or node definitions</i>.
								</p>
							
							
								<p class="c5">
									It is possible for a node type to have more than one residual definition. This means that all properties and child nodes other than those explicitly named must conform to <i>at least one</i> of the residual definitions.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.16." id="section_6.7.16."></a>6.7.16 Value Constraints
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Each string in the array returned by <b>PropertyDefinition.getValueConstraints()</b> specifies a constraint on the value(s) of the property. The constraints are OR-ed together, meaning that in order to be valid, the value (each of the values, in the case of multi-value properties) must meet <i>at least one</i> of the constraints. For example, a constraint array of <b>["constraint1", "constraint2", "constraint3"]</b> has the interpretation: "the value of this property must meet either constraint1, constraint2 or constraint3".
								</p>
							
							
								<p class="c5">
									Reporting constraint information is optional. Therefore, the return of an empty array indicates that there are no <i>discoverable</i> constraints, meaning that either there are constraints but they are inexpressible in the constraint-string syntax, or constraint discovery is simply not supported.
								</p>
							
							
								<p class="c5">
									In the case of multi-value properties, the constraint array returned applies independently to each of the values of the property. For example, if one value meets one constraint in the constraint array while the other meets another, the constraint set is considered met for the property as a whole.
								</p>
							
							
								<p class="c5">
									If a property does not exist or (in the case of multi-value properties) contains an empty array, the constraint set is considered to have been met by default since, by definition, no values have failed to meet the constraints.
								</p>
							
							
								<p class="c5">
									The constraint strings themselves have different formats and interpretations depending on the type of the property in question. The following describes the value constraint syntax for each property type:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>STRING</b>: The constraint string is a regular expression pattern. For example the regular expression “<b>.*</b>” means “any string, including the empty string”. Whereas a simple literal string (without any regular expression-specific meta-characters) like “<b>banana</b>” matches only the string “<b>banana</b>” (see <a href="#section_6.7.16.1.">6.7.16.1</a> <i>Choice Lists</i>, below).
				</p>
			</li>
			<li>
				<p class="c5">
					<b>PATH</b>: The constraint string is a path terminating with either no final “<b>/</b>”, a single “<b>/</b>” or the substring “<b>/*</b>”. For example, possible constraint strings for a property of type <b>PATH</b> include:
				</p>
			</li>
		</ul>
		<div class="c22">
			<ol>
				<li>
					<p>
						“<b>/myapp:products/myapp:televisions</b>”
					</p>
				</li>
				<li>
					<p>
						“<b>/myapp:products/myapp:televisions/</b>”
					</p>
				</li>
				<li>
					<p>
						“<b>/myapp:products/*</b>”
					</p>
				</li>
				<li>
					<p>
						“<b>myapp:products/myapp:televisions</b>”
					</p>
				</li>
				<li>
					<p>
						“<b>../myapp:televisions</b>”
					</p>
				</li>
				<li>
					<p>
						“<b>../myapp:televisions/*</b>”
					</p>
				</li>
			</ol>
		</div>
		
			
				
					
						
							
								<p class="c5">
									The following principles apply:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The constraint must match the <i>normalized</i> path. For example, the “<b>*</b>” means “matches descendants” not “matches any subsequent path”, so that <b>/a/*</b> does not match <b>/a/../c</b>. Similarly, a trailing “<b>/</b>” has no effect (hence, <b>1</b> and <b>2</b>, above, are equivalent).
				</p>
			</li>
			<li>
				<p class="c5">
					Relative path constraints only match relative path values and absolute path constraints only match absolute path values.
				</p>
			</li>
			<li>
				<p class="c5">
					The trailing “<b>*</b>” character means that the value of the <b>PATH</b> property is restricted to the indicated subtree (in other words any additional relative path can replace the “<b>*</b>”). For example, 3, above would allow <b>/myapp:products/myapp:radios</b>, <b>/myapp:products/myapp:microwaves/X900</b>, and so forth.
				</p>
			</li>
			<li>
				<p class="c5">
					A constraint without a “<b>*</b>” means that the <b>PATH</b> property is restricted to that precise path. For example, <b>1</b>, above would allow only the value <b>/myapp:products/myapp:televisions</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The constraint can indicate either a relative path or an absolute path depending on whether it includes a leading “<b>/</b>” character. <b>1</b> and <b>4</b> above, for example, are distinct.
				</p>
			</li>
			<li>
				<p class="c5">
					The constraint string returned must reflect the namespace mapping in the current <b>Session</b> (i.e., the current state of the namespace registry overlaid with any session-specific mappings). Constraint strings for <b>PATH</b> properties should be stored in fully-qualified form (using the actual URI instead of the prefix) and then be converted to prefix form according to the current mapping. Note however that these constraint strings are not themselves valid <b>PATH</b> values, since they may contain a “<b>*</b>” character, which is not allowed in the value of an actual <b>PATH</b> property.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					<b>NAME</b>: The constraint string is a <i>name</i> in prefix form. For example, “<b>myapp:products</b>”. No wildcards or other pattern matching are supported. As with <b>PATH</b> properties, the string returned must reflect the namespace mapping in the current <b>Session</b>. Constraint strings for <b>NAME</b> properties should be stored in fully-qualified form (using the actual URI instead of the prefix) and then be converted to prefix form according to the current mapping.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>REFERENCE</b>: The constraint string is a <i>name</i> in prefix form. This name is interpreted as a node type name and the <b>REFERENCE</b> property is restricted to referring only to nodes that have at least the indicated node type<sup><a class="sdfootnoteanc" name="sdfootnote8anc" href="#sdfootnote8sym" id="sdfootnote8anc"><sup>8</sup></a></sup>. For example, a constraint of “<b>mytype:document</b>” would indicate that the <b>REFERENCE</b> property in question can only refer to nodes that have at least the node type <b>mytype:document</b> (assuming this was the only constraint returned in the array, recall that the array of constraints are to be "OR-ed" together). No wildcards or other pattern matching are supported. As with <b>PATH</b> properties, the string returned must reflect the namespace mapping in the current <b>Session</b>. Constraint strings for <b>REFERENCE</b> properties should be stored in fully-qualified form (using the actual URI instead of the prefix) and then be converted to prefix form according to the current mapping.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									The remaining types all have value constraints in the form of inclusive or exclusive ranges: i.e., "<b>[</b><b><i>min</i></b><b>,</b> <b><i>max</i></b><b>]</b>", "<b>(</b><b><i>min</i></b><b>,</b> <b><i>max</i></b><b>)</b>", "<b>(</b><b><i>min</i></b><b>,</b> <b><i>max</i></b><b>]</b>" or "<b>[</b><b><i>min</i></b><b>,</b> <b><i>max</i></b><b>)</b>". Where "<b>[</b>" and "<b>]</b>" indicate "inclusive", while "<b>(</b>" and "<b>)</b>" indicate "exclusive". A missing <b>min</b> or <b>max</b> value indicates no bound in that direction. For example <b>[,5]</b> means no minimum but a maximum of <b>5</b> (inclusive) while <b>[,]</b> means simply that any value will suffice. The meaning of the <b><i>min</i></b> and <b><i>max</i></b> values themselves differ between types as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>BINARY</b>: <b><i>min</i></b> and <b><i>max</i></b> specify the allowed size range of the binary value in bytes.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>DATE</b>: <b><i>min</i></b> and <b>max</b> are dates specifying the allowed date range. The date strings must be in the ISO 8601:2000-compliant format: <b><i>sYYYY</i></b><b>-</b><b><i>MM</i></b><b>-</b><b><i>DD</i></b><b>T</b><b><i>hh</i></b><b>:</b><b><i>mm</i></b><b>:</b><b><i>ss</i></b><b>.</b><b><i>sssTZD</i></b>. See <a href="#section_6.2.5.1.">6.2.5.1</a> <i>Date</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>LONG, DOUBLE</b>: <b><i>min</i></b> and <b><i>max</i></b> are numbers.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.7.16.1." id="section_6.7.16.1."></a>6.7.16.1 Choice Lists
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Because constraints are returned as an array of disjunctive constraints, in many cases the elements of the array can serve directly as a “choice list”. This may, for example, be used by an application to display options to the end user indication the set of permitted values.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.17." id="section_6.7.17."></a> 6.7.17 Automatic Item Creation
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The ability to specify the automatic creation of child nodes and properties has a number of interesting repercussions. Consider a situation where we have three node types, <b>C,</b> <b>B</b> and <b>A</b>:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>C</b> specifies an auto-created <b>STRING</b> property called <b>Z</b> with default value “<b>hello</b>”.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>B</b> specifies an auto-created child node <b>Y</b> of node type <b>C</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>A</b> specifies an auto-created child node called <b>X</b> of node type <b>B</b>.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Therefore, when a node <b>N</b> of node type <b>A</b> is added, this triggers a chain of automatic node creation resulting in a structure like this:
								</p>
							
							
								<p class="c5">
									<b>N--&gt; X--&gt; Y--&gt; Z="hello"</b>
								</p>
							
							
								<p class="c5">
									It is perfectly possible for a repository to have node types that may result in a cascade of item creation. However, <i>it must never be the case that a repository has</i> <i>a set of node types that may result in an infinite loop of automatic item creation</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.18." id="section_6.7.18."></a> 6.7.18 Discovery of Constraints on Existing Items
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Node</b> and <b>Property</b> interfaces also have methods that allow direct access to the <b>NodeDefinition</b> or <b>PropertyDefinition</b> applicable to a particular node or property.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>NodeDefinition</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDefinition()</b>
									</p>
									<p class="c5">
										Returns the node definition that applies to this <b>Node</b>. In some cases there may appear to be more than one definition that could apply to this node. However, it is assumed that upon creation of this node, a single particular definition was used and it is <i>that</i> definition that this method returns. How this governing definition is selected upon node creation from among others which may have been applicable is an implementation issue and is not covered by this specification. The <b>NodeDefinition</b> returned when this method is called on the root node of a workspace is also up to the implementation.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Property</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>PropertyDefinition</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getDefinition()</b>
									</p>
									<p class="c5">
										Returns the property definition that applies to this <b>Property</b>. In some cases there may appear to be more than one definition that could apply to this property. However, it is assumed that upon creation of this property, a single particular definition was used and it is <i>that</i> definition that this method returns. How this governing definition is selected upon property creation from among others which may have been applicable is an implementation issue and is not covered by this specification.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if an error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.19." id="section_6.7.19."></a>6.7.19 Predefined Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Every repository must support at least the primary node type <b>nt:base</b>. All other primary node types must be subtypes of <b>nt:base</b>. A number of predefined primary node types are defined for common application domains.
								</p>
							
							
								<p class="c5">
									In general, support for these additional primary node types is optional.
								</p>
							
							
								<p class="c5">
									Three mixin node types <b>mix:referenceable</b>, <b>mix:versionable</b> and <b>mix:lockable</b> are defined. In general support for these types is also optional. However:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>mix:referenceable</b> is required in order to support UUID-bearing nodes, which in turn support <b>REFERENCE</b> property types and versioning.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					Additionally, versioning requires the mixin node type <b>mix:versionable</b> and the primary node types <b>nt:version</b>, <b>nt:versionHistory</b>, <b>nt:versionLabels</b>, <b>nt:versionedChild</b> and <b>nt:frozenNode</b>. See <a href="#section_8.2.">8.2</a> <i>Versioning</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					Locking requires the mixin node type <b>mix:lockable</b>. See <a href="#section_8.4.">8.4</a> <i>Locking</i>.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_6.7.19.1." id="section_6.7.19.1."></a>6.7.19.1 Node Type Definition Notation
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following sections give the definition of each predefined node type and a short description and explanation for each. The node type definitions are in the following format:
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<i>...</i>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									...
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<i>...</i>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									...
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									...
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <i>...</i>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes ...
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType ...
								</p>
							
							
								<p class="c12">
									AutoCreated ...
								</p>
							
							
								<p class="c12">
									Mandatory ...
								</p>
							
							
								<p class="c12">
									OnParentVersion ...
								</p>
							
							
								<p class="c12">
									Protected ...
								</p>
							
							
								<p class="c12">
									SameNameSiblings ...
								</p>
							
							
								<p class="c12">
									<i>.</i>
								</p>
							
							
								<p class="c12">
									<i>. (more ChildNodeDefinitions)</i>
								</p>
							
							
								<p class="c12">
									<i>.</i>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <i>...</i>
								</p>
							
							
								<p class="c12">
									RequiredType ...
								</p>
							
							
								<p class="c12">
									ValueConstraints ...
								</p>
							
							
								<p class="c12">
									DefaultValues ...
								</p>
							
							
								<p class="c12">
									AutoCreated ...
								</p>
							
							
								<p class="c12">
									Mandatory ...
								</p>
							
							
								<p class="c12">
									OnParentVersion ...
								</p>
							
							
								<p class="c12">
									Protected ...
								</p>
							
							
								<p class="c12">
									Multiple ...
								</p>
							
							
								<p class="c12">
									<i>.</i>
								</p>
							
							
								<p class="c12">
									<i>. (more PropertyDefinitions)</i>
								</p>
							
							
								<p class="c12">
									.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.20." id="section_6.7.20."></a>6.7.20 Node Type Definitions in Content
		</h4>
		
			
				
					
						
							
								<p class="c5">
									It is <i>optional</i> for the repository to expose the definitions of its available node types as content. However, if it does expose these definitions then it should expose them using the built-in node type <b>nt:nodeType</b> (and its associated node types <b>nt:propertyDefinition</b> and <b>nt:childNodeDefinition</b>). These node types are defined to store node type definitions themselves. For example, to store a <i>PropertyDefinition</i> a node of type <b>nt:propertyDefinition</b> is used. It has properties for each of the attributes: the <i>Name</i> is stored in the property <b>jcr:name</b>, the <i>RequiredType</i> in <b>jcr:requiredType</b> and so on.
								</p>
							
							
								<p class="c5">
									The attributes that make up a node type definition may in some cases have no set value. For example, some <i>ChildNodeDefinitions</i> may not define a <i>DefaultPrimaryType</i> (this amounts to stating that when such a child node is created by the client the client <i>must</i> provide a valid node type, otherwise an exception will be thrown; no node type will automatically be assumed).
								</p>
							
							
								<p class="c5">
									In order to store this information (i.e., the lack of a value) in a <b>nt:nodeType</b>, <b>nt:childNodeDefinition</b> or <b>nt:propertyDefinition</b> node the property representing that attribute must simply be not present, since null values for properties are not allowed (see <a href="#section_4.7.3.">4.7.3</a> <i>No Null Values</i>).
								</p>
							
							
								<p class="c5">
									However, to indicate this state in the node type definitions that follow we do use the value <b>null</b>, even though in an in-content representation of the node type this would be represented by the absence of the property in question. For example, in the definition of the node type <b>nt:file</b>,
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:file</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:hierarchyNode</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:base]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p class="c5">
									<br>
									the child node <b>jcr:content</b> must exist (hence Mandatory is <b>true</b>, but it must be added by the client, not automatically (hence AutoCreated is <b>false</b>) and, when created, the client must provide the node type (hence <i>DefaultPrimaryType</i> is <b>null</b>). In an in-content storage of this node type however, the <b>null</b> status of <i>DefaultPrimaryType</i> would be represented by the absence of the property <b>jcr:defaultPrimaryType</b>.
								</p>
							
							
								<p class="c5">
									Note that the <i>PrimaryItemName</i> indicator in <b>nt:nodeType</b> works similarly, if there is no primary item specified then the <b>jcr:primaryItemName</b> property of the <b>nt:nodeType</b> node is simply missing. But in the notation used here, this is indicated by specifying a <b>null</b>.
								</p>
							
							
								<p class="c5">
									Again, similarly, to indicate that a property or child node definition is residual, the value returned by <b>ItemDefinition.getName()</b> is “<b>*</b>”. However, “<b>*</b>” is not a valid value for the property <b>jcr:name</b> in a <b>nt:propertyDefinition</b> or <b>nt:childNodeDefinition</b> node (because <b>jcr:name</b> it is a <b>NAME</b> property, not a <b>STRING</b>). As a result, an in-content definition of a residual item will simply not have a <b>jcr:name</b> property. In the notation below, however, the indicator “<b>*</b>” is still used.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.21." id="section_6.7.21."></a> 6.7.21 Predefined Mixin Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The three predefined mixin types are <b>mix:referenceable</b>, <b>mix:versionable</b> and <b>mix:lockable</b>. <b>mix:versionable</b> is a subtype of <b>mix:referenceable</b>. <b>mix:referenceable</b> and <b>mix:lockable</b> have no supertypes. There is no required supertype for mixin types.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.21.1." id="section_6.7.21.1."></a>6.7.21.1 mix:lockable
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>mix:lockable</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>[]</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:lockOwner</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:lockIsDeep</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c5">
									<i><br>
									This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									Only nodes with mixin node type <b>mix:lockable</b> may hold locks. See <a href="#section_8.4.">8.4</a> <i>Locking</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.21.2." id="section_6.7.21.2."></a>6.7.21.2 mix:referenceable
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>[]</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:uuid</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>INITIALIZE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type specifies an auto-created, mandatory, <b>STRING</b> property called <b>jcr:uuid</b>. This property is set automatically by the implementation when the <b>mix:referenceable</b> node is created or when this mixin type is added to an existing node.
								</p>
							
							
								<p class="c5">
									A node must be <b>mix:referenceable</b> in order to be the target of a <b>REFERENCE</b> property.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.21.3." id="section_6.7.21.3."></a>6.7.21.3 mix:versionable
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>mix:versionable</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:versionHistory</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:versionHistory"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:baseVersion</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:isCheckedOut</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>[true]</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:predecessors</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[nt:version]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:mergeFailed</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This mixin node type supports the versioning system. For a node to be versionable, it must be of this mixin node type. See <a href="#section_8.2.">8.2</a> <i>Versioning</i> for details.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22." id="section_6.7.22."></a> 6.7.22 Predefined Primary Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The primary node types described here are optional, except for <b>nt:base</b>, which is required. Every node in the repository must be of at least this type. Any custom, implementation-specific primary node types must be subtypes of <b>nt:base</b>.
								</p>
							
							
								<p class="c5">
									<b>nt:version</b> and <b>nt:versionHistory</b> are required for versioning support.
								</p>
							
							
								<p class="c5">
									<b>nt:nodeType</b>, <b>nt:propertyDefinition</b> and <b>nt:childNodeDefinition</b> are required if storage of node type definitions in the repository content itself is supported.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.1." id="section_6.7.22.1."></a>6.7.22.1 Node Type Inheritance Hierarchy
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The node type names below are arranged in a hierarchy showing their inheritance structure.
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:unstructured</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:hierarchyNode</b>
								</p>
							
							
								<p class="c12">
									<b>| |</b>
								</p>
							
							
								<p class="c12">
									<b>| |--nt:file</b>
								</p>
							
							
								<p class="c12">
									<b>| |</b>
								</p>
							
							
								<p class="c12">
									<b>| |--nt:linkedFile</b>
								</p>
							
							
								<p class="c12">
									<i><b>|</b></i> <b>|</b>
								</p>
							
							
								<p class="c12">
									<b>| |--nt:folder</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:nodeType</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:propertyDefinition</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:childNodeDefinition</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:versionHistory</b>*
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:versionLabels</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:version</b>*
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:frozenNode</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:versionedChild</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:query</b>
								</p>
							
							
								<p class="c12">
									<b>|</b>
								</p>
							
							
								<p class="c12">
									<b>|--nt:resource</b>*
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									* these node types also have <b>mix:referenceable</b> as a supertype.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.2." id="section_6.7.22.2."></a>6.7.22.2 Additions to the Hierarchy
		</h4>
		
			
				
					
						
							
								<p class="c5">
									An implementation may extend the definition of any predefined node type by adding supertypes to those defined in this specification. These additional supertypes may be either predefined mixin node types or implementation-specific mixin or primary node types.
								</p>
							
							
								<p class="c5">
									For example, a repository may require that all nodes of type <b>nt:file</b> be, additionally, <b>mix:versionable</b>. In such a repository the definition of <b>nt:file</b>, when introspected, would report an additional supertype of <b>mix:versionable</b>.
								</p>
							
							
								<p class="c5">
									The hierarchy above and the definitions below, therefore, reflect the <i>minimal</i> set of supertypes for each predefined node type.
								</p>
							
							
								<p class="c5">
									Note that this extension mechanism is distinct from the automatic addition of mixin types that may be done on node creation in level 2 (see <a href="#section_7.4.4.">7.4.4</a> <i>Automatic Addition and Removal of Mixins</i>). Though the two features may both be employed in the same repository, they differ in that one affects the actual hierarchy of the supported node types, while the other works on a node-by-node basis.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.3." id="section_6.7.22.3."></a>6.7.22.3 nt:base
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>[]</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:primaryType</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COMPUTE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:mixinTypes</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COMPUTE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c5">
									<br>
									<i>This node type is required.</i>
								</p>
							
							
								<p class="c5">
									All node types inherit from <b>nt:base</b>. As its name suggests it is the base type for all other types, and hence has no supertypes.
								</p>
							
							
								<p class="c5">
									This node type specifies the special properties <b>jcr:primaryType</b>, and <b>jcr:mixinTypes</b>.
								</p>
							
							
								<p class="c5">
									The <b>jcr:primaryType</b> property is a <b>NAME</b> property holding the name of the primary node type of its node. This property is mandatory.
								</p>
							
							
								<p class="c5">
									The <b>jcr:mixinTypes</b> is a multi-value <b>NAME</b> property that holds the names of the node’s assigned mixin node types, if any. This property may not exist if the node in question has no mixin types assigned.
								</p>
							
							
								<p class="c5">
									Since this information is itself stored as content, it will be serialized and deserialized along with all other content. This allows the preservation of node type information across serialization/deserialization cycles. See <a href="#section_7.4.5.">7.4.5</a> <i>Serialization and Node Types</i>.
								</p>
							
							
								<p class="c5">
									These properties are protected and are therefore maintained entirely by the repository itself. An application using the API can read the properties but cannot remove or alter them.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.4." id="section_6.7.22.4."></a>6.7.22.4 nt:unstructured
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:unstructured</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:base</b><b>]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:unstructured</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>VERSION</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>UNDEFINED</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>UNDEFINED</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This is the most flexible node type. It allows any number of child nodes or properties with any names. It also allows multiple nodes having the same name as well as both multi-value and single value properties with any names.
								</p>
							
							
								<p class="c5">
									This node type supports client-orderable child nodes.
								</p>
							
							
								<p class="c5">
									Like all node types, it inherits the special <b>jcr:primaryType</b> and <b>jcr:mixinTypes</b> properties from <b>nt:base</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.5." id="section_6.7.22.5."></a>6.7.22.5 nt:hierarchyNode
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:hierarchyNode</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:created</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>DATE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>INITIALIZE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type serves primarily as the supertype of <b>nt:file</b> and <b>nt:folder</b>. It defines one property inherited by these node types: <b>jcr:created</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.6." id="section_6.7.22.6."></a>6.7.22.6 nt:file
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:file</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:hierarchyNode</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:base]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									Nodes of this node type may be used to represent files. This node type inherits the child nodes and properties of <b>nt:hierarchyNode</b> and requires a single child node called <b>jcr:content</b>. The <b>jcr:content</b> node is used to hold the actual content of the file. This child node is mandatory, but not auto-created. Its node type will be application-dependent and therefore it must be added by the client. A common approach is to make the <b>jcr:content</b> a node of type <b>nt:resource</b>.
								</p>
							
							
								<p class="c5">
									The strategy in separating the <b>nt:file</b> node from its <b>jcr:content</b> child node is to divide hierarchy from content. The idea is to provide a common indicator that indicates a cut off point below which the nodes and properties have a different semantic interpretation than they do above. This type of division is common to many hierarchical information structures, such as file systems.
								</p>
							
							
								<p class="c5">
									The <b>jcr:content</b> child node is also designated as the primary child item of its parent.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.7." id="section_6.7.22.7."></a>6.7.22.7 nt:linkedFile
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:linkedFile</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:hierarchyNode</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:content</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									The <b>nt:linkedFile</b> node type is similar to <b>nt:file</b>, except that the content node is not stored directly as a child node, but rather is specified by a <b>REFERENCE</b> property. In other words the content node can reside anywhere in the repository. In addition, because of the extra level of indirection, the same content node can be referenced by multiple <b>nt:linkedFile</b> nodes. This feature can be used, for example, to present multiple orthogonal hierarchical views of the same content.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.8." id="section_6.7.22.8."></a>6.7.22.8 nt:folder
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:folder</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:hierarchyNode</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:hierarchyNode]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>VERSION</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									Nodes of this node type can be used to represent folders. This node type inherits the child nodes and properties of <b>nt:hierarchyNode</b> and adds the ability to have any number of other <b>nt:hierarchyNode</b> child nodes. This means, in particular, that it can have child nodes of <b>nt:file</b> or <b>nt:folder</b>. In this way, it is analogous to a folder in a conventional file system.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.9." id="section_6.7.22.9."></a>6.7.22.9 nt:resource
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:resource</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>jcr:data</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:encoding</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:mimeType</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:data</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BINARY</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:lastModified</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>DATE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type can be used to represent the content of a file. In particular, the <b>jcr:content</b> subnode of an <b>nt:file</b> node will often be an <b>nt:resource</b>. The <b>jcr:encoding</b> property indicates the character set encoding used. If this resource is does not contain character data then this property will not be present. If the resource does hold character data then this property should hold one of the character set names defined in <b>http://www.iana.org/assignments/character-sets</b>. The <b>jcr:mimeType</b> should contain the name of the media type of this resource as defined in <b>http://www.iana.org/assignments/media-types/</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.10." id="section_6.7.22.10."></a>6.7.22.10 nt:nodeType
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:nodeType</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:nodeTypeName</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:supertypes</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:isMixin</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:hasOrderableChildNodes</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:primaryItemName</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:propertyDefinition</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:propertyDefinition]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:propertyDefinition</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>VERSION</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:childNodeDefinition</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:childNodeDefinition]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:childNodeDefinition</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>VERSION</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>true</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This is the node type for the nodes that store node type definitions themselves (see <a href="#section_6.7.20.">6.7.20</a> <i>Storage of Node Type Definitions</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.11." id="section_6.7.22.11."></a>6.7.22.11 nt:propertyDefinition
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:propertyDefinition</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:name</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:autoCreated</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:mandatory</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:onParentVersion</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["COPY", "VERSION", "INITIALIZE",<br>
									"COMPUTE", "IGNORE", "ABORT"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:protected</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:requiredType</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["STRING", "BINARY", "LONG", "DOUBLE",<br>
									"BOOLEAN", "DATE", "NAME", "PATH",<br>
									"REFERENCE", "UNDEFINED"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:valueConstraints</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:defaultValues</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>UNDEFINED</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:multiple</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									A node type used in conjunction with <b>nt:nodeType</b> for storing node type definitions themselves. See also <b>nt:childNodeDefinition</b>.
								</p>
							
							
								<p class="c5">
									Note that in order to represent a residual property definition (see <a href="#section_6.7.15.">6.7.15</a> <i>Residual Definitions</i>) the property <b>jcr:name</b> must not be present in the <b>nt:propertyDefinition</b> node.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.12." id="section_6.7.22.12."></a>6.7.22.12 nt:childNodeDefinition
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:childNodeDefinition</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:name</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:autoCreated</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:mandatory</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:onParentVersion</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["COPY", "VERSION", "INITIALIZE",<br>
									"COMPUTE", "IGNORE", "ABORT"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:protected</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:requiredPrimaryTypes</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>[nt:base]</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:defaultPrimaryType</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:sameNameSiblings</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									A node type used in conjunction with <b>nt:nodeType</b> for storing node type definitions themselves. See also <b>nt:propertyDefinition</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.13." id="section_6.7.22.13."></a>6.7.22.13 nt:versionHistory
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:versionHistory</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:versionableUuid</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:rootVersion</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[</b><b>nt:version]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:version</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:versionLabels</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:versionLabels]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:versionLabels</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:version]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:version</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type is used in the versioning system. It is required in those implementations that support versioning. See <a href="#section_8.2.">8.2</a> <i>Versioning</i>, for more details.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.14." id="section_6.7.22.14."></a>6.7.22.14 nt:versionLabels
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:versionLabels</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type is used in the versioning system. It is required in those implementations that support versioning. See <a href="#section_8.2.">8.2</a> <i>Versioning</i>, for more details.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.15." id="section_6.7.22.15."></a>6.7.22.15 nt:version
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:version</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:created</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>DATE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:predecessors</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:successors</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenNode</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:frozenNode]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type is used in the versioning system. It is required in those implementations that support versioning. See <a href="#section_8.2.">8.2</a> <i>Versioning</i>, for more details.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.16." id="section_6.7.22.16."></a>6.7.22.16 nt:frozenNode
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:frozenNode</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenPrimaryType</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenMixinTypes</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenUuid</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>UNDEFINED</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>UNDEFINED</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:base]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>true</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type is used in the versioning system. It is required in those implementations that support versioning. See <a href="#section_8.2.">8.2</a> <i>Versioning</i>, for more details.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.17." id="section_6.7.22.17."></a>6.7.22.17 nt:versionedChild
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:versionedChild</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:childVersionHistory</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:versionHistory"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type is used in the versioning system. It is required in those implementations that support versioning. See <a href="#section_8.2.">8.2</a> <i>Versioning</i>, for more details.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.7.22.18." id="section_6.7.22.18."></a>6.7.22.18 nt:query
		</h4>
		
			
				
					
						
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:query</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:statement</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:language</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>false</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									<i>This node type is optional.</i>
								</p>
							
							
								<p class="c5">
									This node type <i>may</i> be used to store a persistent query. See <a href="#section_6.6.">6.6</a> <i>Searching Repository Content</i>, or more details
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.8." id="section_6.8."></a>6.8 System Node
		</h3>
		
			
				
					
						
							
								<p class="c5">
									The location <b>/jcr:system</b> is reserved for use as a “system folder”. Some implementations may use this location for storing or exposing repository-internal data in content. For example, if a repository exposes node type definitions in content, then those node type definitions should be located at <b>/jcr:system/jcr:nodeTypes</b>.
								</p>
							
							
								<p class="c5">
									If a repository supports versioning, then it must expose the version storage at <b>/jcr:system/jcr:versionStorage</b> (see <a href="#section_8.2.2.1.">8.2.2.1</a> <b>jcr:versionStorage</b>).
								</p>
							
							
								<p class="c5">
									If <b>/jcr:system</b> is supported its node type is left up to the implementation.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_6.9." id="section_6.9."></a>6.9 Access Control
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A level 1 compliant implementation must support the access control discovery method <b>Session.checkPermission</b> (see below).
								</p>
							
							
								<p class="c5">
									In the simplest cases, where an implementation does not actually support access control, the behavior of this method can be hardcoded.
								</p>
							
							
								<p class="c5">
									In repositories that do support access control, this method reports whether a particular <b>Session</b> has permission to perform a particular action according to the relevant access control policies. However, the specification does not attempt to define mechanisms for the <i>setting</i> of access control policies.
								</p>
							
							
								<p class="c5">
									As mentioned above (see <a href="#section_6.1.">6.1</a> <i>Accessing the Repository</i>), the <b>Session</b> object returned by <b>Repository.login</b> reflects a particular set of access permissions. These permissions may be determined by the <b>Credentials</b> passed on <b>login</b> or by some external authentication and authorization mechanism within which the repository implementation is embedded.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.9.1." id="section_6.9.1."></a>6.9.1 JAAS
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If an external mechanism is employed, a likely candidate is the Java Authentication and Authorization Service (JAAS) (see http://java.sun.com/products/jaas/).
								</p>
							
							
								<p class="c5">
									By providing a signature of <b>Repository.login</b> that does not require <b>Credentials</b>, the content repository allows for authorization and authentication to be handled by JAAS (or another external mechanism) if the implementer so chooses.
								</p>
							
							
								<p class="c5">
									To use JAAS authentication to create <b>Session</b>s with end-user identity, invocations of the <b>Repository.login</b> method that do not specify <b>Credentials</b> (i.e., either a <b>null</b> <b>Credentials</b> is passed or a signature without the <b>Credentials</b> parameter is used) <i>should</i> obtain the identity of the already-authenticated user by calling the static <b>getSubject</b> method of <b>javax.security.auth.Subject</b>.
								</p>
							
							
								<p class="c5">
									The discovery mechanism for finding what permissions apply is also JAAS-compatible since it uses the JAAS-like concept of <i>actions</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_6.9.2." id="section_6.9.2."></a>6.9.2 Checking Permissions
		</h4>
		<p class="c5">
			Permission checking is done through the method <b>Session.checkPermission</b>:
		</p>
		
			
				
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>checkPermission(String absPath,<br>
										String actions)</b>
									</p>
									<p class="c5">
										Determines whether this <b>Session</b> has permission to perform the specified <b>actions</b> at the specified <b>absPath</b>. This method quietly returns if the access request is permitted, or throws a suitable <b>java.security.AccessControlException</b> otherwise.
									</p>
									<p class="c5">
										The actions parameter is a comma separated list of action strings. The following action strings are defined:
									</p>
									<p class="c5">
										<b>add_node<br></b>If <b>checkPermission(path, "add_node")</b> returns quietly, then this <b>Session</b> has permission to add a node at <b>path</b>, otherwise permission is denied.
									</p>
									<p class="c5">
										<b>set_property<br></b>If <b>checkPermission(path, "set_property")</b> returns quietly, then this <b>Session</b> has permission to set (add or change) a property at <b>path</b>, otherwise permission is denied.
									</p>
									<p class="c5">
										<b>remove<br></b>If <b>checkPermission(path, "remove")</b> returns quietly, then this <b>Session</b> has permission to remove an item at <b>path</b>, otherwise permission is denied.
									</p>
									<p class="c5">
										<b>read<br></b>If <b>checkPermission(path, "read")</b> returns quietly, then this <b>Session</b> has permission to retrieve (and read the value of, in the case of a property) an item at <b>path</b>, otherwise permission is denied.
									</p>
									<p class="c5">
										When more than one action is specified in the <b>actions</b> parameter, this method will only return quietly if this <b>Session</b> has permission to perform <i>all</i> of the listed actions at the specified <b>path</b>.
									</p>
									<p class="c5">
										The information returned through this method will only reflect access control policies and not other restrictions that may exist. For example, even though <b>checkPermission</b> may indicate that a particular <b>Session</b> may add a property at <b>/A/B/C</b>, the node type of the node at <b>/A/B</b> may prevent the addition of a property called <b>C</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h2>
			<a name="section_7." id="section_7."></a>7 Level 2 Repository Features
		</h2>
		
			
				
					
						
							
								<p class="c5">
									The following section explains level 2 of the content repository API on a functional basis. For an explanation organized on an interface-by-interface basis, see the accompanying Javadoc.
								</p>
							
							
								<p class="c5">
									Level 2 defines a <i>read/write</i> repository. This includes all features of level 1, as well as the following:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Adding and removing nodes and properties
				</p>
			</li>
			<li>
				<p class="c5">
					Writing the values of properties
				</p>
			</li>
			<li>
				<p class="c5">
					Persistent namespace changes
				</p>
			</li>
			<li>
				<p class="c5">
					Import from XML/SAX
				</p>
			</li>
			<li>
				<p class="c5">
					Assigning node types to nodes
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Where a level 1-only repository would differ in behavior from a level 2 repository, this is indicated.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_7.1." id="section_7.1."></a> 7.1 Writing Repository Content
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Methods for writing content to the repository fall into two categories: those that write directly to the workspace and those that write to the transient storage associated with the session. The latter require a <b>save</b> for their changes to be written to the workspace, the former do not.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.1.1." id="section_7.1.1.1."></a>7.1.1.1 Writing to Transient Storage
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The purpose behind the transient storage in the session is to provide a space in which complex changes can be made to content without having these changes validated at every step. When a node/property structure is fully assembled it can be saved and validated against node type and other constraints. This allows structures of nodes and properties to be temporarily invalid while they are being built.
								</p>
							
							
								<p class="c5">
									The methods that write to the transient layer are:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>Node.addNode</b>, <b>setProperty</b>, <b>orderBefore</b>, <b>addMixin</b> and<br>
					<b>removeMixin</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Property</b>.<b>setValue</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Item</b>.<b>remove</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Session.move</b> and <b>importXML</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Query.storeAsNode</b>.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Changes made though these methods will only be pushed to the workspace when a <b>save</b> is called that includes the change within its scope.
								</p>
							
							
								<p class="c5">
									<b>Session.save</b> persists all pending changes currently stored in the <b>Session</b> object. Conversely, <b>Session.refresh(false)</b> discards all pending changes currently stored in the <b>Session</b>.
								</p>
							
							
								<p class="c5">
									For more fine-grained control over which changes are persisted or discarded, the methods <b>Item.save</b> and <b>Item.refresh(false)</b> are also provided. <b>Item.save</b> saves all pending changes that apply to that particular item and its subtree. Analogously, <b>Item.refresh</b> discards all pending changes that apply to that item and its subtree.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.1.2." id="section_7.1.1.2."></a>7.1.1.2 Writing Directly to the Workspace
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The methods that write changes directly to the workspace are :
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>Node.checkin</b>, <b>checkout</b>, <b>restore</b>, <b>restoreByLabel</b>, <b>merge</b>, <b>cancelMerge</b>, <b>doneMerge</b>, <b>update</b>, <b>lock</b> and <b>unlock</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Workspace.move</b>, <b>copy</b>, <b>clone</b>, <b>restore</b> and <b>importXML</b>
				</p>
			</li>
			<li>
				<p class="c5">
					<b>VersionHistory.addVersionLabel</b>, <b>removeVersionLabel</b>, <b>removeVersion</b>.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									(some of these are relevant only in repositories that support the relevant feature: locking or versioning)
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.1.3." id="section_7.1.1.3."></a>7.1.1.3 Effect of Transactions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In repositories that support transactions, all changes, whether workspace-direct or session-mediated, may be further insulated from persistent storage by their transaction context. If a set of write methods is within the scope of a transaction then the changes they make will only be reflected in persistent storage upon commit of that transaction.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.1.4." id="section_7.1.1.4."></a>7.1.1.4 Invalid States
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If an item has been modified in the <b>Session</b> but not yet saved, and its corresponding item in the persistent workspace is altered through a direct-to-workspace method, this has no effect on the transient state of the <b>Session</b>. The altered item in the <b>Session</b> remains and may be saved later. Of course, the change made to the workspace may render the attempt to save the session-change invalid (for example if the workspace-change removed the parent of the session-change item). Note that this is precisely the same situation as would arise if a change were made to a workspace through <i>another</i> <b>Session</b>. In both cases the <b>save</b> on <i>this</i> <b>Session</b> may throw an <b>InvalidItemStateException</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.1.5." id="section_7.1.1.5."></a>7.1.1.5 Timing of Validation
		</h4>
		
			
				
					
						
							
								<p class="c5">
									For those write methods that require a <b>save</b>, implementers have considerable flexibility in deciding whether a particular validation is to be performed immediately during the invocation of the write method or later on <b>save</b>. For example, in the case <b>Node.addNode</b>, an implementer might immediately check that the path given is valid while postponing validation of node type constraints until <b>save</b>-time.
								</p>
							
							
								<p class="c5">
									The <i>suggestion</i> is that an implementation should perform each validation as soon as possible, given the underlying design of the repository.
								</p>
							
							
								<p class="c5">
									The <i>requirement</i> is that an implementation must prohibit the emergence of a persistent state in violation the validation rules defined by this specification. Therefore at the latest, all validation must be done on <b>save</b>.
								</p>
							
							
								<p class="c5">
									In the context of a particular change to an item, we often refer to <b>save</b> generically, as in, “the change will be persisted on <b>save</b>”. Such statements refer to any invocation of <b>save</b>, (<b>Session.save</b> or <b>Item.save</b>) that include the changed item within its scope.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.1.6." id="section_7.1.1.6."></a>7.1.1.6 Session
		</h4>
		
			
				
					
						
							
								<p class="c5">
									<b>Session</b> has the following <b>save-</b> and <b>Value-</b>related methods:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>save()</b>
									</p>
									<p class="c5">
										Validates all pending changes currently recorded in this <b>Session</b>. If validation of <i>all</i> pending changes succeeds, then this change information is cleared from the <b>Session</b>. If the <b>save</b> occurs outside a transaction, the changes are persisted and thus made visible to other <b>Session</b>s. If the <b>save</b> occurs within a transaction, the changes are not persisted until the transaction is committed (see <a href="#section_8.1.">8.1</a> <i>Transactions</i> for more details).
									</p>
									<p class="c5">
										If validation fails, then no pending changes are saved and they remain recorded on the <b>Session</b>. There is no best-effort or partial <b>save</b>.
									</p>
									<p class="c5">
										The item in persistent storage to which a transient item is saved is determined by matching UUIDs and paths. See <a href="#section_7.1.2.">7.1.2</a> <i>Saving by UUID and Path</i>, for details.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> will be thrown if any of the changes to be persisted would violate the access permissions of the <b>Session</b>.
									</p>
									<p class="c5">
										If any of the changes to be persisted would cause the removal of a node that is currently the target of a <b>REFERENCE</b> property then a <b>ReferentialIntegrityException</b> is thrown, provided that this <b>Session</b> has read access to that <b>REFERENCE</b> property. If, on the other hand, this <b>Session</b> does not have read access to the <b>REFERENCE</b> property in question, then an <b>AccessDeniedException</b> is thrown instead.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> will be thrown if any of the changes to be persisted would be prevented by the presence of an already existing item in the workspace.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown if any of the changes to be persisted would violate a node type restriction. Additionally, a repository may use this exception to enforce implementation- or configuration-dependant restrictions.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if any of the changes to be persisted conflicts with a change already persisted through another session and the implementation is such that this conflict can only be detected at <b>save</b>-time and therefore was not detected earlier, at change-time.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the <b>save</b> would result in a change to persistent storage that would violate the read-only status of a checked-in node.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if the <b>save</b> would result in a change to persistent storage that would violate a lock.
									</p>
									<p class="c5">
										A <b>NoSuchNodeTypeException</b> is thrown if the <b>save</b> would result in the addition of a node with an unrecognized node type.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> will be thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>refresh(boolean keepChanges)</b>
									</p>
									<p class="c5">
										If <b>keepChanges</b> is <b>false</b>, this method discards all pending changes currently recorded in this <b>Session</b> and returns all items to reflect the current saved state. Outside a transaction this state is simply the current state of persistent storage. Within a transaction, this state will reflect persistent storage as modified by changes that have been saved but not yet committed.
									</p>
									<p class="c5">
										If <b>keepChanges</b> is <b>true</b> then pending changes are not discarded but items that do not have changes pending have their state refreshed to reflect the current saved state, thus revealing changes made by other sessions. In some implementations this may be a null operation. See <a href="#section_7.1.3.4.">7.1.3.4</a> <i>Seeing Changes Made by Other Sessions</i>, for more details.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasPendingChanges()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this <b>Session</b> holds pending (that is, unsaved) changes; otherwise returns <b>false</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>ValueFactory</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getValueFactory()</b>
									</p>
									<p class="c5">
										This method returns a <b>ValueFactory</b> that is used to create <b>Value</b> objects for use when setting repository properties (see 7.1.5 Adding and Writing Properties and 7.1.5.3 Creating Value Objects).
									</p>
									<p class="c5">
										If writing to the repository is not supported (because this is a level 1-only implementation, for example) an <b>UnsupportedRepositoryOperationException</b> will be thrown.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.1.7." id="section_7.1.1.7."></a>7.1.1.7 Item
		</h4>
		
			
				
					
						
							
								<p class="c5">
									There are also the more fine-grained <b>save</b> and <b>refresh</b> methods on <b>Item</b>.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Item</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>save()</b>
									</p>
									<p class="c5">
										Validates all pending changes currently recorded in this <b>Session</b> that apply to this <b>Item</b> or any of its descendants (that is, the subtree rooted at this <b>Item</b>). If validation of <i>all</i> pending changes succeeds, then this change information is cleared from the <b>Session</b>. If the <b>save</b> occurs outside a transaction, the changes are persisted and thus made visible to other <b>Session</b>s. If the <b>save</b> occurs within a transaction, the changes are not persisted until the transaction is committed (see <a href="#section_8.1.">8.1</a> <i>Transactions</i> for more details).
									</p>
									<p class="c5">
										If validation fails, then no pending changes are saved and they remain recorded on the <b>Session</b>. There is no best-effort or partial <b>save</b>.
									</p>
									<p class="c5">
										The item in persistent storage to which a transient item is saved is determined by matching UUIDs and paths. See <a href="#section_7.1.2.">7.1.2</a> <i>Saving by UUID and Path</i>, for details.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> will be thrown if any of the changes to be persisted would violate the access permissions of the <b>Session</b>.
									</p>
									<p class="c5">
										If any of the changes to be persisted would cause the removal of a node that is currently the target of a <b>REFERENCE</b> property then a <b>ReferentialIntegrityException</b> is thrown, provided that this <b>Session</b> has read access to that <b>REFERENCE</b> property. If, on the other hand, this <b>Session</b> does not have read access to the <b>REFERENCE</b> property in question, then an <b>AccessDeniedException</b> is thrown instead.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> will be thrown if any of the changes to be persisted would be prevented by the presence of an already existing item in the workspace.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown if any of the changes to be persisted would violate a node type restriction. Additionally, a repository may use this exception to enforce implementation- or configuration-dependant restrictions.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if any of the changes to be persisted conflicts with a change already persisted through another session and the implementation is such that this conflict can only be detected at <b>save</b>-time and therefore was not detected earlier, at change-time.
									</p>
									<p class="c5">
										A <b>ReferentialIntegrityException</b> is thrown if any of the changes to be persisted would cause the removal of a node that is currently referenced by a <b>REFERENCE</b> property that this <b>Session</b> has read access to.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the <b>save</b> would result in a change to persistent storage that would violate the read-only status of a checked-in node.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if the <b>save</b> would result in a change to persistent storage that would violate a lock.
									</p>
									<p class="c5">
										A <b>NoSuchNodeTypeException</b> is thrown if the <b>save</b> would result in the addition of a node with an unrecognized node type.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> will be thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>refresh(boolean keepChanges)</b>
									</p>
									<p class="c5">
										If <b>keepChanges</b> is <b>false</b>, this method discards all pending changes currently recorded in this <b>Session</b> that apply to this <b>Item</b> or any of its descendants (that is, the subtree rooted at this <b>Item</b>) and returns these items to reflect the current saved state. Outside a transaction this state is simply the current state of persistent storage. Within a transaction, this state will reflect persistent storage as modified by changes that have been saved but not yet committed.
									</p>
									<p class="c5">
										If <b>keepChanges</b> is <b>true</b> then pending changes are not discarded but items (within the subtree rooted at this <b>Item</b>) that do not have changes pending have their state refreshed to reflect the current saved state, thus revealing changes made by other sessions. In some implementations this may be a null operation. See <a href="#section_7.1.3.4.">7.1.3.4</a> <i>Seeing Changes Made by Other Sessions</i>, for more details.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Item</b> object represents a workspace item that has been removed (either by this session or another).
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.2." id="section_7.1.2."></a>7.1.2 Saving by UUID and Path
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When an item is saved (either through <b>Item.save</b> or <b>Session.save</b>) the item in persistent storage to which pending changes are written is determined using the same principles as those that govern correspondence of nodes between workspaces (see 4.10.2 Multiple Workspaces and Corresponding Nodes). The difference in this case is that the correspondence is not between two workspaces but between the transient storage of the session and the persistent storage of its associated workspace. In the context of saving a node, those principles amount to the following:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					If the transient item has a UUID, then the changes are written to the persistent item with the same UUID.
				</p>
			</li>
			<li>
				<p class="c5">
					If the transient item does not have a UUID, then a combination of the UUID of its nearest UUID-bearing ancestor and its relative path from that ancestor is used to determine the persistent item to which the changes will be written. For example, if
				</p>
				<ul>
					<li>
						<p class="c5">
							node <b>/a/b/c</b> and node <b>/a/b</b> do not have UUIDs;
						</p>
					</li>
					<li>
						<p class="c5">
							node <b>/a</b> has UUID <b><i>u</i></b>;
						</p>
					</li>
					<li>
						<p class="c5">
							then, pending changes to transient node <b>/a/b/c</b> are written to the persistent node located at path <b>b/c</b> <i>relative to</i> the persistent node with UUID <b><i>u</i></b>.
						</p>
					</li>
				</ul>
			</li>
		</ul>
		<h4>
			<a name="section_7.1.3." id="section_7.1.3."></a>7.1.3 Reflecting Item State
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Every <b>Item</b> object (instance of a <b>Node</b> or <b>Property</b>) is associated with the <b>Session</b> object through which it was acquired. When changes are made to an <b>Item</b> object, those changes are recorded in its associated <b>Session</b> and immediately reflected in the <b>Item</b> object itself. In other words, after a change is made, a subsequent re-retrieval of the same item entity <i>through the same</i> <b>Session</b>, will return an <b>Item</b> object reflecting the recent change. In this context “retrieval through the same <b>Session</b>” includes not just acquisition of nodes and properties through the getter methods (like <b>getNode</b>, <b>getProperty</b> etc.) but also items returned through other means, such as within the result set of a query.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.3.1." id="section_7.1.3.1."></a>7.1.3.1 Re-using Item Objects
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Whether the second <b>Item</b> object is the same actual Java object instance as the first is an implementation issue. However, the state reflected by the object must at all times be consistent with any other <b>Item</b> object (associated with the same <b>Session</b>) representing the same actual item entity. Note that the criteria of item identity in this context are those described above in <a href="#section_7.1.2.">7.1.2</a> <i>Saving by UUID and Path</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.3.2." id="section_7.1.3.2."></a>7.1.3.2 Effect of Save and Refresh
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a <b>save</b> is performed on an <b>Item</b>, any changes recorded for that <b>Item</b> in the <b>Session</b> are persisted and the record of that change in the <b>Session</b> is removed. From the perspective of the application, the apparent state of the <b>Item</b> itself does not change (apart from the values returned by <b>isNew</b> or <b>isModified</b>), since the item has reflected the changes since they were initially made. If one or more of the pending changes cause an exception to be thrown on <b>save</b>, then <i>no</i> pending changes are saved, not even those which did not cause the problem. In this case the set of pending changes recorded on the session is left unaffected.
								</p>
							
							
								<p class="c5">
									When a <b>refresh(false)</b> is performed on an <b>Item</b>, any pending changes recorded for that <b>Item</b> in the <b>Session</b> are discarded and the state of the <b>Item</b> object reverts to its current saved state in the workspace. If an exception occurs on <b>refresh</b>, the set of pending changes recorded on the session is left unaffected and <b>Item</b> state is similarly unaffected.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.3.3." id="section_7.1.3.3."></a>7.1.3.3 Invalid Items
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Methods of an <b>Item</b> object (i.e., <b>Node</b> or <b>Property</b>) may throw an <b>InvalidItemStateException</b> in certain circumstances.
								</p>
							
							
								<p class="c5">
									The first case is if <b>Item.remove</b> has been called on the item. In this case any subsequent calls to any read or write methods or invocations of <b>save</b> or <b>refresh</b> on that <b>Item</b> will throw an <b>InvalidItemStateException</b>.
								</p>
							
							
								<p class="c5">
									Before the removal is persisted (by a <b>save</b> on the <i>parent</i> of the removed node) it may be cancelled by a <b>refresh(false)</b> on the parent of the removed node. This has the effect of reverting the parent node to its current saved state in the workspace. At this point the invalid <b>Item</b> object may become valid again, or the repository may require a new <b>Item</b> object to be acquired. Which approach is taken is a matter of implementation.
								</p>
							
							
								<p class="c5">
									An <b>InvalidItemStateException</b> may be thrown on a write method of an <b>Item</b> if the change being made would (upon <b>save</b>) conflict with a change made, and persisted, through another <b>Session</b>. If detection of the conflict is only possible at <b>save</b>-time, then <b>save</b> will throw an <b>InvalidItemStateException</b>.
								</p>
							
							
								<p class="c5">
									Whether a conflict is detected when the change is made to the <b>Item</b> or later, when an attempt is made to save that change, depends on the implementation. The key issue is when a particular <b>Session</b> sees changes made in the persistent storage by other sessions.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.3.4." id="section_7.1.3.4."></a>7.1.3.4 Seeing Changes Made by Other Sessions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When recording pending changes to an <b>Item</b> in the <b>Session</b> at least two approaches are possible. Which approach is taken is up to the implementation.
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>Copy-on-Read</b>: When an <b>Item</b> object is acquired, its state in persistent storage is copied to transient storage associated with the <b>Session</b>. Any subsequent changes are applied to the transient state object. Upon <b>save</b>, the transient state object is copied back to persistent storage and removed from transient storage. In such an implementation, when an <b>Item</b> is retrieved through a particular <b>Session</b>, any changes made to the persistent state of that item by another <b>Session</b> will not be visible to the first <b>Session</b> until a <b>refresh</b> and reacquisition of the item in question. Under this system, conflicts with persistent state will only be detected upon <b>save</b>, meaning that <b>InvalidItemStateException</b> will only be thrown on <b>save</b>, not earlier. The copy-on-read approach also has some repercussions in the context of transactions (in those implementations that support this feature). See <a href="#section_8.1.4.">8.1.4</a> <i>Single Session Across Multiple Transactions</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>Copy-on-Write</b>: An alternative approach is <i>not</i> to immediately copy the state of a newly acquired <b>Item</b> object to transient storage, but rather to only copy the state when a change is made to that state. In this case, as long as no changes are made to an <b>Item</b> object, its state always reflects the current state in persistent storage and thus any changes in that persistent state made by other sessions are immediately visible through the methods of that <b>Item</b>. If, on the other hand, a change is made to the <b>Item</b> state by this Session then the item state is copied from persistent storage to transient storage and the change is applied to that copy. From this point until a <b>refresh</b> or <b>save</b>, changes made to the persistent item will not be visible through the <b>Item</b> object. Note that in copy-on-write implementations a <b>refresh(true)</b> (a refresh that does not discard pending changes) will, by definition, have no effect.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									This specification does not prescribe either of these approaches. Implementations are free to use either one (or indeed any other that may be suitable) as long as the minimal requirement is met of never allowing two <b>Item</b> objects acquired through the same <b>Session</b> to reflect conflicting state information.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.3.5." id="section_7.1.3.5."></a>7.1.3.5 Resolving Conflicts with Persistent State
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When an <b>InvalidItemStateException</b> is thrown (either at write-time or <b>save</b>-time) an application may wish to resolve the conflict. The standard solution is to do the following:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					If the <b>Item</b> in question has unsaved changes pending, make a temporary copy of it.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>refresh(false)</b> the original <b>Item</b>, thus discarding the recent changes (including the one which caused the conflict).
				</p>
			</li>
			<li>
				<p class="c5">
					Merge the changes recorded in the temporary copy with the now up-to-date <b>Item</b> object.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									In those repositories that support it, applications may avoid such conflicts by using the locking mechanism (see <a href="#section_8.4.">8.4</a> <i>Locking</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.3.6." id="section_7.1.3.6."></a>7.1.3.6 Item Status
		</h4>
		
			
				
					
						
							
								<p class="c5">
									This specification provides the following methods on <b>Item</b> for determining whether a particular item has pending changes (<b>isModified</b>) or constitutes part of the pending changes of its parent (<b>isNew</b>).
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Item</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isNew()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this is a new item, meaning that it exists only in transient storage on the <b>Session</b> and has not yet been saved. Within a transaction, <b>isNew</b> on an <b>Item</b> may return <b>false</b> (because the item has been saved) even if that <b>Item</b> is not in persistent storage (because the transaction has not yet been committed).
									</p>
									<p class="c5">
										Note that in level 1 (that is, read-only) implementations, this method will always return <b>false</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isModified()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this <b>Item</b> has been saved but has subsequently been modified through the current session and therefore the state of this item as recorded in the session differs from the state of this item as saved. Within a transaction, <b>isModified</b> on an <b>Item</b> may return <b>false</b> (because the <b>Item</b> has been saved since the modification) even if the modification in question is not in persistent storage (because the transaction has not yet been committed).
									</p>
									<p class="c5">
										Note that in level 1 (that is, read-only) implementations, this method will always return <b>false</b>.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.4." id="section_7.1.4."></a>7.1.4 Adding Nodes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The methods for adding nodes are:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Node</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>addNode(String&nbsp;relPath)</b>
									</p>
									<p class="c5">
										Creates a new node at <b>relPath</b>. The new node will only be persisted on <b>save</b> if it meets the constraint criteria of the parent node's node type.
									</p>
									<p class="c5">
										In order to save a newly added node, <b>save</b> must be called either on the <b>Session</b>, or on the new node's parent or higher-order ancestor (grandparent, etc.). An attempt to call <b>save</b> <i>only</i> on the newly added node will throw a <b>RepositoryException</b>.
									</p>
									<p class="c5">
										In the context of this method the <b>relPath</b> provided must not have an index on its final element. If it does then a <b>RepositoryException</b> is thrown.
									</p>
									<p class="c5">
										Strictly speaking, the parameter is actually a relative path to the parent node of the node to be added, appended with the name desired for the new node (if the node is being added directly below <b>this</b> node then only the name need be specified). It does not specify a position within the child node ordering (if such ordering is supported). If ordering is supported by the node type of the parent node then the new node is appended to the end of the child node list.
									</p>
									<p class="c5">
										Since this signature does not allow explicit node type assignment, the new node's primary node type will be determined (either immediately or on <b>save</b> depending on the implementation) by the child node definitions in the node types of its parent. See <a href="#section_7.4.2.">7.4.2</a> <i>Assigning a Primary Node Type</i>.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> will be thrown either immediately (by this method), or on <b>save</b>, if an item at the specified path already exists and same-name siblings are not allowed. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the specified path implies intermediary nodes that do not exist. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if adding the node would violate a node type or implementation-specific constraint or if an attempt is made to add a node as the child of a property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the node to which the new child is being added is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the addition of the node. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Node</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>addNode(String relPath,<br>
										String primaryNodeTypeName)</b>
									</p>
									<p class="c5">
										Creates a new node at <b>relPath</b> of the specified primary node type.
									</p>
									<p class="c5">
										The same as <b>addNode(String relPath)</b> except that the primary node type of the new node is explicitly specified.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> will be thrown either immediately (by this method), or on <b>save</b>, if an item at the specified path already exists and same-name siblings are not allowed. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the specified path implies intermediary nodes that do not exist. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>NoSuchNodeTypeException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the specified node type is not recognized. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if adding the node would violate a node type or implementation-specific constraint or if an attempt is made to add a node as the child of a property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the node to which the new child is being added is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the addition of the node. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.4.1." id="section_7.1.4.1."></a>7.1.4.1 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If we wish to add a new “shape” to our product information, we might do it like this:
								</p>
							
							
								<p class="c12">
									<b>Node productsNode = root.getNode("products");</b>
								</p>
							
							
								<p class="c12">
									<b>Node triangleNode = productsNode.addNode("triangle");</b>
								</p>
							
							
								<p class="c12">
									<b>Node contentNode = triangleNode.addNode("jcr:content");</b>
								</p>
							
							
								<p class="c12">
									<b>contentNode.setProperty("myapp:title", "Triangle: an<br>
									economical choice");</b>
								</p>
							
							
								<p class="c12">
									<b>contentNode.setProperty("myapp:price", 50);</b>
								</p>
							
							
								<p class="c12">
									<b>contentNode.setProperty("myapp:lead", "Triangles have</b>
								</p>
							
							
								<p class="c12">
									<b>three sides, but they're not always</b>
								</p>
							
							
								<p class="c12">
									<b>equal!");</b>
								</p>
							
							
								<p class="c12">
									<b>productsNode.save();</b>
								</p>
							
							
								<p class="c5">
									<br>
									This would add the new node <b>triangle</b> below the <b>products</b> node and add to <b>triangle</b>'s <b>jcr:content</b> node the properties <b>myapp:title</b>, <b>myapp:price</b> and <b>myapp:lead</b> with the specified values.
								</p>
							
							
								<p class="c5">
									As another example, suppose we wish to iterate through a collection of strings and add each as a new paragraph under the node <b>triangle/jcr:content</b>. In that case, we might do the following:
								</p>
							
							
								<p class="c12">
									<b>Node contentNode = triangleNode.getNode("jcr:content");</b>
								</p>
							
							
								<p class="c12">
									<b>for (Iterator i = strings.iterator(); i.hasNext();) {</b>
								</p>
							
							
								<p class="c12">
									<b>String text = (String) i.next();</b>
								</p>
							
							
								<p class="c12">
									<b>Node paraNode = contentNode.addNode("paragraph"); paraNode.setProperty("text", text);</b>
								</p>
							
							
								<p class="c12">
									<b>}</b>
								</p>
							
							
								<p class="c5">
									<br>
									For each string retrieved from <b>strings</b> a new node is created called <b>paragraph</b> which is given a new property called <b>text</b>, which, in turn, is assigned the retrieved string.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.5." id="section_7.1.5."></a> 7.1.5 Adding and Writing Properties
		</h4>
		
			
				
					
						
							
								<p class="c5">
									To add new properties or change the values of existing properties of a node we use the <b>setProperty</b> methods of <b>Node</b>:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name,<br>
										Value value)</b>
									</p>
									<p class="c5">
										Sets the specified (single value) property of this node to the specified <b>value</b>. If the property does not yet exist, it is created. The property type of the property will be that specified by the node type of this node.
									</p>
									<p class="c5">
										If the property type of the supplied <b>Value</b> object is different from that required, then a best-effort conversion is attempted. If the conversion fails, a <b>ValueFormatException</b> is thrown. If another error occurs, a <b>RepositoryException</b> is thrown.
									</p>
									<p class="c5">
										If the node type of this node does not indicate a specific property type, then the property type of the supplied <b>Value</b> object is used and if the property already exists (has previously been set) it assumes both the new value and new property type.
									</p>
									<p class="c5">
										If the property is multi-valued, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										Passing a <b>null</b> as the second parameter removes the property. It is equivalent to calling <b>remove</b> on the <b>Property</b> object itself. For example, <b>N.setProperty("P", (Value)null)</b> would remove property called <b>"P"</b> of the node in <b>N</b>.
									</p>
									<p>
										<a name="OLE_LINK2" id="OLE_LINK2"></a>To save the addition or removal of a property, a <b>save</b> call must be performed that includes the parent of the property in its scope: that is, a <b>save</b> on either the session, this node, or an ancestor of this node. To save a change to an existing property, a <b>save</b> call that includes that property in its scope is required. This means that in addition to the above-mentioned <b>save</b> options, a <b>save</b> on the changed property itself will also work.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the change would violate a node type or implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if <b>this</b> node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name, Value[] values)</b>
									</p>
									<p class="c5">
										Sets the specified (multi-value) property to the specified array of values. If the property does not yet exist, it is created. Same as
									</p>
									<p class="c5">
										<b>setProperty(String name, Value value)</b>
									</p>
									<p class="c5">
										except that an array of <b>Value</b> objects is assigned instead of a single <b>Value</b>.
									</p>
									<p class="c5">
										The property type of the property will be that specified by the node type of this node. If the property type of the supplied <b>Value</b> objects is different from that required, then a best-effort conversion is attempted. If the conversion fails, a <b>ValueFormatException</b> is thrown. All <b>Value</b> objects in the array must be of the same type, otherwise a <b>ValueFormatException</b> is thrown. If the property is not multi-valued then a <b>ValueFormatException</b> is also thrown. If another error occurs, a <b>RepositoryException</b> is thrown.
									</p>
									<p class="c5">
										If the node type of this node does not indicate a specific property type, then the property type of the supplied <b>Value</b> objects is used and if the property already exists it assumes both the new values and the new property type.
									</p>
									<p class="c5">
										Passing a <b>null</b> as the second parameter removes the property. It is equivalent to calling remove on the <b>Property</b> object itself. For example, <b>N.setProperty("P", (Value[])null)</b> would remove property called <b>"P"</b> of the node in <b>N</b>.
									</p>
									<p class="c5">
										Note that this is different from passing an array that contains <b>null</b> elements. In such a case, the array is compacted by removing the <b>null</b>s. The resulting set of values of the property never contains <b>null</b>s. However, the set may be empty: <b>N.setProperty("P", new Value[]{null})</b> would set the property to the empty set of values.
									</p>
									<p class="c5">
										To save the addition or removal of a property, a <b>save</b> call must be performed that includes the parent of the property in its scope: that is, a <b>save</b> on either the session, this node, or an ancestor of this node. To save a change to an existing property, a <b>save</b> call that includes that property in its scope is required. This means that in addition to the above-mentioned <b>save</b> options, a <b>save</b> on the changed property itself will also work.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the change would violate a node type or implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if <b>this</b> node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name,<br>
										Value[] values,<br>
										int type)</b>
									</p>
									<p class="c5">
										Sets the specified (multi-value) property to the specified array of values. If the property does not yet exist, it is created. The type of the property is determined by the <b>type</b> parameter specified.
									</p>
									<p class="c5">
										If the property type of the supplied <b>Value</b> objects is different from that specified, then a best-effort conversion is attempted. If the conversion fails, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If the property already exists it assumes both the new values and the new property type.
									</p>
									<p class="c5">
										All <b>Value</b> objects in the array must be of the same type, otherwise a <b>ValueFormatException</b> is thrown. If the property is not multi-valued then a <b>ValueFormatException</b> is also thrown. If another error occurs, a <b>RepositoryException</b> is thrown.
									</p>
									<p class="c5">
										Passing a <b>null</b> as the second parameter removes the property. It is equivalent to calling remove on the <b>Property</b> object itself. For example, <b>N.setProperty("P", (Value[])null, type)</b> would remove property called <b>"P"</b> of the node in <b>N</b>.
									</p>
									<p class="c5">
										Note that this is different from passing an array that contains <b>null</b> elements. In such a case, the array is compacted by removing the <b>null</b>s. The resulting set of values of the property never contains <b>null</b>s. However, the set may be empty: <b>N.setProperty("P", new Value[]{null}, type)</b> would set the property to the empty set of values.
									</p>
									<p class="c5">
										To save the addition or removal of a property, a <b>save</b> call must be performed that includes the parent of the property in its scope: that is, a <b>save</b> on either the session, this node, or an ancestor of this node. To save a change to an existing property, a <b>save</b> call that includes that property in its scope is required. This means that in addition to the above-mentioned <b>save</b> options, a <b>save</b> on the changed property itself will also work.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the change would violate a node type or implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if <b>this</b> node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name, String[] values)</b>
									</p>
									<p class="c5">
										Sets the specified property to the specified array of values. Same as
									</p>
									<p class="c5">
										<b>setProperty(String name, Value[] values)</b>
									</p>
									<p class="c5">
										except that the values are specified as <b>String</b> objects instead of <b>Value</b> objects.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name,<br>
										String[] values,<br>
										int type)</b>
									</p>
									<p class="c5">
										Sets the specified property to the specified array of values and to the specified type. Same as
									</p>
									<p class="c5">
										<b>setProperty(String name,<br>
										Value[] values,<br>
										int type)</b>
									</p>
									<p class="c5">
										except that the values are specified as <b>String</b> objects instead of <b>Value</b> objects.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name,<br>
										Value value,<br>
										int type)</b>
									</p>
									<p class="c5">
										Sets the specified (single-value) property to the specified value. If the property does not yet exist, it is created. The type of the property is determined by the <b>type</b> parameter specified.
									</p>
									<p class="c5">
										If the property type of the supplied <b>Value</b> object is different from that required, then a best-effort conversion is attempted. If the conversion fails, a <b>ValueFormatException</b> is thrown.
									</p>
									<p class="c5">
										If the property is not single-valued then a <b>ValueFormatException</b> is also thrown.
									</p>
									<p class="c5">
										If the property already exists it assumes both the new value and the new property type.
									</p>
									<p class="c5">
										Passing a <b>null</b> as the second parameter removes the property. It is equivalent to calling <b>remove</b> on the <b>Property</b> object itself. For example, <b>N.setProperty("P", (Value)null, type)</b> would remove property called <b>"P"</b> of the node in <b>N</b>.
									</p>
									<p class="c5">
										To save the addition or removal of a property, a <b>save</b> call must be performed that includes the parent of the property in its scope: that is, a <b>save</b> on either the session, this node, or an ancestor of this node. To save a change to an existing property, a <b>save</b> call that includes that property in its scope is required. This means that in addition to the above-mentioned <b>save</b> options, a <b>save</b> on the changed property itself will also work.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the change would violate a node type or implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if <b>this</b> node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										If another error occurs, a <b>RepositoryException</b> is thrown.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name,<br>
										String value,<br>
										int type)</b>
									</p>
									<p class="c5">
										Sets the specified property to the specified value. Same as
									</p>
									<p class="c5">
										<b>setProperty(String name,<br>
										Value value,<br>
										int type)</b>
									</p>
									<p class="c5">
										except that the value is specified as a <b>String</b> object instead of a <b>Value</b> object.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Property</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setProperty(String name, String value)</b>
									</p>
									<p class="c5">
										<b>setProperty(String name, InputStream value)</b>
									</p>
									<p class="c5">
										<b>setProperty(String name, boolean value)</b>
									</p>
									<p class="c5">
										<b>setProperty(String name, Calendar value)</b>
									</p>
									<p class="c5">
										<b>setProperty(String name, double value)</b>
									</p>
									<p class="c5">
										<b>setProperty(String name, long value)</b>
									</p>
									<p class="c5">
										<b>setProperty(String name, Node value)</b>
									</p>
									<p class="c5">
										Sets the specified property to the specified value. In the context of these methods, each Java type <i>implies</i> a particular property type. The correspondence is:
									</p>
									<p class="c5">
										<b>String: PropertyType.STRING</b>
									</p>
									<p class="c17">
										<b>InputStream: PropertyType.BINARY</b>
									</p>
									<p class="c5">
										<b>boolean: PropertyType.BOOLEAN</b>
									</p>
									<p class="c5">
										<b>Calendar: PropertyType.DATE</b>
									</p>
									<p class="c5">
										<b>double: PropertyType.DOUBLE</b>
									</p>
									<p class="c5">
										<b>long: PropertyType.LONG</b>
									</p>
									<p class="c5">
										<b>Node: PropertyType.REFERENCE</b>
									</p>
									<p class="c5">
										In the case of the signature that takes a <b>Node</b>, the <b>REFERENCE</b> property in question is set to <i>refer</i> to the supplied node (see <a href="#section_6.2.5.4.">6.2.5.4</a> <i>Reference</i>).
									</p>
									<p class="c5">
										The property type of the property being set is determined by the node type of this node. If this property type is something other than that implied by the (Java) type of the passed value, a best-effort conversion is attempted. If the conversion fails, a <b>ValueFormatException</b> is thrown. If the property is multi-valued, a <b>ValueFormatException</b> is also thrown. If another error occurs, a <b>RepositoryException</b> is thrown.
									</p>
									<p class="c5">
										If the node type of <b>this</b> node does not specify a particular property type for the property being set then the property type implied by the (Java) type of the passed value is used and if the property already exists (has previously been set) it assumes both the new value and new type.
									</p>
									<p class="c5">
										Passing a <b>null</b> as the second parameter removes the property. It is equivalent to calling <b>remove</b> on the <b>Property</b> object itself. For example, <b>N.setProperty("P", (Calendar)null)</b> would remove property called <b>"P"</b> of the node in <b>N</b>. Obviously, a <b>null</b> cannot be passed to the signatures that take the primitive types <b>boolean</b>, <b>long</b> or <b>double</b>.
									</p>
									<p class="c5">
										To save the addition or removal of a property, a <b>save</b> call must be performed that includes the parent of the property in its scope: that is, a <b>save</b> on either the session, this node, or an ancestor of this node. To save a change to an existing property, a <b>save</b> call that includes that property in its scope is required. This means that in addition to the above-mentioned <b>save</b> options, a <b>save</b> on the changed property itself will also work.
									</p>
									<p class="c5">
										To create a property of <b>PropertyType.NAME</b> or <b>PropertyType.PATH</b> an explicit type must be specified using a three-argument signature.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the change would violate a node type or implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if <b>this</b> node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<br>
									To change the value of a property that has already been retrieved you can also use the <b>setValue</b> methods in the <b>Property</b> Interface itself:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Property</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>setValue(Value value)</b>
									</p>
									<p class="c5">
										<b>setValue(Value[] values)</b>
									</p>
									<p class="c5">
										<b>setValue(String value)</b>
									</p>
									<p class="c5">
										<b>setValue(String[] values)</b>
									</p>
									<p class="c5">
										<b>setValue(InputStream value)</b>
									</p>
									<p class="c5">
										<b>setValue(double value)</b>
									</p>
									<p class="c5">
										<b>setValue(long value)</b>
									</p>
									<p class="c5">
										<b>setValue(Calendar value)</b>
									</p>
									<p class="c5">
										<b>setValue(boolean value)</b>
									</p>
									<p class="c5">
										<b>setValue(Node node)</b>
									</p>
									<p class="c5">
										Sets the value of this <b>Property</b> to the specified value. The behavior of these methods is identical with their corresponding <b>Node.setProperty</b> signature.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.5.1." id="section_7.1.5.1."></a>7.1.5.1 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									To change the price of a rhombus to 200 we might do the following:
								</p>
							
							
								<p class="c12">
									<b>String path = "products/rhombus/jcr:content/myapp:price";</b>
								</p>
							
							
								<p class="c12">
									<b>root.getProperty(path).setValue(200);</b>
								</p>
							
							
								<p class="c5">
									<br>
									or, alternatively
								</p>
							
							
								<p class="c12">
									<b>String path = "products/rhombus/jcr:content";</b>
								</p>
							
							
								<p class="c12">
									<b>Node rhombus = root.getNode(path);</b>
								</p>
							
							
								<p class="c12">
									<b>rhombus.setProperty("myapp:price", 200);</b>
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.5.2." id="section_7.1.5.2."></a>7.1.5.2 Setting Multi-value vs. Single-value Properties
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Multi-value and single-value properties are set using different signatures of <b>Node.setProperty</b> and <b>Property.setValue</b>. Multi-value properties must set using the signatures that take either a <b>Value[]</b> or <b>String[]</b>. Single value properties must be set using the signatures that take non-array value arguments. An attempt to set a multi-value property with a non-array value argument, or a single-value property with an array value argument, will throw a <b>ValueFormatException</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.5.3." id="section_7.1.5.3."></a>7.1.5.3 Creating Value Objects
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In order to use methods that accept a <b>Value</b> object the application needs a way to produce such objects. This is done by using the methods of the <b>ValueFactory</b> object, which is acquired through <b>Session.getValueFactory()</b> (see 7.1 Writing Repository Content). <b>ValueFactory</b> provides the following methods:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>ValueFactory</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(String value)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of <b>PropertyType.STRING</b> with the specified value.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(String value, int type)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of the <b>PropertyType</b> specified by <b>type</b> with the specified <b>value</b>.
									</p>
									<p class="c5">
										A <b>ValueFormatException</b> is thrown if the specified <b>value</b> cannot be converted to the specified <b>type</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(long value)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of <b>PropertyType.LONG</b> with the specified <b>value</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(double value)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of <b>PropertyType.DOUBLE</b> with the specified <b>value</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(boolean value)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of <b>PropertyType.BOOLEAN</b> with the specified <b>value</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(Calendar value)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of <b>PropertyType.DATE</b> with the specified <b>value</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(InputStream value)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of <b>PropertyType.BINARY</b> with a value consisting of the content of the specified <b>InputStream</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Value</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>createValue(Node value)</b>
									</p>
									<p class="c5">
										Returns a <b>Value</b> object of <b>PropertyType.REFERENCE</b> that holds the UUID of the specified <b>Node</b>. This <b>Value</b> object can then be used to set a property that will be a reference to that <b>Node</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if the specified <b>Node</b> is not referenceable, the current <b>Session</b> is no longer active, or another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.6." id="section_7.1.6."></a> 7.1.6 Removing Nodes and Properties
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Removing a node or property is done with the <b>Item.remove</b> method:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Item</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>remove()</b>
									</p>
									<p class="c5">
										Removes <b>this</b> item (and its subtree).
									</p>
									<p class="c5">
										To persist a removal, a <b>save</b> must be performed that includes the (former) parent of the removed item within its scope.
									</p>
									<p class="c5">
										A <b>ReferentialIntegrityException</b> will be thrown on <b>save</b> if this item or an item in its subtree is currently the target of a <b>REFERENCE</b> property located in this workspace but outside this item's subtree and the current <b>Session</b> has read access to that <b>REFERENCE</b> property.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> will be thrown on <b>save</b> if this item or an item in its subtree is currently the target of a <b>REFERENCE</b> property located in this workspace but outside this item's subtree and the current <b>Session</b> <i>does not</i> have read access to that <b>REFERENCE</b> property.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if removing this item would violate a node type or implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if the parent node of this item is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the removal of this item. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									A property can also be removed by setting its value to <b>null</b>. When this is done, the <b>null</b> parameter must be cast to a non-array type for single value properties and an array type for multi-value properties.
								</p>
							
							
								<p class="c5">
									Note that setting a multi-value property to an array containing <b>null</b> values is different from setting it to a <b>null</b> cast to an array type. In the former case, all <b>null</b> values within the array are removed and the array is compacted to include only non-null values even if this results in a multi-value property being set to an empty array. In the latter case the entire property is removed. For example,
								</p>
							
							
								<p class="c5">
									<b>p.setValue((String[])null)</b>
								</p>
							
							
								<p class="c5">
									would remove property <b>p</b>, whereas
								</p>
							
							
								<p class="c5">
									<b>p.setValue(new String[]{"a", null, "b"})</b> would set <b>p</b> to <b>["a","b"]</b>
								</p>
							
							
								<p class="c5">
									and
								</p>
							
							
								<p class="c5">
									<b>p.setValue(new String[]{null})</b> would set <b>p</b> to the empty array, <b>[]</b>.
								</p>
							
							
								<p class="c5">
									See also <a href="#section_4.7.3.">4.7.3</a> <i>No Null Values</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.7." id="section_7.1.7."></a>7.1.7 Moving and Copying
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Moving and copying of nodes is done through methods of the <b>Session</b> and <b>Workspace</b> interfaces.
								</p>
							
							
								<p class="c5">
									<b>Session</b> provides a <b>move</b> method:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>move(String srcAbsPath, String destAbsPath)</b>
									</p>
									<p class="c5">
										Moves the node at <b>srcAbsPath</b> (and its entire subtree) to the new location at <b>destAbsPath</b>.
									</p>
									<p class="c5">
										In order to persist the change, <b>save</b> must be called on either the session or a common ancestor to both the source and destination locations.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown either immediately (by this method) or on <b>save</b> if performing this operation would violate a node type or implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										As well, a <b>ConstraintViolationException</b> will be thrown on <b>save</b> if an attempt is made to save <i>only</i> either the source or destination node separately.
									</p>
									<p class="c5">
										Note that this behavior differs from that of <b>Workspace.move</b> (see below), which operates directly in the persistent workspace and does not require a <b>save</b>.
									</p>
									<p class="c5">
										The <b>destAbsPath</b> provided must not have an index on its final element. If it does then a <b>RepositoryException</b> is thrown immediately. Strictly speaking, the <b>destAbsPath</b> parameter is actually an <i>absolute path</i> to the parent node of the new location, appended with the new <i>name</i> desired for the moved node. It does not specify a position within the child node ordering. If ordering is supported by the node type of the parent node of the new location, then the newly moved node is appended to the end of the child node list.
									</p>
									<p class="c5">
										This method cannot be used to move just an individual property by itself. It moves an entire node and its subtree (including, of course, any properties contained therein).
									</p>
									<p class="c5">
										If no node exists at <b>srcAbsPath</b> or no node exists one level above <b>destAbsPath</b> (in other words, there is no node that will serve as the parent of the moved item) then a <b>PathNotFoundException</b> is thrown either immediately or on <b>save</b>. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> is thrown either immediately or on save if a property already exists at <b>destAbsPath</b> or a node already exists there and same-name siblings are not allowed. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown either immediately or on save if the parent node of <b>destAbsPath</b> or the parent node of <b>srcAbsPath</b> is versionable and checked-in, or is non-versionable and its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown either immediately or on save if a lock prevents the move. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<b><br>
									Workspace</b> provides a <b>move</b> method as well as the methods <b>copy</b> and <b>clone</b>:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Workspace</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>copy(String srcAbsPath,<br>
										String destAbsPath)</b>
									</p>
									<p class="c5">
										This method copies the node at <b>srcAbsPath</b> and its entire subtree to the new location at <b>destAbsPath</b>. This operation is performed entirely within the persistent workspace, it does not involve transient storage and therefore does not require a <b>save</b>.
									</p>
									<p class="c5">
										Copies of referenceable nodes are automatically given new UUIDs.
									</p>
									<p class="c5">
										The <b>destAbsPath</b> provided must not have an index on its final element. If it does, then a <b>RepositoryException</b> is thrown. Strictly speaking, the <b>destAbsPath</b> parameter is actually an <i>absolute path</i> to the parent node of the new location, appended with the new <i>name</i> desired for the copied node. It does not specify a position within the child node ordering. If ordering is supported by the node type of the parent node of the new location, then the newly moved node is appended to the end of the child node list.
									</p>
									<p class="c5">
										This method cannot be used to copy just an individual property by itself. It copies an entire node and its subtree (including, of course, any properties contained therein).
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown if the operation would violate a node-type or other implementation-specific constraint.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the parent node of <b>destAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the current session (i.e., the session that was used to acquire this <b>Workspace</b> object) does not have sufficient access permissions to complete the operation.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if the node at <b>srcAbsPath</b> or the parent of <b>destAbsPath</b> does not exist.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> is thrown if a property already exists at <b>destAbsPath</b> or a node already exists there and same-name siblings are not allowed.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the copy.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>copy(String srcWorkspace,<br>
										String srcAbsPath,<br>
										String destAbsPath)</b>
									</p>
									<p class="c5">
										This method copies the subtree at <b>srcAbsPath</b> in <b>srcWorkspace</b> to <b>destAbsPath</b> in <b>this</b> workspace. Unlike <b>clone</b>, this method <i>does</i> assign new UUIDs to the new copies of referenceable nodes. This operation is performed entirely within the persistent workspace, it does not involve transient storage and therefore does not require a <b>save</b>.
									</p>
									<p class="c5">
										The <b>destAbsPath</b> provided must not have an index on its final element. If it does, then a <b>RepositoryException</b> is thrown. Strictly speaking, the <b>destAbsPath</b> parameter is actually an <i>absolute path</i> to the parent node of the new location, appended with the new <i>name</i> desired for the copied node. It does not specify a position within the child node ordering. If ordering is supported by the node type of the parent node of the new location, then the new copy of the node is appended to the end of the child node list.
									</p>
									<p class="c5">
										This method cannot be used to copy just an individual property by itself. It copies an entire node and its subtree (including, of course, any properties contained therein).
									</p>
									<p class="c5">
										A <b>NoSuchWorkspaceException</b> is thrown if <b>srcWorkspace</b> does not exist.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown if the operation would violate a node-type or other implementation-specific constraint.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the parent node of <b>destAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the current session (i.e., the session that was used to acquire this <b>Workspace</b> object) does not have sufficient access permissions to complete the operation.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if the node at <b>srcAbsPath</b> in <b>srcWorkspace</b> or the parent of <b>destAbsPath</b> in this workspace does not exist.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> is thrown if a property already exists at <b>destAbsPath</b> or a node already exists there and same-name siblings are not allowed.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the copy.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c12">
										clone(String srcWorkspace,<br>
										String srcAbsPath,<br>
										String destAbsPath,<br>
										boolean removeExisting)
									</p>
									<p class="c5">
										Clones the subtree at the node <b>srcAbsPath</b> in <b>srcWorkspace</b> workspace to <b>destAbsPath</b> in <b>this</b> workspace. Unlike the signature of <b>copy</b> that copies between workspaces, this method <i>does not</i> assign new UUIDs to new referenceable nodes but preserves the UUIDs of their respective source nodes.
									</p>
									<p class="c5">
										If <b>removeExisting</b> is <b>true</b> and an existing node in <b>this</b> workspace (the destination workspace) has the same UUID as a node being cloned from <b>srcWorkspace</b>, then the incoming node takes precedence, and the existing node (and its subtree) is removed. If <b>removeExisting</b> is <b>false</b> then a UUID collision causes this method to throw a <b>ItemExistsException</b> and no changes are made.
									</p>
									<p class="c5">
										If successful, the changes are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										The <b>destAbsPath</b> provided must not have an index on its final element. If it does, then a <b>RepositoryException</b> is thrown. Strictly speaking, the <b>destAbsPath</b> parameter is actually an <i>absolute path</i> to the parent node of the new location, appended with the new <i>name</i> desired for the copied node. It does not specify a position within the child node ordering. If ordering is supported by the node type of the parent node of the new location, then the new clone of the node moved node is appended to the end of the child node list.
									</p>
									<p class="c5">
										This method cannot be used to clone just an individual property by itself. It clones an entire node and its subtree (including, of course, any properties contained therein).
									</p>
									<p class="c5">
										A <b>NoSuchWorkspaceException</b> is thrown if <b>srcWorkspace</b> does not exist.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown if the operation would violate a node-type or other implementation-specific constraint
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the parent node of <b>destAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the current session (i.e. the session that was used to acquire this <b>Workspace</b> object) does not have sufficient access permissions to complete the operation.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if the node at <b>srcAbsPath</b> in <b>srcWorkspace</b> or the parent of <b>destAbsPath</b> in this workspace do not exist.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> is thrown if a property already exists at <b>destAbsPath</b> or a node already exists there and same-name siblings are not allowed or if <b>removeExisting</b> is false and a UUID conflict occurs.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the clone.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>move(String srcAbsPath, String destAbsPath)</b>
									</p>
									<p class="c5">
										Moves the node at <b>srcPath</b> (and its entire subtree) to the new location at <b>destPath</b>. If successful, the change is persisted immediately, there is no need to call <b>save</b>. Note that this is in contrast to <b>Session.move</b> which operates within the transient space and hence requires a <b>save</b>.
									</p>
									<p class="c5">
										The <b>destAbsPath</b> provided must not have an index on its final element. If it does then a <b>RepositoryException</b> is thrown. Strictly speaking, the <b>destAbsPath</b> parameter is actually an <i>absolute path</i> to the parent node of the new location, appended with the new <i>name</i> desired for the moved node. It does not specify a position within the child node ordering. If ordering is supported by the node type of the parent node of the new location, then the newly moved node is appended to the end of the child node list.
									</p>
									<p class="c5">
										This method cannot be used to move just an individual property by itself. It moves an entire node and its subtree (including, of course, any properties contained therein).
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown if the operation would violate a node-type or other implementation-specific constraint
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the parent node of <b>destAbsPath</b> or the parent node of <b>srcAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the current session does not have sufficient access permissions to complete the operation.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if the item at <b>srcAbsPath</b> or the parent of <b>destAbsPath</b> does not exist.
									</p>
									<p class="c5">
										An <b>ItemExistsException</b> is thrown if a property already exists at <b>destAbsPath</b> or a node already exists there and same-name siblings are not allowed.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the move.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.7.1." id="section_7.1.7.1."></a>7.1.7.1 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following code,
								</p>
							
							
								<p class="c12">
									<b>Workspace workspace = ...;</b>
								</p>
							
							
								<p class="c12">
									<b>workspace.move("/products/TV/Paragraph",</b>
								</p>
							
							
								<p class="c12">
									<b>"/products/Radio/Paragraph");</b>
								</p>
							
							
								<p class="c5">
									<br>
									would move a paragraph from one location to another. <b>Workspace.copy</b> works analogously.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.8." id="section_7.1.8."></a> 7.1.8 Updating and Cloning Nodes across Workspaces
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In repositories that have multiple workspaces, a node in one workspace may have <i>corresponding nodes</i> in other workspaces.
								</p>
							
							
								<p class="c5">
									As mentioned in 4.10.2 Multiple Workspaces and Corresponding Nodes, a node's corresponding node is defined as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					A node's corresponding nodes are those with the same <i>correspondence identifier</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					The correspondence identifier of a referenceable node is its UUID.
				</p>
			</li>
			<li>
				<p class="c5">
					The correspondence identifier of a non-referenceable node with at least one referenceable ancestor is the pair consisting of the UUID of its nearest referenceable ancestor and its relative path from that ancestor.
				</p>
			</li>
			<li>
				<p class="c5">
					The correspondence identifier of a non-referenceable node with no referenceable ancestor is its absolute path.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Note also that (as stated in 4.9 Referenceable Nodes) if a repository has a workspace with a referenceable root node then <i>all</i> its workspaces must have referenceable root nodes <i>and</i> those root nodes must all have the same UUID.
								</p>
							
							
								<p class="c5">
									Apart from having the same correspondence identifier, corresponding nodes need have nothing else in common. They can have entirely different properties and child nodes, for example.
								</p>
							
							
								<p class="c5">
									While a node <i>may</i> have a corresponding node in another workspace, it is not <i>required</i> to.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.8.1." id="section_7.1.8.1."></a>7.1.8.1 Creating a Corresponding Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Corresponding nodes can be created by “cloning” a node (or subtree of nodes) from one workspace to another using the <b>Workspace.clone</b> method:
								</p>
							
							
								<p class="c12">
									Workspace.clone(String srcWorkspace,<br>
									String srcAbsPath,<br>
									String destAbsPath,<br>
									boolean removeExisting)
								</p>
							
							
								<p class="c5">
									This method clones the subtree at <b>srcAbsPath</b> in <b>srcWorkspace</b> to <b>destAbsPath</b> in <b>this</b> workspace. The <b>clone</b> method clones both referenceable and nonreferenceable nodes. In the case of referenceable nodes <b>clone</b> preserves the node's UUID so that the new node in the destination workspace has the same UUID as the node in the source workspace.
								</p>
							
							
								<p class="c5">
									For a non-referenceable node, a corresponding node in another workspace can be created either through <b>clone</b>, or simply by creating a node in the destination workspace (using <b>Node.addNode</b>) with the same relative path to the nearest referenceable node.
								</p>
							
							
								<p class="c5">
									However, the use of <b>clone</b> is <i>required</i> for the creation corresponding referenceable nodes because simply creating a new referenceable node at the same path in the other workspace will not work, since the new node will automatically be assigned a new UUID and not the same UUID as its correspondee.
								</p>
							
							
								<p class="c5">
									If there already exists anywhere in this workspace a node with the same UUID as an incoming node from <b>srcWorkspace</b>, and <b>removeExisting</b> is <b>false</b>, then <b>clone</b> will throw an <b>ItemExistsException</b>.
								</p>
							
							
								<p class="c5">
									If <b>removeExisting</b> is <b>true</b> then the existing node is removed from its current location and the cloned node with the same UUID from <b>srcWorkspace</b> is copied to this workspace as part of the copied subtree (that is, not into the former location of the old node). The subtree of the cloned node will reflect the clones state in <b>srcWorkspace</b>, in other words the existing node will be moved <i>and</i> changed. If the existing node cannot be moved and changed because of node type constraints, access control constraints or because its parent is checked-in (or its parent is non-versionable but its nearest versionable ancestor is checked-in), then the appropriate exception is thrown (<b>ConstraintViolationException</b>, <b>AccessControlException</b> or <b>VersionException</b>, respectively).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.8.2." id="section_7.1.8.2."></a>7.1.8.2 Update
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Node correspondence governs the behavior of the <b>update</b> method. This method causes <b>this</b> node to be updated to reflect the state of its corresponding node in <b>srcWorkspace</b>.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>update(String srcWorkspaceName)</b>
									</p>
									<p class="c5">
										If this node does have a corresponding node in the workspace <b>srcWorkspaceName</b>, then this replaces this node and its subtree with a clone of the corresponding node and its subtree.
									</p>
									<p class="c5">
										If this node does not have a corresponding node in the workspace <b>srcWorkspaceName</b>, then the update method has no effect.
									</p>
									<p class="c5">
										If the <b>update</b> succeeds, the changes made to <b>this</b> node and its subtree are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										Note that <b>update</b> does not respect the checked-in status of nodes. An <b>update</b> may change a node even if it is currently checked-in (this fact is only relevant in an implementation that supports versioning, see <a href="#section_8.2.">8.2</a> <i>Versioning</i>).
									</p>
									<p class="c5">
										If the specified <b>srcWorkspace</b> does not exist, a <b>NoSuchWorkspaceException</b> is thrown.
									</p>
									<p class="c5">
										If the current session does not have sufficient permissions to perform the operation, then an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Session</b> (not necessarily this <b>Node</b>) has pending unsaved changes.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the update.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.8.3." id="section_7.1.8.3."></a>7.1.8.3 getCorrespondingNodePath
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The API also provides a method for quickly finding the path of a node's corresponding node (if it exists) in another workspace:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										String
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getCorrespondingNodePath(String workspaceName)</b>
									</p>
									<p class="c5">
										Returns the absolute path of the node in the specified workspace that corresponds to <b>this</b> node.
									</p>
									<p class="c5">
										If no corresponding node exists then an <b>ItemNotFoundException</b> is thrown.
									</p>
									<p class="c5">
										If the specified workspace does not exist then a <b>NoSuchWorkspaceException</b> is thrown.
									</p>
									<p class="c5">
										If the current <b>Session</b> does not have sufficient permissions to perform this operation, an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.1.9." id="section_7.1.9."></a>7.1.9 Referenceable Nodes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A node that is referenceable has an independent identity from its position in the workspace hierarchy (by virtue of its UUID): it maintains its identity regardless of where it is moved in the hierarchy.
								</p>
							
							
								<p class="c5">
									Non-referenceable nodes, on the other hand, are intrinsically tied to their position in the hierarchy relative to their nearest referenceable ancestor. If a non-referenceable node is moved from its position it becomes, in effect, a different node.
								</p>
							
							
								<p class="c14">
									Consequently, a referenceable node and its non-referenceable sub-nodes form a natural unit within the WS hierarchy. It is this unit that is respected during a <b>save</b>, <b>update</b> and <b>merge</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.10." id="section_7.1.10."></a>7.1.10 Treatment of UUIDs
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A number of different methods in the API transfer node state from one location to another. They often differ in how they treat the UUID of the node. Some methods always behave the same way in this regard, others have various options that control their behavior. The following table summarizes the behaviors of the methods.
								</p>
							
						
					
				
			
		
		<table border="1" cellpadding="7" cellspacing="0">
			
			
			
			
			
			
			<tr valign="top">
				<td rowspan="2">
					<p class="c5">
						<b>Method</b>
					</p>
				</td>
				<td rowspan="2">
					<p class="c5">
						<b>New UUID</b>
					</p>
				</td>
				<td colspan="3">
					<p class="c5">
						<b>Keep UUID</b> (<i>3</i> <i>behaviors on</i> <i>conflict</i>)
					</p>
				</td>
				<td rowspan="2">
					<p class="c5">
						<b>Comments</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c5">
						<b>Throw</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>Remove from existing location</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>Replace at existing location</b>
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c5">
						<b>Workspace.copy<br></b>(see <a href="#section_7.1.7.">7.1.7</a> <i>Moving and Copying</i>)
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						<b>copy</b> (both within and between workspaces) simply creates a new UUID for any referenceable nodes it copies.
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c5">
						<b>Session.save</b><br>
						<b>Item.save<br></b>(see <a href="#section_7.1.">7.1</a> <i>Writing Repository Content</i>)
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>save</b> pushes items to the persistent workspace, replacing existing items using UUID matching, wherever they may be in terms of path (non-referenceable nodes are kept bound to their UUID-bearing ancestor, however).
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c5">
						<b>Node.update<br></b>(see <a href="#section_7.1.8.">7.1.8</a> <i>Updating and Cloning Nodes across Workspaces</i>)
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>update</b> pulls the state of <b>this</b> node from another workspace using UUID matching, regardless of where (in terms of path) the source node is in the source workspace.
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c5">
						<b>Workspace.clone<br></b>(see <a href="#section_7.1.7.">7.1.7</a> <i>Moving and Copying</i>)
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						<b>clone</b> keeps UUIDs. There are two options to deal with cases where this workspace already contains a node with the same UUID as one being cloned over: either throw, or remove the existing node in this workspace.
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c5">
						<b>Node.restore</b><br>
						<b>Node.restoreByLabel</b><br>
						<b>Workspace.restore<br></b>(see <a href="#section_8.2.">8.2</a> <i>Versioning</i>)
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						no
					</p>
				</td>
				<td>
					<p class="c5">
						<b>restore</b> and <b>restoreByLabel</b> keep UUIDs. Similar to <b>clone</b>, there are two options to deal with cases where this workspace already contains a node with the same UUID as being copied in as part of a restored version: either throw, or remove the existing node in this workspace.
					</p>
				</td>
			</tr>
			<tr valign="top">
				<td>
					<p class="c5">
						<b>Workspace.importXML<br>
						Session.importXML</b><br>
						<b>Session.<br>
						getImportContentHandler</b>,<br>
						<b>Workspace.<br>
						getImportContentHandler</b><br>
						(see <a href="#section_7.3.">7.3</a> <i>Importing Repository Content</i>)
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						<b>yes</b>
					</p>
				</td>
				<td>
					<p class="c5">
						All four options are supported.
					</p>
				</td>
			</tr>
		</table>
		
			
				
					
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.1.11." id="section_7.1.11."></a>7.1.11 Ordering Child Nodes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If a node supports <i>orderable child nodes</i> then the following method can be used to arrange the order of its child nodes.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>orderBefore(String srcChildRelPath,<br>
										String destChildRelPath)</b>
									</p>
									<p class="c5">
										If this node supports child node ordering, this method inserts the child node at <b>srcChildRelPath</b> before its sibling, the child node at <b>destChildRelPath</b>, in the child node list. To place the node <b>srcChildRelPath</b> at the end of the list, a <b>destChildRelPath</b> of <b>null</b> is used.
									</p>
									<p class="c5">
										Note that (apart from the case where <b>dest</b><b>Child</b><b>RelPath</b> is <b>null</b>) both of these arguments must be relative paths of depth one, in other words they are the <i>names</i> of the child nodes, possibly suffixed with an index (see <a href="#section_4.6.1.">4.6.1</a> <i>Names vs. Paths</i>).
									</p>
									<p class="c5">
										If <b>srcChildRelPath</b> and <b>destChildRelPath</b> are the same, then no change is made.
									</p>
									<p class="c5">
										Changes to ordering of child nodes are persisted on <b>save</b> of the parent node.
									</p>
									<p class="c5">
										If this node does not support child node ordering, then a <b>UnsupportedRepositoryOperationException</b> thrown.
									</p>
									<p class="c5">
										If <b>srcChildRelPath</b> is not the relative path to a child node of this node then an <b>ItemNotFoundException</b> is thrown.
									</p>
									<p class="c5">
										If <b>destChildRelPath</b> is neither the relative path to a child node of this node nor <b>null</b>, then an <b>ItemNotFoundException</b> is also thrown.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately (by this method), or on <b>save</b>, if this operation would violate a implementation-specific constraint. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> will be thrown either immediately (by this method), or on <b>save</b>, if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> will be thrown either immediately (by this method), or on <b>save</b>, if a lock prevents the re-ordering. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										If another error occurs a <b>RepositoryException</b> is thrown.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<br>
									If a node type returns <b>true</b> on a call to <b>NodeType.hasOrderableChildNodes()</b>, then all nodes of that node type <i>must</i> support the method <b>Node.orderBefore</b>. If a node type returns <b>false</b> on a call to this method, then nodes of that node type <i>may</i> support <b>Node.orderBefore</b>. Only the primary node type of a node controls that node's status in this regard. This setting on a mixin node type will not have any effect on the node.
								</p>
							
							
								<p class="c5">
									If a node has orderable child nodes then at any time the current order of its child nodes is reflected in the order of nodes in the iterator returned by <b>Node.getNodes</b>.
								</p>
							
							
								<p class="c5">
									If a node does not have orderable child nodes then the order of nodes returned by <b>Node.getNodes</b> is not guaranteed and may change at any time.
								</p>
							
							
								<p class="c5">
									Note that the order of properties returned by <b>Node.getProperties</b> is never client-controllable.
								</p>
							
							
								<p class="c5">
									See <a href="#section_4.4.">4.4</a> <i>Orderable Child Nodes</i>.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_7.2." id="section_7.2."></a> 7.2 Adding and Deleting Namespaces
		</h3>
		
			
				
					
						
							
								<p class="c5">
									As discussed in <a href="#section_6.3.">6.3</a> <i>Namespaces</i>, above, each content repository has a single, persistent namespace registry represented by the <b>NamespaceRegistry</b> object accessed via <b>Workspace.getNamespaceRegistry()</b>. In level 1 only the <b>NamespaceRegistry</b> methods related to discovering information must function. In level 2 the <b>NamespaceRegistry</b> additionally allows for persistent changes to namespace mappings using the following methods:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>NamespaceRegistry</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>registerNamespace(String prefix, String uri)</b>
									</p>
									<p class="c5">
										Sets a one-to-one mapping between <b>prefix</b> and <b>uri</b> in the global namespace registry of this repository.
									</p>
									<p class="c5">
										Assigning a new prefix to a URI that already exists in the namespace registry erases the old prefix. In general this can be done, though an implementation is free to prevent particular remappings by throwing a <b>NamespaceException</b>.
									</p>
									<p class="c5">
										On the other hand, taking a prefix that is already assigned to a URI and re-assigning it to a new URI in effect unregisters that URI. Therefore, the same restrictions apply to this operation as to <b>NamespaceRegistry.unregisterNamespace</b>:
									</p>
									<ul>
										<li>
											<p class="c5">
												Attempting to re-assign a built-in prefix (<b>jcr</b>, <b>nt</b>, <b>mix</b>, <b>xml</b> or the empty prefix) to a new URI will throw a <b>NamespaceException</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												Attempting to re-assign a prefix that is currently assigned to a URI that is present in content (either within an item name or within the value of a <b>NAME</b> or <b>PATH</b> property) will throw a <b>NamespaceException</b>. This includes prefixes in use within in-content node type definitions.
											</p>
										</li>
										<li>
											<p class="c5">
												Attempting to register a namespace with a prefix that begins with the characters “<b>xml</b>” (in any combination of case) will throw a <b>NamespaceException</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												An implementation may prevent the re-assignment of any other namespace prefixes for implementation-specific reasons by throwing a <b>NamespaceException</b>.
											</p>
										</li>
									</ul>
									<p class="c5">
										In a level 1 implementation, this method always throws an <b>UnsupportedRepositoryOperationException</b>.
									</p>
									<p class="c5">
										If the session associated with the <b>Workspace</b> object through which this registry was acquired does not have sufficient permissions to register the namespace an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>unregisterNamespace(String prefix)</b>
									</p>
									<p class="c5">
										Removes a namespace mapping from the registry. The following restrictions apply:
									</p>
									<ul>
										<li>
											<p class="c5">
												Attempting to unregister a built-in namespace (<b>jcr</b>, <b>nt</b>, <b>mix</b>, <b>xml</b> or the empty namespace) will throw a <b>NamespaceException</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												Attempting to unregister a namespace that is currently present in content (either within an item name or within the value of a <b>NAME</b> or <b>PATH</b> property) will throw a <b>NamespaceException</b>. This includes prefixes in use within in-content node type definitions.
											</p>
										</li>
										<li>
											<p class="c5">
												An attempt to unregister a namespace that is not currently registered will throw a <b>NamespaceException</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												An implementation may prevent the unregistering of any other namespace for implementation-specific reasons by throwing a <b>NamespaceException</b>.
											</p>
										</li>
									</ul>
									<p class="c5">
										In a level 1 implementation, this method always throws an <b>UnsupportedRepositoryOperationException</b>.
									</p>
									<p class="c5">
										If the session associated with the <b>Workspace</b> object through which this registry was acquired does not have sufficient permissions to unregister the namespace an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p class="c5">
									<br>
									Once registered, a prefix can be used in the name of any node or property in the repository. The prefix serves as shorthand for the URI to which it is mapped. Because the space of URIs is universal managed, the combination of the per-repository namespace and the larger URI namespace can be used to provide universally uniqueness of node or property names. Of course, just as in the case of XML namespaces, ensuring this universal uniqueness requires applications to map their application-specific prefixes to URIs that are uniquely identified with that particular application.
								</p>
							
							
								<p class="c5">
									The namespace registry always contains at least the following built-in mappings, which cannot be removed through the API:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>jcr -&gt; http://www.jcp.org/jcr/1.0</b><br>
					Reserved for items defined within built-in node types. For example <b>jcr:content</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>nt -&gt; http://www.jcp.org/jcr/nt/1.0<br></b>Reserved for the names of built-in primary node types.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>mix -&gt; http://www.jcp.org/jcr/mix/1.0<br></b>Reserved for the names of built-in mixin node types.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>xml</b> <b>-&gt; http://www.w3.org/XML/1998/namespace</b><br>
					Reserved for reasons of compatibility with XML.
				</p>
			</li>
			<li>
				<p>
					“” (the empty prefix) -&gt; “”(the empty URI)<br>
					This makes the <i>default namespace</i> the <i>empty URI</i>. In effect this means that a name without a prefix is identical in both its prefixed form and in its fully qualified form (i.e. when it is stored internally as <i>URI plus local name</i>). See <a href="#section_6.3.3.">6.3.3</a> <i>Internal Storage of Names and Values</i>.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_7.2.1." id="section_7.2.1."></a> 7.2.1 Visibility of Namespace Registry Changes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A content repository implementation must ensure that changes to the persistent namespace registry are immediately visible to all sessions.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_7.3." id="section_7.3."></a> 7.3 Importing Repository Content
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Level 2 repositories must support the import of content from either of the standard XML mappings, system view and document view (see <a href="#section_6.4.">6.4</a> <i>XML Mappings</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.3.1." id="section_7.3.1."></a>7.3.1 Import from System View
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Given a system view XML document the subtree constructed upon import is determined by reversing the mapping discussed in <a href="#section_6.4.1.">6.4.1</a> <i>System View XML Mapping</i>. The mapping is largely straightforward (though see <a href="#section_7.3.3.">7.3.3</a> <i>Respecting Property Semantics</i> and <a href="#section_7.3.8.">7.3.8</a> <i>Importing jcr:root</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.3.2." id="section_7.3.2."></a> 7.3.2 Import from Document View
		</h4>
		
			
				
					
						
							
								<p class="c5">
									One of the applications for which the document view mapping is designed is to allow the import of arbitrary XML into a content repository (another application is to provide a context in which XPath queries are more readable than they would be in system view, see <a href="#section_6.6.1.">6.6.1</a> <i>XPath over Document View</i>). On import, the repository first checks if the incoming XML appears to be a system view document. If it does not then it is assumed to be in document view form, and the following occurs:
								</p>
							
						
					
				
			
		
		<ol>
			<li>
				<p class="c5">
					Namespace declarations in the incoming XML document that do not already exist in the repository namespace registry are added to the repository namespace registry.
				</p>
			</li>
			<li>
				<p class="c5">
					Each XML element <b>E</b> becomes a content repository node of the same name, <b>E</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The node type of the content repository node <b>E</b> is determined by the implementation in accordance with its policy on respecting property semantics (see <a href="#section_7.3.3.">7.3.3</a> <i>Respecting Property Semantics</i> and <a href="#section_7.3.4.">7.3.4</a> <i>Determining Node Types</i>).
				</p>
			</li>
			<li>
				<p class="c5">
					Each child XML element <b>C</b> of XML element <b>E</b> becomes a content repository child node <b>C</b> of node <b>E</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Each XML attribute <b>A</b> within an XML element <b>E</b> becomes a property <b>A</b> of content repository node <b>E</b>. The value of each XML attribute <b>A</b> becomes the value of the corresponding property <b>A</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The type of each imported property is determined by the implementation in accordance with its policy on respecting property semantics (see <a href="#section_7.3.3.">7.3.3</a> <i>Respecting Property Semantics</i> and <a href="#section_7.3.4.">7.3.4</a> <i>Determining Node Types</i>).
				</p>
			</li>
			<li>
				<p class="c5">
					Escape sequences representing non-XML-valid characters in element names and whitespace in attribute values may be encountered if the incoming XML stream is the product of an earlier document view export (see <a href="#section_6.4.2.">6.4.2</a> <i>Document View XML Mapping</i>). In these cases, whether the escape sequences are decoded is left up to the implementation. Note that the predefined entity references <b>&amp;amp;</b>, <b>&amp;lt;</b>, <b>&amp;gt;</b>, <b>&amp;apos;</b> and <b>&amp;quot;</b>, as well as all other entity and character references, must be decoded in any case, in accordance with the XML specification).
				</p>
			</li>
			<li>
				<p class="c5">
					An implementation that respects node type information may be able to determine whether a particular attribute is intended to be a single or multi value property, and treat any spaces embedded in the value according (either as delimiters or as literal spaces). Implementations are also free to rely on other out-of-band information (such as any schema associated by the incoming XML) to help determine the intended interpretation of whitespace with a particular incoming attribute value.
				</p>
			</li>
			<li>
				<p class="c5">
					Text within an XML element <b>E</b> becomes a <b>STRING</b> property called <b>jcr:xmlcharacters</b> of a node called <b>jcr:xmltext</b>, which itself becomes a child node of the node <b>E</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					If import is done through the <b>ContentHandler</b> returned by <b>getImportContentHandler</b>, the value of <b>E/jcr:xmltext/jcr:xmlcharacters</b> will be the character data passed to <b>ContentHandler.characters</b>. Data passed to <b>ContentHandler.ignorableWhitespace</b> is ignored. If import is done through <b>importXML</b>, pure whitespace between elements (that is, containing no non-whitespace characters) is ignored. However, whitespace leading, trailing and between non-whitespace characters is included in the text that is stored in <b>E/jcr:xmltext/jcr:xmlcharacters</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					An XML element can have a child element and an attribute with the same name while a content repository node cannot have a child node and property with the same name. For example, <b>&lt;a b="x"&gt;&lt;b/&gt;&lt;/a&gt;</b> would imply a content repository node with one property called <b>b</b> and one child node also called <b>b</b>, which is not allowed. Therefore if such a fragment of XML is encountered on import it is an implementation issue as to how to deal with it.
				</p>
			</li>
		</ol>
		<h4>
			<a name="section_7.3.2.1." id="section_7.3.2.1."></a>7.3.2.1 Roundtripping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Upon document view import, a content repository will automatically add repository metadata in the form of extra properties (at least <b>jcr:primaryType</b>, for example) if these are not already present in the incoming XML, and of course, in the case of an arbitrary XML document, they will not be.
								</p>
							
							
								<p class="c5">
									When re-exported using document view, the resulting XML will contain these extra properties in the form of XML attributes that may not have been present in the imported XML. As a result, if roundtripping of arbitrary XML is desired, the application must take care of stripping out unwanted repository-related meta-data like the <b>jcr:primaryType</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.3.2.2." id="section_7.3.2.2."></a>7.3.2.2 Example
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following XML document
								</p>
							
						
					
				
			
			
				<br>
				&lt;?xml version="1.0" encoding="UTF-8"?&gt;
			
			
				<br>
				&lt;myapp:document xmlns:myapp="http://mycorp.com/myapp"
			
			
				<br>
				myapp:title="JSR 170"
			
			
				<br>
				myapp:lead="Content Repository"&gt;
			
			
				<br>
				&lt;myapp:body&gt;
			
			
				<br>
				&lt;myapp:paragraph myapp:title="Node Types"&gt;
			
			
				<br>
				myapp:text="An important feature..."/&gt;
			
			
				<br>
				&lt;/myapp:body&gt;
			
			
				<br>
				&lt;/myapp:document&gt;
			
			
				
					
						
							
								<p class="c5">
									<br>
									when imported in document view would result in the addition of the following mapping to the repository namespace registry:
								</p>
							
							
								<p class="c5">
									<b>myapp -&gt; http://mycorp.com/myapp<br>
									<br></b> and the creation of the following subtree
								</p>
							
							
								<p class="c12">
									<b>Node</b>
								</p>
							
							
								<p class="c12">
									<b>Property = "value"</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									<b>myapp:document</b>
								</p>
							
							
								<p>
									├─<b>jcr:primaryType = "nt:unstructured"</b>
								</p>
							
							
								<p>
									├─<b>myapp:title = "JSR 170"</b>
								</p>
							
							
								<p>
									├─<b>myapp:lead = "Content Repository"</b>
								</p>
							
							
								<p>
									└─<b>myapp:body</b>
								</p>
							
							
								<p>
									├─<b>jcr:primaryType = "nt:unstructured"</b>
								</p>
							
							
								<p>
									└─<b>myapp:paragraph</b>
								</p>
							
							
								<p>
									├─<b>jcr:primaryType = "nt:unstructured"</b>
								</p>
							
							
								<p>
									├─<b>myapp:title = "Node Types"</b>
								</p>
							
							
								<p>
									└─<b>myapp:text = "An important feature..."</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									Note that the use of <b>nt:unstructured</b> as the default node type is an implementation-level issue, so the example is a valid outcome of the import, but not the only one.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.3.3." id="section_7.3.3."></a> 7.3.3 Respecting Property Semantics
		</h4>
		
			
				
					
						
							
								<p class="c5">
									During either system or document view import, elements (in system view) or attributes (in document view) may be encountered that correspond to properties with repository-level semantics. This includes, in particular, the properties that are defined in <b>nt:base</b>, <b>mix:lockable</b>, <b>mix:referenceable</b> or <b>mix:versionable</b> (that is properties such as <b>jcr:primaryType</b>, <b>jcr:mixinTypes</b>, <b>jcr:uuid</b>, <b>jcr:lockIsDeep</b>, and so forth).
								</p>
							
							
								<p class="c5">
									When an element or attribute representing such a property is encountered, an implementation may either <i>skip</i> it or <i>respect</i> it.
								</p>
							
							
								<p class="c5">
									To respect it means to import it and alter the internal state of the repository in accordance with the semantics of the property in the given implementation. For example, to respect <b>jcr:primaryType</b> means to attempt to create a node of the indicated primary node type. If the node type in question is not supported by the implementation, an exception is thrown (see 7.3.6 Workspace Import Methods for details).
								</p>
							
							
								<p class="c5">
									To skip the element or attribute means not to import it all. <i>It does not mean to import it but then ignore its semantic implications</i>.
								</p>
							
							
								<p class="c5">
									The implementation-specific policy regarding what to skip and what to respect must be internally consistent. For example, it makes no sense to skip <b>jcr:mixinTypes</b> (thus missing the presence of <b>mix:lockable</b>, for example) and yet respect <b>jcr:lockOwner</b> and <b>jcr:lockIsDeep</b>.
								</p>
							
							
								<p class="c5">
									If an implementation chooses to skip <b>jcr:primaryType</b>, the node type of the imported node is determined by the implementation (see <a href="#section_7.3.4.">7.3.4</a> <i>Determining Node Types</i>, immediately below).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.3.4." id="section_7.3.4."></a>7.3.4 Determining Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In cases of XML import where primary node type information is unavailable, either because it is skipped (see <a href="#section_7.3.3.">7.3.3</a> <i>Respecting Property Semantics</i>, immediately above) or because it is not available in the first place (as is the case on document view import of arbitrary XML), the implementation must determine an appropriate node type to assign to each newly created node. This specification does not attempt to define or restrict how this is done. However, simply for the sake of illustration, some of the possibilities include:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Making all imported nodes <b>nt:unstructured</b> (obviously this will only work if the implementation in question supports that node type).
				</p>
			</li>
			<li>
				<p class="c5">
					Dynamically creating node types appropriate to the incoming nodes. This approach might be suitable in cases where the incoming structures all fall into a few well defined and easily recognized patterns.
				</p>
			</li>
			<li>
				<p class="c5">
					Use node types created according to structure information provided to the repository from an external source such as a schema.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_7.3.5." id="section_7.3.5."></a> 7.3.5 Determining Property Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In document view import (unlike system view import) property type information is not explicitly recorded. As a result, the implementation must determine a suitable property type for each incoming property. The determination of the property type for a particular incoming property must be done according to the following principles:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					If the property type is determinable from the node type assigned to its node (regardless of how this node type is itself determined; see <a href="#section_7.3.4.">7.3.4</a> <i>Determining Node Types</i>) then that property type is used.
				</p>
			</li>
			<li>
				<p class="c5">
					If the property type is not determinable from the node type assigned to its node then the determination of the property is left up to the implementation. The most common possibility is to default to the type <b>STRING</b>, though this is not required. Some implementations may choose, for example, to attempt “guess” the type according to an analysis of the content. This specification does not attempt to define or restrict how an implementation handles this case.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_7.3.6." id="section_7.3.6."></a> 7.3.6 Workspace Import Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Workspace</b> interface provides the following methods for importing content into the repository:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Workspace</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>ContentHandler</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getImportContentHandler(<br>
										String parentAbsPath,<br>
										int uuidBehavior)</b>
									</p>
									<p class="c5">
										Returns an <b>org.xml.sax.ContentHandler</b> which can be used to push SAX events into the repository. If the incoming XML stream (in the form of SAX events) does not appear to be a <i>system view</i> XML document then it is interpreted as a <i>document view</i> XML document.
									</p>
									<p class="c5">
										The incoming XML is deserialized into a subtree of items immediately below the node at <b>parentAbsPath</b>.
									</p>
									<p class="c5">
										This method simply returns the <b>ContentHandler</b> without altering the state of the repository; the actual deserialization is done through the methods of the <b>ContentHandler</b>. Invalid XML data will cause the <b>ContentHandler</b> to throw a <b>SAXException</b>.
									</p>
									<p class="c5">
										As SAX events are fed into the <b>ContentHandler</b>, changes are made directly at the workspace level, without going through the <b>Session</b>. As a result, there is not need to call <b>save</b>. The advantage of this direct-to-workspace method is that a large import will not result in a large cache of pending nodes in the <b>Session</b>. The disadvantage is that structures that violate node type constraints cannot be imported, fixed and then saved. Instead, a constraint violation will cause the <b>ContentHandler</b> to throw a <b>SAXException</b>. See <b>Session.getImportContentHandler</b> for a version of this method that <i>does</i> go through the <b>Session</b>.
									</p>
									<p class="c5">
										The flag <b>uuidBehavior</b> governs how the UUIDs of incoming (deserialized) nodes are handled. There are four options (defined as constants in the interface <b>javax.jcr.ImportUUIDBehavior</b>):
									</p>
									<ul>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_CREATE_NEW</b>: Incoming referenceable nodes are assigned newly created UUIDs upon addition to the workspace. As a result UUID collisions never occur.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then the already existing node (and its subtree) is removed from wherever it may be in the workspace before the incoming node is added. Note that this can result in nodes “disappearing” from locations in the workspace that are remote from the location to which the incoming subtree is being written.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REPLACE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace, then the already existing node is replaced by the incoming node in the same position as the existing node. Note that this may result in the incoming subtree being disaggregated and “spread around” to different locations in the workspace. In the most extreme case this behavior may result in no node at all being added as child of <b>parentAbsPath</b>. This will occur if the topmost element of the incoming XML has the same UUID as an existing node elsewhere in the workspace.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_THROW</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then a <b>SAXException</b> is thrown by the <b>ContentHandler</b> during deserialization.
											</p>
										</li>
									</ul>
									<p class="c5">
										A <b>SAXException</b> will be thrown by the returned <b>ContentHandler</b> during deserialization if the top-most element of the incoming XML would deserialize to a node with the same name as an existing child of <b>parentAbsPath</b> and that child does not allow same-name siblings.
									</p>
									<p class="c5">
										A <b>SAXException</b> will also be thrown by the returned <b>ContentHandler</b> during deserialization if <b>uuidBehavior</b> is set to <b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b> and an incoming node has the same UUID as the node at <b>parentAbsPath</b> or one of its ancestors.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown if no node exists at <b>parentAbsPath</b>.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown if the new subtree cannot be added to the node at <b>parentAbsPath</b> due to node-type or other implementation-specific constraints, and this can be determined before the first SAX event is sent.
									</p>
									<p class="c5">
										Unlike <b>Session.getImportContentHandler</b>, this method will also enforce node type constraints by having the returned <b>ContentHandler</b> throw a <b>SAXException</b> during deserialization. However, which node type constraints are enforced depends upon whether node type information in the imported data is respected, and this is an implementation-specific issue (see 7.3.3 Respecting Property Semantics).
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the node at <b>parentAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the addition of the subtree.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the session associated with this <b>Workspace</b> object does not have sufficient permissions to perform the import.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>importXML(String parentAbsPath,<br>
										InputStream in,<br>
										int uuidBehavior)</b>
									</p>
									<p class="c5">
										Deserializes an XML document and adds the resulting item subtree as a child of the node at <b>parentAbsPath</b>.
									</p>
									<p class="c5">
										If the incoming XML stream does not appear to be a <i>system view</i> XML document then it is interpreted as a <i>document view</i> XML document.
									</p>
									<p class="c5">
										Changes are made directly at the workspace level, without going through the <b>Session</b>. As a result, there is not need to call <b>save</b>. The advantage of this direct-to-workspace method is that a large import will not result in a large cache of pending nodes in the <b>Session</b>. The disadvantage is that invalid data cannot be imported, fixed and then saved. Instead, invalid data will cause this method to throw an <b>InvalidSerializedDataException</b>. See <b>Session.importXML</b> for a version of this method that <i>does</i> go through the <b>Session</b>.
									</p>
									<p class="c5">
										The flag <b>uuidBehavior</b> governs how the UUIDs of incoming (deserialized) nodes are handled. There are four options (defined as constants in the interface <b>javax.jcr.ImportUUIDBehavior</b>):
									</p>
									<ul>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_CREATE_NEW</b>: Incoming referenceable nodes are assigned newly created UUIDs upon addition to the workspace. As a result UUID collisions never occur.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then the already existing node (and its subtree) is removed from wherever it may be in the workspace before the incoming node is added. Note that this can result in nodes “disappearing” from locations in the workspace that are remote from the location to which the incoming subtree is being written.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REPLACE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then the already existing node is replaced by the incoming node in the same position as the existing node. Note that this may result in the incoming subtree being disaggregated and “spread around” to different locations in the workspace. In the most extreme edge case this behavior may result in no node at all being added as child of <b>parentAbsPath</b>. This will occur if the topmost element of the incoming XML has the same UUID as an existing node elsewhere in the workspace.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_THROW</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then an <b>ItemExistsException</b> is thrown.
											</p>
										</li>
									</ul>
									<p class="c5">
										An <b>ItemExistsException</b> will be thrown if the top-most element of the incoming XML would deserialize to a node with the same name as an existing child of <b>parentAbsPath</b> and that child does not allow same-name siblings.
									</p>
									<p class="c5">
										An <b>IOException</b> is thrown if an I/O error occurs.
									</p>
									<p class="c5">
										If no node exists at <b>parentAbsPath</b>, a <b>PathNotFoundException</b> is thrown.
									</p>
									<p class="c5">
										If node-type or other implementation-specific constraints prevent the addition of the subtree, a <b>ConstraintViolationException</b> is thrown.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will also be thrown if <b>uuidBehavior</b> is set to <b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b> and an incoming node has the same UUID as the node at <b>parentAbsPath</b> or one of its ancestors.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the node at <b>parentAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the addition of the subtree.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> is thrown if the session associated with this <b>Workspace</b> object does not have sufficient permissions to perform the import.
									</p>
									<p class="c5">
										If another error occurs, a <b>RepositoryException</b> is thrown.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.3.7." id="section_7.3.7."></a>7.3.7 Session Import Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Session</b> contains the following methods for importing and exporting content:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>ContentHandler</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getImportContentHandler(String parentAbsPath,<br>
										int uuidBehavior)</b>
									</p>
									<p class="c5">
										Returns an <b>org.xml.sax.ContentHandler</b> which can be used to push SAX events into the repository. If the incoming XML stream (in the form of SAX events) does not appear to be a <i>system view</i> XML document then it is interpreted as a <i>document view</i> XML document.
									</p>
									<p class="c5">
										The incoming XML is deserialized into a subtree of items immediately below the node at <b>parentAbsPath</b>.
									</p>
									<p class="c5">
										This method simply returns the <b>ContentHandler</b> without altering the state of the session; the actual deserialization to the session transient space is done through the methods of the <b>ContentHandler</b>. Invalid XML data will cause the <b>ContentHandler</b> to throw a <b>SAXException</b>.
									</p>
									<p class="c5">
										As SAX events are fed into the <b>ContentHandler</b>, the tree of new items is built in the transient storage of the session. In order to persist the new content, <b>save</b> must be called. The advantage of this through-the- session method is that (depending on what constraint checks the implementation leaves until <b>save</b>) structures that violate node type constraints can be imported, fixed and then saved. The disadvantage is that a large import will result in a large cache of pending nodes in the session. See <b>Workspace.getImportContentHandler</b> for a version of this method that <i>does not</i> go through the session.
									</p>
									<p class="c5">
										The flag <b>uuidBehavior</b> governs how the UUIDs of incoming (deserialized) nodes are handled. There are four options (defined as constants in the interface <b>javax.jcr.ImportUUIDBehavior</b>):
									</p>
									<ul>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_CREATE_NEW</b>: Incoming referenceable nodes are added in the same way that new node is added with <b>Node.addNode</b>. That is, they are either assigned newly created UUIDs upon addition or upon <b>save</b> (depending on the implementation, see <a href="#section_4.9.1.1.">4.9.1.1</a> <i>When UUIDs are Assigned</i>). In either case, UUID collisions will not occur.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then the already existing node (and its subtree) is removed from wherever it may be in the workspace before the incoming node is added. Note that this can result in nodes “disappearing” from locations in the workspace that are remote from the location to which the incoming subtree is being written. Both the removal and the new addition will be persisted on <b>save</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REPLACE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace, then the already-existing node is replaced by the incoming node in the same position as the existing node. Note that this may result in the incoming subtree being disaggregated and “spread around” to different locations in the workspace. In the most extreme case this behavior may result in no node at all being added as child of <b>parentAbsPath</b>. This will occur if the topmost element of the incoming XML has the same UUID as an existing node elsewhere in the workspace. The change will be persisted on <b>save</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_THROW</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then a <b>SAXException</b> is thrown by the <b>ContentHandler</b> during deserialization.
											</p>
										</li>
									</ul>
									<p class="c5">
										Unlike <b>Workspace.getImportContentHandler</b>, this method does not necessarily enforce all node type constraints during deserialization. Those that would be immediately enforced in a normal write method (<b>Node.addNode</b>, <b>Node.setProperty</b> etc.) of this implementation cause the returned <b>ContentHandler</b> to throw an immediate <b>SAXException</b> during deserialization. All other constraints are checked on <b>save</b>, just as they are in normal write operations. However, which node type constraints are enforced also depends upon whether node type information in the imported data is respected, and this is an implementation-specific issue (see 7.3.3 Respecting Property Semantics).
									</p>
									<p class="c5">
										A <b>SAXException</b> will also be thrown by the returned <b>ContentHandler</b> during deserialization if <b>uuidBehavior</b> is set to <b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b> and an incoming node has the same UUID as the node at <b>parentAbsPath</b> or one of its ancestors.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown either immediately or on <b>save</b> if no node exists at <b>parentAbsPath</b>. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown either immediately or on <b>save</b> if the new subtree cannot be added to the node at <b>parentAbsPath</b> due to node-type or other implementation-specific constraints. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown either immediately or on <b>save</b> if the node at <b>parentAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown either immediately or on <b>save</b> if a lock prevents the addition of the subtree. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>importXML(String parentAbsPath,<br>
										InputStream in,<br>
										int uuidBehavior)</b>
									</p>
									<p class="c5">
										Deserializes an XML document and adds the resulting item subtree as a child of the node at <b>parentAbsPath</b>.
									</p>
									<p class="c5">
										If the incoming XML stream does not appear to be a <i>system view</i> XML document then it is interpreted as a <i>document view</i> XML document.
									</p>
									<p class="c5">
										The tree of new items is built in the transient storage of the <b>Session</b>. In order to persist the new content, <b>save</b> must be called. The advantage of this through-the- session method is that (depending on what constraint checks the implementation leaves until <b>save</b>) structures that violate node type constraints can be imported, fixed and then saved. The disadvantage is that a large import will result in a large cache of pending nodes in the <b>session</b>. See <b>Workspace.importXML</b> for a version of this method that <i>does not</i> go through the <b>Session</b>.
									</p>
									<p class="c5">
										The flag <b>uuidBehavior</b> governs how the UUIDs of incoming (deserialized) nodes are handled. There are four options (defined as constants in the interface <b>javax.jcr.ImportUUIDBehavior</b>):
									</p>
									<ul>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_CREATE_NEW</b>: Incoming referenceable nodes are added in the same way that new node is added with <b>Node.addNode</b>. That is, they are either assigned newly created UUIDs upon addition or upon <b>save</b> (depending on the implementation, see <a href="#section_4.9.1.1.">4.9.1.1</a> <i>When UUIDs are Assigned</i>). In either case, UUID collisions will not occur.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then the already existing node (and its subtree) is removed from wherever it may be in the workspace before the incoming node is added. Note that this can result in nodes “disappearing” from locations in the workspace that are remote from the location to which the incoming subtree is being written. Both the removal and the new addition will be persisted on <b>save</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_REPLACE_EXISTING</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace, then the already-existing node is replaced by the incoming node in the same position as the existing node. Note that this may result in the incoming subtree being disaggregated and “spread around” to different locations in the workspace. In the most extreme case this behavior may result in no node at all being added as child of <b>parentAbsPath</b>. This will occur if the topmost element of the incoming XML has the same UUID as an existing node elsewhere in the workspace. The change will be persisted on <b>save</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>IMPORT_UUID_COLLISION_THROW</b>: If an incoming referenceable node has the same UUID as a node already existing in the workspace then an <b>ItemExistsException</b> is thrown.
											</p>
										</li>
									</ul>
									<p class="c5">
										Unlike <b>Workspace.importXML</b>, this method does not necessarily enforce all node type constraints during deserialization. Those that would be immediately enforced in a normal write method (<b>Node.addNode</b>, <b>Node.setProperty</b> etc.) of this implementation cause an immediate <b>ConstraintViolationException</b> during deserialization. All other constraints are checked on <b>save</b>, just as they are in normal write operations. However, which node type constraints are enforced depends upon whether node type information in the imported data is respected, and this is an implementation-specific issue (see 7.3.3 Respecting Property Semantics).
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will also be thrown immediately if <b>uuidBehavior</b> is set to <b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b> and an incoming node has the same UUID as the node at <b>parentAbsPath</b> or one of its ancestors.
									</p>
									<p class="c5">
										A <b>PathNotFoundException</b> is thrown either immediately or on <b>save</b> if no node exists at <b>parentAbsPath</b>. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown either immediately or on <b>save</b> if the node at <b>parentAbsPath</b> is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown either immediately or on <b>save</b> if a lock prevents the addition of the subtree. Implementations may differ on when this validation is performed.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_7.3.8." id="section_7.3.8."></a>7.3.8 Importing jcr:root
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If the root node of a workspace is exported it will be rendered in XML (in either view) under the name <b>jcr:root</b> (see <a href="#section_6.4.">6.4</a> <i>XML Mappings</i>). In addition, if the root node has a UUID (in many implementations it will, see <a href="#section_4.9.">4.9</a> <i>Referenceable Nodes</i>) this will also be recorded in the serialization.
								</p>
							
							
								<p class="c5">
									If this XML document is imported back into the workspace a number of different results may occur, depending on the methods and settings used to perform the import. The following summarizes the possible results of using various <b>uuidBehavior</b> values (in either using either <b>Workspace.getImportContentHandler</b> or <b>Workspace.importXML</b>) when a node with the same UUID as the existing root node is encountered on import (the constants below are defined in the interface <b>javax.jcr.ImportUUIDBehavior</b>).
								</p>
							
							
								<p class="c5">
									<b>IMPORT_UUID_CREATE_NEW</b>: The XML element representing <b>jcr:root</b> is rendered as a normal node at the position specified (with the name <b>jcr:root</b>). It gets a new UUID, so there is no effect on the existing root node of the workspace.
								</p>
							
							
								<p class="c5">
									<b>IMPORT_UUID_COLLISION_REMOVE_EXISTING</b>: If deserialization is done through a <b>ContentHandler</b> (acquired by <b>getImportContentHandler</b>) a <b>SAXException</b> will be thrown. Similarly, if deserialization is done through <b>importXML</b> a <b>ConstraintViolationException</b> will be thrown. Note that this is simply a special case of the general rule that under this <b>uuidBehavior</b> setting, an exception will be thrown on any attempt to import a node with the same UUID as the node at <b>parentAbsPath</b> <i>or any of its ancestors</i> (which, of course, includes the root node).
								</p>
							
							
								<p class="c5">
									<b>IMPORT_UUID_COLLISION_REPLACE_EXISTING</b>: This setting is equivalent to importing into the <b>Session</b> and then calling <b>save</b> since <b>save</b> always operates according to UUID (plus relative path, for non-referenceables). In both cases the result is that the root node of the workspace will be replaced along with its subtree (i.e., the whole workspace), just as if the root node had been altered through the normal <b>getNode</b>, <i>change</i>, <b>save</b> cycle.
								</p>
							
							
								<p class="c5">
									<b>IMPORT_UUID_COLLISION_THROW</b>: Under this setting a <b>ContentHandler</b> will throw a <b>SAXException</b> and the <b>importXML</b> method will throw <b>ItemExistsException</b>.
								</p>
							
							
								<p class="c5">
									Note that an implementation is always free to prevent the replacement of a root node (or indeed any node) either through access control restrictions or other implementation-specific restrictions.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_7.4." id="section_7.4."></a>7.4 Assigning Node Types
		</h3>
		
			
				
					
						
							
								<p class="c5">
									Level 2 compliant implementations must support the assignment of primary and mixin node types to nodes upon creation and, optionally, the assignment and removal of mixin node types from existing nodes.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.4.1." id="section_7.4.1."></a> 7.4.1 The Special Properties jcr:primaryType and jcr:mixinTypes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a node is created, its <b>jcr:primaryType</b> property is automatically created and set to the name of the assigned primary node type. When a mixin type is assigned, its name is added to the multi-valued <b>jcr:mixinTypes</b> property, which is created if it does not yet exist.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.4.2." id="section_7.4.2."></a> 7.4.2 Assigning a Primary Node Type
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Assignment of a node type to a node on creation is done by supplying the node type name alongside the new node's path in a call to
								</p>
							
							
								<p class="c5">
									<b>Node.addNode(String relPath, String primaryNodeTypeName)</b>
								</p>
							
							
								<p class="c5">
									(see <a href="#section_7.1.4.">7.1.4</a> <i>Adding Nodes</i>).
								</p>
							
							
								<p class="c5">
									Alternatively, in many cases the application using the API will not need to explicitly supply a node type since the very name of the new child node will be enough to unambiguously determine its node type by reference to one of the node definitions contained in the node type of the parent node. In such cases, <b>Node.addNode(String relPath)</b> will be sufficient.
								</p>
							
							
								<p class="c5">
									Automatic determination of node types is only required to work if the name of the node being added is explicitly named in a child node definition of the parent node type (or one of that type's supertypes; see <a href="#section_6.7.14.">6.7.14</a> <i>NodeDefinition</i>). The implementation is not required to take residual definitions into account (see <a href="#section_6.7.15.">6.7.15</a> <i>Residual Definitions</i>).
								</p>
							
							
								<p class="c5">
									If the node type of the new child node cannot be determined automatically and no primary node type is explicitly specified, then a <b>ConstraintViolationException</b> is thrown (see <a href="#section_7.1.4.">7.1.4</a> <i>Adding Nodes</i>).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.4.3." id="section_7.4.3."></a> 7.4.3 Assigning Mixin Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									To assign a mixin type, the method<br>
									<b>Node.addMixin(String mixinName)</b> is used. The mixin type adds additional child node or property definitions to a node (i.e., either permitting or requiring additional child nodes or properties).
								</p>
							
							
								<p class="c5">
									Conflicts with other mixin node types or with the primary node type that are detected immediately will cause a <b>ConstraintViolationException</b> to be thrown on the <b>addMixin</b> call. Conflicts detected upon <b>save</b> will cause a <b>ConstraintViolationException</b> to be thrown at that time. Which conflicts are detected at which stage may differ across implementations.
								</p>
							
							
								<p class="c5">
									Note that the <i>orderable child nodes status</i> of a mixin node type has no effect, so it will never conflict with the orderable child nodes status of the primary node type.
								</p>
							
							
								<p class="c5">
									In some implementations it may be possible to add mixin types to a node only before the first <b>save</b> of that node (in effect, at node creation). Other implementations may support dynamic addition, and possibly removal, of mixin node types during a node's lifetime. The method <b>Node.removeMixin</b> is provided for those cases that support dynamic removal. If an implementation does not support dynamic addition or removal, the <b>addMixin</b> or <b>removeMixin</b> method will throw a <b>ConstraintViolationException</b>.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>addMixin(String mixinName)</b>
									</p>
									<p class="c5">
										Adds the specified mixin node type to this node. Also adds <b>mixinName</b> to this node's <b>jcr:mixinTypes</b> property immediately. Semantically, the mixin node type assignment <i>may</i> take effect immediately and at the very least, it <i>must</i> take effect on <b>save</b>.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> is thrown either immediately or on <b>save</b> if a conflict with another assigned mixin or the primary node type or for an implementation-specific reason. Implementations may differ on when this validation is done.
									</p>
									<p class="c5">
										In some implementations it may only be possible to add mixin types before a node is first saved, and not after. In such cases any later calls to <b>addMixin</b> will throw a <b>ConstraintViolationException</b> either immediately or on <b>save</b>.
									</p>
									<p class="c5">
										If the specified mixin node type is not recognized a <b>NoSuchNodeTypeException</b> is thrown either immediately or on <b>save</b>. Implementations may differ on when this validation is done.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown either immediately or on <b>save</b> if <b>this</b> node is versionable and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is done.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown either immediately or on <b>save</b> if a lock prevents the addition of the mixin. Implementations may differ on when this validation is done.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> will be thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>removeMixin(String mixinName)</b>
									</p>
									<p class="c5">
										Removes the specified mixin node type from this node. Also removes <b>mixinName</b> from this node's <b>jcr:mixinTypes</b> property immediately. Semantically, the mixin node type removal <i>may</i> take effect immediately and at the very least, it <i>must</i> take effect on <b>save</b>.
									</p>
									<p class="c5">
										If this node does not have the specified mixin, a <b>NoSuchNodeTypeException</b> is thrown either immediately or on <b>save</b>. Implementations may differ on when this validation is done.
									</p>
									<p class="c5">
										A <b>ConstraintViolationException</b> will be thrown either immediately or on <b>save</b> if the removal of a mixin is not allowed. Implementations are free to enforce any policy they like with regard to mixin removal and may differ on when this validation is done.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown either immediately or on <b>save</b> if <b>this</b> node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is done.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown either immediately or on <b>save</b> if a lock prevents the removal of the mixin. Implementations may differ on when this validation is done.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> will be thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>canAddMixin(String mixinName)</b>
									</p>
									<p class="c5">
										Returns true if the specified mixin node type, <b>mixinName</b>, can be added to this node. Returns <b>false</b> otherwise. A result of <b>false</b> must be returned in each of the following cases:
									</p>
									<ul>
										<li>
											<p class="c5">
												The mixin's definition conflicts with an existing primary or mixin node type of this node.
											</p>
										</li>
										<li>
											<p class="c5">
												This node is versionable and checked-in or is non-versionable and its nearest versionable ancestor is checked-in.
											</p>
										</li>
										<li>
											<p class="c5">
												This node is <i>protected</i> (as defined in this node's <b>NodeDefinition</b>, found in the node type of this node's parent).
											</p>
										</li>
										<li>
											<p class="c5">
												An access control restriction would prevent the addition of the mixin.
											</p>
										</li>
										<li>
											<p class="c5">
												A lock would prevent the addition of the mixin.
											</p>
										</li>
										<li>
											<p class="c5">
												An implementation-specific restriction would prevent the addition of the mixin.
											</p>
										</li>
									</ul>
									<p class="c5">
										A <b>NoSuchNodeTypeException</b> is thrown if the specified mixin node type name is not recognized.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> will be thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.4.4." id="section_7.4.4."></a> 7.4.4 Automatic Addition and Removal of Mixins
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A repository may automatically assign a mixin type to a node upon creation. For example if, as a matter of configuration, all <b>nt:file</b> nodes in a repository are to be versionable, then the repository may automatically assign the mixin type <b>mix:versionable</b> to each such node as it is created.
								</p>
							
							
								<p class="c5">
									Similarly, a repository may automatically strip incoming deserialized nodes of any mixin node types that the repository does not support (see 7.3.3 Respecting Property Semantics).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_7.4.5." id="section_7.4.5."></a> 7.4.5 Serialization and Node Types
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When deserializing content from another content repository, each imported node will come with its attached <b>jcr:primaryType</b> and <b>jcr:mixinTypes</b> properties. This information may be used while deserializing to validate the node according to the specified node types (and to do whatever internal bookkeeping the implementation requires in terms of noting the node types of the incoming nodes).
								</p>
							
							
								<p class="c5">
									Any node types referenced by the imported content that are not skipped (see 7.3.3 Respecting Property Semantics) will have to be already registered with the target repository. This implies that it will be necessary to first import and register those node types referenced by the content that are not already registered with the target repository.
								</p>
							
							
								<p class="c5">
									Though this specification does not attempt to define the details of the process of importing node type definitions, the fact that node type definitions may themselves be stored as normal content (see <a href="#section_6.7.22.10.">6.7.22.10</a> <i>nt:nodeType</i>) means that the standard serialization/deserialization mechanism can be used to export and import their definitions (see <a href="#section_6.5.">6.5</a> <i>Exporting Repository Content</i> and <a href="#section_7.3.">7.3</a> <i>Importing Repository Content</i>). Actually registering them is, as mentioned, outside the scope of this specification (see <a href="#section_6.7.1.">6.7.1</a> <i>Node Type Configuration</i>).
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_7.5." id="section_7.5."></a> 7.5 Thread-Safety Requirements
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A content repository implementation is required to provide a thread-safe implementation of all methods of <b>javax.jcr.Repository</b>.
								</p>
							
							
								<p class="c5">
									A content repository implementation is <i>not</i> required to provide thread-safe implementations of other interfaces. As a consequence, an application which concurrently or sequentially operates against objects having affinity to a particular <b>Session</b> through more than one thread must provide synchronization sufficient to ensure no more than one thread concurrently operates against that <b>Session</b> and changes made by one thread are visible to other threads.
								</p>
							
						
					
				
			
		
		<h2>
			<a name="section_8." id="section_8."></a> 8 Optional Repository Features
		</h2>
		
			
				
					
						
							
								<p class="c5">
									This section provides an overview of optional features that may be supported by a content repository implementation. These are: Transactions, Versioning, Observation, Locking and SQL Search. None of these features have any dependencies on each other or on any level 2 feature, therefore any combination of these five may be supported by either a level 1 or level 2 repository.
								</p>
							
							
								<p class="c5">
									Like the sections above, this section is arranged into topics based on functional categories. For an overview of the specification by Java interface, please consult the accompanying Javadoc.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_8.1." id="section_8.1."></a>8.1 Transactions
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A compliant content repository may support transactions. If it does so, it must adhere to the Java Transaction API (JTA) specification (see http://java.sun.com/products/jta/index.html).
								</p>
							
							
								<p class="c5">
									Whether a particular implementation supports transactions can be determined by querying the repository descriptor table with <b>Repository.getDescriptor("</b><b>OPTION_TRANSACTIONS_SUPPORTED")</b> (a return value of <b>true</b> indicates support for transactions, see 6.1.1.1 Repository Descriptors).
								</p>
							
							
								<p class="c5">
									The actual methods used to control transaction boundaries are not defined by this specification (that is why there are no <i>begin</i>, <i>commit</i> or <i>rollback</i> methods in this API). These methods are defined by the JTA specification.
								</p>
							
							
								<p class="c5">
									The JTA provides for two general approaches to transactions, container managed transactions and user managed transactions. In the first case, container managed transactions, the transaction management is taken care of by the application server and it is entirely transparent to the application using the API. The JTA interfaces <b>javax.transaction.TransactionManager</b> and <b>javax.transaction.Transaction</b> are the relevant ones in this context (though the client, as mentioned, will never have a need to use these).
								</p>
							
							
								<p class="c5">
									In the second case, user managed transactions, the application using the API may choose to control transaction boundaries from within the application. In this case the relevant interface is <b>javax.transaction.UserTransaction</b>. This is the interface that provides the methods <b>begin</b>, <b>commit</b>, <b>rollback</b> and so forth. Note that behind the scenes the <b>javax.transaction.TransactionManager</b> and <b>javax.transaction.Transaction</b> are still employed, but again, the client does not deal with these.
								</p>
							
							
								<p class="c5">
									A content repository implementation must support both of these approaches.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.1.1." id="section_8.1.1."></a> 8.1.1 Container Managed Transactions: Sample Request Flow
		</h4>
		
			
				
					
						
							
								<p>
									<img src="jsr170-8_1_1.png" name="Frame74" alt="Frame74" id="Frame74"><br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.1.2." id="section_8.1.2."></a> 8.1.2 User Managed Transactions: Sample Code
		</h4>
		
			
				
					
						
							
								<p class="c12">
									// Get user transaction (for example, through JNDI)
								</p>
							
							
								<p class="c12">
									UserTransaction utx = ...
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									// Get a node
								</p>
							
							
								<p class="c12">
									Node n = ...
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									// Start a user transaction
								</p>
							
							
								<p class="c12">
									utx.begin();
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									// Do some work
								</p>
							
							
								<p class="c12">
									n.setProperty("myapp:title", "A Tale of Two Cities")
								</p>
							
							
								<p class="c12">
									n.save();
								</p>
							
							
								<p class="c12">
									// Do some more work
								</p>
							
							
								<p class="c12">
									n.setProperty("myapp:author", "Charles Dickens")
								</p>
							
							
								<p class="c12">
									n.save();
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									// Commit the user transaction
								</p>
							
							
								<p class="c12">
									utx.commit();
								</p>
							
							
								<p>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.1.3." id="section_8.1.3."></a>8.1.3 Save vs. Commit
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Throughout this specification we often mention the distinction between <i>transient</i> and <i>persistent</i> levels. The persistent level refers to the (one or more) workspaces that make up the actual content storage of the repository. The transient level refers to in-memory storage associated with a particular <b>Session</b> object.
								</p>
							
							
								<p class="c5">
									In these discussions we usually assume that operations occur outside the context of transactions; it is assumed that <b>save</b> and other workspace-altering methods immediately effect changes to the persistent layer, causing those changes to be made visible to other sessions.
								</p>
							
							
								<p class="c5">
									<i>This is not the case, however, once transactions are introduced</i>. Within a transaction, changes made by <b>save</b> (or other, workspace-direct, methods) are transactionalized and are only persisted and published (made visible to other sessions), upon commit of the transaction. A rollback will, conversely, revert the effects of any saves or workspace-direct methods called within the transaction.
								</p>
							
							
								<p class="c5">
									Note, however, that changes made in the transient storage are <i>not</i> recorded by a transaction. This means that a rollback will not revert changes made to the transient storage of the <b>Session</b>. After a rollback the <b>Session</b> object state will still contain any pending changes that were present before the rollback.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.1.4." id="section_8.1.4."></a> 8.1.4 Single Session Across Multiple Transactions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Because modifications in the transient layer are not transactionalized, the possibility exists for some implementations to allow a <b>Session</b> to be shared across transactions. This possibility arises because in JTA, an <b>XAResource</b> may be successively associated with different global transactions and in many implementations the natural mapping will be to make the <b>Session</b> implement the <b>XAResource</b>. The following code snippet illustrates how an <b>XAResource</b> may be shared across two global transactions:
								</p>
							
							
								<p class="c12">
									// Associate the resource (our Session) with a global<br>
									// transaction xid1<br>
									res.start(xid1, TMNOFLAGS);<br>
									<br>
									// Do something with res, on behalf of xid1<br>
									// ...
								</p>
							
							
								<p>
									<br>
									// Suspend work on this transaction<br>
									res.end(xid1, TMSUSPEND);<br>
									<br>
									// Associate (the same!) resource with another<br>
									// global transaction xid2<br>
									res.start(xid2, TMNOFLAGS);<br>
									<br>
									// Do something with res, on behalf of xid2<br>
									// ...<br>
									<br>
									// End work<br>
									res.end(xid2, TMSUCCESS);<br>
									<br>
									// Resume work with former transaction<br>
									res.start(xid1, TMRESUME);<br>
									<br>
									// Commit work recorded when associated with xid2<br>
									res.commit(xid2, true);<br><br>
								</p>
							
							
								<p class="c5">
									<br>In cases where the <b>XAResource</b> corresponds to a <b>Session</b> (that is, probably most implementations), items that have been obtained in the context of <b>xid1</b> would still be valid when the <b>Session</b> is effectively associated with <b>xid2</b>. In other words, all transactions working on the same <b>Session</b> would share the transient items obtained through that <b>Session</b>.
								</p>
							
							
								<p class="c5">
									In those implementations that adopt a copy-on-read approach to transient storage (see <a href="#section_7.1.3.4.">7.1.3.4</a> <i>Seeing Changes Made by Other Sessions</i>) this will mean that the transient layer reflects an unchanged item's state <i>in the transaction<br>
									context in which the item was acquired</i>. As soon as an item is refreshed or changed, the session will then reflect the state of that item in the transaction context within which that refresh or change took place.
								</p>
							
							
								<p class="c5">
									Some implementers may choose to circumvent any problems with shared transient items by undoing changes inside the transient layer when a session is disassociated from a global transaction. This is however, outside the scope of this specification.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.1.5." id="section_8.1.5."></a> 8.1.5 Mention of Transactions within this Specification
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In order to avoid the awkwardness of qualifying every statement about <b>save</b> with the phrase “<i>unless the operation occurs within a transaction</i>” we simply assume the absence of transactions throughout most of the specification and note the qualification here.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_8.2." id="section_8.2."></a>8.2 Versioning
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A compliant content repository may support versioning. This feature allows the state of a node to be recorded in such a way that it can later be restored. The versioning system is modelled after the Workspace Versioning and Configuration Management (WVCM) API defined by JSR 147.
								</p>
							
							
								<p class="c5">
									Whether a particular implementation supports versioning can be determined by querying the repository descriptor table with <b>Repository.getDescriptor("</b><b>OPTION_VERSIONING_SUPPORTED")</b> (a return value of <b>true</b> indicates support for versioning, see 6.1.1.1 Repository Descriptors).
								</p>
							
							
								<p class="c5">
									A versioning repository has, in addition to one or more workspaces, a special <i>version storage</i> area. The version storage consists of <i>version histories</i>. Versionable nodes in different workspaces share the same version history if and only if they have the same UUID (see <a href="#section_4.10.2.">4.10.2</a> <i>Multiple Workspaces and Corresponding Nodes</i>).
								</p>
							
							
								<p class="c5">
									A version history is a collection of versions connected to one another by the <i>successor</i> relationship. A new version is added to the version history of a versionable node when one of its workspace instances is <i>checked-in</i>. Every new version is attached to the version history as the successor of one (or more) of the existing versions. The result is that a version history is a directed acyclic graph of versions, where the arcs in the graph represent the successor relation.
								</p>
							
							
								<p class="c5">
									The version storage objects are themselves defined as nodes. Though there is only one version storage per repository, the version storage data is reflected in each workspace as a special, protected, sub-tree of nodes of types <b>nt:versionHistory</b> and <b>nt:version</b> (see <a href="#section_8.2.2.">8.2.2</a> <i>Version Storage</i>).
								</p>
							
							
								<p class="c5">
									When a versionable node is <i>checked-in</i> (using <b>Node.checkin</b>) a new version is created in the version history of that node. The versionable node is also set to be read-only. In order to alter it with a regular write method, it must be checked-out (using <b>Node.checkout</b>). A versionable node can also be restored to the state recorded in one of its versions using <b>Node.restore</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.1." id="section_8.2.1."></a>8.2.1 Versionable Nodes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									To be <i>versionable</i>, a node must have <b>mix:versionable</b> as one of its mixin node types. Recall from <a href="#section_6.7.21.3.">6.7.21.3</a> <i>mix:versionable</i>, that this node type has the following definition:
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>mix:versionable</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:versionHistory</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:versionHistory"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:baseVersion</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:isCheckedOut</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>[true]</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:predecessors</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[nt:version]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>COPY</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:mergeFailed</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c5">
									As the definition indicates, <b>mix:versionable</b> is a subtype of <b>mix:referenceable</b> which mandates the property <b>jcr:uuid</b>, exposing a universally unique identifier for the node (see <a href="#section_6.7.21.2.">6.7.21.2</a>, <i>mix:referenceable</i>). The result is that all versionable nodes are guaranteed to have a UUID.
								</p>
							
							
								<p class="c5">
									In addition to this inherited property, a <b>mix:versionable</b> node has the properties <b>jcr:versionHistory</b>, <b>jcr:baseVersion</b>, <b>jcr:isCheckedOut</b>, <b>jcr:predecessors</b> and <b>jcr:mergeFailed</b>.
								</p>
							
							
								<p class="c5">
									<b>jcr:versionHistory</b> is a <b>REFERENCE</b> property which points to the <b>nt:versionHistory</b> node that holds as its children the <b>nt:version</b> nodes that make up this versionable node’s version history. Note that the UUID of the <b>nt:versionHistory</b> node is different from the UUID shared by the set of corresponding versionable nodes (at most one per workspace) that it serves.
								</p>
							
							
								<p class="c5">
									<b>jcr:baseVersion</b> is also a <b>REFERENCE</b> property. It points to the current base version of this node. The base version is one of the <b>nt:version</b> nodes within the version history pointed to by <b>jcr:versionHistory</b>, above. The base version (like all versions) is an <b>nt:version</b> node, and this property stores the UUID of <i>that</i> node. Again, the UUID of the version node is different from that shared by the set of corresponding versionable nodes in the workspaces, and from all other version nodes.
								</p>
							
							
								<p class="c5">
									<b>jcr:isCheckedOut</b> is a <b>BOOLEAN</b> property that records whether this versionable node is checked-out or checked-in. When a versionable node is in the checked-in state, it is <i>read-only</i>, and cannot be altered by the regular write methods of the API. Note that this status is distinct from the node type-enforced <i>protected</i> status. When a versionable node is checked-out it can (if it is not protected) be altered by the API write methods. The checked-out status provides an indicator to other sessions on the same workspace telling them when a particular versionable node is “being worked on”. The read-only status enforced when a versionable node is checked-in propagates to all its non-versionable descendants. When a versionable node is checked in, it and its non-versionable subtree become read-only; when it is checked-out, it and its non-versionable subtree lose their read-only status.
								</p>
							
							
								<p class="c5">
									<b>jcr:predecessors</b> is a multi-value <b>REFERENCE</b> property that points to one or more versions within the version graph of the version history pointed by <b>jcr:versionHistory</b>. These versions are those that are currently scheduled to become the predecessors of this versionable node when it is checked-in (and recorded in a version of its own).
								</p>
							
							
								<p class="c5">
									<b>jcr:mergeFailed</b> is a multi-value <b>REFERENCE</b> property that is used in the context of the <b>merge</b> method. A <b>merge</b> compares the base version of <i>this</i> versionable node with the base version of its corresponding node in some other workspace. If the system can determine which base version is a successor of the other, then it either leaves this versionable node alone (if <i>this</i> node's base version is the successor of the other node's base version) or updates it to reflect the corresponding node (if the corresponding node's base version is a successor of <i>this</i> node's base version). In cases where the system cannot determine which node is the successor, the merge is said to “fail”. When that happens, a reference to the base version of the corresponding node in the other workspace is added to <i>this</i> node's <b>jcr:mergeFailed</b> property, thus keeping a record of which nodes could not be merged, and therefore allowing the application to deal with these nodes appropriately. See <a href="#section_8.2.10.">8.2.10</a> <i>Merge</i>, for more details.
								</p>
							
							
								<p class="c5">
									All of these properties that store the versioning-related meta-data are protected (though of course the versionable node itself, and its other application-specific subitems may or may not be protected). This guarantees that the client cannot alter the meta-data values; they are maintained by the repository implementation itself.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2." id="section_8.2.2."></a>8.2.2 Version Storage
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A version history consists of a single <b>nt:versionHistory</b> node with a set of immediate child nodes all of type <b>nt:version</b>, representing all the versions within that version history.
								</p>
							
							
								<p class="c5">
									An <b>nt:versionHistory</b> has at least one child, the <b>nt:version</b> node representing the <i>root version</i>. From the root version the version graph proceeds through a network of <b>REFERENCE</b> properties linking any additional child <b>nt:version</b> nodes into a version graph defining the successor relations among the versions. The version graph within any given version history must include all and only the children of that version history’s <b>nt:versionHistory</b> node. The following diagram illustrates a single version history:
								</p>
							
							
								<p>
									<img src="jsr170-8_2_2.gif"><br>
									<br>
								</p>
							
							
								<p class="c5">
									The solid arrows represent parent node to child node relations while the dotted arrows represent the successor relations between versions, implemented through <b>REFERENCE</b> properties.
								</p>
							
							
								<p class="c5">
									Here we see an <b>nt:versionHistory</b> node, <b>VH</b> with child <b>nt:version</b> nodes <b>V</b><b><sub>root</sub></b> <b>V</b><b><sub>A</sub></b> <b>V</b><b><sub>B</sub></b> and <b>V</b><b><sub>C</sub></b>. The version graph begins at <b>V</b><b><sub>root</sub></b>, which has successors <b>V</b><b><sub>A</sub></b> and <b>V</b><b><sub>B</sub></b>, both of which, in turn, have <b>V</b><b><sub>C</sub></b> as their respective successor.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.1." id="section_8.2.2.1."></a>8.2.2.1 jcr:versionStorage
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The full set of version histories in the version storage, though stored in a single location in the repository, must be reflected in each workspace as a subtree below the node <b>/jcr:system/jcr:versionStorage</b>. This subtree must be read-only<i>.</i> That is, applications cannot alter this subtree through standard write methods; though the implementation can, of course, alter it as a side-effect of the application calling version-related methods.
								</p>
							
							
								<p class="c5">
									The read-only status of this subtree should be enforced by the implementation as a matter of access control. As a result, the protected status of parts of this subtree (enforced as a matter of node type constraints) is not relevant since, in effect, the entire subtree is protected.
								</p>
							
							
								<p class="c5">
									Though the general repository-wide version history is reflected in each workspace, the access that a particular <b>Session</b> gets to that subtree is governed by that <b>Session</b>'s authorization (which is determined either by the <b>Session</b>'s <b>Credentials</b> or an external authorization mechanism), just as it is for any other part of the workspace.
								</p>
							
							
								<p class="c5">
									All <b>nt:versionHistory</b> nodes are found under <b>/jcr:system/jcr:versionStorage</b>, though there may be a structure of intervening subnodes that sort the version histories by some implementation-specific criteria.
								</p>
							
							
								<p class="c5">
									The node type of the node <b>jcr:versionStorage</b> is left up to the implementation.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.2." id="section_8.2.2.2."></a>8.2.2.2 Searching and Traversing Version Storage
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Exposing the version storage as content in the workspace allows the stored versions and their associated version meta-data to be searched or traversed just like any other part of the workspace.
								</p>
							
							
								<p class="c5">
									This allows, for example, an application to search for a particular version according to the value of its properties. In a repository that supports SQL queries, the following query would return all versions where <b>productName</b> is “Car” and <b>price</b> is greater than 30,000:
								</p>
							
							
								<p class="c5">
									<b>SELECT *<br>
									FROM nt:version<br>
									WHERE productName = "Car"<br>
									AND price &gt; "30000"<br>
									AND jcr:path LIKE<br>
									"/jcr:system/jcr:versionStorage/%"</b>
								</p>
							
							
								<p class="c5">
									When an <b>nt:versionHistory</b> or <b>nt:version</b> node is acquired through a query or directly through a <b>getNode</b>, the actual Java type of the returned object must be <b>VersionHistory</b> (in the case <b>nt:versionHistory</b> nodes) or <b>Version</b> (in the case of <b>nt:version</b> nodes). This allows the application to then cast the returned object down to either <b>Version</b> or <b>VersionHistory</b> and then use it in methods that take those types, for example <b>Node.restore(Version version, boolean removeExisting)</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.3." id="section_8.2.2.3."></a>8.2.2.3 nt:versionHistory
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>nt:versionHistory</b> node type has the following definition (repeated from <a href="#section_6.7.22.13.">6.7.22.13</a> <i>nt:versionHistory</i>):
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:versionHistory</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:versionableUuid</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:rootVersion</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[</b><b>nt:version]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:version</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:versionLabels</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:versionLabels]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:versionLabels</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:version]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>nt:version</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>false</b>
								</p>
							
							
								<p>
									<br>
									<br>
								</p>
							
							
								<p class="c5">
									<b>nt:versionHistory</b>, like all node types, is a subtype of <b>nt:base</b>, so it inherits the <b>jcr:primaryType</b> and <b>jcr:mixinTypes</b> properties.
								</p>
							
							
								<p class="c5">
									Additionally, all <b>nt:versionHistory</b> nodes must also have mixin type <b>mix:referenceable</b>, which means that they have the property <b>jcr:uuid.</b>
								</p>
							
							
								<p class="c5">
									This node type defines a <b>STRING</b> property called <b>jcr:versionableUuid</b> that stores the UUID of the versionable node whose version history this is.
								</p>
							
							
								<p class="c5">
									It type also mandates a single auto-created subnode called <b>jcr:rootVersion</b>. This is a version that serves as the starting point for the version graph; it does not hold any state information (see <a href="#section_8.2.4.">8.2.4</a>, <i>Initializing the Version History</i>, below).
								</p>
							
							
								<p class="c5">
									Every <b>nt:versionHistory</b> node also has an auto-created child node called <b>jcr:versionLabels</b> of node type <b>nt:versionLabels</b>. This node holds a set of reference properties that record all labels that have been assigned to the versions within this version history. Each label is represented by a single reference property which uses the label itself as its name and which refers to that version within this version history to which the label applies.
								</p>
							
							
								<p class="c5">
									All additional versions are added as needed by the versioning system as <b>nt:version</b> child nodes. These children are defined by the second <i>ChildNodeDefinition</i>, with name attribute of <b>"*"</b> (i.e., making this a <i>residual definition</i>, see <a href="#section_6.7.15.">6.7.15</a>, <i>Residual Definitions</i>, above). The names of the <b>nt:version</b> nodes are left up to the implementation.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.4." id="section_8.2.2.4."></a>8.2.2.4 nt:versionLabels
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>nt:versionLabels</b> node type has the following definition (repeated from <a href="#section_6.7.22.14.">6.7.22.14</a> <i>nt:versionLabels</i>):
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:versionLabels</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.5." id="section_8.2.2.5."></a>8.2.2.5 nt:version
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>nt:version</b> node type has the following definition (repeated from <a href="#section_6.7.22.15.">6.7.22.15</a> <i>nt:version</i>):
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:version</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:created</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>DATE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:predecessors</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:successors</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:version"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenNode</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:frozenNode]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p>
									SameNameSiblings <b>false<br></b><br>
								</p>
							
							
								<p class="c5">
									<b>nt:version</b> is a subtype of <b>nt:base</b>, so it has the properties <b>jcr:primaryType and jcr:mixinTypes</b>.
								</p>
							
							
								<p class="c5">
									In addition, each <b>nt:version</b> node inherits the mixin type <b>mix:referenceable</b>, providing it with a <b>jcr:uuid</b> property.
								</p>
							
							
								<p class="c5">
									Additionally it has:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>jcr:created</b>: This property records the date and time that the version was created.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>jcr:predecessors</b>: A multi-value <b>REFERENCE</b> property that points to the immediate predecessors of this version in the version history.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>jcr:successors</b>: A multi-value <b>REFERENCE</b> property that points to the immediate successors of this version in the version history.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									These properties store the meta-data that is needed by the repository to manage the version. In addition to these properties, of course, the version entity must also store the actual state of the node that was versioned to produce it. This is done by storing a “frozen” copy of the versionable node in the form of a special child node of the version node, called <b>jcr:frozenNode</b>:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>jcr:frozenNode</b>: A child node of type <b>nt:frozenNode</b> which holds the actual state of the versionable node at the time that this version was created.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.2.2.6." id="section_8.2.2.6."></a>8.2.2.6 nt:frozenNode
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>nt:frozenNode</b> node type has the following definition (repeated from <a href="#section_6.7.22.16.">6.7.22.16</a> <i>nt:frozenNode</i>):
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:frozenNode</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<b>mix:referenceable</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenPrimaryType</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenMixinTypes</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>NAME</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:frozenUuid</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>UNDEFINED</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>UNDEFINED</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>true</b>
								</p>
							
							
								<p class="c12">
									<i>ChildNodeDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>*</b>
								</p>
							
							
								<p class="c12">
									RequiredPrimaryTypes <b>[nt:base]</b>
								</p>
							
							
								<p class="c12">
									DefaultPrimaryType <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									SameNameSiblings <b>true</b>
								</p>
							
							
								<p class="c5">
									<br>
									The properties and child nodes of the versioned node (call it <b>N</b>) are dealt with according to their respective <b>OnParentVersion</b> attribute, as defined in the node type of <b>N</b>. Those child nodes and properties of <b>N</b> with <b>OnParentVersion=COPY</b> are copied to <b>jcr:frozenNode</b>. The residual property and child node definitions in <b>nt:frozenNode</b> provide the “space” into which these copies are placed.
								</p>
							
							
								<p class="c5">
									Those child nodes and properties of <b>N</b> with <b>OnParentVersion=IGNORE</b> are not copied.
								</p>
							
							
								<p class="c5">
									Those versionable child nodes of <b>N</b> (i.e., children of <b>N</b> that are themselves also versionable) with <b>OnParentVersion=VERSION</b> are dealt with in a special way: a node with the same name as the child node but of type <b>nt:versionedChild</b> is placed as a child of <b>jcr:frozenNode</b>. This special node is not a copy of the child node of <b>N</b> but instead holds a single reference property (called <b>jcr:childVersionHistory</b>) that points to the version history of the child of <b>N</b>. The <b>OnParentVersion</b> mechanism has other options as well, for a full discussion, see <a href="#section_8.2.11.">8.2.11</a> <i>The OnParentVersion Attribute</i>.
								</p>
							
							
								<p class="c5">
									Among the properties of <b>N</b> that are copied over to <b>jcr:frozenNode</b>, a special exception must be made for <b>jcr:primaryType</b>, <b>jcr:mixinTypes</b> and <b>jcr:uuid</b>. These properties cannot be copied to their corresponding <b>jcr:frozenNode</b> node without conflicting with that node’s existing properties of the same name (recall for example, that <b>jcr:frozenNode</b> is of type <b>nt:frozenNode</b>, and so its <b>jcr:primaryType</b> property will, of course, hold the value “<b>nt:frozenNode</b>”, not the node type of <b>N</b>). To address this problem, the copies are renamed <b>jcr:frozenPrimaryType</b>, <b>jcr:frozenMixinTypes</b>, and <b>jcr:frozenUuid</b>, respectively.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.7." id="section_8.2.2.7."></a>8.2.2.7 nt:versionedChild
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>nt:versionedChild</b> node type has the following definition (repeated from <a href="#section_6.7.22.17.">6.7.22.17</a> <i>nt:frozenNode</i>):
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:versionedChild</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:childVersionHistory</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:versionHistory"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.8." id="section_8.2.2.8."></a>8.2.2.8 Version Graph
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The structure of the version graph is based on the following principles:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					A version graph consists of one or more versions.
				</p>
			</li>
			<li>
				<p class="c5">
					A version graph has exactly one root version.
				</p>
			</li>
			<li>
				<p class="c5">
					The root version does not have a predecessor version.
				</p>
			</li>
			<li>
				<p class="c5">
					All other versions (apart from the root version) have one or more predecessors (merges are allowed).
				</p>
			</li>
			<li>
				<p class="c5">
					Each version may have one or more successors (branches are allowed).
				</p>
			</li>
			<li>
				<p class="c5">
					A version cannot be one of its own successors or predecessors. The version graph is a directed acyclic graph.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.2.2.9." id="section_8.2.2.9."></a>8.2.2.9 Reference Properties within a Version
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a <b>REFERENCE</b> property is stored as part of the frozen state of a version, the referential integrity requirement is lifted. For example, given the following situation:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Nodes <b>A</b> and <b>B</b> in a workspace <b>WS</b> (i.e., in the workspace proper, not in the protected version storage subtree)
				</p>
			</li>
			<li>
				<p class="c5">
					<b>A</b> is (at least) versionable.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>B</b> is (at least) referenceable.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>A</b> has <b>REFERENCE</b> property <b>P</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>P</b> has an <i>OnParentVersion</i> setting of <b>COPY</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>P</b> holds a reference to <b>B</b>. <b>B</b> has no other references pointing to it.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Assuming that <b>A</b> is checked in.
								</p>
							
							
								<p class="c5">
									When <b>A</b> is checked in, <b>P</b> will be recorded as part of the frozen state of the newly created version <b>A'</b> by being copied to version storage as a property <b>P'</b> of <b>A'</b>.
								</p>
							
							
								<p class="c5">
									At this point <b>B</b> cannot be removed from the workspace because it has a reference (<b>P</b>) pointing to it. However, if <b>P</b> is removed from <b>A</b>, then <b>B</b> can be removed. Because referential integrity is not enforced for frozen reference properties in version storage, the reference from <b>P'</b> will not prevent the removal of <b>B</b>. This is despite the fact that <b>P'</b> does appear in the same workspace as <b>B</b> (though only in the special version storage subtree at <b>/jcr:system/jcr:versionStorage</b>). Note that this also means that a call to <b>getReferences</b> on <b>B</b> will <i>not</i> return <b>P'</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.2.10." id="section_8.2.2.10."></a>8.2.2.10 Removal of Versions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In some implementations it may be possible to remove versions from within a version history using <b>VersionHistory.removeVersion</b>. In such cases the version graph must be automatically repaired so that each successor of the removed version becomes a successor of every predecessor of the removed version. Note that allowing remove in this context would not constitute an exception to the requirement that the version storage be protected, since protected status applies to standard write methods (e.g. like <b>Node.addNode</b>) and not version-specific methods (like <b>Node.checkin</b>) that alter the version history as a <i>side-effect</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.3." id="section_8.2.3."></a>8.2.3 The Base Version
		</h4>
		
			
				
					
						
							
								<p class="c5">
									For a given version history, every versionable node that shares that version history (there being at most one such node per workspace) contains a reference to its particular <i>base version</i> within the version history. Among any set of nodes with a common version history, each node may identify a different version as its base version. The base version of a particular node <b>N</b> is the one that will serve as the default immediate predecessor of the next version of <b>N</b> that is created.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.4." id="section_8.2.4."></a> 8.2.4 Initializing the Version History
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a new versionable node is created, a new version history is created for it. At first, the version history consists of only the <b>nt:versionHistory</b> node and its single child, the <b>nt:version</b> node representing the <i>root version</i>, which will serve as the starting point, from which the version graph of successors will proceed. The root version does not store any state information; it serves only to make the semantics of subsequent operations consistent. Initially, the root version also serves as the <i>base version</i> for the new versionable node.
								</p>
							
							
								<p class="c5">
									In terms of actual nodes and properties being created or changed, here is what happens when a new <b>mix:versionable</b> node <b>N</b> is created in workspace <b>W</b><b><sub>1</sub></b>:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>N</b> is created by the call <b>M.addNode("N")</b> where <b>M</b> is some suitable parent node for <b>N</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Before being saved, <b>N</b> is made versionable by the call <b>N.addMixin("mix:versionable")</b>. In some implementations, dynamic assignments of mixins may be supported, thus allowing a node to be rendered versionable at any time in its lifecycle, not just upon creation. See <a href="#section_7.4.3.">7.4.3</a> <i>Assigning Mixin Node Types</i>.
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					On <b>save</b> of <b>N</b>, a new version history is automatically created for <b>N</b>. This means that the repository automatically creates a new node of type <b>nt:versionHistory</b> (call it <b>VH</b>). <b>VH</b> automatically gets a child node of type <b>nt:version</b> called <b>jcr:rootVersion</b> (call it <b>V</b><b><sub>0</sub></b>).
				</p>
			</li>
			<li>
				<p class="c5">
					<b>V</b><b><sub>0</sub></b> is the root version of <b>VH</b>. This root version does not contain any state information about <b>N</b> other than the node type and UUID information in the <b>jcr:frozenPrimaryType</b>, <b>jcr:frozenMixinTypes</b>, and <b>jcr:frozenUuid</b>. It is a dummy version.
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>REFERENCE</b> property <b>jcr:versionHistory</b> of <b>N</b> is initialized to the UUID of <b>VH</b>. This constitutes a reference from <b>N</b> to its version history.
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>REFERENCE</b> property <b>jcr:baseVersion</b> of <b>N</b> is initialized to the UUID of <b>V</b><b><sub>0</sub></b>. This constitutes a reference from <b>N</b> to its current base version.
				</p>
			</li>
			<li>
				<p class="c5">
					The multi-value <b>REFERENCE</b> property <b>jcr:predecessors</b> of <b>N</b> is initialized to contain a single UUID, that of <b>V</b><b><sub>0</sub></b> (the same as <b>jcr:baseVersion</b>).
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>BOOLEAN</b> property <b>jcr:isCheckedOut</b> is set to <b>true</b>.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.2.5." id="section_8.2.5."></a>8.2.5 Check In
		</h4>
		
			
				
					
						
							
								<p class="c5">
									To create a new version of a versionable node <b>N</b>, the application calls <b>N.checkin</b>. If <b>N</b> is already checked-in, this method has no effect but simply returns the current base version of this node. If <b>N</b> is not versionable then a <b>UnsupportedRepositoryOperationException</b> is thrown. Otherwise, the following preconditions must hold:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>N</b> must not have any unsaved changes pending, otherwise an <b>InvalidItemStateException</b> is thrown.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N</b>'s <b>jcr:mergeFailed</b> (multi-value) property must not be present, otherwise a <b>VersionException</b> is thrown (notice that this is enforced in any case due to the <b>ABORT</b> setting of the <b>jcr:mergeFailed</b> property's <b>OnParentVersion</b> attribute).
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Given these preconditions, <b>N.checkin</b> will cause the following series of events:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					A new <b>nt:version</b> node <b>V</b> is created and added as a child node to <b>VH</b>, the <b>nt:versionHistory</b> pointed to by <b>N</b>’s <b>jcr:versionHistory</b> property.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N</b>’s current <b>jcr:predecessors</b> property is copied to <b>V</b>, and <b>N</b>'s <b>jcr:predecessors</b> property is then set to the empty array (it is a multi-value property, therefore it can be set to empty). Note that <b>N</b>'s <b>jcr:predecessors</b> property also forms part of the frozen state of <b>N</b> (because it has an <b>OnParentVersion</b> attribute of <b>COPY</b>) and therefore will also be copied to <b>V/jcr:frozenNode</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					A reference to <b>V</b> is added to the <b>jcr:successors</b> property of each of the versions identified in <b>V</b>’s <b>jcr:predecessors</b> property.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N</b>’s <b>jcr:baseVersion</b> property is set to refer to <b>V</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N</b>’s <b>jcr:isCheckedOut</b> property is set to <b>false</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The state of <b>N</b> is recorded in the form of the <b>jcr:frozenNode</b> child of <b>V</b>. The extent of the state stored (i.e. exactly which child items are included and which ignored, etc.) will typically be partial, as prescribed by the <b>OnParentVersion</b> attribute of each of <b>N</b>’s child items. See <a href="#section_8.2.11.">8.2.11</a> <i>OnParentVersion Attribute</i>, for the details. The <b>jcr:primaryType</b>, <b>jcr:mixinTypes</b> and <b>jcr:uuid</b> properties of <b>N</b> are copied over to the child <b>jcr:frozenNode</b> of <b>V</b> but renamed to <b>jcr:frozenPrimaryType</b>, <b>jcr:frozenMixinTypes</b> and <b>jcr:frozenUuid</b> to avoid conflict with <b>jcr:frozenNode</b>'s own properties with these names.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>V</b> is given a automatically generated name. How this is done is implementation specific.
				</p>
			</li>
			<li>
				<p class="c5">
					The node <b>N</b> and its <i>connected non-versionable subtree</i> become read-only. <b>N</b>'s connected non-versionable subtree is the set of non-versionable descendant nodes reachable from <b>N</b> through child links without encountering any versionable nodes. In other words, the read-only status flows down from the checked-in node along every child link until either a versionable node is encountered or an item with no children is encountered.
				</p>
			</li>
			<li>
				<p class="c5">
					Read-only status means that an item cannot be altered by the client using standard API methods (<b>addNode</b>, <b>setProperty</b>, etc.). The only exceptions to this rule are the <b>restore</b><sup><b><a class="sdfootnoteanc" name="sdfootnote9anc" href="#sdfootnote9sym" id="sdfootnote9anc"><sup>9</sup></a></b></sup>, <b>Node.merge</b> and <b>Node.update</b> operations; these do not respect read-only status due to check-in. Note that <b>remove</b> of a read-only node is possible, as long as its parent is not read-only (since removal is an alteration of the parent node).
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									This method acts directly on the workspace and the version storage. All changes are persisted immediately. There is no need to call <b>save</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.6." id="section_8.2.6."></a>8.2.6 Check Out
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In order to alter a versionable node (and its non-versionable subtree) the node must be checked-out. The checked-out state indicates to the repository and other clients that the current base version (the one pointed to be <b>jcr:baseVersion</b>) of <b>N</b> is “being worked on” and will (usually) be checked-in again at some point in the future, thus creating a new version. When a versionable node is first created (or an existing node is first made versionable, in those implementations that allow that) it will already be in the checked-out state (its <b>jcr:checkedOut</b> property is set to <b>true</b>).
								</p>
							
							
								<p class="c5">
									To check-out a versionable node <b>N</b>, the client calls <b>N.checkout</b>. If the node is already checked out, this method has no effect. If <b>N</b> is not versionable then an <b>UnsupportedRepositoryOperationException</b> is thrown. Otherwise, a <b>N.checkout</b> will cause the following series of events:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The current value of <b>N</b>'s <b>jcr:baseVersion</b> is copied to <b>N</b>'s <b>jcr:predecessor</b><b>s</b> property.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N</b>’s <b>jcr:isCheckedOut</b> property is set to <b>true</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N</b> and <b>N</b>'s <i>connected non-versionable subtree</i> lose their read-only status (see <a href="#section_8.2.5.">8.2.5</a> <i>Check In,</i> for an explanation of the term “connected non-versionable subtree”).
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									This method acts directly on the workspace and the version storage. All changes are persisted immediately. There is no need to call <b>save</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.7." id="section_8.2.7."></a>8.2.7 Restoring a Version
		</h4>
		
			
				
					
						
							
								<p class="c5">
									To restore a node <b>N</b> to the state recorded by its version with version name “<b>x.y</b>”, the application calls <b>N.restore("x.y", removeExisting)</b><sup><b><a class="sdfootnoteanc" name="sdfootnote10anc" href="#sdfootnote10sym" id="sdfootnote10anc"><sup>10</sup></a></b></sup>. Assuming that the version node representing the version named “<b>x.y</b>” is node <b>V</b>, then the following will occur:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The child node and properties of <b>N</b> will be changed, removed or added to, depending on their corresponding copies in <b>V</b> and their own <b>OnParentVersion</b> attributes (see <a href="#section_8.2.11.">8.2.11</a> <i>OnParentVersion Attribute</i>, for details). The second parameter of <b>Node.</b><b>restore</b> is the <b>removeExisting</b> flag which governs what happens if nodes that are being introduced into the subtree of <b>N</b> as a result of the <b>restore</b> have the same UUID as existing node is in the workspace outside the subtree of <b>N</b> (see <a href="#section_8.2.14.1.">8.2.14.1</a> <i>Node Versioning Methods</i>).
				</p>
			</li>
		</ul>
		<ul>
			<li>
				<p class="c5">
					<b>N</b>’s <b>jcr:baseVersion</b> property will be changed to point to <b>V</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N</b>’s <b>jcr:isCheckedOut</b> property is set to <b>false</b>.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Unlike most other operations that alter the state of a node, <b>restore</b> works regardless of whether the node in question is <i>checked-out</i> or <i>checked-in</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.8." id="section_8.2.8."></a> 8.2.8 Restoring a Group of Versions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In certain circumstances a “chicken and egg” problem may arise due to a cycle of <b>REFERENCE</b> properties when attempting to restore a node that has been removed.
								</p>
							
							
								<p class="c5">
									For example, let us say that there is a node <b>/A</b> with child nodes <b>/A/B</b> and <b>/A/C</b>. Furthermore let there be <b>REFERENCE</b> properties <b>/A/B/X /A/C/Y</b> such that <b>X</b> refers to <b>/A/C</b> and <b>Y</b> refers to <b>/A/B</b>. Now assume that <b>A</b>, <b>B</b> and <b>C</b> are first checked-in (thus creating versions of all three nodes) and then <b>B</b> and <b>C</b> are deleted from the workspace.
								</p>
							
							
								<p class="c5">
									In order to restore <b>B</b> or <b>C</b> the other must be restored first, since the reference properties <b>X</b> and <b>Y</b> both require the existence of the node to which they refer. This is the “chicken and egg” problem.
								</p>
							
							
								<p class="c5">
									To deal with such situations the method
								</p>
							
							
								<p class="c5">
									<b>Workspace.restore(Version[] versions,<br>
									boolean removeExisting)</b>
								</p>
							
							
								<p class="c5">
									is provided. This method allows the client to simultaneously restore two or more versions. In this case the client must first find the <b>Version</b> objects (call them <b>Va</b>, <b>Vb</b> and <b>Vc</b>) that correspond to the versions of <b>A</b>, <b>B</b> and <b>C</b> that are to be restored and calling
								</p>
							
							
								<p class="c5">
									<b>ws.restore(new Version[]{Va, Vb, Vc}, removeExisting)</b>
								</p>
							
							
								<p class="c5">
									Notice that in order to restore <b>B</b> and <b>C</b>, the previous version of <b>A</b> must also be restored because its state contains the child links to <b>B</b> and <b>C</b>.
								</p>
							
							
								<p class="c5">
									The <b>removeExisting</b> flag governs what happens in cases of UUID collision.
								</p>
							
							
								<p class="c5">
									See <a href="#section_8.2.14.2.">8.2.14.2</a> <i>Workspace Versioning Methods</i>, for more information.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.9." id="section_8.2.9."></a>8.2.9 Update
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The method <b>Node.update(String srcWorkspace)</b> works in the same way as it does in repositories without versioning: it replaces <b>this</b> node and its subtree with a clone of the its corresponding node and its subtree in <b>srcWorkspace</b>. Unlike most other methods that change the state of a node, <b>update</b> will work if the node in question is read-only due to a checked-in node. See also, <a href="#section_7.1.8.">7.1.8</a> <i>Updating and Cloning Nodes across Workspaces</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.10." id="section_8.2.10."></a>8.2.10 Merge
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The method <b>Node.merge</b> can be thought of as a <i>version-sensitive</i> <b>Node.update</b>. It works as follows:
								</p>
							
							
								<p class="c5">
									The <b>merge</b> method can be called on a versionable or non-versionable node.
								</p>
							
							
								<p class="c5">
									Like <b>update</b>, <b>merge</b> does not respect the checked-in status of nodes. A <b>merge</b> may change a node even if it is currently checked-in.
								</p>
							
							
								<p class="c5">
									If <b>this</b> node (the one on which <b>merge</b> is called) does not have a corresponding node in the indicated workspace, then the <b>merge</b> method returns quietly and no changes are made.
								</p>
							
							
								<p class="c5">
									If <b>this</b> node does have a corresponding node, then the following happens:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					For each versionable node <b>N</b> in the subtree rooted at <b>this</b> node, a <i>merge test</i> is performed comparing <b>N</b> with its corresponding node in <b>srcWorkspace</b>, <b>N'</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The merge test is done by comparing <i>the base version of</i> <b>N</b> (call it <b>V</b>) and <i>the base version of</i> <b>N'</b> (call it <b>V'</b>).
				</p>
			</li>
			<li>
				<p class="c5">
					For any versionable node <b>N</b> there are three possible outcomes of the merge test: <i>update</i>, <i>leave</i> or <i>failed</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					If <b>N</b> does not have a corresponding node then the merge result for <b>N</b> is <i>leave</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					If <b>N</b> is currently checked-in then:
				</p>
				<ul>
					<li>
						<p class="c5">
							If <b>V'</b> is a successor (to any degree) of <b>V</b>, then the merge result for <b>N</b> is <i>update</i>.
						</p>
					</li>
					<li>
						<p class="c5">
							If <b>V'</b> is a predecessor (to any degree) of <b>V</b> or if <b>V</b> and <b>V'</b> are identical (i.e., are actually the same version), then the merge result for <b>N</b> is <i>leave</i>.
						</p>
					</li>
					<li>
						<p class="c5">
							If <b>V</b> is neither a successor of, predecessor of, nor identical with <b>V'</b>, then the merge result for <b>N</b> is <i>failed</i>. This is the case where <b>N</b> and <b>N'</b> represent divergent branches of the version graph, thus determining the result of a merge is non-trivial.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					If <b>N</b> is currently checked-out then:
				</p>
				<ul>
					<li>
						<p class="c5">
							If <b>V'</b> is a predecessor (to any degree) of <b>V</b> or if <b>V</b> and <b>V'</b> are identical (i.e., are actually the same version), then the merge result for <b>N</b> is <i>leave</i>.
						</p>
					</li>
					<li>
						<p class="c5">
							If any other relationship holds between <b>V</b> and <b>V'</b>, then the merge result for <b>N</b> is <i>fail</i>.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					If <b>bestEffort</b> is <b>false</b> then the first time a merge result of <i>fail</i> occurs, the entire merge operation on this subtree is aborted, no changes are made to the subtree and a <b>MergeException</b> is thrown. If no merge result of <i>fail</i> occurs then:
				</p>
				<ul>
					<li>
						<p class="c5">
							Each versionable node <b>N</b> with result <i>update</i> is updated to reflect the state of <b>N'</b>. The state of a node in this context refers to its set of properties and child node links.
						</p>
					</li>
					<li>
						<p class="c5">
							Each versionable node <b>N</b> with result <i>leave</i> is left unchanged, <i>unless</i> <b><i>N</i></b> <i>is the child of a node with status</i> update <i>and</i> <b><i>N</i></b> <i>does not have a corresponding node in</i> <b><i>srcWorkspace</i></b><i>, in which case it is removed.</i>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					If <b>bestEffort</b> is <b>true</b> then:
				</p>
				<ul>
					<li>
						<p class="c5">
							Each versionable node <b>N</b> with result <i>update</i> is updated to reflect the state of <b>N'</b>. The state of a node in this context refers to its set of properties and child node links.
						</p>
					</li>
					<li>
						<p class="c5">
							Each versionable node <b>N</b> with result <i>leave</i> is left unchanged, <i>unless</i> <b><i>N</i></b> <i>is the child of a node with status</i> update <i>and</i> <b><i>N</i></b> <i>does not have a corresponding node in</i> <b><i>srcWorkspace</i></b><i>, in which case it is removed</i>.
						</p>
					</li>
					<li>
						<p class="c5">
							Each versionable node <b>N</b> with result <i>failed</i> is left unchanged except that the UUID of <b>V'</b> (which is, in some sense, the “offending” version; the one that caused the merge to fail on that <b>N</b>) is added to the multi-value <b>REFERENCE</b> property <b>jcr:mergeFailed</b> of <b>N</b>. If the UUID of <b>V'</b> is already in <b>jcr:mergeFailed</b>, it is not added again. The <b>jcr:mergeFailed</b> property never contains repeated references to the same version. If the <b>jcr:mergeFailed</b> property does not yet exist then it is created. If present, the <b>jcr:mergeFailed</b> property will always contain at least one value. If not present on a node, this indicates that no merge failure has occurred on that node. Note that the presence of this property on a node will in any case prevent it from being checked-in because the <b>OnParentVersion</b> setting of <b>jcr:mergeFailed</b> is <b>ABORT</b>.
						</p>
					</li>
					<li>
						<p class="c5">
							This property can later be used by the application to find those nodes in the subtree that have failed to merge and thus require special attention (see <a href="#section_8.2.10.2.">8.2.10.2</a> <i>Merging Branches</i>, immediately below). This property is multi-valued so that a record of successive failed merges can be kept.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					In either case, (regardless of whether <b>bestEffort</b> is <b>true</b> or <b>false</b>) for each non-versionable node (including both referenceable and non-referenceable), if the merge result of its <i>nearest versionable ancestor</i> is <i>update,</i> or if it has <i>no versionable ancestor</i>, then it is updated to reflect the state of its corresponding node. Otherwise, it is left unchanged. The definition of corresponding node in this context is the same as usual: the match is done by UUID (for a referenceable nodes) or UUID plus relative path (for non-referenceable nodes).
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Note that as a result of the final rule, above, a <b>merge</b> performed on a subtree with no versionable nodes at all (or indeed in a repository that does not support versioning in the first place) will be equivalent to an <b>update</b>.
								</p>
							
							
								<p class="c5">
									The merge method returns a <b>NodeIterator</b> over all versionable nodes in the subtree that received a merge result of <i>fail</i>.
								</p>
							
							
								<p class="c5">
									Note that if <b>bestEffort</b> is <b>false</b>, then <b>merge</b> will either return an empty iterator (since no merge failure occurred) or throw a <b>MergeException</b> (on the first merge failure that was encountered).
								</p>
							
							
								<p class="c5">
									If <b>bestEffort</b> is <b>true</b>, then the iterator will contain all nodes that received a <i>fail</i> during the course of this <b>merge</b> operation.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.10.1." id="section_8.2.10.1."></a>8.2.10.1 Merge Algorithm
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The above declarative description can also be expressed in pseudo-code as follows:
								</p>
							
							
								<p class="c5">
									let <b>ws'</b> be the workspace against which the <b>merge</b> is done.<br>
									let <b>bestEffort</b> be the flag passed to <b>merge</b>.<br>
									let <b>failedset</b> be a set of UUIDs, initially empty.<br>
									let <b>startnode</b> be the node on which <b>merge</b> was called.<br>
									<b>domerge(startnode)</b>.<br>
									return the nodes with the UUIDs in <b>failedset</b>.
								</p>
							
							
								<p class="c5">
									<b>domerge(n)</b><br>
									let <b>n'</b> be the corresponding node of <b>n</b> in <b>ws'</b>.<br>
									if no such <b>n'</b> <b>doleave(n)</b>.<br>
									else if <b>n</b> is not versionable <b>doupdate(n, n')</b>.<br>
									else if <b>n'</b> is not versionable <b>doleave(n)</b>.<br>
									let <b>v</b> be base version of <b>n</b>.<br>
									let <b>v'</b> be base version of <b>n'</b>.<br>
									if <b>v'</b> is a successor of <b>v</b> and<br>
									<b>n</b> is not checked-in <b>doupdate(n, n')</b>.<br>
									else if <b>v</b> is equal to or a predecessor of <b>v'</b> <b>doleave(n)</b>.<br>
									else <b>dofail(n, v')</b>.
								</p>
							
							
								<p class="c5">
									<b>dofail(n, v')<br></b> if <b>bestEffort</b> = <b>false</b> throw <b>MergeException</b>.<b><br></b> else add UUID of <b>v'</b> (if not already present) to the<br>
									<b>jcr:mergeFailed</b> property of <b>n</b>,<br>
									add UUID of <b>n</b> to <b>failedset</b>,<br>
									<b>doleave(n)</b>.
								</p>
							
							
								<p class="c5">
									<b>doLeave(n)<br></b> for each child node <b>c</b> of <b>n domerge(c)</b>.<br>
									<br>
									<b>doupdate(n, n')</b><br>
									replace set of properties of <b>n</b> with those of <b>n'</b>.<br>
									let <b>S</b> be the set of child nodes of <b>n</b>.<br>
									let <b>S'</b> be the set of child nodes of <b>n'</b>.<br>
									judging by the name of the child node:<br>
									let <b>C</b> be the set of nodes in <b>S</b> and in <b>S'</b><br>
									let <b>D</b> be the set of nodes in <b>S</b> but not in <b>S'</b>.<br>
									let <b>D'</b> be the set of nodes in <b>S'</b> but not in <b>S</b>.<br>
									remove from <b>n</b> all child nodes in <b>D</b>.<br>
									for each child node of <b>n'</b> in <b>D'</b> copy it (and its subtree) to <b>n<br></b> as a new child node (if an incoming node has the same<br>
									UUID as a node already existing in this workspace,<br>
									the already existing node is removed).<br>
									for each child node <b>m</b> of <b>n</b> in <b>C</b> <b>domerge(m)</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.10.2." id="section_8.2.10.2."></a>8.2.10.2 Merging Branches
		</h4>
		
			
				
					
						
							
								<p class="c5">
									As mentioned, when a merge test on a node <b>N</b> fails, this indicates that the two base versions <b>V</b> and <b>V'</b> are on separate branches of the version graph. Consequently, determining the result of the merge is not simply a matter of determining which version is the successor of the other in terms of version history. Instead, the <i>content</i> (that is, the subtree) of <b>N'</b> must be merged into the content of <b>N</b> according to some domain specific criteria which must be performed at the application level, for example, through a merge tool provided to the user.
								</p>
							
							
								<p class="c5">
									The <b>jcr:mergeFailed</b> property is used to tag nodes that fail the merge test so that an application can find them and deal appropriately with them. The <b>jcr:mergeFailed</b> property is multi-valued so that information about merge failures is not lost if more than one successive merge is attempted before being dealt with by the application.
								</p>
							
							
								<p class="c5">
									In the above example, after the <i>content</i> of <b>N'</b> is merged into <b>N</b>, the application will want to also merge the two branches of the version graph. This is done by calling <b>N.doneMerge(V')</b> where <b>V'</b> is retrieved by following the reference stored in the <b>jcr:mergeFailed</b> property of <b>N</b>. This has the effect of moving the reference-to-<b>V'</b> from the <b>jcr:mergeFailed</b> property of <b>N</b> to its <b>jcr:predecessors</b> property.
								</p>
							
							
								<p class="c5">
									If, on the other hand, the application chooses not to join the two branches, then <b>cancelMerge(V')</b> is performed. This has the effect of removing the reference to <b>V'</b> from the <b>jcr:mergeFailed</b> property of <b>N</b> without adding it to <b>jcr:predecessors</b>.
								</p>
							
							
								<p class="c5">
									Once the last reference in <b>jcr:mergeFailed</b> has been either moved to <b>jcr:predecessors</b> (with <b>doneMerge</b>) or just removed from <b>jcr:mergeFailed</b> (with <b>cancelMerge</b>) the <b>jcr:mergeFailed</b> property is automatically removed, thus enabling this node to be checked-in, creating a new version (note that before the <b>jcr:mergeFailed</b> is removed, its <b>OnParentVersion</b> setting of <b>ABORT</b> prevents check in). This new version will have a predecessor connection to each version for which <b>doneMerge</b> was called, thus joining those branches of the version graph.
								</p>
							
							
								<p class="c5">
									See <a href="#section_8.2.14.">8.2.14</a> <i>Versioning API</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.11." id="section_8.2.11."></a> 8.2.11 OnParentVersion Attribute
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Every item (node or property) in the repository has a status indicator that governs what happens to that item when its parent node is versioned. This status is defined by the <b>onParentVersion</b> attribute in the <b>PropertyDefinition</b> or <b>NodeDefinition</b> that applies to the item in question.
								</p>
							
							
								<p class="c5">
									For example, let <b>N</b> be a versionable node, meaning it has mixin node type <b>mix:versionable</b>. Also let <b>N</b> have a primary node type that allows it to have one property called <b>P</b> and one child node called <b>C</b>.
								</p>
							
							
								<p class="c5">
									What happens to <b>P</b> and <b>C</b> when a new version of <b>N</b> is checked in depends on their respective <b>OnParentVersion</b> attribute as defined in the <b>PropertyDefinition</b> for <b>P</b> and the <b>NodeDefinition</b> for <b>C</b>.
								</p>
							
							
								<p class="c5">
									The possible values for the <b>OnParentVersion</b> attribute are: <b>COPY</b>, <b>VERSION</b>, <b>INITIALIZE</b>, <b>COMPUTE</b>, <b>IGNORE</b> and <b>ABORT</b>.
								</p>
							
							
								<p class="c5">
									The sections below describe, for each possible value of the <b>OnParentVersion</b> attribute, what happens to <b>C</b> and <b>P</b> when,
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>N.checkin()</b> is performed, creating the new version <b>V</b><b><sub>N</sub></b> and adding to the version history.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>N.restore(V</b><b><sub>N</sub></b><b>, b)</b> is performed, restoring the version <b>V</b><b><sub>N</sub></b> (the boolean parameter <b>b</b> governs what happens on UUID collision).
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.2.11.1." id="section_8.2.11.1."></a>8.2.11.1 COPY
		</h4>
		
			
				
					
						
							
								<h5>
									Child Node
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, <b>C</b> and all its descendent items, down to the leaves of the subtree, will be copied to the version storage as a child subtree of <b>V</b><b><sub>N</sub></b>. The copy of <b>C</b> and its subtree will not have its own version history but will be part of the state preserved in <b>V</b><b><sub>N</sub></b>. <b>C</b> itself need not be versionable.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the copy of <b>C</b> and its subtree stored will be restored as well, replacing the current <b>C</b> and its subtree in the workspace.
								</p>
							
							
								<h5>
									Property
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, <b>P</b> will be copied to the version storage as a child of <b>V</b><b><sub>N</sub></b>. This copy of <b>P</b> is part of the state preserved in <b>V</b><b><sub>N</sub></b>.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the copy of <b>P</b> stored as its child will be restored as well, replacing the current <b>P</b> in the workspace.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.11.2." id="section_8.2.11.2."></a>8.2.11.2 VERSION
		</h4>
		
			
				
					
						
							
								<h5>
									Child Node
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, the node <b>V</b><b><sub>N</sub></b> will get a subnode of type <b>nt:versionedChild</b> with the same name as <b>C</b>. The single property of this node, <b>jcr:childVersionHistory</b> is a <b>REFERENCE</b> to <i>the version history of</i> <b><i>C</i></b> (not to <b>C</b> or any actual version of <b>C</b>). This also requires that <b>C</b> itself be versionable (otherwise it would not have a version history). If <b>C</b> is not versionable then the behavior of <b>COPY</b> applies on <b>checkin</b>, however the recursive copy terminates at each versionable node encountered further below in the subtree, at which points the standard <b>VERSION</b> behavior is again followed.
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>nt:versionedChild</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>nt:base</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:childVersionHistory</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>REFERENCE</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>["nt:versionHistory"]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>true</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>true</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>ABORT</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c5">
									<br>
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, if the workspace currently has an already existing node corresponding to <b>C</b>’s version history and the <b>removeExisting</b> flag of the <b>restore</b> is set to <b>true</b>, then that instance of <b>C</b> becomes the child of the restored <b>N</b>.
								</p>
							
							
								<p class="c5">
									If the workspace currently has an already existing node corresponding to <b>C</b>’s version history and the <b>removeExisting</b> flag of the <b>restore</b> is set to <b>false</b> then an <b>ItemExistsException</b> is thrown.
								</p>
							
							
								<p class="c5">
									If the workspace does not have an instance of <b>C</b> then one is restored from <b>C</b>’s version history. The workspace in which the <b>restore</b> is being performed will determine which particular version of <b>C</b> will be restored. This determination depends on the configuration of the workspace and is outside the scope of this specification.
								</p>
							
							
								<h5>
									Property
								</h5>
							
							
								<p class="c5">
									In the case of properties, an <b>OnParentVersion</b> attribute of <b>VERSION</b> has the same effect as <b>COPY</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.11.3." id="section_8.2.11.3."></a>8.2.11.3 INITIALIZE
		</h4>
		
			
				
					
						
							
								<h5>
									Child Node
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, a new node <b>C</b> will be created and placed in version storage as a child of <b>V</b><b><sub>N</sub></b>. This new <b>C</b> will be initialized just as it would be if created normally in a workspace. No state information of the current <b>C</b> in the workspace is preserved.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the <b>C</b> stored as its child will be ignored, and the current <b>C</b> in the workspace will be left unchanged.
								</p>
							
							
								<h5>
									Property
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, a new <b>P</b> will be created and placed in version storage as a child of <b>V</b><b><sub>N</sub></b>. The new <b>P</b> will be initialized just as it would be if created normally in a workspace.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the <b>P</b> stored as its child will be ignored, and the current <b>P</b> in the workspace will be left unchanged.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.11.4." id="section_8.2.11.4."></a>8.2.11.4 COMPUTE
		</h4>
		
			
				
					
						
							
								<h5>
									Child Node
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, a new node <b>C</b> will be created and placed in version storage as a child of <b>V</b><b><sub>N</sub></b>. This new <b>C</b> will be initialized by some procedure defined for that type of child node.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the <b>C</b> stored as its child will be ignored, and the current <b>C</b> in the workspace will be left unchanged.
								</p>
							
							
								<h5>
									Property
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, a new <b>P</b> will be created and placed in version storage as a child of <b>V</b><b><sub>N</sub></b>. The new <b>P</b> will be initialized by some procedure defined for that type of property.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the <b>P</b> stored as its child will be ignored, and the current <b>P</b> in the workspace will be left unchanged.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.11.5." id="section_8.2.11.5."></a>8.2.11.5 IGNORE
		</h4>
		
			
				
					
						
							
								<h5>
									Child Node
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, no state information about <b>C</b> will be stored in <b>V</b><b><sub>N</sub></b>.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the child node <b>C</b> of the current <b>N</b> will remain and not be removed.
								</p>
							
							
								<h5>
									Property
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b>, no state information about <b>P</b> will be stored in <b>V</b><b><sub>N</sub></b>.
								</p>
							
							
								<p class="c5">
									On <b>restore</b> of <b>V</b><b><sub>N</sub></b>, the property <b>P</b> of the current <b>N</b> will remain and not be removed.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.11.6." id="section_8.2.11.6."></a>8.2.11.6 ABORT
		</h4>
		
			
				
					
						
							
								<h5>
									Child Node or Property
								</h5>
							
							
								<p class="c5">
									On <b>checkin</b> of <b>N</b> a <b>VersionException</b> will be thrown. Having a child node or property with an <b>OnParentVersion</b> attribute of <b>ABORT</b> prevents the parent node from being checked-in.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.12." id="section_8.2.12."></a> 8.2.12 The OnParentVersionAction Class
		</h4>
		
			
				
					
						
							
								<p class="c14">
									The above six legal values from the OnParentVersion attribute are represented in the Java API by six integer constants defined by the class <b>OnParentVersionAction</b>.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.version.<br>
										<b>OnParentVersionAction</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>COPY</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>VERSION</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>INITIALIZE</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>COMPUTE</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>IGNORE</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>ABORT</b>
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.2.13." id="section_8.2.13."></a>8.2.13 Removal of Versions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Though a version history is meant, in theory, to provide a permanent record of a versionable node, in practice it sometimes becomes necessary to clean-up a version history by removing a version. To do this, this API provides the <b>VersionHistory.removeVersion</b> method. See <a href="#section_8.2.14.3.">8.2.14.3</a> <i>VersionHistory Interface</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.14." id="section_8.2.14."></a>8.2.14 Versioning API
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The versioning API consists the version-related methods in the <b>Node</b> interface as well as two interfaces that extend the <b>Node</b> interface, <b>VersionHistory</b> and <b>Version</b>. <b>VersionHistory</b> is the interface for an <b>nt:versionHistory</b> node and <b>Version</b> is the interface for an <b>nt:version</b> node.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.14.1." id="section_8.2.14.1."></a>8.2.14.1 Node Versioning Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Node</b> interface has the following version-related methods.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										Version
									</p>
								</td>
								<td>
									<p class="c5">
										<b>checkin()</b>
									</p>
									<p class="c5">
										Creates a new version with a system generated name and returns that version. The <b>jcr:isCheckedOut</b> property of this node is set to <b>false</b> thus putting the node into the <i>checked-in</i> state. This means that this node and its <i>connected non-versionable subtree</i> become read-only. A node's connected non-versionable subtree is the set of non-versionable descendant nodes reachable from that node through child links without encountering any versionable nodes. In other words, the read-only status flows down from the checked-in node along every child link until either a versionable node is encountered or an item with no children is encountered.
									</p>
									<p class="c5">
										Read-only status means that an item cannot be altered by the client using standard API methods (<b>addNode</b>, <b>setProperty</b>, etc.). The only exceptions to this rule are the <b>restore</b><sup><b><a class="sdfootnoteanc" name="sdfootnote11anc" href="#sdfootnote11sym" id="sdfootnote11anc"><sup>11</sup></a></b></sup>, <b>Node.merge</b> and <b>Node.update</b> operations; these do not respect read-only status due to check-in. Note that <b>remove</b> of a read-only node is possible, as long as its parent is not read-only (since removal is an alteration of the parent node).
									</p>
									<p class="c5">
										See <a href="#section_8.2.5.">8.2.5</a> <i>Check In</i> for more details.
									</p>
									<p>
										<a name="OLE_LINK1" id="OLE_LINK1"></a>If this node is already checked-in, this method has no effect but returns the current base version of this node.
									</p>
									<p class="c5">
										If this node is not versionable, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown or if a child item of this node has an <b>OnParentVersion</b> status of <b>ABORT</b>. This includes the case where an unresolved merge failure exists on this node, as indicated by the presence of the <b>jcr:mergeFailed</b> property.
									</p>
									<p class="c5">
										If <b>checkin</b> succeeds, the change to the <b>jcr:checkedOut</b> property is automatically saved (there is no need to do an additional <b>save</b>).
									</p>
									<p class="c5">
										If there are unsaved changes pending on this node, an <b>InvalidItemStateException</b> is thrown.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the checkin.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>checkout()</b>
									</p>
									<p class="c5">
										Sets this versionable node to checked-out status by setting its <b>jcr:isCheckedOut</b> property to <b>true</b>, sets the <b>jcr:predecessors</b> property to be a reference to the current base version (the same value as held in <b>jcr:baseVersion</b>). This method puts the node into the <i>checked-out</i> state, making it and its connected non-versionable subtree no longer read-only (see <b>checkin</b>, above, for an explanation of the term “connected non-versionable subtree”).
									</p>
									<p class="c5">
										If successful, these changes are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										See <a href="#section_8.2.6.">8.2.6</a> <i>Check Out</i> for more details.
									</p>
									<p class="c5">
										If this node is not versionable, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the checkout.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										NodeIterator
									</p>
								</td>
								<td>
									<p class="c5">
										<b>merge(String srcWorkspace, boolean bestEffort)</b>
									</p>
									<p class="c5">
										This method can be thought of as a version-sensitive update (see <a href="#section_7.1.8.">7.1.8</a> <i>Updating and Cloning Nodes across Workspaces</i>).
									</p>
									<p class="c5">
										It recursively tests each versionable node in the subtree of this node against its corresponding node in <b>srcWorkspace</b> with respect to the relation between their respective base versions and either updates the node in question or not, depending on the outcome of the test. For details see <a href="#section_8.2.10.">8.2.10</a> <i>Merge</i>.
									</p>
									<p class="c5">
										A <b>MergeException</b> is thrown if <b>bestEffort</b> is <b>false</b> and a versionable node is encountered whose corresponding node's base version is on a divergent branch from this node's base version.
									</p>
									<p class="c5">
										If successful, the changes are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										This method returns a <b>NodeIterator</b> over all versionable nodes in the subtree that received a merge result of <i>fail</i>. If <b>bestEffort</b> is <b>false</b>, this iterator will be empty (since if it <b>merge</b> returns successfully, instead of throwing an exception, it will be because no failures were encountered). If <b>bestEffort</b> is <b>true</b>, this iterator will contain all nodes that received a <i>fail</i> during the course of this <b>merge</b> operation.
									</p>
									<p class="c5">
										If the specified <b>srcWorkspace</b> does not exist, a <b>NoSuchWorkspaceException</b> is thrown.
									</p>
									<p class="c5">
										If the current session does not have sufficient permissions to perform the operation, then an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Session</b> (not necessarily this <b>Node</b>) has pending unsaved changes.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the merge.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>doneMerge(Version version)</b>
									</p>
									<p class="c5">
										Completes the merge process with respect to this node and the specified <b>version</b>.
									</p>
									<p class="c5">
										See <a href="#section_8.2.10.">8.2.10</a> <i>Merge</i> for more details.
									</p>
									<p class="c5">
										If successful, the changes are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the version specified is not among those referenced in this node's <b>jcr:mergeFailed</b> property or if this node is currently checked-in.
									</p>
									<p class="c5">
										An <b>UnsupportedRepositoryOperationException</b> is thrown if this node is not versionable.
									</p>
									<p class="c5">
										If there are unsaved changes pending on this node, an <b>InvalidItemStateException</b> is thrown.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the operation.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>cancelMerge(Version version)</b>
									</p>
									<p class="c5">
										Cancels the merge process with respect to this node and the specified <b>version</b>.
									</p>
									<p class="c5">
										See <a href="#section_8.2.10.">8.2.10</a> <i>Merge</i> for more details.
									</p>
									<p class="c5">
										If successful, the changes are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the version specified is not among those referenced in this node's <b>jcr:mergeFailed</b> property or if this node is currently checked-in.
									</p>
									<p class="c5">
										An <b>UnsupportedRepositoryOperationException</b> is thrown if this node is not versionable.
									</p>
									<p class="c5">
										If there are unsaved changes pending on this node, an <b>InvalidItemStateException</b> is thrown.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the operation.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										boolean
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isCheckedOut()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node is either
									</p>
									<ul>
										<li>
											<p class="c5">
												versionable and currently checked-out,
											</p>
										</li>
										<li>
											<p class="c5">
												non-versionable and its nearest versionable ancestor is checked-out or
											</p>
										</li>
										<li>
											<p class="c5">
												non-versionable and it has no versionable ancestor.
											</p>
										</li>
									</ul>
									<p class="c5">
										Returns <b>false</b> if this node is either
									</p>
									<ul>
										<li>
											<p class="c5">
												versionable and currently checked-in or
											</p>
										</li>
										<li>
											<p class="c5">
												non-versionable and its nearest versionable ancestor is checked-in.
											</p>
										</li>
									</ul>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>restore(String versionName,<br>
										boolean removeExisting)</b>
									</p>
									<p class="c5">
										Restores this node to the state defined by the version with the specified <b>versionName</b>.
									</p>
									<p class="c5">
										If this node is not versionable, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										If successful, the change is persisted immediately and there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if no version with the specified <b>versionName</b> exists in this node's version history or if an attempt is made to restore the root version (<b>jcr:rootVersion</b>).
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Session</b> (not necessarily this <b>Node</b>) has pending unsaved changes.
									</p>
									<p class="c5">
										This method will work regardless of whether this node is checked-in or not.
									</p>
									<p class="c5">
										A UUID collision occurs when a node exists <i>outside the subtree rooted at this node</i> with the same UUID as a node that would be introduced by the <b>restore</b> operation <i>into the subtree at this node</i>. The result in such a case is governed by the <b>removeExisting</b> flag. If <b>removeExisting</b> is <b>true</b>, then the incoming node takes precedence, and the existing node (and its subtree) is removed. If <b>removeExisting</b> is <b>false</b>, then a <b>ItemExistsException</b> is thrown and no changes are made. Note that this applies not only to cases where the restored node itself conflicts with an existing node but also to cases where a conflict occurs with <i>any</i> node that would be introduced into the workspace by the restore operation. In particular conflicts involving subnodes of the restored node that have <b>OnParentVersion</b> settings of <b>COPY</b> or <b>VERSION</b> (see <a href="#section_8.2.11.">8.2.11</a> <i>OnParentVersion Attribute</i>) are also governed by the <b>removeExisting</b> flag.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the restore.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>restore(Version version,<br>
										boolean removeExisting)</b>
									</p>
									<p class="c5">
										Restores this node to the state defined by the specified <b>version</b>.
									</p>
									<p class="c5">
										If this node is not versionable, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										If successful, the change is persisted immediately and there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if the specified <b>version</b> is not part of this node's version history.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Session</b> (not necessarily this <b>Node</b>) has pending unsaved changes.
									</p>
									<p class="c5">
										This method will work regardless of whether this node is checked-in or not.
									</p>
									<p class="c5">
										A UUID collision occurs when a node exists <i>outside the subtree rooted at this node</i> with the same UUID as a node that would be introduced by the <b>restore</b> operation <i>into the subtree at this node</i>. The result in such a case is governed by the <b>removeExisting</b> flag. If <b>removeExisting</b> is <b>true</b>, then the incoming node takes precedence, and the existing node (and its subtree) is removed. If <b>removeExisting</b> is <b>false</b>, then a <b>ItemExistsException</b> is thrown and no changes are made. Note that this applies not only to cases where the restored node itself conflicts with an existing node but also to cases where a conflict occurs with <i>any</i> node that would be introduced into the workspace by the restore operation. In particular conflicts involving subnodes of the restored node that have <b>OnParentVersion</b> settings of <b>COPY</b> or <b>VERSION</b> (see <a href="#section_8.2.11.">8.2.11</a> <i>OnParentVersion Attribute</i>) are also governed by the <b>removeExisting</b> flag.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the restore.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>restore(Version version,<br>
										String&nbsp;relPath,<br>
										boolean removeExisting)</b>
									</p>
									<p class="c5">
										Restores the specified <b>version</b> to <b>relPath</b>, relative to this node.
									</p>
									<p class="c5">
										A node need not exist at <b>relPath</b>, though the parent of <b>relPath</b> must exist, otherwise a <b>PathNotFoundException</b> is thrown.
									</p>
									<p class="c5">
										If a node <i>does</i> exist at <b>relPath</b> then it must correspond to the version being restored (the version must be a version <i>of that node</i>), otherwise a <b>VersionException</b> is thrown.
									</p>
									<p class="c5">
										If no node exists at <b>relPath</b> then a <b>VersionException</b> is thrown if the parent node of <b>relPath</b> is versionable and checked-in or is non-versionable but its nearest versionable ancestor is checked-in.
									</p>
									<p class="c5">
										If there is a node at <b>relPath</b> then the checked-in status of that node itself and the checked-in status of its parent are irrelevant. The restore will work even if one or both are checked-in.
									</p>
									<p class="c5">
										A UUID collision occurs when a node exists <i>outside the subtree rooted at</i> <b><i>relPath</i></b> with the same UUID as a node that would be introduced by the <b>restore</b> operation <i>into the subtree at</i> <b><i>relPath</i></b> (note that in cases where there is no node at <b>relPath</b>, this amounts to saying that a UUID collision occurs if there exists a node <i>anywhere</i> in this workspace with the same UUID as a node that would be introduced by the <b>restore</b>). The result in such a case is governed by the <b>removeExisting</b> flag. If <b>removeExisting</b> is <b>true</b> then the incoming node takes precedence, and the existing node (and its subtree) is removed. If <b>removeExisting</b> is <b>false</b>, then a <b>ItemExistsException</b> is thrown and no changes are made. Note that this applies not only to cases where the restored node itself conflicts with an existing node but also to cases where a conflict occurs with <i>any</i> node that would be introduced into the workspace by the restore operation. In particular conflicts involving subnodes of the restored node that have <b>OnParentVersion</b> settings of <b>COPY</b> or <b>VERSION</b> (see <a href="#section_8.2.11.">8.2.11</a> <i>OnParentVersion Attribute</i>) are also governed by the <b>removeExisting</b> flag.
									</p>
									<p class="c5">
										If the would-be parent of the location <b>relPath</b> is actually a property, or if a node type restriction would be violated, then a <b>ConstraintViolationException</b> is thrown.
									</p>
									<p class="c5">
										If the <b>restore</b> succeeds, the changes made to this node are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Session</b> (not necessarily this <b>Node</b>) has pending unsaved changes.
									</p>
									<p class="c5">
										An <b>UnsupportedRepositoryOperationException</b> is thrown if versioning is not supported.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the restore.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										void
									</p>
								</td>
								<td>
									<p class="c5">
										<b>restoreByLabel(String versionLabel,<br>
										boolean removeExisting)</b>
									</p>
									<p class="c5">
										Restores this node to the state defined by the version with the specified <b>versionLabel</b>.
									</p>
									<p class="c5">
										If this node is not versionable, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										If successful, the change is persisted immediately and there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										A <b>VersionException</b> is thrown if no version with the specified <b>versionLabel</b> exists in this node's version history.
									</p>
									<p class="c5">
										This method will work regardless of whether this node is checked-in or not.
									</p>
									<p class="c5">
										A UUID collision occurs when a node exists <i>outside the subtree rooted at this node</i> with the same UUID as a node that would be introduced by the <b>restore</b> operation <i>into the subtree at this node</i>. The result in such a case is governed by the <b>removeExisting</b> flag. If <b>removeExisting</b> is <b>true</b>, then the incoming node takes precedence, and the existing node (and its subtree) is removed. If <b>removeExisting</b> is <b>false</b>, then a <b>ItemExistsException</b> is thrown and no changes are made. Note that this applies not only to cases where the restored node itself conflicts with an existing node but also to cases where a conflict occurs with <i>any</i> node that would be introduced into the workspace by the restore operation. In particular conflicts involving subnodes of the restored node that have <b>OnParentVersion</b> settings of <b>COPY</b> or <b>VERSION</b> (see <a href="#section_8.2.11.">8.2.11</a> <i>OnParentVersion Attribute</i>) are also governed by the <b>removeExisting</b> flag.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Session</b> (not necessarily this <b>Node</b>) has pending unsaved changes.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the restore.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										VersionHistory
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getVersionHistory()</b>
									</p>
									<p class="c5">
										Returns the <b>VersionHistory</b> object of this node. This object provides access to the <b>nt:versionHistory</b> node holding this node's versions.
									</p>
									<p class="c5">
										If <b>this</b> node is not versionable, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										Version
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getBaseVersion()</b>
									</p>
									<p class="c5">
										Returns the current base version of this versionable node.
									</p>
									<p class="c5">
										If this node is not versionable, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.2.14.2." id="section_8.2.14.2."></a>8.2.14.2 Workspace Versioning Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Workspace</b> object provides the "group restore" method.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Workspace</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>restore(Version[] versions,<br>
										boolean removeExisting)</b>
									</p>
									<p class="c5">
										Restores a set of versions at once. Used in cases where a "chicken and egg" problem of mutually referring <b>REFERENCE</b> properties would prevent the restore in any serial order.
									</p>
									<p class="c5">
										If the restore succeeds, the changes made are persisted immediately, there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										This method will work regardless of whether the nodes corresponding to the specified versions are checked-in or not.
									</p>
									<p class="c5">
										The following restrictions apply to the set of versions specified:
									</p>
									<p class="c5">
										If <b>S</b> is the set of versions being restored simultaneously,
									</p>
									<ul>
										<li>
											<p class="c5">
												For every version <b>V</b> in <b>S</b> that corresponds to a <i>missing</i> node in the workspace, there must also be a parent of <b>V</b> in <b>S</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>S</b> must contain at least one version that corresponds to an <i>existing</i> node in the workspace.
											</p>
										</li>
										<li>
											<p class="c5">
												No <b>V</b> in <b>S</b> can be a root version (<b>jcr:rootVersion</b>).
											</p>
										</li>
									</ul>
									<p class="c5">
										If any of these restrictions does not hold, the restore will fail because the system will be unable to determine the path locations to which one or more versions are to be restored. In this case a <b>VersionException</b> is thrown.
									</p>
									<p class="c5">
										The versionable nodes in this workspace that correspond to the versions being restored define a set of (one or more) subtrees. A UUID collision occurs when this workspace contains a node <i>outside these subtrees</i> that has the same UUID as one of the nodes that would be introduced by the <b>restore</b> operation into one of these subtrees. The result in such a case is governed by the <b>removeExisting</b> flag. If <b>removeExisting</b> is <b>true</b> then the incoming node takes precedence, and the existing node (and its subtree) is removed. If <b>removeExisting</b> is <b>false</b> then a <b>ItemExistsException</b> is thrown and no changes are made. Note that this applies not only to cases where the restored node itself conflicts with an existing node but also to cases where a conflict occurs with <i>any</i> node that would be introduced into the workspace by the restore operation. In particular conflicts involving subnodes of the restored node that have <b>OnParentVersion</b> settings of <b>COPY</b> or <b>VERSION</b> (see <a href="#section_8.2.11.">8.2.11</a> <i>OnParentVersion Attribute</i>) are also governed by the <b>removeExisting</b> flag.
									</p>
									<p class="c5">
										An <b>UnsupportedRepositoryOperationException</b> is thrown if versioning is not supported.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if a lock prevents the restore.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this <b>Session</b> (not necessarily this <b>Node</b>) has pending unsaved changes.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if another error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.2.14.3." id="section_8.2.14.3."></a>8.2.14.3 VersionHistory Interface
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A <b>VersionHistory</b> object provides an interface for an <b>nt:versionHistory</b> node. It provides convenient access to version history information.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c5">
										javax.jcr.version.<br><b>VersionHistory</b> <b>extends Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getVersionableUUID()</b>
									</p>
									<p class="c5">
										Returns the UUID of the versionable node for which this is the version history.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Version</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getRootVersion()</b>
									</p>
									<p class="c5">
										Returns the root version of this version history.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>VersionIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getAllVersions()</b>
									</p>
									<p class="c5">
										Returns an iterator over all the versions within this version history. The order of the returned objects will not necessarily correspond to the order of versions in terms of the successor relation. To traverse the version graph one must traverse the <b>jcr:successors</b> <b>REFERENCE</b> properties starting with the root version (see above). A version history will always have at least one version, the root version. Therefore, this method will always return an iterator of at least size 1.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Version</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getVersion(String versionName)</b>
									</p>
									<p class="c5">
										Retrieves a particular version from this version history by version name.
									</p>
									<p class="c5">
										Throws a <b>VersionException</b> if the specified version is not in this version history.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Version</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getVersionByLabel(String label)</b>
									</p>
									<p class="c5">
										Retrieves a particular version from this version history by version label.
									</p>
									<p class="c5">
										Throws a <b>VersionException</b> if the specified <b>label</b> is not in this version history.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>addVersionLabel(String versionName,<br>
										String label,<br>
										boolean moveLabel)</b>
									</p>
									<p class="c5">
										Adds the specified label to the specified version. This corresponds to adding a value to the <b>jcr:versionLabels</b> multi-value property of the <b>nt:version</b> node that represents the specified version.
									</p>
									<p class="c5">
										Note that this change is made immediately; there is no need to call <b>save</b>. In fact, since the version storage is read-only with respect to normal repository methods, <b>save</b> does not even function in this context.
									</p>
									<p class="c5">
										Within a particular version history, a given label may appear a maximum of once. If the specified label is already assigned to a version in this history and <b>moveLabel</b> is <b>true</b> then the label is removed from its current location and added to the version with the specified <b>versionName</b>. If <b>moveLabel</b> is <b>false</b>, then an attempt to add a label that already exists in this version history will throw a <b>VersionException</b>.
									</p>
									<p class="c5">
										A <b>VersionException</b> is also thrown if the named version is not in this <b>VersionHistory</b> or if it is the root version (<b>jcr:rootVersion</b>).
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasVersionLabel(String label)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if any version in the history has the given <b>label</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>hasVersionLabel(Version version, String label)</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if the given <b>version</b> has the given <b>label</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getVersionLabels()</b>
									</p>
									<p class="c5">
										Returns all version labels of the history or an empty array if there are none.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getVersionLabels(Version version)</b>
									</p>
									<p class="c5">
										Returns all version labels of the given <b>version</b> - empty array if none.
									</p>
									<p class="c5">
										Throws a <b>VersionException</b> if the specified <b>version</b> is not in this version history.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>removeVersionLabel(String label)</b>
									</p>
									<p class="c5">
										Removes the specified label from among the labels of this version history. This corresponds to removing a property from the <b>jcr:versionLabels</b> child node of the <b>nt:versionHistory</b> node that represents this version history.
									</p>
									<p class="c5">
										Note that this change is made immediately; there is no need to call <b>save</b>. In fact, since the version storage is read-only with respect to normal repository methods, <b>save</b> does not even function in this context.
									</p>
									<p class="c5">
										If a <b>label</b> is specified that does not exist in this version history, a <b>VersionException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>removeVersion(String versionName)</b>
									</p>
									<p class="c5">
										Removes the named version from this version history and automatically repairs the version graph. If the version to be removed is <b>V</b>, <b>V</b>'s predecessor set is <b>P</b> and <b>V</b>'s successor set is <b>S</b>, then the version graph is repaired s follows:
									</p>
									<ul>
										<li>
											<p class="c5">
												For each member of <b>P</b>, remove the reference to <b>V</b> from its successor list and add references to each member of <b>S</b>.
											</p>
										</li>
										<li>
											<p class="c5">
												For each member of <b>S</b>, remove the reference to <b>V</b> from its predecessor list and add references to each member of <b>P</b>.
											</p>
										</li>
									</ul>
									<p class="c5">
										Note that this change is made immediately; there is no need to call <b>save</b>. In fact, since the version storage is read-only with respect to normal repository methods, <b>save</b> does not even function in this context.
									</p>
									<p class="c5">
										A <b>ReferentialIntegrityException</b> will be thrown if the specified version is currently the target of a <b>REFERENCE</b> property elsewhere in the repository (not necessarily in this workspace) and the current <b>Session</b> has read access to that <b>REFERENCE</b> property.
									</p>
									<p class="c5">
										An <b>AccessDeniedException</b> will be thrown if the current <b>Session</b> does not have permission to remove the specified version or if the specified version is currently the target of a <b>REFERENCE</b> property elsewhere in the repository (not necessarily in this workspace) and the current <b>Session</b> <i>does not</i> have read access to that <b>REFERENCE</b> property.
									</p>
									<p class="c5">
										Throws an <b>UnsupportedRepositoryOperationException</b> if this operation is not supported by the implementation.
									</p>
									<p class="c5">
										Throws a <b>VersionException</b> if the named version is not in this <b>VersionHistory</b>.
									</p>
									<p class="c5">
										Throws a <b>RepositoryException</b> if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.14.4." id="section_8.2.14.4."></a>8.2.14.4 The Version Interface
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A <b>Version</b> object provides an interface for an <b>nt:version</b> node. It provides convenient access to version information.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c5">
										javax.jcr.version.<br><b>Version</b> <b>extends Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>VersionHistory</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getContainingHistory()</b>
									</p>
									<p class="c5">
										Returns the <b>VersionHistory</b> that contains this <b>Version</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Calendar</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getCreated()</b>
									</p>
									<p class="c5">
										Returns the date this version was created. This corresponds to the value of the <b>jcr:created</b> property in the <b>nt:version</b> node that represents this version.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Version[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getSuccessors()</b>
									</p>
									<p class="c5">
										Returns the successor versions of this version. This corresponds to returning all the <b>nt:version</b> nodes referenced by the <b>jcr:successors</b> multi-value property in the <b>nt:version</b> node that represents this version.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Version[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPredecessors()</b>
									</p>
									<p class="c5">
										Returns the predecessor versions of this version. This corresponds to returning all the <b>nt:version</b> nodes whose <b>jcr:successors</b> property includes a reference to the <b>nt:version</b> node that represents this version.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.15." id="section_8.2.15."></a> 8.2.15 Serialization of Version Storage
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Serialization of version information can be done in the same way as normal serialization by serializing the subtree below <b>/jcr:system/jcr:versionStorage</b>. The special status of these nodes with respect to versioning is transparent to the serialization mechanism.
								</p>
							
							
								<p class="c5">
									The serialized content of the source version storage can be deserialized as “normal” content on the target repository, but it will not actually be interpreted and integrated into the repository as version storage data unless it is integrated into or used to replace the target repository's own version storage.
								</p>
							
							
								<p class="c5">
									Methods for doing this kind of “behind the scenes” alteration to an existing version storage (whether based on the serialized version storage of another repository, or otherwise) are beyond the scope of this specification.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.2.16." id="section_8.2.16."></a> 8.2.16 Versioning within a Transaction
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In a repository that supports both versioning and transactions, all versioning operations must be fully transactional, meaning that they can be bracketed within a transaction and rolled-back just like any other set of operations.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_8.3." id="section_8.3."></a>8.3 Observation
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A compliant content repository may support observation. This feature enables applications to register interest in events that describe changes to a workspace, and then monitor and respond to those events. The observation mechanism dispatches events when a <i>persistent change</i> is made to the workspace.
								</p>
							
							
								<p class="c5">
									Whether a particular implementation supports observation can be determined by querying the repository descriptor table with <b>Repository.getDescriptor("</b><b>OPTION_OBSERVATION_SUPPORTED")</b> (a return value of <b>true</b> indicates support for observation, see 6.1.1.1 Repository Descriptors).
								</p>
							
							
								<p class="c5">
									Note that (in those repositories that support transactions) in the case of changes made within a transaction, the corresponding events will only be dispatched upon <i>commit</i> of the transaction, whereas in the case of changes made outside a transaction the events will be dispatched upon <b>save</b> (or immediately in the case of direct-to-workspace methods). See <a href="#section_8.3.4.">8.3.4</a> <i>Event Production</i>.
								</p>
							
							
								<p class="c5">
									An object implementing the <b>Event</b> interface represents an event generated by a repository. It also contains the constants representing the five event types.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.observation.<b><br>
										Event</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getType()</b>
									</p>
									<p class="c5">
										Returns the type of this event. A constant defined by in this interface. One of <b>NODE_ADDED</b>, <b>NODE_REMOVED</b>, <b>PROPERTY_ADDED</b>, <b>PROPERTY_REMOVED</b> and <b>PROPERTY_CHANGED</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getPath()</b>
									</p>
									<p class="c5">
										Returns the absolute path of the item associated with this event. The interpretation given to the returned path depends upon the type of the event:
									</p>
									<ul>
										<li>
											<p class="c5">
												If the event type is <b>NODE_ADDED</b> then this method returns the absolute path of the node that was added.
											</p>
										</li>
										<li>
											<p class="c5">
												If the event type is <b>NODE_REMOVED</b> then this method returns the absolute path of the node that was removed.
											</p>
										</li>
										<li>
											<p class="c5">
												If the event type is <b>PROPERTY_ADDED</b> then this method returns the absolute path of the property that was added.
											</p>
										</li>
										<li>
											<p class="c5">
												If the event type is <b>PROPERTY_REMOVED</b> then this method returns the path of the property that was removed.
											</p>
										</li>
										<li>
											<p class="c5">
												If the event type is <b>PROPERTY_CHANGED</b> then this method returns the absolute path of the changed property.
											</p>
										</li>
									</ul>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getUserID()</b>
									</p>
									<p class="c5">
										Returns the user ID connected with this event. This is the string returned by <b>getUserID</b> of the session that caused the event.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c12">
										NODE_ADDED
									</p>
									<p class="c5">
										An event of this type is generated when a node is added.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c12">
										NODE_REMOVED
									</p>
									<p class="c5">
										An event of this type is generated when a node is removed.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c12">
										PROPERTY_ADDED
									</p>
									<p class="c5">
										An event of this type is generated when a property is added.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c12">
										PROPERTY_REMOVED
									</p>
									<p class="c5">
										An event of this type is generated when a property is removed.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>int</b>
									</p>
								</td>
								<td>
									<p class="c12">
										PROPERTY_CHANGED
									</p>
									<p class="c5">
										An event of this type is generated when the value of a property is changed.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.3.1." id="section_8.3.1."></a>8.3.1 Event Listeners
		</h4>
		
			
				
					
						
							
								<p class="c5">
									An application registers its interest in events by registering an event listener with the workspace. Listeners are <i>per workspace</i>, not repository-wide; they only receive events for the workspace in which they are registered.
								</p>
							
							
								<p class="c5">
									Note that it is up to the implementation whether changes made to the subtree below <b>jcr:system</b> trigger events (6.8 System Node).
								</p>
							
							
								<p class="c5">
									When an persistent change occurs, the repository calls the <b>onEvent</b> method of each registered listener that is entitled (based on the filters set for that listener) to receive notification, and passes it an <b>EventIterator</b> object. The <b>EventIterator</b> contains the bundle of events (again, filtered for that particular listener) that describe the persistent changes made to the workspace.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.observation.<b><br>
										EventListener</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>onEvent(EventIterator event)</b>
									</p>
									<p class="c5">
										This method is called when a bundle of events is dispatched. See <a href="#section_8.3.4.">8.3.4</a> <i>Event Production</i>.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.3.2." id="section_8.3.2."></a>8.3.2 Listener Registration
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Registration of event listeners is done through the <b>ObservationManager</b> object acquired from the <b>Workspace</b>.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<b><br>
										Workspace</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Observation<br>
										Manager</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getObservationManager()</b>
									</p>
									<p class="c5">
										Returns the <b>ObservationManager</b> object.
									</p>
									<p class="c5">
										If the implementation does not support observation, an <b>UnsupportedRepositoryOperationException</b> is thrown.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.3.3." id="section_8.3.3."></a>8.3.3 Observation Manager
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>ObservationManager</b> interface supports listener registration and deregistration.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.observation.<b><br>
										ObservationManager</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>addEventListener(EventListener listener,<br>
										int eventTypes,<br>
										String absPath,<br>
										boolean isDeep,<br>
										String[] uuid,<br>
										String[] nodeTypeName,<br>
										boolean noLocal)</b>
									</p>
									<p class="c5">
										Adds an event listener that listens for the specified <b>eventTypes</b> (a combination of one or more event types encoded as a bit mask value).
									</p>
									<p class="c5">
										The set of events can be filtered by specifying restrictions based on characteristics of the <i>associated parent node</i> of the event. The associated parent node of an event is the parent node of the item at (or formerly at) the path returned by <b>Event.getPath</b>. The following restrictions are available:
									</p>
									<ul>
										<li>
											<p class="c5">
												<b>absPath, isDeep</b>: Only events whose associated parent node is at <b>absPath</b> (or within its subtree, if <b>isDeep</b> is <b>true</b>) will be received. It is permissible to register a listener for a path where no node currently exists.
											</p>
										</li>
									</ul>
									<ul>
										<li>
											<p class="c5">
												<b>uuid</b>: Only events whose associated parent node has one of the UUIDs in this list will be received. If this parameter is <b>null</b> then no UUID-related restriction is placed on events received. Note that specifying an empty array instead of <b>null</b> would result in no nodes being listened to.
											</p>
										</li>
										<li>
											<p class="c5">
												<b>nodeTypeName:</b> Only events whose associated parent node has one of the node types (or a subtype of one of the node types) in this list will be received. If this parameter is <b>null</b> then no node type-related restriction is placed on events received. Note that specifying an empty array instead of <b>null</b> would result in no node types being listened to.
											</p>
										</li>
									</ul>
									<p class="c5">
										The restrictions are "ANDed" together. In other words, for a particular node to be listened to, it must meet <i>all</i> the restrictions.
									</p>
									<p class="c5">
										Additionally, if <b>noLocal</b> is <b>true</b>, then events generated by the session through which the listener was registered are ignored. Otherwise, they are not ignored.
									</p>
									<p class="c5">
										The filters of an already-registered <b>EventListener</b> can be changed at runtime by re-registering the same <b>EventListener</b> object (i.e. the same actual Java object) with a new set of filter arguments. The implementation must ensure that no events are lost during the changeover.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>removeEventListener(EventListener listener)</b>
									</p>
									<p class="c5">
										Deregisters an event listener.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>EventListenerIterator</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getRegisteredEventListeners()</b>
									</p>
									<p class="c5">
										Returns all event listeners that have been registered through this session. If no listeners have been registered, an empty iterator is returned.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.3.4." id="section_8.3.4."></a>8.3.4 Event Production
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Events are dispatched upon each <i>persistent change</i> to the workspace. Changes that affect only the transient session level are not tracked by the observation mechanism. This means that events will be dispatched as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					If a set of operations is <i>within a transaction</i> (see <a href="#section_8.1.">8.1</a> <i>Transactions</i>) then the events reflecting the resulting changes will only be dispatched after the changes are persisted by a successful <i>commit</i>.
				</p>
			</li>
			<li>
				<p class="c5">
					If a set of operations is <i>not within a transaction</i> then:
				</p>
				<ul>
					<li>
						<p class="c5">
							If an operation is <i>immediately persistent</i> (like <b>Workspace.copy</b>, for example), the events reflecting the resulting changes will be dispatched upon the successful completion of the operation.
						</p>
					</li>
					<li>
						<p class="c5">
							If a set of operations is <i>not immediately persistent</i> (like most <b>Node</b> and <b>Session</b> methods, for example) then the events reflecting the resulting changes will be dispatched upon the successful <b>save</b> of those changes.
						</p>
					</li>
				</ul>
			</li>
		</ul>
		<h4>
			<a name="section_8.3.5." id="section_8.3.5."></a>8.3.5 Event Filtering
		</h4>
		
			
				
					
						
							
								<p class="c5">
									An event listener will only receive events for which its session (the session through which it was registered) has sufficient access control permissions and which meet the filtering restrictions specified upon registration. See <a href="#section_8.3.3.">8.3.3</a> <i>Observation Manager</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.6." id="section_8.3.6."></a>8.3.6 Event Bundles
		</h4>
		
			
				
					
						
							
								<p class="c5">
									On each persistent change, those listeners that are entitled to receive one or more events will have their <b>onEvent</b> method called and be passed an <b>EventIterator</b>.
								</p>
							
							
								<p class="c5">
									The <b>EventIterator</b> will contain the event bundle reflecting the persistent changes made but excluding those to which that particular listener is not entitled, according to the listeners access permissions and filters.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7." id="section_8.3.7."></a> 8.3.7 Interpretation of Events
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The set of available event types is small, consisting of only five types: <b>NODE_ADDED</b>, <b>NODE_REMOVED</b>, <b>PROPERTY_ADDED, PROPERTY_REMOVED</b> and <b>PROPERTY_CHANGED</b>. The intent of the event notification system is to describe, for every persistent operation, the resulting state change in the workspace, and not necessarily the operational steps performed by the client that lead to that change. The set of five event types and the bundling of those events is sufficient to describe any state change and make that change correctly interpretable by the consumer of the events. The following describes the events generated as a result of a number of common operations. Note that the following describes the events that would be generated when the change caused by the operation in question is persisted.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.1." id="section_8.3.7.1."></a>8.3.7.1 Creating a new Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a new node is created, distinct events are generated for the addition of the actual new node itself (a <b>NODE_ADDED</b> event) as well for each of the automatically created child nodes or properties (either <b>NODE_ADDED</b> or <b>PROPERTY_ADDED</b>, as the case may be). This includes properties required by the system, such as <b>jcr:primaryType</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.2." id="section_8.3.7.2."></a>8.3.7.2 Creating a Property
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a new property is created, a <b>PROPERTY_ADDED</b> event is generated. No <b>PROPERTY_CHANGED</b> event is generated.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.3." id="section_8.3.7.3."></a>8.3.7.3 Changing a Property
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When an existing property's value is changed, a <b>PROPERTY_CHANGED</b> event is generated.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.4." id="section_8.3.7.4."></a>8.3.7.4 Removing a Child Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a node is removed, a <b>NODE_REMOVED</b> event <i>must</i> be generated for the node on which the <b>remove</b> was called. Additionally, an implementation <i>should</i> also generate a <b>NODE_REMOVE</b> or <b>PROPERTY_REMOVE</b> (as appropriate) for each item in the removed subtree.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.5." id="section_8.3.7.5."></a>8.3.7.5 Removing a Property
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a property is removed, a <b>PROPERTY_REMOVED</b> event is generated.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.6." id="section_8.3.7.6."></a>8.3.7.6 Copying a Subtree
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a subtree is copied, an implementation <i>must</i> generate a single <b>NODE_ADDED</b> event reflecting the addition of the root of the copied subtree at the destination location. Additionally, an implementation <i>should</i> generate appropriate events for each resulting node and property addition in the copied subtree.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.7." id="section_8.3.7.7."></a>8.3.7.7 Moving a Subtree
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a subtree is moved an implementation <i>must</i> generate a <b>NODE_REMOVED</b> for the removal of the root of the moved subtree from the source location and a <b>NODE_ADDED</b> for its addition at the destination location. Additionally, an implementation <i>should</i> generate a <b>NODE_REMOVE</b> or <b>PROPERTY_REMOVE</b> (as appropriate) for each node and property removed from its source path location and a <b>NODE_ADDED</b> or <b>PROPERTY_ADDED</b> (as appropriate) for each node and property added at its destination path location.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.8." id="section_8.3.7.8."></a>8.3.7.8 Re-ordering a set of Child Nodes
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When an <b>orderBefore(A, B)</b> is performed, an implementation <i>must</i> generate a <b>NODE_REMOVED</b> for node <b>A</b> and a <b>NODE_ADDED</b> for node <b>A</b>. Note that the paths associated with these two events will either differ by the last index number (if the movement of A causes it to be re-ordered with respect to its same-name siblings) or be identical (if <b>A</b> does not have same-name siblings or if the movement of <b>A</b> does not change its order relative to its same-name siblings). Additionally, an implementation <i>should</i> generate appropriate events reflecting the “shifting over” of the node <b>B</b> and any nodes that come after it in the child node ordering. Each such shifted node would also produce a <b>NODE_REMOVED</b> and <b>NODE_ADDED</b> event pair with paths differing at most by a final index.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.9." id="section_8.3.7.9."></a>8.3.7.9 Adding a Mixin
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If this is the <i>first</i> mixin to be added to this node<i>,</i> a <b>PROPERTY_ADDED</b> event will be generated reflecting the addition of the multi-value <b>jcr:mixinTypes</b> property. If this is <i>not</i> the first mixin to be added then a <b>PROPERTY_CHANGED</b> event will be generated reflecting the addition of the new value to <b>jcr:mixinTypes</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.10." id="section_8.3.7.10."></a>8.3.7.10 Removing a Mixin
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Assuming an implementation allows removal of mixin types then a <b>PROPERTY_CHANGED</b> event is produced reflecting the removal of the relevant value from <b>jcr:mixinTypes</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.11." id="section_8.3.7.11."></a>8.3.7.11 Checking in a Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									In versioning repositories, the version storage appears as a protected subtree of each workspace. By placing listeners on this subtree a client can be alerted to versioning events. The events generated will reflect the changes made to the version storage area (for example, the addition of a new <b>nt:version</b> node below an <b>nt:versionHistory</b> node) as a result of the check-in operation. From this information the source of the check-in can be determined (for example, the <b>nt:frozenNode</b>'s <b>jcr:frozenUuid</b> property holds the UUID of the workspace node that was checked-in).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.12." id="section_8.3.7.12."></a>8.3.7.12 Restoring, Updating or Merging a Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Restoring updating and merging of nodes will generate events that reflect the changes made to those nodes as a result of the operation.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.7.13." id="section_8.3.7.13."></a>8.3.7.13 Locking and Unlocking a Node
		</h4>
		
			
				
					
						
							
								<p class="c5">
									By listening for changes on <b>mix:lockable</b> nodes, locking events can be detected. Locking a node will generate <b>PROPERTY_ADDED</b> events reflecting the addition of the <b>jcr:lockOwner</b> and <b>jcr:lockIsDeep</b> properties. Unlocking a node will generate <b>PROPERTY_REMOVED</b> events reflecting the removal of these properties.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.8." id="section_8.3.8."></a>8.3.8 Deserializing Content
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Whether events are generated for each node and property addition that occurs when content is deserialized into a workspace is left up to the implementation.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.9." id="section_8.3.9."></a>8.3.9 External Mechanisms
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Whether events are generated for changes made to a workspace through mechanisms external to this specification is left up to the implementation.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.10." id="section_8.3.10."></a>8.3.10 Location of Listeners
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The classes implementing the listener interfaces will reside on the same JVM as the repository itself. In implementations where both the application using the API and the repository itself are operating on the same JVM, this poses no particular problems.
								</p>
							
							
								<p class="c5">
									In client-server implementations that use RMI to connect the application to a remote repository, the application must ensure that any listeners registered to the repository are serializable, thus allowing them to be passed to the JVM running the repository instance.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.11." id="section_8.3.11."></a> 8.3.11 Persistence of Event Listeners
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Though not explicitly defined in this specification, nothing prevents a repository from registering “Persistent Event Listeners” through its configuration.
								</p>
							
							
								<p class="c5">
									Since the “persistence” of an event listener is only limited through the registering <b>Session</b>’s lifespan, the repository can use the same mechanisms as for a non-durable registration but use a session that has the lifespan of the repository instance (the “system” session, for example).
								</p>
							
							
								<p class="c5">
									Persistent event listeners may be used to provide more system level functionality such as specialized access control and syndication/replication mechanisms.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.12." id="section_8.3.12."></a> 8.3.12 Vetoable Event Listeners
		</h4>
		
			
				
					
						
							
								<p class="c5">
									This specification defines only <i>asynchronous</i> event delivery. It is possible for a repository to also implement <i>synchronous</i> events in order to support the vetoing of changes before they happen. However, this functionality is outside the scope of this specification.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.3.13." id="section_8.3.13."></a>8.3.13 Exceptions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The method <b>EventListener.onEvent</b> does not specify a <b>throws</b> clause. This does not prevent a listener from throwing a <b>RuntimeException</b>, although any listener that does should be considered to be in error.
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_8.4." id="section_8.4."></a>8.4 Locking
		</h3>
		
			
				
					
						
							
								<p class="c5">
									In those repositories that support it, locking allows a user to temporarily lock nodes in order to prevent other users from changing them.
								</p>
							
							
								<p class="c5">
									This function is typically used to serialize access to a node in order to forestall the “lost update problem”. Though a compliant content repository will already prevents this kind of inadvertent overwriting of repository content through the <b>InvalidItemStateException</b>, the use of locking can prevent the exception from occurring in the first place.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.1." id="section_8.4.1."></a> 8.4.1 Discovery of Lock Capabilities
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Whether a particular implementation supports locking can be determined by querying the repository descriptor table with <b>Repository.getDescriptor("</b><b>OPTION_LOCKING_SUPPORTED")</b> (a return value of <b>true</b> indicates support for locking, see 6.1.1.1 Repository Descriptors).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.2." id="section_8.4.2."></a>8.4.2 Lockable
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A lock is placed on a node by calling <b>Node.lock</b>. The node on which a lock is placed is called the <i>holding node</i> of that lock. Only nodes with mixin node type <b>mix:lockable</b> (inherited as part of their primary node type or explicitly assigned) may hold locks. The definition of <b>mix:lockable</b> is:
								</p>
							
							
								<p class="c12">
									<i>NodeTypeName</i>
								</p>
							
							
								<p class="c12">
									<b>mix:lockable</b>
								</p>
							
							
								<p class="c12">
									<i>Supertypes</i>
								</p>
							
							
								<p class="c12">
									<b>[]</b>
								</p>
							
							
								<p class="c12">
									<i>IsMixin</i>
								</p>
							
							
								<p class="c12">
									<b>true</b>
								</p>
							
							
								<p class="c12">
									<i>HasOrderableChildNodes</i>
								</p>
							
							
								<p class="c12">
									<b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PrimaryItemName</i>
								</p>
							
							
								<p class="c12">
									<b>null</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:lockOwner</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>STRING</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
							
								<p class="c12">
									<i>PropertyDefinition</i>
								</p>
							
							
								<p class="c12">
									Name <b>jcr:lockIsDeep</b>
								</p>
							
							
								<p class="c12">
									RequiredType <b>BOOLEAN</b>
								</p>
							
							
								<p class="c12">
									ValueConstraints <b>[]</b>
								</p>
							
							
								<p class="c12">
									DefaultValues <b>null</b>
								</p>
							
							
								<p class="c12">
									AutoCreated <b>false</b>
								</p>
							
							
								<p class="c12">
									Mandatory <b>false</b>
								</p>
							
							
								<p class="c12">
									OnParentVersion <b>IGNORE</b>
								</p>
							
							
								<p class="c12">
									Protected <b>true</b>
								</p>
							
							
								<p class="c12">
									Multiple <b>false</b>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.3." id="section_8.4.3."></a>8.4.3 Shallow and Deep Locks
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A lock can be specified as either <i>shallow</i> or <i>deep</i>. A shallow lock applies only to its holding node. A deep lock applies to its holding node and all its descendants.
								</p>
							
							
								<p class="c5">
									Consequently, there is a distinction between a lock <i>being held by</i> a node and a lock <i>applying to</i> a node. A lock always applies to its holding node. However, if it is a deep lock, it also applies to all nodes in the holding node's subtree. When a lock applies to a node, that node is said to be <i>locked</i>.
								</p>
							
							
								<p class="c5">
									Since a deep lock applies to all nodes in the lock-holding node's subtree, this may include both <b>mix:lockable</b> nodes and non-<b>mix:lockable</b> nodes. The deep lock applies to both categories of node equally and it <i>does not</i> add any <b>jcr:lockOwner</b> or <b>jcr:isDeep</b> properties to any of the deep-locked <b>mix:lockable</b> nodes. However, if any such nodes exist and they already have these properties, this means that they are already locked, and hence the attempt to deep lock above them will fail.
								</p>
							
							
								<p class="c5">
									Additionally, assuming a deep lock exists above a <b>mix:lockable</b> node any attempt to lock this lower level <b>mix:lockable</b> node will also fail, because it is already locked from above.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.4." id="section_8.4.4."></a>8.4.4 Lock Owner
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The user who places a lock on a node is called the lock owner. The lock owner is identified by the user ID bound to the <b>Session</b> through which the node in question was accessed (that is, the string returned by <b>Session.getUserID</b>). The user ID is recorded in the property <b>jcr:lockOwner</b> of the lock holding node. The lock owner's ID is provided for informational purposes only, it is not used in testing whether a particular user has any permissions with respect to the lock (this is governed purely by whether the <b>Session</b> holds the applicable lock token, see below).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.5." id="section_8.4.5."></a> 8.4.5 Placing and Removing a Lock
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When <b>Node.lock</b> is performed on a <b>mix:lockable</b> node, the properties defined in that node type are automatically created and set as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>jcr:lockOwner</b> is set to the user ID of the user who set the lock (this is the value returned by <b>Session.getUserID</b>).
				</p>
			</li>
			<li>
				<p class="c5">
					<b>jcr:lockIsDeep</b> is set to reflect whether the lock is deep or not.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									When <b>Node.unlock</b> is performed on a locked <b>mix:lockable</b> node, by a user with the correct lock token (see below) these two properties are removed. The identity of the holder of the lock token does not matter (it does not have to be the lock owner). Anyone with the correct token can remove the lock.
								</p>
							
							
								<p class="c5">
									Additionally, the content repository may give permission to some users to unlock locks for which they do not have the lock token. Typically such “lock-superuser” capability is intended to facilitate administrational clean-up of orphaned open-scoped locks.
								</p>
							
							
								<p class="c5">
									An attempt to call <b>lock</b> or <b>unlock</b> on a node that is not <b>mix:lockable</b> will throw a <b>UnsupportedRepositoryOperationException</b>.
								</p>
							
							
								<p class="c5">
									An attempt to lock an already locked node or unlock an already unlocked node will throw a <b>LockException</b>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.6." id="section_8.4.6."></a>8.4.6 Lock Token
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The method <b>Node.lock</b> returns a <b>Lock</b> object, which in turn contains a lock token. A lock token is a string that uniquely identifies a particular lock and acts as a “key” allowing a user to alter a locked node.
								</p>
							
							
								<p class="c5">
									In order to use the lock token as a key, it must be added to the <b>Session</b> of the user, thus empowering that session to alter the nodes to which the lock applies. When a lock token is attached to a <b>Session</b>, the user of that session becomes a <i>token holder</i> of that lock token.
								</p>
							
							
								<p class="c5">
									The method <b>Node.lock</b> automatically adds the lock token for a newly placed lock to the current <b>Session</b>. If a user requires more control over which lock tokens are attached to the session, the <b>Session</b> interface provides the methods <b>addLockToken</b>, <b>removeLockToken</b> and <b>getLockTokens</b>.
								</p>
							
							
								<p class="c5">
									Note that, as mentioned above, any user with the correct lock token assumes the power to remove a lock and alter nodes under that lock. It does not have to be the lock owner.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.7." id="section_8.4.7."></a> 8.4.7 Session-scoped and Open-scoped Locks
		</h4>
		
			
				
					
						
							
								<p class="c5">
									When a lock is placed on a node, it can be specified to be either a session-scoped lock or an open-scoped lock. A session-scoped lock automatically expires when the session through which the lock owner placed the lock expires. An open-scoped lock does not expire until it is either explicitly unlocked or an implementation-specific limitation intervenes (like a timeout, see below).
								</p>
							
							
								<p class="c5">
									In both cases, the lock token must be attached to the current session in order to alter any nodes locked by that token's lock. In the case of session-scoped locks, however, the user need not explicitly do anything since the token is automatically attached to the session and expires with it in any case.
								</p>
							
							
								<p class="c5">
									With open–scoped locks the token is also automatically attached to the session. However, the user must additionally ensure that a reference to the lock token is preserved separately so that it can later be attached to another session. By assumption, an open-scoped lock is being used to avoid co-expiration with the initial session. Otherwise, there would be no point in using an open scoped lock, since session scoping would suffice. It is for handling these cases of attaching an existing lock token from a previous session to a new session that the methods <b>addLockToken</b>, <b>removeLockToken</b> and <b>getLockTokens</b> are provided.
								</p>
							
							
								<p class="c5">
									To determine an existing lock’s scoping, the method <b>Lock.isSessionScoped()</b> is provided.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.8." id="section_8.4.8."></a>8.4.8 Effect of a Lock
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If a lock applies to particular node (i.e., the node either holds the lock or is a descendant of a node holding a deep lock), that node cannot be changed by anyone except the user who is the token holder for that lock. The user need not be the lock owner.
								</p>
							
							
								<p class="c5">
									Note that since at most one session per repository may hold the same lock token, serial access to the locked item is ensured.
								</p>
							
							
								<p class="c5">
									More precisely, a lock applying to a node prevents all non-token holders from doing any of the following:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Adding or removing its properties.
				</p>
			</li>
			<li>
				<p class="c5">
					Changing the values of its properties.
				</p>
			</li>
			<li>
				<p class="c5">
					Adding or removing its child nodes.
				</p>
			</li>
			<li>
				<p class="c5">
					Adding or removing its mixin node types.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									<i>Removing</i> a node is considered an alteration of <i>its parent</i>. This means that a locked node may be removed by any user with sufficient access permissions as long as its parent node is not locked.
								</p>
							
							
								<p class="c5">
									Similarly, a locked node and its subtree may be moved, if both the source parent and the destination parent-to-be are not locked. Locked nodes can always be read and copied (that is, serve as the source of a copy) by any user with sufficient access permissions.
								</p>
							
							
								<p class="c5">
									When an action is prevented due to a lock, a <b>LockException</b> is thrown either immediately or on the subsequent <b>save</b>. Implementations may differ on which of these behaviors is used to enforce locking.
								</p>
							
							
								<p class="c5">
									There is at most one lock on any node at one time.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.9." id="section_8.4.9."></a>8.4.9 Timing Out
		</h4>
		
			
				
					
						
							
								<p class="c5">
									An implementation may unlock any lock at any time due to implementation-specific criteria, such as time limits on locks.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.10." id="section_8.4.10."></a>8.4.10 Locks and Transactions
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Locking and unlocking are treated just like any other operation in the context of a transaction. For example, consider the following series of operations:
								</p>
							
							
								<p class="c5">
									<i>begin</i><br>
									<b>lock<br></b> <i>do A<br></i> <b>save<br></b> <i>do B<br></i> <b>save<br>
									unlock<br></b><i>commit</i>
								</p>
							
							
								<p class="c5">
									In this example the <b>lock</b> and <b>unlock</b> have no effect. This series of operations is equivalent to:
								</p>
							
							
								<p class="c5">
									<i>begin</i><br>
									<i>do A<br></i> <b>save<br></b> <i>do B<br></i> <b>save<br></b><i>commit</i>
								</p>
							
							
								<p class="c5">
									The reason for this is that changes to a workspace are only published (that is, made visible to other <b>Session</b>s) upon commit of the transaction, and this includes changes in the locked status of a node. As a result, if a lock is enabled and then disabled within the same transaction, its effect never makes it to the persistent workspace and therefore it does nothing.
								</p>
							
							
								<p class="c5">
									In order to use locks properly (that is, to prevent the “lost update problem”), locking and unlocking must be done in separate transactions. For example:
								</p>
							
							
								<p class="c5">
									<i>begin</i><br>
									<b>lock<br></b><i>commit</i>
								</p>
							
							
								<p class="c5">
									<i>begin</i><br>
									<i>do A<br></i> <b>save<br></b> <i>do B<br></i> <b>save<br>
									unlock<br></b><i>commit</i>
								</p>
							
							
								<p class="c5">
									This series of operations would ensure that the actions <i>A</i> and <i>B</i> are protected by the lock.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.11." id="section_8.4.11."></a>8.4.11 Locking Methods
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The methods for locking, unlocking and querying the locking status of a node are found in the <b>Node</b> interface itself:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Node</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Lock</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>lock(boolean isDeep, boolean isSessionScoped)</b>
									</p>
									<p class="c5">
										Places a lock on this node. If successful, this node is said to <i>hold</i> the lock.
									</p>
									<p class="c5">
										If <b>isDeep</b> is <b>true</b> then the lock <i>applies</i> to this node and all its descendant nodes; if <b>false</b>, the lock applies only to this, the holding node.
									</p>
									<p class="c5">
										If <b>isSessionScoped</b> is <b>true</b> then this lock will expire upon the expiration of the current session (either through an automatic or explicit <b>Session.logout</b>); if <b>false</b>, this lock does not expire until explicitly unlocked or automatically unlocked due to a implementation-specific limitation, such as a timeout.
									</p>
									<p class="c5">
										Returns a <b>Lock</b> object reflecting the state of the new lock and including a lock token.
									</p>
									<p class="c5">
										The lock token is also automatically added to the set of lock tokens held by the current <b>Session</b>.
									</p>
									<p class="c5">
										If successful, then the property <b>jcr:lockOwner</b> is created and set to the value of <b>Session.getUserID</b> for the current session and the property <b>jcr:lockIsDeep</b> is set to the value passed in as <b>isDeep</b>. These changes are persisted automatically; there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										Note that it is possible to lock a node even if it is checked-in (the lock-related properties will be changed despite the checked-in status). See <a href="#section_8.2.">8.2</a> <i>Versioning</i> for an explanation of “checked-in” status.
									</p>
									<p class="c5">
										If this node is not of mixin node type <b>mix:lockable</b> then a <b>LockException</b> is thrown.
									</p>
									<p class="c5">
										If this node is already locked (either because it holds a lock or a lock above it applies to it), a <b>LockException</b> is thrown.
									</p>
									<p class="c5">
										If <b>isDeep</b> is <b>true</b> and a descendant node of this node already holds a lock, then a <b>LockException</b> is thrown.
									</p>
									<p class="c5">
										If the current session does not have sufficient permissions to place the lock, an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this node has pending unsaved changes.
									</p>
									<p class="c5">
										An <b>UnsupportedRepositoryOperationException</b> is thrown if this implementation does not support locking.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Lock</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLock()</b>
									</p>
									<p class="c5">
										Returns the <b>Lock</b> object that applies to this node. This may be either a lock on this node itself or a deep lock on a node above this node.
									</p>
									<p class="c5">
										If this <b>Session</b> (the one through which this <b>Node</b> was acquired) holds the lock token for this lock, then the returned <b>Lock</b> object contains that lock token (accessible through <b>Lock.getLockToken</b>). If this <b>Session</b> does not hold the applicable lock token, then the returned <b>Lock</b> object will not contain the lock token (its <b>Lock.getLockToken</b> method will return <b>null</b>). See <b>Lock</b>, below.
									</p>
									<p class="c5">
										If this node is not locked (no lock applies to this node) then a <b>LockException</b> is thrown.
									</p>
									<p class="c5">
										If the current session does not have sufficient permissions to get the lock, an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										An <b>UnsupportedRepositoryOperationException</b> is thrown if this implementation does not support locking.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>unlock()</b>
									</p>
									<p class="c5">
										Removes the lock on this node. Also removes the properties <b>jcr:lockOwner</b> and <b>jcr:lockIsDeep</b> from this node. These changes are persisted automatically; there is no need to call <b>save</b>.
									</p>
									<p class="c5">
										If this node does not currently hold a lock or holds a lock for which this <b>Session</b> does not have the correct lock token, then a <b>LockException</b> is thrown. Note however that the system may give permission to some users to unlock locks for which they do not have the lock token. Typically such “lock-superuser” capability is intended to facilitate administrational clean-up of orphaned open-scoped locks.
									</p>
									<p class="c5">
										Note also that it is possible to unlock a node even if it is checked-in (the lock-related properties will be changed despite the checked-in status). See <a href="#section_8.2.">8.2</a> <i>Versioning</i> for an explanation of “checked-in” status.
									</p>
									<p class="c5">
										If the current session does not have sufficient permissions to remove the lock, an <b>AccessDeniedException</b> is thrown.
									</p>
									<p class="c5">
										An <b>InvalidItemStateException</b> is thrown if this node has pending unsaved changes.
									</p>
									<p class="c5">
										An <b>UnsupportedRepositoryOperationException</b> is thrown if this implementation does not support locking.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>holdsLock()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node holds a lock; otherwise returns <b>false</b>. To <i>hold</i> a lock means that this node has actually had a lock placed on it specifically, as opposed to just having a lock <i>apply</i> to it due to a deep lock held by an node above.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isLocked()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this node is locked either as a result of a lock held by this node or by a deep lock on a node above this node; otherwise returns <b>false</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.12." id="section_8.4.12."></a>8.4.12 The Lock Object
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Lock</b> object represents a lock on a particular node:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.lock.<br>
										<b>Lock</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLockOwner()</b>
									</p>
									<p class="c5">
										Returns the user ID of the user who owns this lock. This is the value of the <b>jcr:lockOwner</b> property of the lock-holding node. It is also the value returned by <b>Session.getUserID</b> at the time that the lock was placed. The lock owner's identity is only provided for informational purposes. It does not govern who can perform an <b>unlock</b> or make changes to the locked nodes; that depends entirely upon who the token holder is.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isDeep()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this is a deep lock; <b>false</b> otherwise.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>Node</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getNode()</b>
									</p>
									<p class="c5">
										Returns the lock holding node. Note that <b>N.getLock().getNode()</b> (where <b>N</b> is a locked node) will only return <b>N</b> if <b>N</b> is the lock holder. If <b>N</b> is in the subtree of the lock holder, <b>H</b>, then this call will return <b>H</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLockToken()</b>
									</p>
									<p class="c5">
										May return the lock token for this lock. If this <b>Session</b> holds the lock token for this lock, then this method will return that lock token. If this <b>Session</b> does not hold the applicable lock token then this method will return <b>null</b>.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isLive()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this <b>Lock</b> object represents a lock that is currently in effect. If this lock has been unlocked either explicitly or due to an implementation-specific limitation (like a timeout) then it returns <b>false</b>. Note that this method is intended for those cases where one is holding a <b>Lock</b> Java object and wants to find out whether the lock (the repository-level entity that is attached to the lockable node) that this object originally represented still exists. For example, a timeout or explicit <b>unlock</b> will remove a lock from a node but the <b>Lock</b> Java object corresponding to that lock may still exist, and in that case its <b>isLive</b> method will return <b>false</b>.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if an error occurs.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>boolean</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>isSessionScoped()</b>
									</p>
									<p class="c5">
										Returns <b>true</b> if this is a session-scoped lock. Returns <b>false</b> if this is an open-scoped lock.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>refresh()</b>
									</p>
									<p class="c5">
										If this lock's time-to-live is governed by a timer, this method resets that timer so that the lock does not timeout and expire. If this lock's time-to-live is not governed by a timer, then this method has no effect.
									</p>
									<p class="c5">
										A <b>LockException</b> is thrown if this <b>Session</b> does not hold the correct lock token for this lock.
									</p>
									<p class="c5">
										A <b>RepositoryException</b> is thrown if another error occurs.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.4.13." id="section_8.4.13."></a> 8.4.13 Session Methods Related to the Lock Token
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>Session</b> object provides the following methods for managing lock tokens:
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.<br>
										<b>Session</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>addLockToken(String lt)</b>
									</p>
									<p class="c5">
										Adds the specified lock token to this session. Holding a lock token allows the <b>Session</b> object of the lock owner to alter nodes that are locked by the lock specified by that particular lock token.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>String[]</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>getLockTokens()</b>
									</p>
									<p class="c5">
										Returns an array containing all lock tokens currently held by this session.
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										<b>void</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>removeLockToken(String lt)</b>
									</p>
									<p class="c5">
										Removes the specified lock token from this session.
									</p>
								</td>
							</tr>
						</table>
						
							
								<p>
									<br>
									<br>
								</p>
							
						
					
				
			
		
		<h3>
			<a name="section_8.5." id="section_8.5."></a> 8.5 Searching Repository Content with SQL
		</h3>
		
			
				
					
						
							
								<p class="c5">
									A repository (either level 1 or level 2) may support search using the SQL query syntax.
								</p>
							
							
								<p class="c5">
									Whether a particular implementation supports SQL can be determined by querying the repository descriptor table with <b>Repository.getDescriptor("</b><b>OPTION_QUERY_SQL_SUPPORTED")</b> (a return value of <b>true</b> indicates support for SQL, see 6.1.1.1 Repository Descriptors).
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.1." id="section_8.5.1."></a>8.5.1 The SQL Language
		</h4>
		
			
				
					
						
							
								<p class="c5">
									If supported, the SQL language syntax is invoked by specifying the constant <b>Query.SQL</b> in <b>QueryManager.createQuery</b> (see <a href="#section_6.6.8.">6.6.8</a> Query API):
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr>
								<td colspan="2" valign="top">
									<p class="c12">
										javax.jcr.query.<br>
										<b>Query</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c12">
										String
									</p>
								</td>
								<td>
									<p class="c5">
										<b>SQL</b>
									</p>
									<p class="c5">
										A string constant representing the SQL query language applied to the <i>database view</i> of the workspace.
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.5.2." id="section_8.5.2."></a>8.5.2 Database View
		</h4>
		
			
				
					
						
							
								<p class="c5">
									SQL queries can be thought of as working against a <i>database view</i> of the workspace being searched (similar in principle to the two XML views described in <a href="#section_6.4.">6.4</a> <i>XML Mappings</i>).
								</p>
							
							
								<p class="c5">
									Note however, that it is entirely up to the implementation whether this database view directly reflects the underlying storage mechanisms of the repository (as it might in repositories that are actually database-backed). All that is required is that if SQL queries are supported, they behave as if they were running against the database view described below.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.2.1." id="section_8.5.2.1."></a>8.5.2.1 Node Types as Tables
		</h4>
		<ul>
			<li>
				<p class="c5">
					Each node type (primary or mixin) corresponds to a table.
				</p>
			</li>
			<li>
				<p class="c5">
					Each column in the table corresponds to a property defined in or inherited by that node type (including properties inherited from either primary or mixin node types). Modeling residual properties as columns is optional (see below).
				</p>
			</li>
			<li>
				<p class="c5">
					Each row corresponds to a node in the workspace.
				</p>
			</li>
			<li>
				<p class="c5">
					Note that because of the hierarchical structure of node type definitions, nodes will appear in more than just one table. For example, querying the <b>nt:base</b> table will show all nodes in the workspace, but that table will be limited to the columns corresponding to the properties defined by <b>nt:base</b>: <b>jcr:primaryType</b> and <b>jcr:mixinTypes</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Child node relationships are not recorded in the database view.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.2." id="section_8.5.2.2."></a>8.5.2.2 Pseudo-property jcr:path
		</h4>
		<ul>
			<li>
				<p class="c5">
					A special column, <b>jcr:path</b>, that does not correspond to any actual property is present in node type tables. The <b>jcr:path</b> column holds the normalized absolute path for the node represented by each row.
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>jcr:path</b> column always appears in the result table
				</p>
			</li>
			<li>
				<p class="c5">
					Note that the actual value of a particular <b>jcr:path</b> column within a particular <b>Row</b> of the result table can be calculated by the implementation at the time that a request is made for that value. For example, on the call <b>someRow.getValue("jcr:path")</b> (where <b>someRow</b> is an instance of <b>Row</b>). This type of “lazy loading” allows implementations to avoid calculating paths for all nodes in the return set at query time. Such an approach would be advantageous for those implementations in which path calculation is expensive.
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>jcr:path</b> value returned in a result table will be in <i>compact form</i>, where index notation is only used if necessary, i.e., where lack of an index indicates an implicit index of <b>[1]</b>. However, when a test is performed within a <b>WHERE</b> clause against a <b>jcr:path</b>, the query mechanism will intelligently match both compact and explicit forms of the same path. For example, the following <b>WHERE</b> clauses define the same constraint:
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								
									
										<p class="c5">
											<b>WHERE jcr:path='/foo/bar'</b>
										</p>
									
									
										<p class="c5">
											<b>WHERE jcr:path='/foo[1]/bar[1]'</b>
										</p>
									
									
										<p class="c14">
											Consequently, to select all same name siblings one uses the following syntax:
										</p>
									
									
										<p class="c5">
											<b>WHERE jcr:path LIKE '/foo/bar[%]'</b>
										</p>
									
								
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Predicates in the <b>WHERE</b> clause that test <b>jcr:path</b> are only required to support the operators <b>=, &lt;&gt;</b> and <b>LIKE</b>. In the case of <b>LIKE</b> predicates, support is only required for tests using the <b>%</b> wildcard character as a match for a whole path segment (the part between two <b>/</b> characters) or within index brackets. This set of minimum requirements would, for example, allow the following path queries:
				</p>
				<ul>
					<li>
						<p class="c5">
							Exact path:<br>
							<b>jcr:path='/books/mybooks/EffectiveJava'</b>
						</p>
					</li>
					<li>
						<p class="c5">
							Child:<br>
							<b>jcr:path LIKE '/books/%' AND NOT jcr:path LIKE '/books/%/%'</b>
						</p>
					</li>
					<li>
						<p class="c5">
							Descendant:<br>
							<b>jcr:path LIKE '/books/mybooks/%'</b>
						</p>
					</li>
					<li>
						<p class="c5">
							Descendant or self:<br>
							<b>jcr:path LIKE '/books/mybooks/%' OR jcr:path='/books/mybooks'</b>
						</p>
					</li>
					<li>
						<p class="c5">
							Index test:<br>
							<b>jcr:path LIKE '/books[%]/mybooks[%]'</b>
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					See also 6.6.3.3 Property Constraint and 6.6.3.4 Path Constraint.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.3." id="section_8.5.2.3."></a>8.5.2.3 Path Literals
		</h4>
		<ul>
			<li>
				<p class="c5">
					Any path literals mentioned within a <b>WHERE</b> clause must be normalized (no “<b>..</b>” and “<b>.</b>” or trailing “<b>/</b>”).
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.4." id="section_8.5.2.4."></a>8.5.2.4 Pseudo-property jcr:score
		</h4>
		<ul>
			<li>
				<p class="c5">
					Another special column, <b>jcr:score</b>, that does not correspond to any actual property, must also be present in the result table.
				</p>
			</li>
			<li>
				<p class="c5">
					The <b>jcr:score</b> can be used to return a relevance value for each row. The calculation of this value is not defined. It is not required to always be meaningful. If it is meaningful then it may, for example, be associated with the result of a <b>CONTAINS()</b> function (see <a href="#section_8.5.4.5.">8.5.4.5</a> <i>CONTAINS</i>). Alternatively it may not be connected to full text search at all, and may reflect a relevance value derived according to some other criteria.
				</p>
			</li>
			<li>
				<p class="c5">
					Support for comparing <b>jcr:score</b> in the <b>WHERE</b> clause is not required.
				</p>
			</li>
			<li>
				<p class="c5">
					In some implementations the label for this column may not be literally “<b>jcr:score</b>” but instead be the function name “<b>jcr:score(...)</b>”.
				</p>
			</li>
			<li>
				<p class="c5">
					See also 6.6.3.3 Property Constraint and 6.6.5.2 jcr:contains Function.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.5." id="section_8.5.2.5."></a>8.5.2.5 Namespace delimiting colons
		</h4>
		<ul>
			<li>
				<p class="c5">
					Since table and column names are, respectively, node type and property names, they will in many cases contain a namespace-delimiting colon character. In content repository SQL the colon is therefore considered a valid character within table and column names and does not indicate a parameter, as it would in standard SQL.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.6." id="section_8.5.2.6."></a>8.5.2.6 Joins
		</h4>
		<ul>
			<li>
				<p class="c5">
					Support for joins is required only on the <b>jcr:path</b> column and only for joining a primary node type table with a mixin node type tables. For example:
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								
									
										<p class="c5">
											<b>SELECT nt:file.jcr:path, jcr:lockOwner<br>
											FROM nt:file, mix:lockable<br>
											WHERE jcr:lockOwner = 'John'<br>
											AND mynt:file.jcr:path=mix:lockable.jcr:path</b>
										</p>
									
									
										<p class="c5">
											Additional join support, on other columns and with other tables, is optional.
										</p>
									
								
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.2.7." id="section_8.5.2.7."></a>8.5.2.7 Multi-value Properties
		</h4>
		<ul>
			<li>
				<p class="c5">
					Multi-value properties cannot be specified in the <b>SELECT</b> clause and are excluded when the <b>SELECT</b> clause specifies a “<b>*</b>”.
				</p>
			</li>
			<li>
				<p class="c5">
					In the <b>WHERE</b> clause the comparison operators function the same way they do in XPath when applied to multi-value properties: if the predicate is true of at least one value of a multi-value property then it is true for the property as a whole (see 6.6.4.10 Searching Multi-value Properties).
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.8." id="section_8.5.2.8."></a>8.5.2.8 Null Values
		</h4>
		<ul>
			<li>
				<p class="c5">
					In the <b>WHERE</b> clause the term <b>property IS NULL</b> is true if <b>property</b> is missing from a particular node instance. This covers the cases where:
				</p>
				<ul>
					<li>
						<p class="c5">
							The property is declared explicitly in the node type but happens not to be present on this particular node.
						</p>
					</li>
					<li>
						<p class="c5">
							The node type has a residual property declaration that <i>would</i> allow the specified property to be present on the node, but it happens not to be present on this particular node.
						</p>
					</li>
					<li>
						<p class="c5">
							The property is not declared at all (neither explicitly nor implicitly) in the node type and hence is not present on this particular node.
						</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="c5">
					Similarly, <b>property IS NOT NULL</b> tests for the existence of the property in the node instance (and of course if does exist it will either be explicitly defined or present due to an implicit declaration as a residual property).
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.9." id="section_8.5.2.9."></a>8.5.2.9 Undefined Property Types
		</h4>
		<ul>
			<li>
				<p class="c5">
					When a node type <b>T</b> defines a property <b>P</b> with an <b>UNDEFINED</b> property type this means that two node instances of type <b>T</b> can each have a property called <b>P</b> but with differing property types. In such cases the database view of <b>T</b> is a single column of type <b>VARCHAR</b> (see below). In other words, the different types are converted to strings.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.2.10." id="section_8.5.2.10."></a>8.5.2.10 Data Type Mapping
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following type mapping governs the usage of property variables and literals within a content repository SQL statement.
								</p>
							
						
					
					
						<table border="1" cellpadding="7" cellspacing="0">
							
							
							<tr valign="top">
								<td>
									<p class="c5">
										<b>Property type</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>SQL type</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>STRING</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>VARCHAR</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>BINARY</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>BINARY</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>DOUBLE</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>DOUBLE</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>LONG</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>BIGINT</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>BOOLEAN</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>BIT</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>DATE</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>DATE</b>
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>NAME</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>VARCHAR</b> (namespace aware)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>PATH</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>VARCHAR</b> (namespace aware)
									</p>
								</td>
							</tr>
							<tr valign="top">
								<td>
									<p class="c5">
										<b>REFERENCE</b>
									</p>
								</td>
								<td>
									<p class="c5">
										<b>CHAR(36)</b>
									</p>
								</td>
							</tr>
						</table>
					
				
			
		
		<h4>
			<a name="section_8.5.2.11." id="section_8.5.2.11."></a>8.5.2.11 Optional Features
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The following are some common optional features that some implementations may choose to support (though this list should not be taken to exclude additional extensions as well).
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					It is optional to support the specifying of residual properties (by name, not wildcard) in the <b>SELECT</b>, <b>WHERE</b> and <b>ORDER BY</b> clauses.
				</p>
			</li>
			<li>
				<p class="c5">
					It is optional to support properties in the <b>SELECT</b>, <b>WHERE</b> and <b>ORDER BY</b> clauses that are not explicitly defined in the node types listed in the <b>FROM</b> clause but which are defined in subtypes of those node types.
				</p>
			</li>
			<li>
				<p class="c5">
					It is optional to support the specifying of properties in the <b>SELECT</b>, <b>WHERE</b> and <b>ORDER BY</b> clauses that are not explicitly defined in the node types listed in the <b>FROM</b> clause but which are defined in mixin node types that may be assigned to node instances of the types that are mentioned in the <b>SELECT</b> clause.
				</p>
			</li>
		</ul>
		<h4>
			<a name="section_8.5.3." id="section_8.5.3."></a>8.5.3 SQL EBNF
		</h4>
		
			
				
					
						
							
								<p class="c5">
									<i>Terminals are in bold or in single quotes.</i>
								</p>
							
							
								<p class="c12">
									query ::= select [from] [where] [orderby]
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p>
									select ::= <b>SELECT</b> ('<b>*'</b> | proplist )<br><br>
								</p>
							
							
								<p>
									from ::= <b>FROM</b> ntlist<br><br>
								</p>
							
							
								<p>
									where ::= <b>WHERE</b> whereexp<br><br>
								</p>
							
							
								<p class="c12">
									orderby ::= <b>ORDER BY</b> propname [<b>DESC</b>|<b>ASC</b>]
								</p>
							
							
								<p class="c12">
									{',' propname [<b>DESC</b>|<b>ASC</b>]}
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									proplist ::= propname {'<b>,</b>' propname}
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									ntlist ::= ntname {',' ntname}
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									whereexp ::= propname op value |
								</p>
							
							
								<p class="c12">
									propname <b>IS NULL</b> |
								</p>
							
							
								<p class="c12">
									propname <b>IS NOT NULL</b> |<br>
									value <b>IN</b> propname |<br>
									like |
								</p>
							
							
								<p class="c12">
									contains |<br>
									whereexp <b>AND</b> whereexp |<br>
									whereexp <b>OR</b> whereexp |<br> <b>NOT</b> whereexp |<br>
									'<b>('</b> whereexp '<b>)'</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									op ::= '='|'&gt;'|'&lt;'|'&gt;='|'<b>&lt;=</b>'|'<b>&lt;&gt;</b>'
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									propname ::= joinpropname | simplepropname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									joinpropname ::= quotedjoinpropname |<br>
									unquotedjoinpropname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									quotedjoinpropname ::= ''' unquotedjoinpropname '''
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									unquotedjoinpropname ::= ntname '.jcr:path'
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									simplepropname ::= quotedpropname | unquotedpropname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									quotedpropname ::= ''' unquotedpropname '''
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									unquotedpropname ::= <i>/* A property name, possible a pseudo-property: jcr:score or jcr:path */</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									ntname ::= quotedntname | unquotedntname
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									quotedntname ::= ''' unquotedntname '''
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									unquotedntname ::= <i>/* A node type name */</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									value ::= ''' literalvalue ''' | literalvalue
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									literalvalue ::= <i>/* A property value (in standard string<br>
									form) */</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p>
									like ::= propname <b>LIKE</b> likepattern [ escape ]<br><br>
								</p>
							
							
								<p class="c12">
									likepattern ::= ''' likechar { likepattern } '''
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									likechar ::= char | '<b>%'</b> | '<b>_'</b>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									escape ::= <b>ESCAPE</b> ''' likechar '''
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									char ::= <i>/* Any character valid within the<br>
									string representation of a value<br>
									except for the characters % and _<br>
									themselves. These must be escaped */</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p>
									contains ::= <b>CONTAINS(</b>scope ',' searchexp '<b>)'</b> <br><br>
								</p>
							
							
								<p class="c12">
									scope ::= unquotedpropname | '<b>.</b>'
								</p>
							
							
								<p class="c12">
									searchexp ::= ''' exp '''
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									exp ::= [-]term {whitespace [OR] whitespace [-]term}
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									term ::= word | '"' word {whitespace word} '"'
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									word ::= <i>/* A string containing no whitespace */</i>
								</p>
							
							
								<p>
									<br>
								</p>
							
							
								<p class="c12">
									whitespace ::= <i>/* A string of only whitespace*/</i>
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.4." id="section_8.5.4."></a>8.5.4 SQL Syntax in Detail
		</h4>
		
			
				
					
						
							
								<p class="c5">
									A SQL statement in a content repository query is composed of a <b>SELECT</b> clause optionally followed by up to three more clauses: a <b>FROM</b> clause, a <b>WHERE</b> clause and an <b>ORDER BY</b> clause.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.4.1." id="section_8.5.4.1."></a>8.5.4.1 SELECT
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>SELECT</b> clause specifies a list of properties (columns) by name, or the wildcard character (“<b>*</b>”) to mean “all properties”. Notice the special case of <b>joinpropname</b>, this provides for joins, but only on the <b>jcr:path</b> column, as described in <a href="#section_8.5.2.">8.5.2</a> <i>Database View</i>. See also 6.6.3.1 Column Specifier.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.4.2." id="section_8.5.4.2."></a>8.5.4.2 FROM
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>FROM</b> clause narrows the search to include only the specified tables (node types). For example, the query
								</p>
							
							
								<p class="c5">
									<b>SELECT myapp:productName FROM mynt:shippable</b>
								</p>
							
							
								<p class="c5">
									would return all properties in the workspace called <b>myapp:product</b> that belong to nodes of node type <b>mynt:shippable</b>. Note that when a node type is specified in <b>FROM</b> clause the table (in the database view) searched will contain all nodes of the named type plus all node of subtypes of the named type. However the columns available in that table will reflect only those declared or inherited by the named type. To search all node types (tables) one would specify <b>FROM nt:base</b> (though an implementation can always prevent searches whose scope is unfeasibly large). See also 6.6.3.2 Type Constraint.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.4.3." id="section_8.5.4.3."></a>8.5.4.3 WHERE
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>WHERE</b> clause allows you to place constraints on the nodes (rows) returned by specifying values or ranges of values for the properties (columns) of those nodes (rows). For example, the query,
								</p>
							
							
								<p class="c12">
									<b>SELECT myapp:image FROM mynt:document WHERE height &lt; 100 AND keyword LIKE '%apple%'</b>
								</p>
							
							
								<p class="c5">
									would find all the properties called <b>myapp:image</b> of nodes of type <b>mynt:document</b> (and subtypes) that also have:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					a property called <b>height</b> with value less than 100 and
				</p>
			</li>
			<li>
				<p class="c5">
					a property called <b>keyword</b> with substring “<b>apple</b>”.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									The evaluation order within an expression is:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					<b>(...)</b> (Parentheses)
				</p>
			</li>
			<li>
				<p class="c5">
					<b>&lt;</b>, <b>&gt;</b>, <b>=</b>, <b>&lt;=</b>, <b>&gt;=</b>, <b>&lt;&gt;</b>, <b>LIKE</b>, <b>IS NULL</b>, <b>IS NOT NULL</b> (Operators)
				</p>
			</li>
			<li>
				<p class="c5">
					<b>CONTAINS</b> (Function)
				</p>
			</li>
			<li>
				<p class="c5">
					<b>NOT</b> (Logical negation)
				</p>
			</li>
			<li>
				<p class="c5">
					<b>AND</b> (Logical conjunction)
				</p>
			</li>
			<li>
				<p class="c5">
					<b>OR</b> (Logical disjunction)
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									Literal values of types <b>NAME</b>, <b>PATH</b> and <b>STRING</b> must be enclosed in single quotes. Any literal single quote within the pattern must be escaped as two consecutive single quotes.
								</p>
							
							
								<p class="c5">
									The collation sequence used when comparing <b>STRING</b> values using <b>&gt;</b>, <b>&lt;</b>, <b>&gt;=</b> or <b>&lt;=</b> is implementation-specific.
								</p>
							
							
								<p class="c5">
									For types <b>LONG</b> and <b>DOUBLE</b> comparisons are done by numeric value, not string representation.
								</p>
							
							
								<p class="c5">
									In case of type mismatches in a comparison <b>LONG</b>s can be converted to <b>DOUBLE</b>s; for any other type mismatch each operand is converted to <b>STRING</b> (see <a href="#section_6.2.6.">6.2.6</a> <i>Property Type Conversion</i>) and compared using the established collation sequence.
								</p>
							
							
								<p class="c5">
									See also 6.6.3.3 Property Constraint and <a href="#section_6.6.4.10.">6.6.4.10</a> <i>Searching Multi-value Properties</i>.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.4.4." id="section_8.5.4.4."></a>8.5.4.4 LIKE
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Within the <b>WHERE</b> clause, the <b>LIKE</b> operator is used to pattern match the string form of a property's value. Its argument (<b>likepattern</b>) may contain the percent (“<b>%</b>”) and underscore (“<b>_</b>”) characters.
								</p>
							
							
								<p class="c5">
									The <b>likepattern</b> must be enclosed in single quotes. Any literal single quote within the pattern must be escaped as two consecutive single quotes.
								</p>
							
							
								<p class="c5">
									A <b>likepattern</b> with neither a percent (“<b>%</b>”) nor an underscore (“<b>_</b>”) character makes the <b>LIKE</b> operator equivalent to an equals (“<b>=</b>”) operator.
								</p>
							
							
								<p class="c5">
									Within the <b>likepattern</b>, literal instances of percent (“<b>%</b>”) or underscore (“<b>_</b>”) must be escaped using the SQL <b>ESCAPE</b> clause which allows the definition of an arbitrary escape character within the context of a single LIKE statement. For example
								</p>
							
							
								<p class="c5">
									<b>SELECT * FROM mytype WHERE a LIKE 'foo\%' ESCAPE '\'<br></b><br>
									the above statement will select nodes of type '<b>mytype</b>' with property '<b>a</b>' that contain exactly the value '<b>foo%</b>'
								</p>
							
							
								<p class="c5">
									See also 8.5.2.2 Pseudo-property jcr:path, 6.6.3.3 Property Constraint, 6.6.3.4 Path Constraint and 6.6.5.1 jcr:like Function.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.4.5." id="section_8.5.4.5."></a>8.5.4.5 CONTAINS
		</h4>
		
			
				
					
						
							
								<p class="c5">
									Within the <b>WHERE</b> clause, the <b>CONTAINS</b> function is used to embed a statement in a full-text search language. The function takes two parameters: <b>scope</b> and <b>searchexp</b> (see EBNF above)
								</p>
							
							
								<p class="c5">
									At minimum, all implementations must support the <i>simple search-engine syntax</i> defined by <b>searchexp</b> in the EBNF above. This syntax is based on the syntax of search engines like Google.
								</p>
							
							
								<p class="c5">
									The semantics of the simple search expression are as follows:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					Terms separated by whitespace are implicitly <b>AND</b>ed together.
				</p>
			</li>
			<li>
				<p class="c5">
					Terms may also be <b>OR</b>ed with explicit use of the <b>OR</b> keyword.
				</p>
			</li>
			<li>
				<p class="c5">
					<b>AND</b> has higher precedence than <b>OR</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					Terms may be excluded by prefixing with a <b>–</b> (minus sign) character. This means that the result set <i>must not</i> contain the excluded term.
				</p>
			</li>
			<li>
				<p class="c5">
					A term may be either a single word or a phrase delimited by double quotes (“<b>"</b>”).
				</p>
			</li>
			<li>
				<p class="c5">
					The entire text search expression (<b>searchexp</b> in the EBNF, above) <i>must be</i> delimited by single quotes (“<b>'</b>”).
				</p>
			</li>
			<li>
				<p class="c5">
					Within the <b>searchexp</b> literal instances of single quote (“<b>'</b>”), double quote (“<b>"</b>”) and hyphen (“<b>-</b>”) must be escaped with a backslash (“<b>\</b>”). Backslash itself must therefore also be escaped, ending up as double backslash (“<b>\\</b>”).
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									The <b>scope</b> specifies the particular property that the full-text search is to be performed on. However, support for searching on particular properties is not required. Specifying '.' indicates that the full-text search is to be done on all <i>indexed properties</i> of the nodes specified by the rest of the query. Only support for a scope of '.' is required.
								</p>
							
							
								<p class="c5">
									The scope of the <b>CONTAINS</b> clause specifying '.' is the intersection of two sets. These two sets are:
								</p>
							
						
					
				
			
		
		<ul>
			<li>
				<p class="c5">
					The values of those properties that are the immediate children of the nodes specified by the <b>FROM</b> clause and other subclauses of <b>WHERE</b>.
				</p>
			</li>
			<li>
				<p class="c5">
					The contents of the full-text index of the repository. A repository may, for example, index only the values of <b>STRING</b> properties. Additionally, it may index some binary properties according to some application-specific encoding. The scope of full-text indexing is implementation specific.
				</p>
			</li>
		</ul>
		
			
				
					
						
							
								<p class="c5">
									For example, the query,
								</p>
							
							
								<p class="c12">
									SELECT * FROM mynt:product WHERE<br>
									CONTAINS(., 'apples "good for you" –oranges')
								</p>
							
							
								<p class="c18">
									would return a result containing all nodes of type <b>mynt:product</b> that have am indexed property whose value contains the string “apples”, the string “good for you” and does not contain the string “oranges”.
								</p>
							
							
								<p class="c5">
									The relevance score for each matching node may be returned as in score column. The specification does not define the calculation of the score value, it is implementation specific.
								</p>
							
							
								<p class="c5">
									An implementation may additionally support other embedded full-text search languages other than the simple search engine style shown here.
								</p>
							
							
								<p class="c5">
									See also <u>6.6.3.3</u> Property Constraint, 6.6.5.2 jcr:contains Function and 8.5.2.4 Pseudo-property.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.4.6." id="section_8.5.4.6."></a>8.5.4.6 ORDER BY
		</h4>
		
			
				
					
						
							
								<p class="c5">
									The <b>ORDER BY</b> clause causes the returned <b>QueryResult</b> objects to be sorted according to the value of a particular property.
								</p>
							
							
								<p class="c5">
									Implementations must support ordering on <b>jcr:score</b> (or <b>jcr:score(...)</b> depending on the implementation). Support for ordering on <b>PATH</b> and <b>NAME</b> properties is not required. If it is supported then the collation sequence for these types is implementation specific.
								</p>
							
							
								<p class="c5">
									See also 8.5.2.4 Pseudo-property, 6.6.3.5 Ordering Specifier and 6.6.5.5 order by Clause.
								</p>
							
						
					
				
			
		
		<h4>
			<a name="section_8.5.5." id="section_8.5.5."></a>8.5.5 Query Results
		</h4>
		
			
				
					
						
							
								<p>
									<a name="_Level_1section_6.1.1."></a>Results are returned in the same structure as with XPath queries. See 6.6.3 Structure of a Query and <a href="#section_6.6.12.">6.6.12</a> <i>Query Results</i>.
								</p>
							
						
					
				
			
		
		<div id="sdfootnote1">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote1sym" href="#sdfootnote1anc" id="sdfootnote1sym">1</a> Unless otherwise noted, all references to “objects” refer to instances of Java classes implementing the indicated Java interface from the <b>javax.jcr</b> package. For example, the term “<b>Repository</b> object” means an instance of a class implementing the interface <b>javax.jcr.Repository</b>.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote2">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote2sym" href="#sdfootnote2anc" id="sdfootnote2sym">2</a> There are other signatures of <b>login</b> as well. See <a href="#section_6.1.1.">6.1.1</a> <i>Repository</i> for details.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote3">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote3sym" href="#sdfootnote3anc" id="sdfootnote3sym">3</a> A few <b>Node</b> methods act immediately on the persistent workspace and do not require <b>save</b>. See <u><a href="#section_7.1.">7.1</a></u> Writing Repository Content for details.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote4">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote4sym" href="#sdfootnote4anc" id="sdfootnote4sym">4</a> See http://www.w3.org/TR/xmlschema-0/#ListDt for more information about the XML Schema list type.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote5">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote5sym" href="#sdfootnote5anc" id="sdfootnote5sym">5</a> This escaping scheme is based on the scheme described in ISO/IEC 9075-14:2003 for converting arbitrary strings into valid XML element and attribute names.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote6">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote6sym" href="#sdfootnote6anc" id="sdfootnote6sym">6</a> See http://www.w3.org/TR/2005/WD-xpath20-20050404/#doc-xpath-StringLiteral for details.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote7">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote7sym" href="#sdfootnote7anc" id="sdfootnote7sym">7</a> See http://www.w3.org/TR/xmlschema-0/#ListDt for more information about the XML Schema list type.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote8">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote8sym" href="#sdfootnote8anc" id="sdfootnote8sym">8</a> This is a minimal requirement. The referenced node may have additional mixin node types other than that indicated (and in fact, by definition, it must have at least <b>mix:referenceable</b>, for example). In addition it may be of a node type that is a subtype of the type indicated by the constraint.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote9">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote9sym" href="#sdfootnote9anc" id="sdfootnote9sym">9</a> <b>Workspace.restore</b>, <b>Node.restore</b> (all signatures) and <b>Node.restoreByLabel</b>.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote10">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote10sym" href="#sdfootnote10anc" id="sdfootnote10sym">10</a> There is also a variant, <b>Node.restoreByLabel</b>, which allows the version to be selected by (one of) its <b>jcr:versionLabel</b> value; otherwise, the semantics are the same.
									</p>
								
							
						
					
				
			
		</div>
		<div id="sdfootnote11">
			
				
					
						
							
								
									<p class="c5">
										<a class="sdfootnotesym" name="sdfootnote11sym" href="#sdfootnote11anc" id="sdfootnote11sym">11</a> <b>Workspace.restore</b>, <b>Node.restore</b> (all signatures) and <b>Node.restoreByLabel</b>.
									</p>
								
							
						
					
				
			
		</div>
	</body>
</html>
