<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><title>JCR 2.0: 3 Repository Model (Content Repository for Java Technology API v2.0)</title><meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8"></meta><link rel="stylesheet" type="text/css" href="main.css"></link></head><body><script type="text/javascript" src="header.js"></script><script type="text/javascript" src="nav.js"></script>	<H1>3 Repository Model</H1>
	<P>This section describes
	the objects, types and structures that compose a JCR repository. The
	description is language-neutral and focuses on the static aspects of
	the data model. Discussion of the behavioral aspects of the
	repository, and in particular the Java API for performing operations
	on the model, is found in subsequent sections. The full repository
	model is described here, though an implementation may support only a
	subset of this model, in accordance with §24&nbsp;<I>Repository
	Compliance.</I></P>
<a name="3.1 Overview"></a>	<H2>3.1 Overview</H2>
<a name="3.1.1 Persistent Workspaces"></a>	<H3>3.1.1 Persistent Workspaces</H3>
	<P>A JCR <I>repository</I>
	is composed of one or more <I>persistent workspaces</I>, each
	consisting of a directed acyclic graph of <I>items</I> where the
	edges represent the parent-child relation.</P>
	<P>Each persistent
	workspace is identified by a unique name within the repository,
	which is a string.</P>
<a name="3.1.2 Items"></a>	<H3>3.1.2 Items</H3>
	<P>An item is either a
	<I>node</I> or a <I>property</I>. A node can have zero or more child
	items. A property cannot have child items but can hold zero or more
	<I>values</I>.</P>
	<P>The nodes of a
	workspace form the structure of the stored data while the actual
	content is stored in the values of the properties.</P>
	<P>Each workspace
	contains at least one item, the <I>root node</I>. The root node is
	the only item in the workspace without a parent node; all other
	items have at least one parent.</P>
<a name="3.1.2.1 Shared Nodes"></a>	<H4>3.1.2.1 Shared Nodes</H4>
	<P>In the simplest case,
	a workspace is a <I>tree</I> of items. However, strictly speaking,
	the more general term <I>graph</I> should be used to cover those
	cases where a repository supports the optional <I>shareable nodes</I>
	feature, which allows an item to have more than one parent (see §3.9
	<I>Shareable Nodes Model</I>).</P>
<a name="3.1.3 Names"></a>	<H3>3.1.3 Names</H3>
	<P>The name of the root
	node of a workspace is always ““ (the empty string). Every other
	item in a workspace has a name, which must be a <I>JCR name </I>(see
	§3.2 <I>Names</I>).</P>
<a name="3.1.3.1 Same-Name Siblings"></a>	<H4>3.1.3.1 Same-Name Siblings</H4>
	<P>In the simplest case,
	every child item of a given parent has a unique name. However, child
	nodes with identical names can only occur if a repository supports
	<I>same-name siblings </I>(see §22 <I>Same-Name Siblings</I>).
	Additionally, some repositories may support a node and sibling
	property having the same name (see §5.1.8 <I>Node and Property with
	Same Name</I>). However, two sibling properties can never have the
	same name.</P>
	<P>To distinguish sibling
	nodes with the same name an integer index, starting at 1, is used.
	A node with no same-name siblings has an implicit index of 1 and a
	node name without an index is understood to have an index of 1.</P>
<a name="3.1.4 Paths"></a>	<H3>3.1.4 Paths</H3>
	<P>The location of an
	item in the workspace graph can be described by the path from the
	root node to that item. The path consists of the name (and index in
	cases of same-name siblings) of each interceding node in order from
	root to target item, much like a file system path. Relative paths
	can also be used to describe the location of one item with respect
	to another (see §3.4 <I>Paths</I>).</P>
<a name="3.1.5 Identifiers"></a>	<H3>3.1.5 Identifiers</H3>
	<P>In addition to a path,
	every node also has an identifier. In some implementations, the
	identifier may be independent of the path and provide an identity to
	the node that is stable across moves within the workspace. In
	simpler repositories the identifier may be implemented as a
	reflection of the path and therefore not provide any additional
	semantics (see §3.3 <I>Identifiers</I>).</P>
<a name="3.1.6 Property Types"></a>	<H3>3.1.6 Property Types</H3>
	<P>Properties can be
	either single or multi-valued. Each value has one of the 12 possible
	types (see §3.6 <I>Properties</I>). These types include familiar
	data storage types such as strings, numbers, booleans, binaries and
	dates, as well as types that hold pointers to other nodes in the
	workspace.</P>
<a name="3.1.6.1 Repository Diagram"></a>	<H4>3.1.6.1 Repository Diagram</H4>
	<P>T<IMG SRC="jcr-spec_html_3cca006d.png" NAME="graphics1" ALIGN=LEFT HSPACE=14 WIDTH=629 HEIGHT=429 BORDER=0><BR CLEAR=LEFT>he
	above diagram depicts a repository <FONT FACE="Courier New, monospace"><FONT SIZE=2>R</FONT></FONT>
	with workspaces <FONT FACE="Courier New, monospace"><FONT SIZE=2>W</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>0</SUB></FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>W1
	</FONT></FONT>and <FONT FACE="Courier New, monospace"><FONT SIZE=2>W</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>.
	The item graph of <FONT FACE="Courier New, monospace"><FONT SIZE=2>W</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>1</SUB></FONT></FONT>
	contains a root node with child nodes <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>B</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>.
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
	has a property <FONT FACE="Courier New, monospace"><FONT SIZE=2>D</FONT></FONT>
	of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	and a child node <FONT FACE="Courier New, monospace"><FONT SIZE=2>E</FONT></FONT>,
	which in turn has a property <FONT FACE="Courier New, monospace"><FONT SIZE=2>I</FONT></FONT>
	of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>.
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>B</FONT></FONT>
	has the properties <FONT FACE="Courier New, monospace"><FONT SIZE=2>F</FONT></FONT>
	(a <FONT FACE="Courier New, monospace"><FONT SIZE=2>LONG</FONT></FONT>)
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>G</FONT></FONT>
	(a <FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>).
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	has a property <FONT FACE="Courier New, monospace"><FONT SIZE=2>H</FONT></FONT>
	of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>DOUBLE</FONT></FONT>.</P>
<a name="3.1.7 Node Types"></a>	<H3>3.1.7 Node Types</H3>
	<P>Every node has a type.
	A node’s type The names, types and other attributes of its child
	items. Node types can be used to define complex storage objects
	consisting of multiple subnodes and properties, possibly many layers
	deep.</P>
<a name="3.1.8 Sessions"></a>	<H3>3.1.8 Sessions</H3>
	<P>A <I>user</I> connects
	to a repository by passing a set of credentials and the name of the
	workspace that the user wishes to access. The repository returns a
	<I>session</I> which binds the user to the requested persistent
	workspace with a level of authorization determined by that user's
	credentials. A session is always bound to exactly one persistent
	workspace, though a single persistent workspace may be bound to
	multiple sessions.</P>
<a name="3.1.8.1 User"></a>	<H4>3.1.8.1 User</H4>
	<P>A user is any agent
	bound to a session. This may be a human user, an external software
	process, or anything else that holds and controls the session.</P>
<a name="3.1.8.2 Current Session and Workspace"></a>	<H4>3.1.8.2 Current Session and Workspace</H4>
	<P>Through a session, the
	user can access, read and write the nodes and properties of the
	bound workspace, to the extent allowed by that user's authorization
	and the capabilities of the repository. Any object acquired,
	directly, or indirectly through a chain of interceding objects, from
	a particular session, is said to be within the scope of that session
	and any method called on such object is also within the scope of the
	same session.</P>
	<P>In the context of
	discussing a particular object or method call, the session within
	whose scope that object or method call lies is referred to as the
	<I>current session</I>, and the workspace to which that session is
	bound is referred to as the <I>current workspace</I>.</P>
<a name="3.2 Names"></a>	<H2>3.2 Names</H2>
	<P>A <I>JCR name</I> is
	an ordered pair of strings:</P>
	<P>(<I>N</I>,
	<I>L</I>)</P>
	<P>where <I>N</I> is a
	<I>JCR namespace</I> and <I>L</I> is a <I>JCR local name</I>.</P>
<a name="3.2.1 Namespaces"></a>	<H3>3.2.1 Namespaces</H3>
	<P>A <I>JCR namespace</I>
	is either the empty string or a Universal Resource Identifier<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote2anc" HREF="#sdfootnote2sym"><SUP>2</SUP></A></SUP>.</P>
	<P>
	<FONT FACE="Courier New, monospace">Namespace ::=
	EmptyString | Uri</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">EmptyString ::= /* The empty
	string */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Uri ::= /* A URI, as defined in
	Section 3 in</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>http://tools.ietf.org/html/rfc3986#section-3
	*/</FONT></FONT></FONT></P>
<a name="3.2.2 Local Names"></a>	<H3>3.2.2 Local Names</H3>
	<P>A <I>JCR local name</I>
	is a string that conforms to the grammar below.</P>
	<P>
	<FONT FACE="Courier New, monospace">LocalName ::= ValidString –
	SelfOrParent</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">/* Any ValidString
	except SelfOrParent */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">SelfOrParent ::= '.' | '..'</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">ValidString ::= ValidChar
	{ValidChar}</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">ValidChar ::= XmlChar –
	InvalidChar</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">/* Any XmlChar
	except InvalidChar */ </FONT>
	</P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">InvalidChar
	::= '/' | ':' | '[' | ']' | '|' | '*'</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">XmlChar ::=
	/* Any character that matches the Char production<BR> 
	at http://www.w3.org/TR/xml/#NT-Char */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">/* See §1.3.1 String Literals
	in Syntactic Grammars for details</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">on the interpretation of
	string literals in this grammar */</FONT></P>
<a name="3.2.3 Use of JCR Names"></a>	<H3>3.2.3 Use of JCR Names</H3>
	<P>JCR names are used to
	name items, node types and other entities throughout the repository.</P>
<a name="3.2.3.1 Item Names"></a>	<H4>3.2.3.1 Item Names</H4>
	<P>Every item has one JCR name. If the
	item has more than one parent it has the same name relative to each,
	though in most cases an item will have only one parent (see §3.9
	<I>Shareable Nodes Model</I>).</P>
<a name="3.2.3.2 Paths"></a>	<H4>3.2.3.2 Paths</H4>
	<P>JCR names are combined
	into JCR paths which indicate the location of an item within a
	workspace either in relation to the root node or relative to another
	item in the workspace (see §4.5 <I>Workspace</I>).</P>
<a name="3.2.3.3 NAME and PATH Values"></a>	<H4>3.2.3.3 NAME and PATH Values</H4>
	<P>JCR names appear as
	the values of <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	properties (see §3.6.1.9 <I>NAME</I>) and within the values of <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	properties (see §3.6.1.10 <I>PATH</I>).</P>
<a name="3.2.3.4 Node Types"></a>	<H4>3.2.3.4 Node Types</H4>
	<P>JCR names are used to name node types
	(see §3.7 <I>Node Types</I>).</P>
<a name="3.2.3.5 Constants"></a>	<H4>3.2.3.5 Constants</H4>
	<P>JCR names are used to identify other
	types of entities such as <I>privileges</I>, <I>access control
	policies</I> (see §16 <I>Access Control Management</I>), <I>retention
	policies</I>, <I>holds</I> (see §20 <I>Retention and Hold</I>),
	<I>activities</I> (see §15.12 <I>Activities</I>) and <I>configurations</I>
	(see §15.13 <I>Configurations and Baselines</I>).</P>
<a name="3.2.4 Naming Restrictions"></a>	<H3>3.2.4 Naming Restrictions</H3>
	<P>This definition of <I>JCR
	name</I> represents the <I>least restrictive</I> set of constraints
	permitted for the naming of items and other entities. A repository
	<I>may</I> further restrict the names of entities to a subset of JCR
	names and in most cases is encouraged to do so. 
	</P>
	<P>In a read-only
	repository, any such restrictions will stem trivially from the fact
	that the repository controls the set of entity names exposed. A
	writable repository <I>may</I> enforce any implementation-specific
	constraint by causing an exception to be thrown on an invalid JCR
	write method call.</P>
	<P>The characters
	declared invalid within a local name (“<FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT>”,
	“<FONT FACE="Courier New, monospace"><FONT SIZE=2>:</FONT></FONT>”,
	“<FONT FACE="Courier New, monospace"><FONT SIZE=2>[</FONT></FONT>“,
	“<FONT FACE="Courier New, monospace"><FONT SIZE=2>]</FONT></FONT>”,
	“<FONT FACE="Courier New, monospace"><FONT SIZE=2>|</FONT></FONT>”,
	“<FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>”)
	represent only those characters which are used as metacharacters in
	JCR names, paths and name-matching patterns (see §5.2.2 <I>Iterating
	Over Child Items</I>). These restrictions are not necessarily
	sufficient to enforce best practices in the creation of JCR names.
	In particular, the minimal grammar defined here permits JCR names
	with leading and trailing whitespace as well as characters which may
	appear superficially identical while representing different code
	points, creating a potential security issue.</P>
	<P>Though this
	specification does not attempt to define good naming practice,
	implementers are discouraged from permitting names with these and
	other problematic characteristics when possible. However, there may
	be cases where the latitude provided by the minimal grammar is
	useful, for example, when a JCR implementation is built on top of an
	existing data store with an unconventional naming scheme.</P>
<a name="3.2.5 Lexical Form of JCR Names"></a>	<H3>3.2.5 Lexical Form of JCR Names</H3>
	<P>While a JCR name is an
	ordered pair of strings, (<I>N</I>, <I>L</I>), it is not itself a
	string. There are, however, two lexical forms (string
	serializations) that a JCR name can take when used in the JCR API:
	the <I>expanded form</I> and the <I>qualified form</I>. A JCR name
	that is converted to either lexical form is said to have been
	<I>lexicalized</I>.</P>
<a name="3.2.5.1 Expanded Form"></a>	<H4>3.2.5.1 Expanded Form</H4>
	<P>The expanded form of a
	JCR name is defined as:</P>
	<P>
	<FONT FACE="Courier New, monospace">ExpandedName
	::= '{' Namespace '}' LocalName</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Namespace ::= /* see §3.2.1
	Namespaces */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">LocalName ::= /* see §3.2.2
	Local Names */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">/* See §1.3.1 String Literals
	in Syntactic Grammars for details</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">on the interpretation of
	string literals in this grammar */</FONT></P>
<a name="3.2.5.2 Qualified Form"></a>	<H4>3.2.5.2 Qualified Form</H4>
	<P>The qualified form of
	a JCR name is defined as:</P>
	<P>
	<FONT FACE="Courier New, monospace">QualifiedName
	::= [Prefix ':'] LocalName</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Prefix ::= /*
	Any string that matches the NCName production in<BR> 
	 <FONT FACE="Courier New, monospace"><FONT SIZE=2>http://www.w3.org/TR/REC-xml-names</FONT></FONT>
	*/</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">LocalName ::= /* see §3.2.2
	Local Names */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">/* See §1.3.1 String Literals
	in Syntactic Grammars for details</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">on the interpretation of
	string literals in this grammar */</FONT></P>
	<P>A qualified name is
	only interpretable in the context of a <I>namespace mapping</I>,
	which provides a one-to-one mapping between prefixes and namespaces.</P>
	<P>When a qualified name <I>Q</I> is
	passed to a JCR method within the scope of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Session</FONT></FONT>
	<I>S</I> then the JCR name <I>J</I> represented by <I>Q</I> is <I>(N,
	L) </I>where <I>N</I> is the <I>namespace</I> corresponding to <I>P</I>
	in the <I>local namespace mapping</I> of <I>S</I>. See §3.4
	<I>Namespace Mapping</I>.</P>
	<P>When a qualified name
	occurs in a string serialization of repository content or a node
	type definition, the namespace mapping is either provided within the
	serialized form (see, for example, §7 <I>Export</I> and §25.2
	<I>Compact Node Type Definition Notation</I>) or implied by the
	context of use.</P>
<a name="3.2.5.3 Qualified Form with the Empty Namespace"></a>	<H4>3.2.5.3 Qualified Form with the Empty Namespace</H4>
	<P>The qualified form of
	a name (““, <I>L</I>) (i.e., with the empty string as namespace)
	is not written as</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>:</FONT></FONT><I>L</I></P>
	<P>but simply as</P>
	<P><I>L</I></P>
	<P>The former is not a
	valid qualified JCR name.</P>
<a name="3.2.5.4 Exposing Non-JCR Names"></a>	<H4>3.2.5.4 Exposing Non-JCR Names</H4>
	<P>An implementation that
	exposes a non-JCR data store through the JCR API may wish to expose
	names containing JCR-illegal characters by using a substitution or
	escaping scheme. If so, it must do so by substituting private-use
	Unicode characters for the JCR-illegal characters according to the
	following mapping.</P>
	<TABLE WIDTH=638 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=8 CELLSPACING=0>
		<COL WIDTH=187>
		<COL WIDTH=416>
		<TR VALIGN=TOP>
			<TD WIDTH=187 HEIGHT=19>
				<P><B>JCR-Illegal
				character</B></P>
			</TD>
			<TD WIDTH=416>
				<P><B>Substitution
				character</B></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=187 HEIGHT=20>
				<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>
				(U+002A)</P>
			</TD>
			<TD WIDTH=416>
				<P>U+F02A</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=187 HEIGHT=20>
				<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT>
				(U+002F)</P>
			</TD>
			<TD WIDTH=416>
				<P>U+F02F</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=187 HEIGHT=20>
				<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>:</FONT></FONT>
				(U+003A)</P>
			</TD>
			<TD WIDTH=416>
				<P>U+F03A</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=187 HEIGHT=20>
				<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>[</FONT></FONT>
				(U+005B)</P>
			</TD>
			<TD WIDTH=416>
				<P>U+F05B</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=187 HEIGHT=20>
				<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>]</FONT></FONT>
				(U+005D)</P>
			</TD>
			<TD WIDTH=416>
				<P>U+F05D</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=187 HEIGHT=19>
				<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>|</FONT></FONT>
				(U+007C)</P>
			</TD>
			<TD WIDTH=416>
				<P>U+F07C</P>
			</TD>
		</TR>
	</TABLE>
	<P><BR>The mapping must
	be used bi-directionally. When the repository wishes to return the
	name of an entity whose native name contains a JCR-illegal
	character, that character must be replaced with its corresponding
	substitution character in the returned string.</P>
	<P>Conversely, when a
	name containing one of the substitution characters is passed to the
	repository through the JCR API, that character must be replaced with
	its corresponding non-JCR character before further processing is
	done within the native layer, whether writing the name to storage or
	using the name to access an entity.</P>
	<P>In the unlikely event
	that one of the substitution characters appears literally in a
	native name, that character will be returned unchanged through the
	JCR API.</P>
	<P>In repositories that
	do not expose non-JCR names and therefore do not need to use the
	substitution scheme, any private-use substitution character passed
	to the API is stored and returned unchanged. However, such use of a
	private-use substitution character within a JCR name is strongly
	discouraged.</P>
<a name="3.2.6 Use of Qualified and Expanded Names"></a>	<H3>3.2.6 Use of Qualified and Expanded Names</H3>
	<P>When a JCR name is
	passed as an argument to a JCR method it may be in either expanded
	or qualified form. When a repository returns a JCR name it must be
	in qualified form. The qualified form of a name depends upon the
	prevailing local namespace mapping of the current session (see §3.5
	<I>Namespace Mapping</I>).</P>
<a name="3.2.7 Equality of Names"></a>	<H3>3.2.7 Equality of Names</H3>
	<P>Two JCR names (<I>N</I><SUB><I>1</I></SUB>,
	<I>L</I><SUB><I>1</I></SUB>) and (<I>N</I><SUB><I>2</I></SUB>, <I>L</I><SUB><I>2</I></SUB>)
	are <I>equal</I> if and only if <I>N</I><SUB><I>1</I></SUB> is equal
	to <I>N</I><SUB><I>2</I></SUB> and <I>L</I><SUB><I>1</I></SUB> is
	equal to <I>L</I><SUB><I>2</I></SUB>, according to the definition of
	string equality used in the <FONT FACE="Courier New, monospace"><FONT SIZE=2>String.compareTo</FONT></FONT>
	method. This definition applies both in the general context of using
	an API method that takes or returns a JCR name and in the specific
	case of comparing values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	(see §3.6.5.8 <I>NAME</I>).</P>
<a name="3.3 Identifiers"></a>	<H2>3.3 Identifiers</H2>
	<P>Every node has an
	<I>identifier</I>. An identifier is a string whose format is not
	defined by this specification but which adheres to the following
	constraints:</P>
	<UL>
		<LI><P>The identifier of a non-shared
		node is unique within a workspace. The identifier of a shared node
		is common to each member of that node's share-set (see §3.9
		<I>Shareable Nodes Model</I>).</P>
		<LI><P>An identifier <I>must</I> be the
		most stable one available to the implementation. For example, in
		some implementations this might be nothing more than the node path
		itself. Other implementations might support node identifiers that
		are partly or entirely independent of the path.</P>
	</UL>
<a name="3.3.1 Identifier Assignment"></a>	<H3>3.3.1 Identifier Assignment</H3>
	<P>The identifier must be assigned at the
	latest when the node is first persisted, though it may be assigned
	earlier, when the node is first created in transient storage in the
	session (see §10.4.1 <I>Adding a Node</I>). 
	</P>
<a name="3.3.2 Referenceable Identifiers"></a>	<H3>3.3.2 Referenceable Identifiers</H3>
	<P>In implementations that support
	referenceable nodes, these nodes have more stringent requirements on
	their identifiers (see §3.8 <I>Referenceable Nodes</I>).</P>
<a name="3.3.3 Correspondence by Identifier"></a>	<H3>3.3.3 Correspondence by Identifier</H3>
	<P>Identifiers are also used for <I>node
	correspondence</I> across multiple workspaces (see §3.10
	<I>Corresponding Nodes</I>).</P>
<a name="3.4 Paths"></a>	<H2>3.4 Paths</H2>
	<P>A <I>JCR path</I> <I>P</I>,
		</P>
	<P><I>P</I>
	= (<I>S</I><SUB><I>0</I></SUB>, <I>S</I><SUB><I>1</I></SUB>, ...,
	<I>S</I><SUB><I>n</I></SUB>),</P>
	<P>is an ordered list
	with at least one element, where each element <I>S</I><SUB><I>i</I></SUB>,
	for 0 <FONT FACE="Symbol, serif"></FONT> <I>i</I> <FONT FACE="Symbol, serif"></FONT>
	n, is a <I>path segment</I>.</P>
<a name="3.4.1 Path Segment"></a>	<H3>3.4.1 Path Segment</H3>
	<P>A path segment is one
	of:</P>
	<UL>
		<LI><P>a <I>name
		segment</I>, (<I>J</I>, <I>I</I>), where <I>J</I> is a JCR name
		and<BR><I>I</I> is an integer index (<I>I </I>≥ 1).</P>
		<LI><P>an <I>identifier
		segment</I>, <I>U</I>, where <I>U</I> is a JCR identifier.</P>
		<LI><P>the <I>root
		segment</I>.</P>
		<LI><P>the <I>self
		segment</I>.</P>
		<LI><P>the <I>parent
		segment</I>.</P>
	</UL>
	<P>The root, self and
	parent segments are logical constants distinct from each other and
	from all name segments. 
	</P>
<a name="3.4.1.1 Position of Segments in a Path"></a>	<H4>3.4.1.1 Position of Segments in a Path</H4>
	<P>Name, self and parent
	segments can occur at any position in a path.</P>
	<P>A root segment can
	occur only as the first segment of a path.</P>
	<P>An identifier segment
	can occur only as the first and sole segment in a path. No other
	segments may follow an identifier segment.</P>
<a name="3.4.2 Path Resolution"></a>	<H3>3.4.2 Path Resolution</H3>
	<P>The successive path
	segments of JCR path <I>P</I> = (<I>S</I><SUB><I>0</I></SUB>, <I>S</I><SUB><I>1</I></SUB>,
	..., <I>S</I><SUB><I>n</I></SUB>) define a route through workspace <I>W</I>
	to a <I>target</I> item as follows:</P>
	<UL>
		<LI><P>If <I>S</I><SUB><I>0</I></SUB>
		is the root segment then the path is absolute and the <I>current</I>
		item is the root node of <I>W</I>.</P>
		<LI><P>If <I>S</I><SUB><I>0</I></SUB>
		is an identifier segment <I>U</I>, then the path is absolute and
		the <I>current</I> item is the node in <I>W</I> with the identifier
		<I>U</I>.</P>
		<LI><P>Otherwise, the
		path is relative and the <I>current</I> item is determined by the
		context of use.</P>
		<LI><P>For each segment
		<I>S</I> in path <I>P</I>:</P>
		<UL>
			<LI><P>If <I>S</I> is a
			self segment then the <I>current</I> item does not change.</P>
			<LI><P>If <I>S</I> is a
			parent segment then the new <I>current</I> item is a parent of the
			old <I>current</I> item (see §3.4.2.1 <I>Parent Resolution</I>).</P>
			<LI><P>If <I>S</I> is a
			name segment then the new current item is the child of the old
			<I>current</I> item identified by <I>S</I> (see §3.4.2.2 <I>Child
			Resolution</I>).</P>
		</UL>
		<LI><P>Once all segments
		have been traversed, the <I>current</I> item is the <I>target</I>
		item.</P>
	</UL>
<a name="3.4.2.1 Parent Resolution"></a>	<H4>3.4.2.1 Parent Resolution</H4>
	<P>In most cases an item
	will have only one parent, in such a case, parent resolution is
	trivial. In repositories that support shareable nodes, a node may
	share its child nodes and properties with other nodes. A child item
	of a shared node therefore has more than one parent. In such a case
	the parent resolved depends upon the <I>deemed path</I> of the item,
	which is an implementation-specific issue (see §3.9.5 <I>Deemed
	Path</I>). An attempt to resolve the parent of a workspace root node
	always fails.</P>
<a name="3.4.2.2 Child Resolution"></a>	<H4>3.4.2.2 Child Resolution</H4>
	<P>Given a name segment <I>S</I>
	= (<I>J</I>, <I>I</I>), <I>J</I> is the name of the child item
	indicated by that segment while <I>I </I>indicates the index of the
	item. The index is an integer greater than or equal to <FONT FACE="Courier New, monospace"><FONT SIZE=2>1</FONT></FONT>
	and is used to distinguish between sibling child nodes with the same
	name. If there is only one child node with the name <I>J </I>then
	its index is always <FONT FACE="Courier New, monospace"><FONT SIZE=2>1</FONT></FONT>.
	If there is more than one node with the name <I>J</I> then each has
	a unique index (see §22 <I>Same-Name Siblings</I>).</P>
	<P>The child item
	indicated by <I>S</I> is determined as follows:</P>
	<UL>
		<LI><P>If the <I>S</I>
		<I>is not</I> the last segment of the path then, if a child node
		with name <I>J</I> and index <I>I</I> exists, <I>S</I> resolves to
		that node. Otherwise, resolution fails.</P>
		<LI><P>If <I>S</I> <I>is</I>
		the last segment of the path then,</P>
	</UL>
	<UL>
		<LI><P>if <I>S</I> is
		constrained to resolve to a <I>gettable node</I> (as in the case of
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.getNode</FONT></FONT>)
		and a child node with name <I>J</I> and index <I>I</I> is
		retrievable, <I>S</I> resolves to that node. Otherwise,</P>
		<LI><P>if <I>S</I> is
		constrained to resolve to an <I>addable node</I> (as in the case of
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.addNode</FONT></FONT>)
		and a child node named <I>J</I> can be legally added and <I>I</I>
		is equal to 1, then <I>J</I> is used as the name of the new node
		which, if necessary, is given an appropriate index. Otherwise,</P>
		<LI><P>if <I>S</I> is
		constrained to resolve to a <I>gettable property</I> (as in the
		case of <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.getProperty</FONT></FONT>)
		then, if a property with name <I>J</I> is retrievable, and <I>I</I>
		is equal to 1, <I>S</I> resolves to that property. Otherwise,</P>
		<LI><P>if <I>S</I> is
		constrained to resolve to a <I>settable property</I> (as in the
		case of <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.setProperty</FONT></FONT>)
		then, if a property with name <I>J</I> or if a property named <I>J</I>
		can be legally added, and <I>I</I> is equal to 1, <I>S</I> resolves
		to that property. Otherwise,</P>
		<LI><P>if <I>S</I> is
		constrained to resolve to a <I>gettable item</I> (as in the case of
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>Session.getItem</FONT></FONT>)
		then if a node with name <I>J</I> and index <I>I</I> is
		retrievable, <I>S</I> resolves to that node. Otherwise, if there
		exists a property with name J and <I>I</I> is equal to 1, then <I>S</I>
		resolves to that property.</P>
		<LI><P>Otherwise,
		resolution fails.</P>
	</UL>
<a name="3.4.3 Lexical Forms"></a>	<H3>3.4.3 Lexical Forms</H3>
	<P>Given a JCR path <FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
	= <FONT FACE="Courier New, monospace"><FONT SIZE=2>(S0,
	S1, ..., Sn)</FONT></FONT>, its lexical form <FONT FACE="Courier New, monospace"><FONT SIZE=2>L</FONT></FONT>
	can be constructed according to the following algorithm, where <FONT FACE="Courier New, monospace"><FONT SIZE=2>=</FONT></FONT>
	is the assignment operator, <FONT FACE="Courier New, monospace"><FONT SIZE=2>+=</FONT></FONT>
	is the string append operator, <FONT FACE="Courier New, monospace"><FONT SIZE=2>or</FONT></FONT>
	indicates an arbitrary choice between alternative operations and
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nothing</FONT></FONT>
	is the null operation.</P>
	<P>
	<FONT FACE="Courier New, monospace">L = &quot;&quot;</FONT></P>
	<P>
	<FONT FACE="Courier New, monospace">for each S in P </FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">if S is the root segment<I> </I></FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">L += &quot;/&quot;</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">else</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">if S is an identifier
	segment U </FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">L += &quot;[&quot; + U +
	&quot;]&quot;</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">else if S is a self segment </FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">L += &quot;.&quot;</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">else if S is a parent
	segment</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">L += &quot;..&quot;</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">else if S is a name segment
	(J, I)</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">L += the qualified form of
	J</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">or L += the expanded form
	of J <I>//optional syntax</I></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">if I &gt; 1</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">L += &quot;[&quot; + I +
	&quot;]&quot;</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">else </FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">nothing</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">or L += &quot;[1]&quot;
	<I>//optional syntax</I></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">end if</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">end if</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">if S is not the last segment
	of P</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">L += &quot;/&quot;</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">else </FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">nothing </FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">or L += &quot;/&quot;
	<I>//optional syntax</I></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">end if</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">end if </FONT>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">end for</FONT></P>
	<P>The resulting <FONT FACE="Courier New, monospace"><FONT SIZE=2>L</FONT></FONT>
	is a lexical form of <FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>.
	As indicated by the steps marked <I>optional syntax</I>, a JCR path
	may have multiple equivalent lexical forms depending on the use of
	qualified vs. expanded names, the optional <FONT FACE="Courier New, monospace"><FONT SIZE=2>[1]</FONT></FONT>
	index indicator and the optional trailing forward slash (“<FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT>”).</P>
<a name="3.4.3.1 Standard Form"></a>	<H4>3.4.3.1 Standard Form</H4>
	<P>A string constructed
	without any of the optional syntax shown in the algorithm is called
	the <I>standard form</I> of a JCR path. Such a lexical path has the
	following characteristics:</P>
	<UL>
		<LI><P>It consists of
		either one identifier segment or one or more name segments.</P>
		<LI><P>All name segments
		are in qualified form, none are in expanded form.</P>
		<LI><P>No name segment
		has a <FONT FACE="Courier New, monospace"><FONT SIZE=2>[1]</FONT></FONT>
		index.</P>
		<LI><P>There is no
		trailing forward slash (“<FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT>”).</P>
	</UL>
	<P>The following are
	examples of standard form lexical paths:</P>
	<UL>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/ex:document</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/ex:document/ex:paragraph[2]</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>[f81d4fae-7dec-11d0-a765-00a0c91e6bf6]</FONT></FONT></P>
	</UL>
<a name="3.4.3.2 Non-Standard Form"></a>	<H4>3.4.3.2 Non-Standard Form</H4>
	<P>A string constructed
	<I>with one or more optional steps</I> is a <I>non-standard form</I>
	JCR path. A non-standard form lexical path has <I>at least one</I>
	of the following features:</P>
	<UL>
		<LI><P>One or more name
		segments are in expanded form.</P>
		<LI><P>One or more name
		segments has a <FONT FACE="Courier New, monospace"><FONT SIZE=2>[1]</FONT></FONT>
		index.</P>
		<LI><P>The path has a
		trailing forward slash (“<FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT>”).</P>
	</UL>
	<P>The following are
	examples of non-standard form lexical paths:</P>
	<UL>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/ex:document[1]</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/ex:document/</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/{http://example.com/ex}document/ex:paragraph[2]</FONT></FONT></P>
	</UL>
<a name="3.4.3.3 Lexical Path Grammar"></a>	<H4>3.4.3.3 Lexical Path Grammar</H4>
	<P>A JCR path in lexical
	form conforms to the following grammar</P>
	<P>
	<FONT FACE="Courier New, monospace">Path ::= AbsolutePath |
	RelativePath</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">AbsolutePath
	::= '/' [RelativePath] | '[' Identifier ']'</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">RelativePath
	::= [RelativePath '/'] PathSegment ['/']</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">PathSegment
	::= ExpandedName [Index] | <BR> QualifiedName [Index]
	| </FONT>
	</P>
	<P>
	 <FONT FACE="Courier New, monospace">SelfOrParent</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Index ::= '['
	Number ']'</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Identifier ::= /* See §3.3
	Identifiers */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Number ::= /* An integer &gt; 0
	*/</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">ExpandedName
	::= /* See §3.2.5.1 Expanded Form */</FONT></P>
	<P>
	 
	</P>
	<P>
	<FONT FACE="Courier New, monospace">QualifiedName
	::= /* See §3.2.5.2 Qualified Form */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">SelfOrParent
	::= /* see §3.2.2 Local Names */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">/* See §1.3.1 String Literals
	in Syntactic Grammars for details</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">on the interpretation of
	string literals in this grammar */</FONT></P>
<a name="3.4.3.4 Parsing Lexical Paths"></a>	<H4>3.4.3.4 Parsing Lexical Paths</H4>
	<P>When parsing a lexical
	path, the parser must distinguish between name segments that are in
	expanded form and those that are in qualified form (see §3.2.5
	<I>Lexical Form of JCR Names</I>). When making this determination,
	the repository cannot assume that every namespace URI encountered in
	an expanded name will be registered within the repository.</P>
	<P>An otherwise valid
	path containing an expanded name with an unregistered <I>namespace
	URI </I>will always resolve into a valid internal representation of
	a path (i.e., an ordered list of path segments, see §3.4 <I>Paths</I>).
	Any errors that arise from passing such a path must therefore be as
	a result of further processing (not merely parsing) that depends on
	the semantics of the path and the context of use.</P>
	<P>However, a path
	containing a qualified name with an unregistered <I>prefix</I> will
	<I>not</I> resolve into a valid internal path representation. An
	attempt to pass such a path will therefore fail at the parsing
	stage.</P>
<a name="3.4.4 Absolute and Relative Paths"></a>	<H3>3.4.4 Absolute and Relative Paths</H3>
	<P>An abstract JCR path
	is either <I>absolute</I> or <I>relative</I>. 
	</P>
<a name="3.4.4.1 Absolute Path"></a>	<H4>3.4.4.1 Absolute Path</H4>
	<P>An absolute JCR path
	is either <I>root-based </I>or <I>identifier-based</I>.</P>
	<H5>3.4.4.1.1 Root-Based Absolute Paths</H5>
	<P>A root-based absolute
	path begins with the root segment. Its lexical form therefore begins
	with a forward slash, for example,</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>/A/B/C</FONT></FONT></P>
	<H5>3.4.4.1.2 Identifier-Based Absolute Paths</H5>
	<P>An identifier-based
	absolute path consists of a single identifier segment. Its lexical
	form therefore consists of square brackets delimiting an identifier,
	for example,</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>[f81d4fae-7dec-11d0-a765-00a0c91e6bf6]</FONT></FONT></P>
<a name="3.4.4.2 Relative Path"></a>	<H4>3.4.4.2 Relative Path</H4>
	<P>A relative JCR path is
	one which begins with a segment that is neither a root segment nor
	an identifier segment. Its lexical form therefore begins with either
	a JCR name, <FONT FACE="Courier New, monospace"><FONT SIZE=2>..</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>.</FONT></FONT>,
	 for example,</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>D/E/F</FONT></FONT></P>
	<P>or</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>../E/F/G</FONT></FONT></P>
<a name="3.4.5 Normalized Paths"></a>	<H3>3.4.5 Normalized Paths</H3>
	<P>A JCR path is
	normalized by the following steps:</P>
	<UL>
		<LI><P>All self segments
		are removed.</P>
		<LI><P>All redundant
		parent segments are collapsed. A redundant parent segment is one
		which can be removed by also removing a preceding name segment
		while preserving the location indicated by the path. For example,
		the path <FONT FACE="Courier New, monospace"><FONT SIZE=2>/A/B/C/../..</FONT></FONT>
		can be collapsed to <FONT FACE="Courier New, monospace"><FONT SIZE=2>/A</FONT></FONT>.
		Note therefore, that if a normalized path contains any parent
		segments, they must all precede the first name segment.</P>
		<LI><P>If the path is an
		identifier-based absolute path, it is replaced by a root-based
		absolute path that picks out the same node in the workspace as the
		identifier it replaces.</P>
	</UL>
<a name="3.4.6 Passing Paths"></a>	<H3>3.4.6 Passing Paths</H3>
	<P>When a JCR path is
	passed as an argument to a JCR method it may be normalized or
	non-normalized and in standard or non-standard form.</P>
<a name="3.4.7 Returning Paths"></a>	<H3>3.4.7 Returning Paths</H3>
	<P>When a repository
	returns a JCR path it must be normalized (see §3.4.5 <I>Normalized
	Paths</I>), unless the repository is returning the value of a <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	property, in which case the original, possibly non-normalized form
	of the path is preserved and returned. In all cases the returned
	path must be in standard form (see §3.4.3.1 <I>Standard Form</I>).</P>
<a name="3.4.8 Equality of Paths"></a>	<H3>3.4.8 Equality of Paths</H3>
	<P>Two types of path
	equality are defined: <I>segment equality</I> and <I>semantic
	equality</I>.</P>
<a name="3.4.8.1 Segment Equality"></a>	<H4>3.4.8.1 Segment Equality</H4>
	<P>Two paths <I>P</I><SUB><I>1</I></SUB>
	and <I>P</I><SUB><I>2</I></SUB> are segment-equal if and only if:</P>
	<UL>
		<LI><P>They contain the
		same number of segments.</P>
		<LI><P>Each segment in
		<I>P</I><SUB><I>1</I></SUB> is equal to the segment at the same
		position in <I>P</I><SUB><I>2</I></SUB>.</P>
	</UL>
	<P>Two name segments are
	equal if and only if their JCR names are equal (see §3.2.7 <I>Equality
	of Names</I>) and their integer indexes are equal.</P>
	<P>Equality for
	identifier segments is as defined for identifiers in general, that
	is, by standard Java <FONT FACE="Courier New, monospace"><FONT SIZE=2>String</FONT></FONT>
	equality.</P>
	<P>Equality for root,
	self and parent segments is simple type identity; every instance of
	a root, parent or self segment is equal to every other instance of
	the same type.</P>
<a name="3.4.8.2 Semantic Equality"></a>	<H4>3.4.8.2 Semantic Equality</H4>
	<P>For two paths <I>P</I><SUB><I>1</I></SUB><I>
	</I>and <I>P</I><SUB><I>2</I></SUB> semantic equality is defined as
	follows:</P>
	<UL>
		<LI><P>If <I>P</I><SUB><I>1</I></SUB>
		and <I>P</I><SUB><I>2</I></SUB> are normalized then they are
		semantically equal if and only if they are <I>segment-equal.</I></P>
	</UL>
	<UL>
		<LI><P>If <I>P</I><SUB><I>1</I></SUB>
		and <I>P</I><SUB><I>2</I></SUB> are non-normalized then they are
		semantically equal if and only if their normalized forms are
		semantically equal.</P>
	</UL>
<a name="3.4.8.3 Application of Path Equality"></a>	<H4>3.4.8.3 Application of Path Equality</H4>
	<P>When a JCR path is
	passed to a JCR API method that must resolve that path the
	applicable definition of path equality is that of semantic equality.
	Semantic equality of two paths means that, given identical contexts,
	the two paths will resolve to the same item.</P>
	<P>However, values of
	type <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	are not normalized upon storage or retrieval, so the when comparing
	two such values, the applicable definition of equality is that of
	segment equality. (see §3.6.5.9 <I>PATH</I>).</P>
<a name="3.5 Namespace Mapping"></a>	<H2>3.5 Namespace Mapping</H2>
	<P>For compactness and
	legibility in documentation, XML and Java code, JCR names are
	usually expressed in qualified form. 
	</P>
	<P>The use of qualified
	form, however, depends upon a context that supplies a mapping from
	prefix to namespace. In documentation this context is provided
	either by convention or explicit statement. In XML serialization it
	is supplied by <FONT FACE="Courier New, monospace"><FONT SIZE=2>xmlns</FONT></FONT>
	attributes (see §7 <I>Export</I>) and in a running JCR repository
	is provided by the local namespace mapping of each individual
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>Session</FONT></FONT>.</P>
<a name="3.5.1 Namespace Registry"></a>	<H3>3.5.1 Namespace Registry</H3>
	<P>The local namespace
	mapping of a session is determined by the initial set of mappings
	copied from the <I>namespace registry</I> and any session-local
	changes made to that set.</P>
	<P>The namespace registry
	is a single, persistent, repository-wide table that contains the
	default namespace mappings. It may contain namespaces that are not
	used in repository content, and there may be repository content with
	namespaces that are not included in the registry. The namespace
	registry always contains at least the following built-in mappings
	between prefix (on the left) and namespace (on the right):</P>
	<OL>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr
		= http://www.jcp.org/jcr/1.0</FONT></FONT><BR>Reserved
		for items defined within built-in node types (see §3.7 <I>Node
		Types</I>).</P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>nt
		= http://www.jcp.org/jcr/nt/1.0<BR></FONT></FONT>Reserved
		for the names of built-in primary node types.</P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>mix
		= http://www.jcp.org/jcr/mix/1.0<BR></FONT></FONT>Reserved
		for the names of built-in mixin node types.</P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>xml
		= http://www.w3.org/XML/1998/namespace</FONT></FONT><BR>Reserved
		for reasons of compatibility with XML.</P>
		<LI><P><I>(the empty
		string)</I><FONT FACE="Courier New, monospace"><FONT SIZE=2>
		= </FONT></FONT><I>(the empty string)<BR></I>The
		default namespace is the <I>empty namespace</I>.</P>
	</OL>
<a name="3.5.1.1 Empty Prefix and Empty Namespace"></a>	<H4>3.5.1.1 Empty Prefix and Empty Namespace</H4>
	<P>The permanent default
	namespace in JCR is the empty string, also referred to as the <I>empty
	namespace</I>. This permanence is reflected in the immutable default
	namespace mapping in the namespace registry. By definition, the
	prefix in this mapping is the empty string, also referred to as the
	<I>empty prefix</I>.</P>
<a name="3.5.1.2 Additional Built-in Namespaces"></a>	<H4>3.5.1.2 Additional Built-in Namespaces</H4>
	<P>A repository may
	provide additional built-in mappings other than those defined in
	this section. All mappings must be one-to-one, meaning that for a
	given namespace in the registry exactly one prefix is mapped to it,
	and for a given prefix in the registry exactly one namespace is
	mapped to it.</P>
<a name="3.5.2 Session-Local Mappings"></a>	<H3>3.5.2 Session-Local Mappings</H3>
	<P>A local set of
	namespace mappings is associated with each session. When a new
	session is acquired, the mappings present in the persistent
	namespace registry are copied to the local namespace mappings of
	that session. A user can then add new mappings or change existing
	ones. The resulting mapping table applies only within the scope of
	that session (see §5.11 <I>Namespace Mapping</I>).</P>
	<P>If a JCR method
	returns a name from the repository with a namespace URI for which no
	local mapping exists, a prefix is created automatically and a
	mapping between that prefix and the namespace URI in question is
	added to the set of local mappings. The new prefix must differ from
	those already present among the set of local mappings. If a JCR
	method is passed a name or path containing a prefix which does not
	exist in the local mapping an exception is thrown.</P>
<a name="3.5.2.1 Effect of Session Namespace Mappings"></a>	<H4>3.5.2.1 Effect of Session Namespace Mappings</H4>
	<P>All methods that take
	or return names or paths must use the current session (see §3.1.8.2
	<I>Current Session and Workspace</I>) namespace mappings to
	dynamically interpret or produce those names or paths according to
	the current local namespace mapping of the current session. 
	</P>
	<P>Though the precise
	mechanism of this behavior is an implementation detail, its behavior
	must be equivalent to that of a system where names and paths are
	stored internally in expanded form and converted dynamically to and
	from qualified JCR names or paths as necessary.</P>
<a name="3.5.3 Namespace Conventions"></a>	<H3>3.5.3 Namespace Conventions</H3>
	<P>Names and paths
	determined by an application provider should be assigned namespace
	URIs under the control of the provider organization. Because the
	space of URIs is universally managed, this ensures that naming
	collisions will not occur between applications from providers that
	observe this convention.</P>
<a name="3.6 Properties"></a>	<H2>3.6 Properties</H2>
	<P>All data stored within
	a JCR repository is ultimately stored as the values of properties.</P>
<a name="3.6.1 Property Types"></a>	<H3>3.6.1 Property Types</H3>
	<P>Every property is of
	one of the following types: <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>URI</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>LONG</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>DOUBLE</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>DECIMAL</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>.</P>
<a name="3.6.1.1 STRING"></a>	<H4>3.6.1.1 STRING</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	properties store instances of <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.String</FONT></FONT>.</P>
<a name="3.6.1.2 URI"></a>	<H4>3.6.1.2 URI</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>URI</FONT></FONT>
	properties store instances of <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.String</FONT></FONT>
	that conform to the syntax of a URI-reference as defined in RFC
	3986<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote3anc" HREF="#sdfootnote3sym"><SUP>3</SUP></A></SUP>.</P>
<a name="3.6.1.3 BOOLEAN"></a>	<H4>3.6.1.3 BOOLEAN</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>
	properties store instances of the Java primitive type <FONT FACE="Courier New, monospace"><FONT SIZE=2>boolean</FONT></FONT>.</P>
<a name="3.6.1.4 LONG"></a>	<H4>3.6.1.4 LONG</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>LONG</FONT></FONT>
	properties store instances of the Java primitive type <FONT FACE="Courier New, monospace"><FONT SIZE=2>long</FONT></FONT>.</P>
<a name="3.6.1.5 DOUBLE"></a>	<H4>3.6.1.5 DOUBLE</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>DOUBLE</FONT></FONT>
	properties store instances of the Java primitive type <FONT FACE="Courier New, monospace"><FONT SIZE=2>double</FONT></FONT>.</P>
<a name="3.6.1.6 DECIMAL"></a>	<H4>3.6.1.6 DECIMAL</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>DECIMAL</FONT></FONT>
	properties store instances of <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.math.BigDecimal</FONT></FONT>.
		</P>
<a name="3.6.1.7 BINARY"></a>	<H4>3.6.1.7 BINARY</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	properties store instances of <FONT FACE="Courier New, monospace"><FONT SIZE=2>javax.jcr.Binary
	</FONT></FONT>(see §5.10.5 <I>Binary Object</I>).</P>
<a name="3.6.1.8 DATE"></a>	<H4>3.6.1.8 DATE</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>
	properties store instances of <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.util.Calendar</FONT></FONT>.
	Note that an implementation may not support <FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>
	values that cannot be represented in the ISO 8601-based notation
	defined in §3.6.4.3 <I>From DATE To</I>. In such cases an attempt
	to set a property to such a value will throw a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>.</P>
<a name="3.6.1.9 NAME"></a>	<H4>3.6.1.9 NAME</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	properties store instances of JCR names.</P>
<a name="3.6.1.10 PATH"></a>	<H4>3.6.1.10 PATH</H4>
	<P CLASS="sdfootnote-western"><FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	properties store instances of JCR paths and serve as pointers to
	locations within the workspace. <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	properties <I>do not</I> enforce referential integrity.</P>
<a name="3.6.1.11 WEAKREFERENCE"></a>	<H4>3.6.1.11 WEAKREFERENCE</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	properties serve as pointers to referenceable nodes by storing their
	identifiers. <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	properties <I>do not</I> enforce referential integrity (see §3.8.2
	<I>Referential Integrity</I>).</P>
<a name="3.6.1.12 REFERENCE"></a>	<H4>3.6.1.12 REFERENCE</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	properties serve as pointers to referenceable nodes by storing their
	identifiers. <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	properties <I>do</I> enforce referential integrity (see §3.8.2
	<I>Referential Integrity</I>).</P>
<a name="3.6.2 Undefined Type"></a>	<H3>3.6.2 Undefined Type</H3>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>UNDEFINED</FONT></FONT>
	keyword, while not specifying an actual type, may be supported by
	some repositories as a valid property type attribute value in
	property definitions within node types. In that context it indicates
	that the specified property may be of <I>any</I> type. No actual
	existing property in the repository ever has the type <FONT FACE="Courier New, monospace"><FONT SIZE=2>UNDEFINED</FONT></FONT>.</P>
<a name="3.6.3 Single and Multi-Value Properties"></a>	<H3>3.6.3 Single and Multi-Value Properties</H3>
	<P>A property may be a
	single-value or a multi-value property.</P>
	<P>A single-value
	property, if it exists, must have a value. There is no such thing as
	a null value. A multi-value property can have zero or more values.
	Again there is no such thing as a null value, however a multi-value
	property can be empty, just as an array can be empty.</P>
	<P>The values stored
	within a multi-valued property are all of the same type and are
	ordered.</P>
	<P>Whether a particular
	property is a multi-valued property is governed by the property
	definition applicable to it, which is determined by the node type of
	the property's parent node (see §3.7 <I>Node Types</I>).</P>
	<P>Accessing the value of
	a property is done with <FONT FACE="Courier New, monospace"><FONT SIZE=2>Property.getValue</FONT></FONT>
	which returns a single <FONT FACE="Courier New, monospace"><FONT SIZE=2>Value</FONT></FONT>
	object. Accessing the set of values of a multi-value property is
	done through <FONT FACE="Courier New, monospace"><FONT SIZE=2>Property.getValues</FONT></FONT>
	which returns a (possibly empty) array of <FONT FACE="Courier New, monospace"><FONT SIZE=2>Value</FONT></FONT>
	objects (see §5.10 <I>Reading Properties</I>).</P>
<a name="3.6.4 Property Type Conversion"></a>	<H3>3.6.4 Property Type Conversion</H3>
	<P>When the value of a
	property is read or written using a type different from that
	declared for the property, the repository attempts a type conversion
	according to the following rules. Note that even in cases where the
	JCR type conversion is defined in terms of standard JDK type
	conversion method, failure of conversion must only ever cause a JCR
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	to be thrown and never any exception defined in the JDK API.</P>
<a name="3.6.4.1 From STRING To"></a>	<H4>3.6.4.1 From STRING To</H4>
	<P><B>BINARY</B>: The
	string is encoded using UTF-8.</P>
	<P><B>DATE</B>: If the
	string is in the format described in §3.6.4.3 <I>From DATE To</I>,
	it is converted directly, otherwise a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>DOUBLE</B>: The
	string is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Double.valueOf(String)</FONT></FONT>.</P>
	<P><B>DECIMAL</B>: The
	string is converted using the constructor<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	java.math.BigDecimal(String)</FONT></FONT>.</P>
	<P><B>LONG</B>: The
	string is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Long.valueOf(String)</FONT></FONT>.</P>
	<P><B>BOOLEAN</B>: The
	string is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Boolean.valueOf(String)</FONT></FONT>.</P>
	<P><B>NAME</B>: If the
	string is a syntactically valid qualified JCR name with a registered
	prefix, it is converted directly. If it is a syntactically valid
	expanded JCR name with a registered namespace URI, it is returned in
	qualified form. If it is a syntactically valid expanded JCR name
	with an <I>unregistered</I> namespace URI, a prefix is created
	automatically, the mapping added to the local namespace mappings
	(see §3.5.2 <I>Session-Local Mappings</I>), and the name is
	returned in qualified form. Otherwise a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>PATH</B>: If the
	string is a valid JCR path then each name segment is converted as
	per <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	conversion above, and all other segments are converted directly. If
	one or more name conversions fails or if the string is not a valid
	path then a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown. The presence of an item in the current workspace at that
	path is not required.</P>
	<P><B>URI</B>: If the
	string is a syntactically valid URI-reference, it is converted
	directly, otherwise a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown. The string is parsed as described in RFC 3986. In
	particular, the first colon (“<FONT FACE="Courier New, monospace"><FONT SIZE=2>:</FONT></FONT>”)
	encountered is interpreted as the scheme delimiter and the string as
	a whole is assumed to already be in percent-encoded form. This means
	that if a non-URI-legal character is encountered it is not
	percent-encoded, but is instead regarded as an error and a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>REFERENCE or
	WEAKREFERENCE</B>: If the string is a syntactically valid
	identifier, according to the implementation, it is converted
	directly, otherwise a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown. The identifier is not required to be that of an existing
	node in the current workspace.</P>
<a name="3.6.4.2 From BINARY To"></a>	<H4>3.6.4.2 From BINARY To</H4>
	<P><B>STRING</B>: An
	attempt is made to interpret the stream as a UTF-8 encoded string.
	If the string is not a legal UTF-8 byte sequence then the behavior
	is implementation-specific.</P>
	<P><B>All Others</B>: The
	binary stream is first converted to a string, as described above. If
	this is successful, the resulting string is converted according to
	the appropriate conversion as described in §3.6.4.1 <I>From STRING
	To</I>.</P>
<a name="3.6.4.3 From DATE To"></a>	<H4>3.6.4.3 From DATE To</H4>
	<P><B>STRING</B>: The
	date is converted to the following format:</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2><I>sYYYY</I></FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2>-</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><I>MM</I></FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2>-</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><I>DD</I></FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2>T</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><I>hh</I></FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2>:</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><I>mm</I></FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2>:</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><I>ss</I></FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2>.</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><I>sssTZD</I></FONT></FONT></P>
	<P>where:</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>sYYYY<BR></FONT></FONT>Four-digit
	year with optional leading positive (‘<FONT FACE="Courier New, monospace"><FONT SIZE=2>+</FONT></FONT>’)
	or negative (‘<FONT FACE="Courier New, monospace"><FONT SIZE=2>-</FONT></FONT>’)
	sign. <FONT FACE="Courier New, monospace"><FONT SIZE=2>0000</FONT></FONT>
	, <FONT FACE="Courier New, monospace"><FONT SIZE=2>-0000</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>+0000</FONT></FONT>
	all indicate the year 1 BCE. –<FONT FACE="Courier New, monospace"><FONT SIZE=2>YYYY</FONT></FONT>
	where <FONT FACE="Courier New, monospace"><FONT SIZE=2>YYYY</FONT></FONT>
	is the number <I>y</I> indicates the year (<I>y</I>+1) BCE. The
	absence of a sign or the presence of a positive sign indicates a
	year CE. For example, <FONT FACE="Courier New, monospace"><FONT SIZE=2>-0054</FONT></FONT>
	would indicate the year 55 BCE, while <FONT FACE="Courier New, monospace"><FONT SIZE=2>+1969</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>1969</FONT></FONT>
	indicate the year 1969 CE.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>MM<BR></FONT></FONT>Two-digit
	month (01 = January, etc.)</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>DD<BR></FONT></FONT>Two-digit
	day of month (01 through 31)</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>hh<BR></FONT></FONT>Two
	digits of hour (00 through 23, or 24 if <FONT FACE="Courier New, monospace"><FONT SIZE=2>mm</FONT></FONT>
	is 00 and <FONT FACE="Courier New, monospace"><FONT SIZE=2>ss.sss</FONT></FONT>
	is 00.000)</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>mm<BR></FONT></FONT>Two
	digits of minute (00 through 59)</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>ss.sss<BR></FONT></FONT>Seconds,
	to three decimal places (00.000 through 59.999 or 60.999 in the case
	of leap seconds)</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>TZD<BR></FONT></FONT>Time
	zone designator (either <I>Z</I> for Zulu, i.e. UTC, or <I>+hh:mm</I>
	or <I>-hh:mm</I>, i.e. an offset from UTC)</P>
	<P>Note that the “<FONT FACE="Courier New, monospace"><FONT SIZE=2>T</FONT></FONT>”
	separating the date from the time and the separators “<FONT FACE="Courier New, monospace"><FONT SIZE=2>-</FONT></FONT>”and
	“<FONT FACE="Courier New, monospace"><FONT SIZE=2>:</FONT></FONT>”
	appear literally in the string.</P>
	<P>This format is a
	subset of the format defined by ISO 8601:2004. 
	</P>
	<P>If the <FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>
	value cannot be represented in this format a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>BINARY</B>: The
	date is converted to a string, as described in §3.6.4.2 <I>From
	BINARY To</I>, and this string is encoded in UTF-8.</P>
	<P><B>DOUBLE</B>: The
	date is converted to the number of milliseconds since 00:00 (UTC) 1
	January 1970 (<FONT FACE="Courier New, monospace"><FONT SIZE=2>1970-01-01T00:00:00.000Z</FONT></FONT>).
	If this number is out-of-range for a double, a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>DECIMAL</B>: The
	date is converted to the number of milliseconds since 00:00 (UTC) 1
	January 1970 (<FONT FACE="Courier New, monospace"><FONT SIZE=2>1970-01-01T00:00:00.000Z</FONT></FONT>).</P>
	<P><B>LONG</B>: The date
	is converted to the number of milliseconds since 00:00 (UTC) 1
	January 1970 (<FONT FACE="Courier New, monospace"><FONT SIZE=2>1970-01-01T00:00:00.000Z</FONT></FONT>).
	If this number is out-of-range for a long, a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P>Since the string and
	number formats into which a <FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>
	may be converted can hold only a subset of the information
	potentially contained within a <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.util.Calendar</FONT></FONT>,
	conversion from <FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>
	to <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING,
	BINARY, DOUBLE, DECIMAL</FONT></FONT> or <FONT FACE="Courier New, monospace"><FONT SIZE=2>LONG</FONT></FONT>
	may result in loss of information.</P>
<a name="3.6.4.4 From DOUBLE To"></a>	<H4>3.6.4.4 From DOUBLE To</H4>
	<P><B>STRING</B>: The
	double is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Double.toString()</FONT></FONT>.</P>
	<P><B>BINARY</B>: The
	double is converted to a string, as described in §3.6.4.2 <I>From
	BINARY To</I>, and this string is encoded in UTF-8.</P>
	<P><B>DECIMAL</B>: The
	double is converted using the constructor<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	java.math.BigDecimal(double)</FONT></FONT>.</P>
	<P><B>DATE</B>: The
	double is coerced to a long using standard Java type coercion and
	interpreted as the number of milliseconds since 00:00 (UTC) 1
	January 1970 (<FONT FACE="Courier New, monospace"><FONT SIZE=2>1970-01-01T00:00:00.000Z</FONT></FONT>).
	If the resulting value is out of range for a date, a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>LONG</B>: Standard
	Java type coercion is used.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.5 From DECIMAL To"></a>	<H4>3.6.4.5 From DECIMAL To</H4>
	<P><B>STRING</B>: The
	decimal is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.math.BigDecimal.toString()</FONT></FONT>.</P>
	<P><B>BINARY</B>: The
	decimal is converted to a string, as described in §3.6.4.2 <I>From
	BINARY To</I>, and this string is encoded in UTF-8.</P>
	<P><B>DOUBLE</B>: The
	decimal is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.math.BigDecimal.doubleValue()</FONT></FONT>.</P>
	<P><B>DATE</B>: The
	decimal is converted to a long and interpreted as the number of
	milliseconds since 00:00 (UTC) 1 January 1970
	(<FONT FACE="Courier New, monospace"><FONT SIZE=2>1970-01-01T00:00:00.000Z</FONT></FONT>).
	If the resulting value is out of range for a date, a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>LONG</B>: The
	decimal is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.math.BigDecimal.longValue()</FONT></FONT>.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.6 From LONG To"></a>	<H4>3.6.4.6 From LONG To</H4>
	<P><B>STRING</B>: The
	long is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Long.toString()</FONT></FONT>.</P>
	<P><B>BINARY</B>: The
	long is converted to a string, as described in §3.6.4.2 <I>From
	BINARY To</I>, and this string is encoded in UTF-8.</P>
	<P><B>DECIMAL</B>: The
	double is converted using the method<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	java.math.BigDecimal.valueOf(long)</FONT></FONT>.</P>
	<P><B>DATE</B>: The long
	is interpreted as the number of milliseconds since 00:00 (UTC) 1
	January 1970 (<FONT FACE="Courier New, monospace"><FONT SIZE=2>1970-01-01T00:00:00.000Z</FONT></FONT>).
	If the resulting value is out of range for a date, a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>DOUBLE</B>:
	Standard Java type coercion is used.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.7 From BOOLEAN To"></a>	<H4>3.6.4.7 From BOOLEAN To</H4>
	<P><B>STRING</B>: The
	boolean is converted using <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Boolean.toString()</FONT></FONT>.</P>
	<P><B>BINARY</B>: The
	boolean is converted to a string, as described in §3.6.4.2 <I>From
	BINARY To</I>, and this string is encoded in UTF-8.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.8 From NAME To"></a>	<H4>3.6.4.8 From NAME To</H4>
	<P><B>STRING</B>: The
	name is converted to qualified form according to the current local
	namespace mapping (see §3.2.5.2 <I>Qualified Form</I>).</P>
	<P><B>BINARY</B>: The
	name is converted to a string, as described in §3.6.4.2 <I>From
	BINARY To</I>, and then encoded using UTF-8.</P>
	<P><B>PATH</B>: The name
	becomes a relative path of length one.</P>
	<P><B>URI</B>: The name
	becomes a URI-reference consisting of “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	followed by the name in qualified form. For example, the name
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>foo:bar</FONT></FONT>
	becomes the URI-reference <FONT FACE="Courier New, monospace"><FONT SIZE=2>./foo:bar</FONT></FONT>.
	The addition of the leading “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	is done to ensure that a colon-delimited prefix is not interpreted
	as a URI scheme name. If the name includes characters that are
	illegal within a URI-reference (such as any non-ASCII character),
	the UTF-8 byte representations of these characters are
	percent-encoded, as described in RFC 3986<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote4anc" HREF="#sdfootnote4sym"><SUP>4</SUP></A></SUP>.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.9 From PATH To"></a>	<H4>3.6.4.9 From PATH To</H4>
	<P><B>STRING</B>: Each
	path is converted to standard form according to the current local
	namespace mapping (see §3.4.3.1 <I>Standard Form</I>).</P>
	<P><B>BINARY</B>: The
	path is converted to a string, as described in §3.6.4.2 <I>From
	BINARY To</I>, and then encoded using UTF-8.</P>
	<P><B>NAME</B>: If the
	path is a relative path of length one it is converted directly,
	otherwise a <FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>URI</B>: If the
	path is root-based absolute (that is, it has a leading “<FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT>”,
	see §3.4.4.1.1 <I>Root-Based Absolute Paths</I>), it is directly
	converted into a URI-reference. If the path is identifier-based
	absolute (§3.4.4.1.2 <I>Identifier-Based Absolute Paths</I>) or
	relative, it becomes a URI-reference consisting of “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	followed by the path in standard form. For example, the path
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>foo:bar/foo:baz</FONT></FONT>
	becomes the URI-reference <FONT FACE="Courier New, monospace"><FONT SIZE=2>./foo:bar/foo:baz</FONT></FONT>.
	The addition of the leading “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	is done to ensure that a colon-delimited prefix is not interpreted
	as a URI scheme name. If the path includes characters that are
	illegal within a URI-reference (such as any non-ASCII character),
	the UTF-8 byte representations of these characters are
	percent-encoded, as described in RFC 3986<SUP>6</SUP>.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.10 From URI To"></a>	<H4>3.6.4.10 From URI To</H4>
	<P><B>STRING</B>: The <FONT FACE="Courier New, monospace"><FONT SIZE=2>URI</FONT></FONT>
	is converted directly into a <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING.</FONT></FONT></P>
	<P><B>BINARY</B>: Since a
	URI is guaranteed to already contain only ASCII characters it is
	converted directly to a <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	resulting in series of octets that is a UTF-8 encoding of the
	character sequence comprising the URI.</P>
	<P><B>NAME</B>: If the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>URI</FONT></FONT>
	consists of a single path segment without a colon (for example,
	simply <FONT FACE="Courier New, monospace"><FONT SIZE=2>bar</FONT></FONT>)
	it is converted to a <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	by decoding any percent-escaped sequences into octet sequences and
	then decoding those into character sequences using UTF-8. If it has
	a redundant leading “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	followed by a single segment (with or without a colon, like <FONT FACE="Courier New, monospace"><FONT SIZE=2>./bar</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>./foo:bar</FONT></FONT>
	) the redundant “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	is removed and the remainder is converted to a <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME
	</FONT></FONT>in the same way. Otherwise a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>PATH</B>: If the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>URI</FONT></FONT>
	begins with a “<FONT FACE="Courier New, monospace"><FONT SIZE=2>/</FONT></FONT>”
	it is converted a <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH
	</FONT></FONT>by decoding any percent-escaped
	sequences into octet sequences and then decoding those into
	character sequences using UTF-8. If it consists of a path whose
	first segment is without a colon (for example, <FONT FACE="Courier New, monospace"><FONT SIZE=2>bar</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>bar/baz</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>bar/foo:baz</FONT></FONT>)
	it is converted in the same way. If it consists of a path with a
	redundant leading “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	(for example <FONT FACE="Courier New, monospace"><FONT SIZE=2>./bar/baz</FONT></FONT>,
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>./foo:bar/foo:baz</FONT></FONT>
	) the redundant “<FONT FACE="Courier New, monospace"><FONT SIZE=2>./</FONT></FONT>”
	is removed and the remainder is converted to a <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	as described in §3.6.4.1 <I>From STRING To</I>. Otherwise a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.11 From REFERENCE To"></a>	<H4>3.6.4.11 From REFERENCE To</H4>
	<P><B>STRING</B>: The
	identifier is converted directly to a string.</P>
	<P><B>BINARY</B>: The
	identifier is converted directly to a string and then converted to
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	as described in §3.6.4.1 <I>From STRING To</I>.</P>
	<P><B>WEAKREFERENCE</B>:
	The <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	is simply turned into a <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.4.12 From WEAKREFERENCE To"></a>	<H4>3.6.4.12 From WEAKREFERENCE To</H4>
	<P><B>STRING</B>: The
	identifier is converted directly to a string.</P>
	<P><B>BINARY</B>: The
	identifier is converted directly to a string and then converted to
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	as described in §3.6.4.1 <I>From STRING To</I>.</P>
	<P><B>REFERENCE</B>: The
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	is simply turned into a <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>.</P>
	<P><B>All Others</B>: A
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ValueFormatException</FONT></FONT>
	is thrown.</P>
<a name="3.6.5 Comparison of Values"></a>	<H3>3.6.5 Comparison of Values</H3>
	<P>For any values <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> both of the same property type, the
	relations <I>is equal to</I>, <I>is ordered before</I> and <I>is
	ordered after</I> are defined in §3.6.5.1 <I>CompareTo Semantics</I>.</P>
	<P>Note that the
	definition of these relations here does not necessarily imply that
	JCR API methods for testing these relations are supported for every
	property type. In particular, <FONT FACE="Courier New, monospace"><FONT SIZE=2>Value.equals</FONT></FONT>
	is not required to work on <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	values and JCR query is not required to support testing the
	equality or ordering of <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	values.</P>
<a name="3.6.5.1 CompareTo Semantics"></a>	<H4>3.6.5.1 CompareTo Semantics</H4>
	<P>For the property types
	<I>other than</I> <FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>,
	comparison relations are defined in terms of the result of the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>compareTo</FONT></FONT>
	method on instances <FONT FACE="Courier New, monospace"><FONT SIZE=2>V1</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2</FONT></FONT>
	of the Java class corresponding to the JCR property type (see each
	section below for the relevant class). For those types:</P>
	<UL>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is equal to</I> <I>V</I><SUB><I>2</I></SUB> if and only if
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>V1.compareTo(V2)
		== 0</FONT></FONT>.</P>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is ordered before</I> <I>V</I><SUB><I>2</I></SUB><I> </I>if and
		only if <FONT FACE="Courier New, monospace"><FONT SIZE=2>V1.compareTo(V2)
		&lt; 0</FONT></FONT>.</P>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is ordered after</I> <I>V</I><SUB><I>2</I></SUB> if and only if
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>V1.compareTo(V2)
		&gt; 0</FONT></FONT>.</P>
	</UL>
<a name="3.6.5.2 STRING, URI, REFERENCE and WEAKREFERENCE"></a>	<H4>3.6.5.2 STRING, URI, REFERENCE and WEAKREFERENCE</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>URI</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	then the repository <I>should</I> use the semantics of
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.String.compareTo</FONT></FONT>,
	as described in §3.6.5.1 <I>CompareTo Semantics</I>.<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	</FONT></FONT>
	</P>
<a name="3.6.5.3 DATE"></a>	<H4>3.6.5.3 DATE</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>
	then the repository <I>must</I> use the semantics of
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Calendar.compareTo</FONT></FONT>,
	as described in §3.6.5.1 <I>CompareTo Semantics</I>.<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	</FONT></FONT>
	</P>
<a name="3.6.5.4 DOUBLE"></a>	<H4>3.6.5.4 DOUBLE</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>DOUBLE</FONT></FONT>
	then the repository <I>must</I> use the semantics of
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Double.compareTo</FONT></FONT>,
	as described in §3.6.5.1 <I>CompareTo Semantics</I>.<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	</FONT></FONT>
	</P>
<a name="3.6.5.5 LONG"></a>	<H4>3.6.5.5 LONG</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>LONG</FONT></FONT>
	then the repository <I>must</I> use the semantics of
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.Long.compareTo</FONT></FONT>,
	as described in §3.6.5.1 <I>CompareTo Semantics</I>.<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	</FONT></FONT>
	</P>
<a name="3.6.5.6 DECIMAL"></a>	<H4>3.6.5.6 DECIMAL</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>DECIMAL</FONT></FONT>
	then the repository <I>must</I> use the semantics of
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.BigDecimal.compareTo</FONT></FONT>,
	as described in §3.6.5.1 <I>CompareTo Semantics</I>.</P>
<a name="3.6.5.7 BOOLEAN"></a>	<H4>3.6.5.7 BOOLEAN</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>
	then 
	</P>
	<UL>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is equal to</I> <I>V</I><SUB><I>2</I></SUB> if and only if <FONT FACE="Courier New, monospace"><FONT SIZE=2>V1
		== V2</FONT></FONT>.</P>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is ordered before</I> <I>V</I><SUB><I>2</I></SUB><I> </I>if and
		only if <FONT FACE="Courier New, monospace"><FONT SIZE=2>V1
		== false</FONT></FONT> and<FONT FACE="Courier New, monospace"><FONT SIZE=2>
		V2 == true</FONT></FONT>.</P>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is ordered after</I> <I>V</I><SUB><I>2</I></SUB> if and only if
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>V1
		== true</FONT></FONT> and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2
		== false</FONT></FONT>.<FONT FACE="Courier New, monospace"><FONT SIZE=2>
		</FONT></FONT>
		</P>
	</UL>
<a name="3.6.5.8 NAME"></a>	<H4>3.6.5.8 NAME</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	and <I>V</I><SUB><I>1</I></SUB> = (<I>N</I><SUB><I>1</I></SUB>, <I>L</I><SUB><I>1</I></SUB>)
	and <I>V</I><SUB><I>2</I></SUB> = (<I>N</I><SUB><I>2</I></SUB>, <I>L</I><SUB><I>2</I></SUB>)
	where <I>N</I><SUB><I>1</I></SUB><I> </I>and <I>N</I><SUB><I>2</I></SUB>
	are JCR namespaces and <I>L</I><SUB><I>1</I></SUB> and <I>L</I><SUB><I>2</I></SUB>
	are JCR local names then</P>
	<UL>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is equal to</I> <I>V</I><SUB><I>2</I></SUB> if and only if <I>N</I><SUB><I>1</I></SUB>
		is equal to <I>N</I><SUB><I>2</I></SUB> and <I>L</I><SUB><I>1</I></SUB>
		is equal to <I>L</I><SUB><I>2</I></SUB>, according to the semantics
		of <FONT FACE="Courier New, monospace"><FONT SIZE=2>String.compareTo</FONT></FONT>
		(see §3.2.7 <I>Equality of Names</I>).</P>
	</UL>
	<UL>
		<LI><P>Ordering is
		implementation-specific. The only requirement is that a <I>total
		order</I> on values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
		must be defined, meaning that if <I>V</I><SUB><I>1</I></SUB> and <I>V</I><SUB><I>2</I></SUB>
		are not equal then either <I>V</I><SUB><I>1</I></SUB> is ordered
		before <I>V</I><SUB><I>2</I></SUB> or <I>V</I><SUB><I>1</I></SUB>
		is ordered after <I>V</I><SUB><I>2</I></SUB>.</P>
	</UL>
<a name="3.6.5.9 PATH"></a>	<H4>3.6.5.9 PATH</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	then</P>
	<UL>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is equal to</I> <I>V</I><SUB><I>2</I></SUB> if and only if <I>V</I><SUB><I>1</I></SUB>
		and <I>V</I><SUB><I>2</I></SUB> are <I>segment-equal</I> (see
		§3.3.8 <I>Equality of Paths</I>).</P>
		<LI><P>Ordering is
		implementation-specific. The only requirement is that a <I>total
		order</I> on values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
		must be defined, meaning that if <I>V</I><SUB><I>1</I></SUB> and <I>V</I><SUB><I>2</I></SUB>
		are not equal then either <I>V</I><SUB><I>1</I></SUB> is ordered
		before <I>V</I><SUB><I>2</I></SUB> or <I>V</I><SUB><I>1</I></SUB>
		is ordered after <I>V</I><SUB><I>2</I></SUB>.</P>
	</UL>
<a name="3.6.5.10 BINARY"></a>	<H4>3.6.5.10 BINARY</H4>
	<P>If <I>V</I><SUB><I>1</I></SUB>
	and <I>V</I><SUB><I>2</I></SUB> are values of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	and given,</P>
	<UL>
		<LI><P><I>V</I><SUB><I>1</I></SUB>
		<I>is equal to</I> <I>V</I><SUB><I>2</I></SUB> if and only if <I>V</I><SUB><I>1</I></SUB>
		and <I>V</I><SUB><I>2</I></SUB> are bitwise equivalent.</P>
	</UL>
	<UL>
		<LI><P>Ordering is
		implementation-specific.</P>
	</UL>
<a name="3.6.6 Value.equals Method"></a>	<H3>3.6.6 Value.equals Method</H3>
	<P>An implementation of
	the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Value</FONT></FONT>
	interface must override the inherited method <FONT FACE="Courier New, monospace"><FONT SIZE=2>Object.equals(Object)</FONT></FONT>
	so that, given <FONT FACE="Courier New, monospace"><FONT SIZE=2>Value</FONT></FONT>
	instances <FONT FACE="Courier New, monospace"><FONT SIZE=2>V1</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V1.equals(V2)</FONT></FONT>
	will return <FONT FACE="Courier New, monospace"><FONT SIZE=2>true</FONT></FONT>
	if:</P>
	<UL>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>V1</FONT></FONT>
		and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2</FONT></FONT>
		were acquired from the same <FONT FACE="Courier New, monospace"><FONT SIZE=2>Session</FONT></FONT>,
		and</P>
		<LI><P>the contents of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V1</FONT></FONT>
		and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2</FONT></FONT>
		have not yet been accessed, and</P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>V1</FONT></FONT>
		and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2</FONT></FONT>
		are of the same type, and</P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>V1</FONT></FONT>
		<I>is equal to</I> <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2</FONT></FONT>
		as defined in §3.6.5 <I>Comparison of Values</I>.</P>
	</UL>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>V1.equals(V2)</FONT></FONT>
	will return <FONT FACE="Courier New, monospace"><FONT SIZE=2>false</FONT></FONT>
	otherwise.</P>
	<P>In addition:</P>
	<UL>
		<LI><P>The equality
		comparison must not change the state of either <FONT FACE="Courier New, monospace"><FONT SIZE=2>V1</FONT></FONT>
		or <FONT FACE="Courier New, monospace"><FONT SIZE=2>V2</FONT></FONT>
		and</P>
		<LI><P>support for
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>Value.equals</FONT></FONT>
		in the case of <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
		values is optional.</P>
	</UL>
<a name="3.6.7 Length of a Value"></a>	<H3>3.6.7 Length of a Value</H3>
	<P>The <I>length</I> of a
	value is defined as follows:</P>
	<UL>
		<LI><P>For a <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
		value, its length is equal to its length in bytes. This number is
		returned both by <FONT FACE="Courier New, monospace"><FONT SIZE=2>Binary.getSize</FONT></FONT>
		(see §5.10.5 <I>Binary Object</I>) and by <FONT FACE="Courier New, monospace"><FONT SIZE=2>Property.getLength</FONT></FONT>
		and <FONT FACE="Courier New, monospace"><FONT SIZE=2>Property.getLengths</FONT></FONT>
		(see §5.10.3 <I>Value Length</I>).</P>
		<LI><P>For other types,
		the length is the same value that would be returned by calling
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>java.lang.String.length()</FONT></FONT>
		on the <FONT FACE="Courier New, monospace"><FONT SIZE=2>String</FONT></FONT>
		resulting from standard JCR property type conversion (see §3.6.4
		<I>Property Type Conversion</I>). This number is returned by
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>Property.getLength</FONT></FONT>
		and <FONT FACE="Courier New, monospace"><FONT SIZE=2>Property.getLengths</FONT></FONT>.</P>
	</UL>
	<P>For single value
	properties, the length of a property's value is often referred to as
	the <I>property length</I>.</P>
<a name="3.7 Node Types"></a>	<H2>3.7 Node Types</H2>
	<P>Node types are used to
	enforce structural restrictions on the nodes and properties in a
	workspace by defining for each node, its required and permitted
	child nodes and properties.</P>
	<P>Every node has one
	declared <I>primary node type</I> and zero or more <I>mixin node
	types</I>. Primary node types are typically used to defined the core
	characteristics of a node, while mixin node types are used to add
	additional characteristics often related to specific repository
	functions or to metadata. 
	</P>
	<P>In a writable
	repository a node's primary type is first assigned upon node
	creation, while mixin types may be assigned on creation or during a
	node's lifetime. Repository implementations may vary as to how
	flexible they are in allowing changes to the primary or mixin node
	types assigned to a node.</P>
	<P>Each repository has a
	single, system-wide registry of node types. Typically, a repository
	will come with some implementation-determined set of built-in node
	types. Some of these types may be vendor-specific while others may
	be standard node types defined by JCR to support common use-cases
	(see §3.7.11 <I>Standard Application Node Types</I>) or repository
	features. Some repositories may further allow users to register new
	node types programmatically (see §19 <I>Node Type Management</I>).</P>
<a name="3.7.1 Node Type Definition Attributes"></a>	<H3>3.7.1 Node Type Definition Attributes</H3>
	<P>A node type definition
	consists of the following attributes:</P>
<a name="3.7.1.1 Node Type Name"></a>	<H4>3.7.1.1 Node Type Name</H4>
	<P>Every registered node
	type has a JCR <I>name</I>, unique within the repository.</P>
<a name="3.7.1.2 Supertypes"></a>	<H4>3.7.1.2 Supertypes</H4>
	<P>A node type has <I>zero</I>
	or more <I>supertypes</I>. Supertypes are specified by name.</P>
<a name="3.7.1.3 Abstract"></a>	<H4>3.7.1.3 Abstract</H4>
	<P>A node type may be
	declared <I>abstract</I>, meaning that it cannot be directly
	assigned to a node, though it may act as a supertype to other node
	types. The abstract flag is a boolean.</P>
<a name="3.7.1.4 Mixin"></a>	<H4>3.7.1.4 Mixin</H4>
	<P>A node type may be
	declared a mixin node type. A mixin node type can be assigned to a
	node during that node's lifetime, not just upon node creation, as is
	the case with primary node types. The mixin flag is a boolean.</P>
<a name="3.7.1.5 Queryable Node Type"></a>	<H4>3.7.1.5 Queryable Node Type</H4>
	<P>A node type may be
	declared <I>queryable</I>, meaning that the node type can be used in
	a query selector and that the query-related attributes of properties
	defined in that node type take effect. The <I>queryable node type</I>
	attribute is a boolean.</P>
	<H5>3.7.1.5.1 Interaction with Property Definitions  </H5>
	<P>If a node type is
	declared queryable, then the <I>available query operators</I>,
	<I>full-text searchable</I> and <I>query</I>-<I>orderable</I>
	attributes of its property definitions take effect (see §3.7.3.3
	<I>Available Query Operators</I>, §3.7.3.4 <I>Full-Text Searchable</I>,
	§3.7.3.5 <I>Query-Orderable</I>). If a node type is declared
	non-queryable then these attributes of its property definitions have
	no effect.</P>
<a name="3.7.1.6 Orderable Child Nodes"></a>	<H4>3.7.1.6 Orderable Child Nodes</H4>
	<P>A node type may
	declare its child nodes orderable, meaning that for all nodes of
	that type, the order that the child nodes are iterated over can be
	programmatically controlled by the user (see §23 <I>Orderable Child
	Nodes</I>). The orderable child nodes flag is a boolean.</P>
<a name="3.7.1.7 Primary Item"></a>	<H4>3.7.1.7 Primary Item</H4>
	<P>A node type can
	declare one of its child items as primary, meaning that for all
	nodes of that type, that child item is accessible through a
	dedicated API method which does not require the name of the item.
	(see §5.1.7 <I>Primary Item Access</I>). This feature can help
	generic API clients intelligently traverse an unknown node
	structure. The primary item may be an item name, which must be a JCR
	name, or null, meaning that there is no primary item.</P>
	<H5>3.7.1.7.1 Primary Item and Same-Name Siblings</H5>
	<P>In cases where the
	primary child item specifies the name of a set of same-name sibling
	child nodes, the node with index <FONT FACE="Courier New, monospace"><FONT SIZE=2>[1]</FONT></FONT>
	will be regarded as the primary item.</P>
	<H5>3.7.1.7.2 Property and Child Node With Same Name</H5>
	<P>In cases where this
	node has both a child node and a property with the same name and
	where that name is specified as the primary item name, the child
	node will be regarded as the primary item (see §22.4 <I>Property
	and Node with Same Name</I>).</P>
<a name="3.7.1.8 Property Definitions"></a>	<H4>3.7.1.8 Property Definitions</H4>
	<P>A node type may
	contain a list of <I>property definitions</I>, which specify the
	properties that nodes of that type are permitted or required to have
	and the characteristics of those properties. The list of property
	definitions may be empty.</P>
<a name="3.7.1.9 Child Node Definitions"></a>	<H4>3.7.1.9 Child Node Definitions</H4>
	<P>A node type may
	contain a list of child node definitions, which specify the
	permitted or required child nodes and their characteristics. The
	list of child node definitions may be empty.</P>
<a name="3.7.2 Item Definition Attributes"></a>	<H3>3.7.2 Item Definition Attributes</H3>
	<P>Property
	and child node definitions have some attributes in common, while
	others are specific to either property definitions or child nodes in
	particular (this is reflected in the API interfaces, see §8.3
	<I>ItemDefinition Object</I>).
	The common attributes are:</P>
<a name="3.7.2.1 Item Definition Name"></a>	<H4>3.7.2.1 Item Definition Name</H4>
	<P>The name attribute
	specifies the set of child nodes or properties to which the
	definition applies. This set is called the <I>scope</I> of the
	definition. An item within the scope of a given definition is called
	a <I>scoped item</I> (scoped property, scoped child node) of that
	definition. The definition within whose scope a given item falls is
	called the <I>scoping definition</I> of that item.</P>
	<P>In the standard case
	the scope consists of the single item named by the attribute and
	must be a JCR name. 
	</P>
	<H5>3.7.2.1.1 Item Definition Name and Same-Name-Siblings</H5>
	<P>In a repository that
	supports <I>same-name siblings </I>(see §22 <I>Same-Name Siblings</I>),
	the name attribute of a child node definition will have scope over
	all the child nodes of that name. In this case the attribute must
	also be a JCR name.</P>
	<H5>3.7.2.1.2 Item Definition Name and Residual Definitions  </H5>
	<P>In a repository that
	supports <I>residual definitions</I> the name attribute may be “<FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>”<FONT FACE="Courier New, monospace"><FONT SIZE=2>
	</FONT></FONT>(asterisk), specifying that the
	definition is residual, meaning that its scope consists of all other
	properties (child nodes), which are not otherwise scoped by any of
	the other property (child node) definitions in the effective node
	type of the node (see §3.7.6.5 <I>Effective Node Type</I>).</P>
	<H5>3.7.2.1.3 Multiple Item Definitions with the Same Name</H5>
	<P>A
	node type may have two or more item definitions with identical <I>name</I>
	attributes. On <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.setProperty</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.addNode</FONT></FONT>,
	the repository must choose among the available definitions for one
	which matches the name and possible type information specified in
	the method call. If this information is insufficient to select a
	single definition unambiguously, the repository may choose a
	definition based on some implementation-specific criteria or fail
	the operation (see §10.4 <I>Adding Nodes and Setting Properties</I>).</P>
<a name="3.7.2.2 Protected"></a>	<H4>3.7.2.2 Protected</H4>
	<P>If an item <I>I</I> is
	declared protected it is <I>repository-controlled</I>.</P>
	<P>If <I>I</I> is a node
	then, through the<I> core write methods of JCR</I> (see §10.2 <I>Core
	Write Methods</I>),</P>
	<UL>
		<LI><P><I>I</I> cannot
		be removed,</P>
		<LI><P>child nodes of <I>I</I>
		cannot be added, removed, or reordered,</P>
		<LI><P>properties of <I>I</I>
		cannot be added or removed,</P>
		<LI><P>the values of
		existing properties of <I>I</I> cannot be changed,</P>
		<LI><P>the primary node
		type of <I>I</I> cannot be changed and</P>
		<LI><P>mixin node types
		cannot be added to or removed from <I>I</I>.</P>
	</UL>
	<P>If I is a property
	then, through the <I>core write methods of JCR </I>(see §10.2 <I>Core
	Write Methods</I>),</P>
	<UL>
		<LI><P><I>I</I> cannot
		be removed and</P>
		<LI><P>the value of <I>I
		</I>cannot be changed.</P>
	</UL>
	<P>Additionally, if <I>I</I>
	is a property, its being repository-controlled also implies that its
	value is under the control of the repository and can change at any
	time, before or after save. See §3.7.2.3.2 <I>Auto-Created and
	Protected</I>.</P>
<a name="3.7.2.3 Auto-Created"></a>	<H4>3.7.2.3 Auto-Created</H4>
	<P>An
	item may be declared <I>auto-created</I>,
	meaning that it is automatically created upon creation of its parent
	node. The auto-created attribute is a boolean.</P>
	<H5>3.7.2.3.1 Auto-Created and Non-Protected</H5>
	<P>If an item is
	auto-created but not protected then it <I>must</I> be <I>immediately</I>
	created in transient space when its parent node is created. Creation
	of auto-created non-protected items must never be delayed until save
	(see §10.11 <I>Saving</I>).</P>
	<H5>3.7.2.3.2 Auto-Created and Protected</H5>
	<P>If an item is both
	auto-created and protected, then it <I>should</I> be immediately
	created in transient space when its parent node is created. Creation
	of auto-created protected items should not be delayed until save,
	though doing so does not violate JCR compliance. In some
	implementations the value of an auto-created property may be
	assigned upon save, in such cases the creation of the property may
	also be delayed until save (see, for example, §3.7.1 <I>Identifier
	Assignment</I>).</P>
	<H5>3.7.2.3.3 Auto-created and Same-Name Siblings</H5>
	<P>In a repository that
	supports same-name siblings (see §22 <I>Same-Name Siblings</I>), a
	child node definition may specify that a node be both auto-created
	and allow same-name siblings. In that case the repository must
	create at least one such child node with the specified name upon
	parent node creation, though it may create more than one.</P>
	<H5>3.7.2.3.4 Auto-created and Residual Definitions</H5>
	<P>In repositories that
	support residual definitions, an item cannot be both auto-created
	and residual (see §3.7.2.1.2 <I>Item Definition Name and Residual
	Definitions</I>).</P>
	<H5>3.7.2.3.5 Chained Auto-creation</H5>
	<P>An auto-created node
	may itself have auto-created child items, resulting in the automatic
	creation of a tree of items. However, chaining that produces an
	infinite loop of item creation is not permitted. A repository must
	ensure that at no time does it have a set of registered node types
	that could result in such behavior (see §19 <I>Node Type
	Management</I>).</P>
<a name="3.7.2.4 Mandatory"></a>	<H4>3.7.2.4 Mandatory</H4>
	<P>An
	item may be declared <I>mandatory</I>,
	meaning that the item must exist before its parent node is saved.</P>
	<H5>3.7.2.4.1 Mandatory and Multi-Value Properties</H5>
	<P>Since single-value
	properties either have a value or do not exist (there being no
	concept of the null value, see §10.4.2.4 <I>No Null Values</I>), a
	mandatory single-value property must have a value. A mandatory
	multi-value property, on the other hand, may have zero or more
	values.</P>
	<H5>3.7.2.4.2 Mandatory and Same-Name Siblings</H5>
	<P>In a repository that
	supports same-name siblings, a child node definition may specify
	that a node be both mandatory and allow same-name siblings. In that
	case at least one child node must exist upon save of the parent node
	(see §22 <I>Same-Name Siblings</I>). 
	</P>
	<H5>3.7.2.4.3 Mandatory and Residual Definitions</H5>
	<P>In repositories that
	support residual definitions, an item cannot be both mandatory and
	residual (see §3.7.2.1.2 <I>Item Definition Name and Residual
	Definitions</I>).</P>
<a name="3.7.2.5 On-Parent-Version"></a>	<H4>3.7.2.5 On-Parent-Version</H4>
	<P>In a repository that
	supports <I>simple</I> or <I>full versioning</I> the
	on-parent-version attribute governs the behavior of the child item
	when its parent node is checked-in (see §15.2 <I>Check-In: Creating
	a Version</I>). In repositories that do not
	support <I>simple</I> or <I>full
	versioning</I> this attribute has no effect.</P>
<a name="3.7.3 Property Definition Attributes"></a>	<H3>3.7.3 Property Definition Attributes</H3>
	<P>A
	property definition has all the attributes of a generic item
	definition as well as the following property-specific attributes:</P>
<a name="3.7.3.1 Property Type"></a>	<H4>3.7.3.1 Property Type</H4>
	<P>A property definition
	must specify a property type. This must be one of the JCR property
	types (see §3.6.1 <I>Property Types</I>) or, in repositories that
	support it, the <FONT FACE="Courier New, monospace"><FONT SIZE=2>UNDEFINED</FONT></FONT>
	keyword, indicating that the property scoped by this definition can
	be of any type (see §3.6.2 <I>Undefined Type</I>). An attempt to
	save a property with a type different from that required by its
	definition will fail if conversion to that type is not possible (see
	§10.4.2 <I>Setting a Property</I> and §3.6.4 <I>Property Type
	Conversion</I>).</P>
<a name="3.7.3.2 Default Values"></a>	<H4>3.7.3.2 Default Values</H4>
	<P>The
	<I>default values</I>
	attribute of a property definition defines the values
	assigned to property if it is <I>auto-created</I>. If the property
	is single-valued this attribute will hold a single value. If it is
	multi-valued this attribute will hold an array of values. A default
	values setting of <FONT FACE="Courier New, monospace"><FONT SIZE=2>null</FONT></FONT>
	indicates that the property does not have a single static default
	value. It may have no default value at all or it may have a
	parameterized default value defined externally to this
	specification. If the scoped property is not <I>auto-created</I>
	then this attribute has no effect.</P>
<a name="3.7.3.3 Available Query Operators"></a>	<H4>3.7.3.3 Available Query Operators</H4>
	<P>A property definition
	declares the set of query comparison operators that can be validly
	applied to a property. The set of operators that can appear in this
	attribute may be limited by implementation-specific constraints that
	differ across property types. For example, some implementations may
	permit property definitions to provide <FONT FACE="Courier New, monospace"><FONT SIZE=2>EqualTo</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>NotEqualTo</FONT></FONT>
	(see §6.7.16 <I>Comparison</I>) as available operators for <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	properties while others may not. However, in all cases where a
	JCR-defined operator <I>is</I> potentially available for a given
	property type, its behavior must conform to the comparison semantics
	defined in §3.6.5 <I>Comparison of Values</I>.</P>
	<H5>3.7.3.3.1 Interaction with Node Type Definition  </H5>
	<P>This attribute only
	takes effect if the node type holding the property definition has a
	queryable setting of <I>true</I> (see §3.7.1.5 <I>Queryable Node
	Type</I>).</P>
<a name="3.7.3.4 Full-Text Searchable"></a>	<H4>3.7.3.4 Full-Text Searchable</H4>
	<P>A property may be
	declared <I>full-text searchable</I>, meaning that its value is
	accessible through the full-text search function within a query (see
	§6.7.19 <I>FullTextSearch</I>). The full-text searchable flag is a
	boolean.</P>
	<H5>3.7.3.4.1 Interaction with Node Type Definition  </H5>
	<P>This attribute only
	takes effect if the node type holding the property definition has a
	queryable setting of <I>true</I> (see §3.7.1.5 <I>Queryable Node
	Type</I>), otherwise this attribute is automatically set to <I>false</I>.</P>
<a name="3.7.3.5 Query-Orderable"></a>	<H4>3.7.3.5 Query-Orderable</H4>
	<P>A property may be
	declared <I>query-orderable</I>, meaning that query results may be
	ordered by this property using the <I>order </I>clause of a query
	(see §6.7.37 <I>Ordering</I>). The query-orderable flag is a
	boolean.</P>
	<H5>3.7.3.5.1 Interaction with Node Type Definition  </H5>
	<P>This attribute only
	takes effect if the node type holding the property definition has a
	queryable setting of <I>true</I> (see §3.7.1.5 <I>Queryable Node
	Type</I>), otherwise this attribute is automatically set to <I>false</I>.</P>
<a name="3.7.3.6 Value Constraints"></a>	<H4>3.7.3.6 Value Constraints</H4>
	<P>A property definition
	may impose constraints on the value that the property may hold.
	These value constraints are defined by an array of strings, whose
	format differs depending on the type of the property. 
	</P>
	<P>Each string in the
	returned array specifies a constraint on the values of the property.
	In order to be valid, <I>each</I> value of the property (since a
	property may be multi-valued) must independently meet <I>at least
	one</I> of the constraints.</P>
	<P>If a property does not
	exist or, in the case of multi-value properties, contains an empty
	array, the constraint set is considered to have been met.</P>
	<P>An attempt to save a
	property whose value or values fail to meet the constraint criteria
	will fail (see §10.11 <I>Saving</I>).</P>
	<P>Reporting constraint
	information is optional on a per property instance level. The return
	of an empty array indicates that there are no <I>expressible</I>
	constraints, meaning that either there are constraints but they are
	not expressible in the constraint-string syntax, or constraint
	discovery is not supported for that property.</P>
	<P>Constraint strings
	have different formats depending on the type of the property in
	question. The following sections describe the value constraint
	syntax for each property type.</P>
	<H5>3.7.3.6.1 STRING and URI Constraints</H5>
	<P>For <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>URI</FONT></FONT>
	properties, the constraint string is a regular expression pattern
	according to the syntax of <FONT FACE="Courier New, monospace"><FONT SIZE=2>java.util.regex.Pattern</FONT></FONT>.</P>
	<H5>3.7.3.6.2 PATH Constraints</H5>
	<P>For <FONT FACE="Courier New, monospace"><FONT SIZE=2>PATH</FONT></FONT>
	properties, the constraint is an absolute or relative path, possibly
	terminating with a “<FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>”
	as the last segment.</P>
	<P>On assignment the
	constraint may be passed in any valid lexical form, with the
	possible addition of a trailing “<FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>”.
	The constraint, however is stored as a JCR path in normalized form
	plus an optional <I>match-descendants </I>indicator corresponding to
	the “<FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>”.
	The constraint is returned in normalized standard form (see §3.4.5.1
	<I>Standard Form</I> and §3.4.5 <I>Normalized Paths</I>).</P>
	<P>For a constraint
	<I>without</I> match-descendants, the constraint is met when the
	property value is equal to the constraint. For a constraint <I>with</I>
	match-descendants, the constraint is met when the property value is
	either equal to the constraint or equal to a descendant path of the
	constraint (see §3.4.8 <I>Equality of Paths</I>).</P>
	<H5>3.7.3.6.3 NAME Constraints</H5>
	<P>For <FONT FACE="Courier New, monospace">NAME</FONT>
	properties, the constraint is a JCR name. On assignment the
	constraint may be passed in any valid lexical form but is returned
	in qualified form (see §3.2.5.2 <I>Qualified Form</I>).The
	constraint is met if the property value is equal to the constraint
	(see §3.2.7 <I>Equality of Names</I>).</P>
	<H5>3.7.3.6.4 REFERENCE and WEAKREFERENCE Constraints</H5>
	<P>For <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	properties, the constraint is a JCR name. The constraint is met if
	the target node of the property is of the node type indicated by the
	constraint (see §3.7.6.3 <I>Is-of-Type Relation</I>). On assignment
	the constraint passed may be in any valid lexical form but is
	returned in qualified form (see §3.2.5.2 <I>Qualified Form</I>).</P>
	<H5>3.7.3.6.5 BINARY, DATE, LONG, DOUBLE and DECIMAL
	Constraints</H5>
	<P>The remaining types
	all have value constraints in the form of inclusive or exclusive
	ranges specified according to the following pattern:</P>
	<P>
	<FONT FACE="Courier New, monospace">Constraint ::= Open Min ',' Max
	Close</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Open ::= '[' | '('</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Close ::= ']' | ')'</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Min ::= /* Type dependent, see
	below */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">Max ::= /* Type dependent, see
	below */</FONT></P>
	<P>
	<BR><BR>
	</P>
	<P>
	<FONT FACE="Courier New, monospace">/* See §1.3.1 String Literals
	in Syntactic Grammars for details</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">on the interpretation of
	string literals in this grammar */</FONT></P>
	<P>The brackets “<FONT FACE="Courier New, monospace"><FONT SIZE=2>[</FONT></FONT>“
	and “<FONT FACE="Courier New, monospace"><FONT SIZE=2>]</FONT></FONT>”
	indicate inclusivity, while “<FONT FACE="Courier New, monospace"><FONT SIZE=2>(</FONT></FONT>“
	and “<FONT FACE="Courier New, monospace"><FONT SIZE=2>)</FONT></FONT>”
	indicate exclusivity. A missing <FONT FACE="Courier New, monospace"><FONT SIZE=2>min</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>max</FONT></FONT>
	value indicates no bound in that direction. The meaning of the <FONT FACE="Courier New, monospace"><FONT SIZE=2><I>min</I></FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2><I>max</I></FONT></FONT>
	values themselves differ between types as follows:</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>:
	<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>min</I></FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2><I>max</I></FONT></FONT>
	specify the allowed size range of the binary value in bytes.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>:
	<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>min</I></FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>max</FONT></FONT>
	are dates specifying the allowed date range. The date strings must
	be in the standard string serialization (see §3.6.4.3 <I>From</I>
	<I>DATE To)</I>.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>LONG,
	DOUBLE, DECIMAL </FONT></FONT>: <FONT FACE="Courier New, monospace"><FONT SIZE=2><I>min</I></FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>max</I></FONT></FONT>
	are valid Java language numeric literals. 
	</P>
	<P>The
	range is evaluated according to the standard value comparison rules
	(see §3.6.5 <I>Comparison of Values</I>).</P>
	<P>To specify a constant
	value, the constant itself, “<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>c</I></FONT></FONT>”
	may be used instead of the bracket notation, though the constraint
	is always returned in bracket notation.</P>
	<H5>3.7.3.6.6 BOOLEAN</H5>
	<P>For <FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>
	properties the constraint string can be either “<FONT FACE="Courier New, monospace"><FONT SIZE=2>true</FONT></FONT>”
	or “<FONT FACE="Courier New, monospace"><FONT SIZE=2>false</FONT></FONT>”.
	In most cases <FONT FACE="Courier New, monospace"><FONT SIZE=2>getValueConstraints</FONT></FONT>
	will return an empty array since placing a constraint on a <FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>
	value is uncommon.</P>
	<H5>3.7.3.6.7 Choice Lists</H5>
	<P>Because constraints
	are returned as an array of disjunctive constraints, in many cases
	the elements of the array can serve directly as a <I>choice list</I>.
	This may, for example, be used by an application to display options
	to the end user indicating the set of permitted values.</P>
<a name="3.7.3.7 Multi-Value"></a>	<H4>3.7.3.7 Multi-Value</H4>
	<P>A property can be
	declared <I>multi-valued</I>. An attempt to set a single-value
	property by passing an array will fail. Similarly, an attempt to set
	a multi-value property by passing a non-array will also fail (see
	§10.4.2 <I>Setting a Property</I>).</P>
<a name="3.7.4 Child Node Definition Attributes"></a>	<H3>3.7.4 Child Node Definition Attributes</H3>
	<P>A child
	node definition has all the attributes of a generic item definition
	as well as the following node-specific attributes:</P>
<a name="3.7.4.1 Required Primary Node Types"></a>	<H4>3.7.4.1 Required Primary Node Types</H4>
	<P>A child node
	definition must declare one or more <I>required primary node types</I>.
		</P>
	<P>In order to
	successfully save a scoped child node <I>N</I>, it must be true for
	each required primary type <I>R</I> that the assigned primary type <I>A</I>
	of <I>N </I>is of type<I> R</I> (see §3.7.6.3 <I>Is-of-Type
	Relation</I>). 
	</P>
	<P>In cases where this
	attribute specifies more than one required node type, any particular
	node instance will still have only one assigned primary type, but
	that type must be a subtype of <I>all</I> of the types specified by
	this attribute. Such a situation may arise, for example, in
	repositories that support multiple inheritance of node types.</P>
<a name="3.7.4.2 Default Primary Node Type"></a>	<H4>3.7.4.2 Default Primary Node Type</H4>
	<P>The <I>default primary
	type</I> of a child node definition is a JCR name defining the node
	type that the child node will be given if it is auto-created or
	created without an explicitly specified node type. This node type
	must be the same as or a subclass of each of the required primary
	node types.</P>
	<P>If <FONT FACE="Courier New, monospace"><FONT SIZE=2>null</FONT></FONT>
	is returned this indicates that no default primary type is specified
	and that therefore an attempt to create this node without specifying
	a node type will fail.</P>
<a name="3.7.4.3 Same-Name Siblings"></a>	<H4>3.7.4.3 Same-Name Siblings</H4>
	<P>The
	<I>same-name sibling</I>
	attribute of a child node definition indicates whether the child
	node can have sibling nodes with the same name (see §22 <I>Same-Name
	Siblings</I>). In repositories that do not
	support same-name siblings this attribute has no effect.</P>
<a name="3.7.5 Mixin Node Types"></a>	<H3>3.7.5 Mixin Node Types</H3>
	<P>Mixin node types are
	used to add additional properties or child nodes to a given node
	instance, typically in order to expose some aspect of a specialized
	repository feature. For example, referenceability is supported by
	the mixin <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:referenceable</FONT></FONT>
	which defines the property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>
	to expose a node's identifier (see §3.3 <I>Identifiers</I>).</P>
<a name="3.7.5.1 Mixins Apply Per Node Instance"></a>	<H4>3.7.5.1 Mixins Apply Per Node Instance</H4>
	<P>Mixin node types apply
	to specific node instances within a workspace, allowing the
	repository to decouple support for some repository features from the
	primary node type assigned to that node. In effect, mixin node types
	permit <I>per instance node type inheritance</I>. In a writable
	repository mixin node types can be assigned to a node during its
	lifetime, not just upon creation.</P>
<a name="3.7.5.2 Mixins and Inheritance"></a>	<H4>3.7.5.2 Mixins and Inheritance</H4>
	<P>A mixin node type may
	have one or more supertypes, which must also be mixin types.
	Additionally, a mixin node type can serve as a supertype of a
	primary type. This is typically done to build a mixin-linked feature
	into a primary node type. For example, if a repository requires all
	nodes of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>xyz:Document</FONT></FONT>
	to be referenceable it can specify that <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:referenceable</FONT></FONT>
	as a supertype of <FONT FACE="Courier New, monospace"><FONT SIZE=2>xyz:Document</FONT></FONT>.</P>
<a name="3.7.5.3 Mixins Are Not Stand-Alone"></a>	<H4>3.7.5.3 Mixins Are Not Stand-Alone</H4>
	<P>A mixin node type
	cannot be used by itself as the node type of a node. A primary node
	type is always required.</P>
<a name="3.7.6 Node Type Inheritance"></a>	<H3>3.7.6 Node Type Inheritance</H3>
	<P>A mixin node type <I>may</I>
	be part of an inheritance hierarchy. A primary node (other than
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:base</FONT></FONT>)
	must at least be a subtype of the common base primary type, <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:base
	</FONT></FONT>(see §3.7.10 <I>Base Primary Node
	Type</I>). The semantics of inheritance are defined by the following
	rules.</P>
<a name="3.7.6.1 Supertype Relation"></a>	<H4>3.7.6.1 Supertype Relation</H4>
	<P>The <I>supertype</I> relation is
	transitive: If <I>T</I><SUB><I>1</I></SUB> is a supertype of <I>T</I><SUB><I>2</I></SUB>
	and <I>T</I><SUB><I>2</I></SUB> is a supertype of <I>T</I><SUB><I>3</I></SUB>
	then <I>T</I><SUB><I>1</I></SUB> is a supertype of <I>T</I><SUB><I>3</I></SUB>.</P>
	<P>The <I>supertype</I> relation always
	and only stems from explicit <I>supertypes</I> attribute
	declarations within the set of node types: For <I>T</I><SUB><I>1</I></SUB>
	to be a supertype of <I>T</I><SUB><I>2</I></SUB> it is <I>not
	sufficient</I> that the item definitions of <I>T</I><SUB><I>2</I></SUB><I>
	</I>be a superset of the item definitions of <I>T</I><SUB><I>1</I></SUB>.
	For that to be the case, <I>T</I><SUB><I>2</I></SUB> must <I>declare</I>
	<I>T</I><SUB><I>1</I></SUB> as a supertype.</P>
<a name="3.7.6.2 Subtype Relation"></a>	<H4>3.7.6.2 Subtype Relation</H4>
	<P>The <I>subtype</I> relation is the
	converse of supertype: <I>T</I><SUB><I>1</I></SUB> is a subtype of
	<I>T</I><SUB><I>2</I></SUB> if and only if <I>T</I><SUB><I>2</I></SUB>
	is a supertype of <I>T</I><SUB><I>1</I></SUB>. Hence, subtype is
	also a transitive relation.</P>
<a name="3.7.6.3 Is-of-Type Relation"></a>	<H4>3.7.6.3 Is-of-Type Relation</H4>
	<P>The <I>is-of-type</I> relation which
	holds between node instances and node types (as in, node <I>N</I> is
	of type <I>T</I>) is transitive across the <I>subtype</I> relation:
	If <I>N</I> is of type <I>T</I><SUB><I>2</I></SUB> and <I>T</I><SUB><I>2</I></SUB>
	is a subtype of <I>T</I><SUB><I>1</I></SUB> then <I>N</I> is (also)
	of type <I>T</I><SUB><I>1</I></SUB>. This predicate appears in the
	API as the method <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.isNodeType()</FONT></FONT>
	(see §8.6 <I>Node Type Information for Existing Nodes</I>). This
	relation is also the one that is relevant in the child node
	definition attribute <I>required primary node types</I> (see
	§3.7.4.1 <I>Required Primary Node Types</I>).</P>
	<P>The <I>is of type</I> relation always
	and only stems from an explicit assignment of a node type to a node:
	For node <I>N</I> to be of type <I>T</I> it is <I>not sufficient</I>
	for <I>N</I> to have the child items declared by <I>T</I>. For that
	to be the case, <I>N</I> must be <I>explicitly assigned</I> the type
	<I>T</I>, or a subtype of <I>T</I>.</P>
<a name="3.7.6.4 Abstract Node Types"></a>	<H4>3.7.6.4 Abstract Node Types</H4>
	<P>As mentioned (see
	§3.7.1.3 <I>Abstract</I>), a node type may be declared abstract,
	meaning that it cannot be assigned as the primary or mixin node type
	of a node but can be used in the definition of other node types as a
	supertype.</P>
<a name="3.7.6.5 Effective Node Type"></a>	<H4>3.7.6.5 Effective Node Type</H4>
	<P>The
	complete set of node type constraints on a particular node is
	referred to as that node's <I>effective
	node type</I>. This consists of the sum of
	all attributes</P>
	<UL>
		<LI><P>declared
		in that node's primary type,</P>
		<LI><P>inherited
		by that node's primary type,</P>
		<LI><P>declared
		in that node's mixin node types, and</P>
		<LI><P>inherited
		by that node's mixin node types.</P>
	</UL>
	<P>The summing of these
	attributes must conform to the semantics of subtyping defined in
	this section.</P>
<a name="3.7.6.6 Semantics of Subtyping"></a>	<H4>3.7.6.6 Semantics of Subtyping</H4>
	<P>The general principle
	guiding inheritance is to preserve the <I>is-a</I> relation across
	subtyping. This implies that if <I>T'</I> is a subtype of <I>T</I>
	and <I>N</I> is a valid instance of <I>T'</I> then:</P>
	<UL>
		<LI><P><I>N</I> must be a valid instance
		of <I>T</I>.</P>
		<LI><P>A method call that depends on the
		truth of the test <I>N is of type T</I> must not fail <I>solely</I>
		due to <I>N</I> being of type <I>T'</I>.</P>
	</UL>
<a name="3.7.6.7 Node Type Attribute Subtyping Rules"></a>	<H4>3.7.6.7 Node Type Attribute Subtyping Rules</H4>
	<P>If <I>T'</I> is a
	subtype of <I>T</I> then the following must hold:</P>
	<P>The name of <I>T'</I> must differ from
	the name of <I>T</I>.</P>
	<UL>
		<LI><P>The supertypes
		list of <I>T'</I> must include either <I>T</I> or a subtype of <I>T</I>.
				</P>
		<LI><P>If <I>T</I> is a
		primary type, <I>T'</I> must be a primary type. However, if <I>T</I>
		is a mixin then <I>T'</I> may be either a mixin or a primary type.</P>
	</UL>
	<P>If <I>T</I> has orderable child nodes
	then <I>T'</I> must have orderable child nodes.</P>
	<P>If <I>T</I> specifies a primary item <I>I</I>
	then <I>T'</I> inherits that setting and must not specify a primary
	item other than <I>I</I>.</P>
	<P><I>T'</I> may declare any number of
	property definitions as long as they are not invalid (see §3.7.6.8
	<I>Item Definitions in Subtypes</I>).</P>
	<P><I>T'</I> may declare any number of
	child node definitions as long as they are not invalid (see §3.7.6.8
	<I>Item Definitions in Subtypes</I>).</P>
<a name="3.7.6.8 Item Definitions in Subtypes"></a>	<H4>3.7.6.8 Item Definitions in Subtypes</H4>
	<P>If <I>T</I> is a
	registered node type and <I>T'</I> is the definition of a subtype of
	<I>T</I> that meets the criteria in the preceding sections, then an
	item definition <I>D'</I> in <I>T'</I> is either <I>additive</I>,
	<I>overriding</I> or <I>invalid</I>, as determined by the following
	algorithm:</P>
	<UL>
		<LI><P>If <I>D'</I> is
		not statically valid then <I>D'</I> is invalid.</P>
		<LI><P>If <I>D'</I> is a
		residual definition then <I>D'</I> is additive.</P>
		<LI><P>If there <I>does
		not</I> exists a definition <I>D</I> in <I>T</I> with a name and
		class (i.e., either <I>node</I> or <I>property</I>) identical to
		that of <I>D'</I> then <I>D'</I> is additive.</P>
		<LI><P>If there <I>does</I>
		exist a definition <I>D</I> in <I>T</I> with name and class
		identical to that of <I>D'</I> then <I>D'</I> is overriding if: 
		</P>
		<UL>
			<LI><P>The
			implementation supports item definition overrides in this instance
			(implementations are free allow or disallow overrides globally or
			on an instance-by-instance basis) 
			</P>
			<LI><P>If <I>D</I> is a
			property definition then <I>D</I> and <I>D'</I> have identical
			multiple settings and any property values valid against <I>D'</I>
			would also be valid against <I>D</I>.</P>
			<LI><P>If <I>D</I> is a
			child node definition then <I>D</I> and <I>D'</I> have identical
			same-name sibling settings.</P>
		</UL>
	</UL>
	<UL>
		<UL>
			<LI><P>If <I>D</I> is
			autocreated, mandatory or protected then <I>D'</I> must be,
			respectively, that as well.</P>
		</UL>
	</UL>
	<UL>
		<LI><P>Otherwise, <I>D'</I>
		is invalid.</P>
	</UL>
	<P>If <I>D'</I> is
	<I>additive</I> then when <I>T'</I> is registered <I>D'</I> becomes
	part of <I>T'</I> alongside all item definitions inherited from <I>T</I>.</P>
	<P>If <I>D'</I> <I>overrides</I>
	<I>D</I> then when <I>T'</I> is registered <I>D'</I> replaces the
	definition <I>D</I> that would otherwise have been inherited from <I>T</I>.</P>
	<P>If <I>D'</I> is
	<I>invalid</I> then <I>T'</I> cannot be registered.</P>
<a name="3.7.6.9 Effect of Inheritance Rules"></a>	<H4>3.7.6.9 Effect of Inheritance Rules</H4>
	<P>The rules of
	inheritance will have most impact on repositories that allow</P>
	<UL>
		<LI><P>a wide latitude
		in assigning mixins to nodes, 
		</P>
		<LI><P>registration of
		custom node types (see §19 <I>Node
		Type Management</I>) or, in particular,</P>
		<LI><P>registration of
		custom node types with multiple super types (multiple inheritance).</P>
	</UL>
	<P>In fixed node type
	repositories (those without support for mixin assignment or node
	type registration), adherence to the inheritance rules is simply a
	matter of ensuring that the correct relations hold among the
	statically defined node type that the system exposes.</P>
<a name="3.7.7 Applicable Item Definition"></a>	<H3>3.7.7 Applicable Item Definition</H3>
	<P>Though there may be
	more than one definition in the parent node's type that <I>could</I>
	apply to the child item, the definition that does apply is
	determined by the implementation and remains constant through the
	lifetime of the item.</P>
	<P>In writable
	repositories the applicable item definition is determined at item
	creation time.</P>
<a name="3.7.8 Root Node Type"></a>	<H3>3.7.8 Root Node Type</H3>
	<P>The node type of the
	root node of each workspace is implementation-determined. There are
	no restrictions other than those implied by the feature set of the
	repository. For example, a repository that exposes system data under
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system</FONT></FONT>
	will necessarily have a root node of a type that allows a <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:system</FONT></FONT>
	child node. 
	</P>
<a name="3.7.9 Node Type Notation"></a>	<H3>3.7.9 Node Type Notation</H3>
	<P>The node type
	definitions shown in this specification use the <I>compact node type
	definition</I> (CND) notation (see §25.2 <I>Compact Node Type
	Definition Notation</I>).</P>
<a name="3.7.9.1 Implementation Variants in Node Types"></a>	<H4>3.7.9.1 Implementation Variants in Node Types</H4>
	<P>Some
	of the attributes of the node types defined in this specification
	may vary across implementations. For example, it is
	implementation-dependent which node types and which properties are
	queryable (see §3.7.1.5 <I>Queryable Node</I>
	and §3.7.3.3 <I>Available Query
	Operators</I>). Similarly, some of the
	standard application node types (see §3.7.11 <I>Standard
	Application Node Types</I>) may vary as to
	the <I>on-parent-version</I>
	and <I>protected</I>
	status of some properties. In the CND notation, variant attributes
	are indicated with either a question mark (for example, <FONT FACE="Courier New, monospace"><FONT SIZE=2>protected?</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>opv?</FONT></FONT>)
	or, in the case of the queryable node type attribute, by the absence
	of an explicit indicator. For the queryable attribute of a node type
	to be non-variant it must be explicitly defined using the keywords
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>query</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>noquery</FONT></FONT>,
	(see §25.2 <I>Compact Node Type Definition Notation</I>).</P>
<a name="3.7.10 Base Primary Node Type"></a>	<H3>3.7.10 Base Primary Node Type</H3>
	<P>All repositories must
	supply the <I>base primary node type</I>, <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:base</FONT></FONT>,
	as a built-in type.</P>
<a name="3.7.10.1 nt:base"></a>	<H4>3.7.10.1 nt:base</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:base] abstract</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:primaryType (NAME) mandatory autocreated</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">protected
	COMPUTE</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:mixinTypes (NAME) protected multiple COMPUTE</FONT></P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:base</FONT></FONT>
	is an abstract primary node type that is the base type for all other
	primary node types. It is the only primary node type without
	supertypes.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:base</FONT></FONT>
	exposes type information about a node through the properties
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:primaryType</FONT></FONT>,
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:mixinTypes</FONT></FONT>.</P>
	<P>Since every other
	primary type must be a subtype of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:base</FONT></FONT>
	(see §3.7.6.2 <I>Subtype Relation</I>), every primary node type
	will inherit these two type-reflective property definitions.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:primaryType</FONT></FONT>
	is a protected mandatory <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	property which holds the name of the declared primary node type of
	its node. The repository must maintain its value accurately
	throughout the lifetime of the node (see §10.10 <I>Node Type
	Assignment</I>). Since it is mandatory, every node will have this
	property.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:mixinTypes</FONT></FONT>
	is a non-mandatory protected multi-value <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	property which holds a list of the declared mixin node types of its
	node. It is non-mandatory but is required to be present on any node
	that has one or more declared mixin types. If it is present, the
	repository must maintain its value accurately throughout the
	lifetime of the node (see §10.10.3 <I>Assigning Mixin Node Types</I>).</P>
<a name="3.7.11 Standard Application Node Types"></a>	<H3>3.7.11 Standard Application Node Types</H3>
	<P>JCR defines a number
	of standard application node types designed to support common
	application-level entities. A repository may supply zero or more of
	these as built-in types (see §24 <I>Repository Compliance</I>).</P>
<a name="3.7.11.1 nt:hierarchyNode"></a>	<H4>3.7.11.1 nt:hierarchyNode</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:hierarchyNode] &gt;
	mix:created abstract</FONT></P>
	<P>This abstract node
	type serves as the supertype of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:folder</FONT></FONT>
	and inherits the item definitions of <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:created</FONT></FONT>
	and so requires the presence of that node type (see §3.7.11.7
	<I>mix:created</I>).</P>
<a name="3.7.11.2 nt:file"></a>	<H4>3.7.11.2 nt:file</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:file] &gt; nt:hierarchyNode
	primaryitem jcr:content</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ jcr:content (nt:base)
	mandatory</FONT></P>
	<P>Nodes of this node
	type may be used to represent files. This node type inherits the
	item definitions of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:hierarchyNode</FONT></FONT>
	and requires a single child node called <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:content</FONT></FONT>.
	The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:content</FONT></FONT>
	node is used to hold the actual content of the file. This child node
	is mandatory, but not auto-created. Its node type will be
	application-dependent and therefore it must be added by the user. A
	common approach is to make the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:content</FONT></FONT>
	a node of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:resource</FONT></FONT>.
	The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:content</FONT></FONT>
	child node is also designated as the primary child item of its
	parent.</P>
<a name="3.7.11.3 nt:linkedFile"></a>	<H4>3.7.11.3 nt:linkedFile</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:linkedFile] &gt;
	nt:hierarchyNode primaryitem jcr:content</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:content (REFERENCE) mandatory</FONT></P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:linkedFile</FONT></FONT>
	node type is similar to <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>,
	except that the content node is not stored directly as a child node,
	but rather is specified by a <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property. This allows the content node to reside anywhere in the
	workspace and to be referenced by multiple <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:linkedFile</FONT></FONT>
	nodes. The content node must be referenceable. Support for this node
	type requires support for <I>referenceable nodes</I> with
	<I>referential integrity</I> (see §3.8.2 <I>Referential Integrity</I>).</P>
<a name="3.7.11.4 nt:folder"></a>	<H4>3.7.11.4 nt:folder</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:folder] &gt;
	nt:hierarchyNode</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ *
	(nt:hierarchyNode) VERSION</FONT></P>
	<P>Nodes of this type may
	be used to represent folders or directories. This node type inherits
	the item definitions of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:hierarchyNode</FONT></FONT>
	and adds the ability to have any number of other <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:hierarchyNode</FONT></FONT>
	child nodes with any names. This means, in particular, that it can
	have child nodes of types <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:folder</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:linkedFile</FONT></FONT>.</P>
<a name="3.7.11.5 nt:resource"></a>	<H4>3.7.11.5 nt:resource</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:resource] &gt; mix:mimeType,
	mix:lastModified</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">primaryitem jcr:data</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- jcr:data
	(BINARY) mandatory</FONT></P>
	<P>This node type may be
	used to represent the content of a file. In particular, the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:content</FONT></FONT>
	subnode of an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>
	node will often be an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:resource</FONT></FONT>.
	Note that the definition of this node type indicates multiple
	inheritance (see §3.7.6 <I>Node Type Inheritance</I>).</P>
<a name="3.7.11.6 mix:title"></a>	<H4>3.7.11.6 mix:title</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:title] mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- jcr:title
	(STRING) protected? OPV?</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:description (STRING) protected? OPV?</FONT></P>
	<P>This mixin node type can be used to
	add standardized title and description properties to a node.</P>
<a name="3.7.11.7 mix:created"></a>	<H4>3.7.11.7 mix:created</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:created] mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:created (DATE) autocreated protected? OPV?</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:createdBy (STRING) autocreated protected? OPV?</FONT></P>
	<P>This mixin node type
	can be used to add standardized creation information properties to a
	node. In implementations that make these properties protected, their
	values are controlled by the repository, which <I>should</I> set
	them appropriately upon the initial persist of a node with this
	mixin type. In cases where this mixin is added to an already
	existing node the semantics of these properties are implementation
	specific (see §10.10.3 <I>Assigning Mixin Node Types</I>).</P>
<a name="3.7.11.8 mix:lastModified"></a>	<H4>3.7.11.8 mix:lastModified</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:lastModified] mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:lastModified (DATE) autocreated protected? OPV?</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:lastModifiedBy (STRING) autocreated protected? OPV?</FONT></P>
	<P>This mixin node type can be used
	to provide standardized modification information properties to a
	node. In implementations that make these properties protected, their
	values are controlled by the repository, which should
	set them appropriately upon a significant modification
	of the subgraph of a node with this mixin. What constitutes a
	significant modification will depend on the semantics of the various
	parts of a node's subgraph and is implementation-dependent.</P>
<a name="3.7.11.9 mix:language"></a>	<H4>3.7.11.9 mix:language</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:language] mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:language (STRING) protected? OPV?</FONT></P>
	<P>This mixin node type can be used
	to provide a standardized property that
	specifies the natural language in which the content of a node is
	expressed. The value of the <FONT FACE="Courier New, monospace"><FONT SIZE=2><I>jcr:language</I></FONT></FONT>
	property should be a language code as defined in RFC 4646<SUP><I><A CLASS="sdfootnoteanc" NAME="sdfootnote5anc" HREF="#sdfootnote5sym"><SUP>5</SUP></A></I></SUP>.
	Examples include “<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>en</I></FONT></FONT>”
	(English), “<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>en-US</I></FONT></FONT>”
	(United States English), “<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>de</I></FONT></FONT>”
	(German) and “<FONT FACE="Courier New, monospace"><FONT SIZE=2><I>de-CH</I></FONT></FONT>”
	(Swiss German).</P>
<a name="3.7.11.10 mix:mimeType"></a>	<H4>3.7.11.10 mix:mimeType</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:mimeType] mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:mimeType (STRING) protected? OPV?</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:encoding (STRING) protected? OPV?</FONT></P>
	<P>This mixin node type
	can be used to provide standardized mimetype and encoding properties
	to a node.</P>
	<P>If a node of this type
	has a primary item that is a single-value <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	property then <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:mimeType</FONT></FONT>
	property indicates the media type<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote6anc" HREF="#sdfootnote6sym"><SUP>6</SUP></A></SUP>
	applicable to the contents of that property and, if that media type
	is one to which a text encoding applies, the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:encoding</FONT></FONT>
	property indicates the character set<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote7anc" HREF="#sdfootnote7sym"><SUP>7</SUP></A></SUP>
	used.</P>
	<P>If a node of this type
	does not meet the above precondition then the interpretation of the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:mimeType</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:encoding</FONT></FONT>
	properties is implementation-dependent.</P>
<a name="3.7.11.11 nt:address"></a>	<H4>3.7.11.11 nt:address</H4>
	<P>
	<FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>[nt:address]</FONT></FONT></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>-
	jcr:protocol (STRING)</FONT></FONT></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>-
	jcr:host (STRING)</FONT></FONT></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>-
	jcr:port (STRING)</FONT></FONT></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>-
	jcr:repository (STRING)</FONT></FONT></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>-
	jcr:workspace (STRING)</FONT></FONT></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>-
	jcr:path (PATH)</FONT></FONT></FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><FONT SIZE=2>-
	jcr:id (WEAKREFERENCE)</FONT></FONT></FONT></P>
	<P>This node type may be
	used to represent the location of a JCR item not just within a
	particular workspace but within the space of all workspaces in all
	JCR repositories.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:protocol</FONT></FONT>
	property stores a string holding the protocol through which the
	target repository is to be accessed.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:host</FONT></FONT>
	property stores a string holding the host name of the system through
	which the repository is to be accessed.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:port</FONT></FONT>
	property stores a string holding the port number through which the
	target repository is to be accessed.</P>
	<P>The semantics of these
	properties are left undefined but are assumed to be known by the
	application. The names and descriptions of the properties are not
	normative and the repository does not enforce any particular
	semantic interpretation on them.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:repository</FONT></FONT>
	property stores a string holding the name of the target repository.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:workspace
	</FONT></FONT>property stores the name of a workspace.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:path</FONT></FONT>
	property stores a path to an item.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:id</FONT></FONT>
	property stores a weak reference to a node.</P>
	<P>In most cases either
	the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:path</FONT></FONT>
	or the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:id</FONT></FONT>
	property would be used, but not both, since they may point to
	different nodes. If any of the properties other than <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:path</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:id</FONT></FONT>
	are missing, the address can be interpreted as <I>relative</I> to
	the current container at the same level as the missing specifier.
	For example, if no repository is specified, then the address can be
	interpreted as referring to a workspace and path or id within the
	current repository.</P>
<a name="3.7.12 Entity Tags"></a>	<H3>3.7.12 Entity Tags</H3>
	<P>It
	is often useful for an application to be able to quickly find
	whether the value of a <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	property has changed since the last time it was checked. This is
	particularly useful when determining whether to invalidate a cache
	containing a copy of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	value.</P>
	<P>The
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:etag</FONT></FONT>
	mixin type defines a standardized identity validator for
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
	properties similar to the entity tags used in HTTP/1.1<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote8anc" HREF="#sdfootnote8sym"><SUP>8</SUP></A></SUP>.</P>
<a name="3.7.12.1 mix:etag"></a>	<H4>3.7.12.1 mix:etag</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:etag]
	mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- jcr:etag
	(STRING) protected autocreated</FONT></P>
	<P>A <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:etag</FONT></FONT>
	property is an opaque string whose syntax is identical to that
	defined for entity tags in HTTP/1.1. Semantically, the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:etag</FONT></FONT>
	is comparable to the HTTP/1.1 strong entity tag.</P>
	<P>On creation of a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:etag</FONT></FONT>
	node <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>,
	or assignment of <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:etag</FONT></FONT>
	to <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>,
	 the repository must create a <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:etag</FONT></FONT>
	property with an implementation determined value.</P>
	<P>The value of the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:etag</FONT></FONT>
	property must change immediately on persist of any of the following
	changes to <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>:</P>
	<UL>
		<LI><P>A <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
		property is added to <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>.</P>
		<LI><P>A <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
		property is removed from <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>.</P>
		<LI><P>The value of an
		existing <FONT FACE="Courier New, monospace"><FONT SIZE=2>BINARY</FONT></FONT>
		property of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
		changes.</P>
	</UL>
<a name="3.7.13 Unstructured Content"></a>	<H3>3.7.13 Unstructured Content</H3>
	<P>Support
	for unstructured content may be provided by supporting a free-form
	node type: <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:unstructured</FONT></FONT>.
	Support for this node type requires support for the <FONT FACE="Courier New, monospace"><FONT SIZE=2>UNDEFINED</FONT></FONT>
	property type value.</P>
<a name="3.7.13.1 nt:unstructured"></a>	<H4>3.7.13.1 nt:unstructured</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:unstructured]</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">orderable</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- *
	(UNDEFINED) multiple</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- *
	(UNDEFINED)</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ *
	(nt:base) = nt:unstructured sns VERSION</FONT></P>
	<P>This node type is used
	to store unstructured content. It allows any number of child nodes
	or properties with any names. It also allows multiple nodes having
	the same name as well as both multi-value and single-value
	properties with any names. This node type also supports
	client-orderable child nodes.</P>
<a name="3.7.14 Node Type Definition Storage"></a>	<H3>3.7.14 Node Type Definition Storage</H3>
	<P>A repository may
	expose the definitions of its available node types in content using
	the node types <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:nodeType</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:propertyDefinition</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:childNodeDefinition</FONT></FONT>.
	If a repository exposes node type definitions in content, then that
	repository must also support the system node (see §3.11 <I>System
	Node</I>) and the node type definitions should be located below
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:nodeTypes</FONT></FONT>.
	Support for these node types also requires support for same-name
	siblings (see §22 <I>Same-Name Siblings</I>).</P>
<a name="3.7.14.1 nt:nodeType"></a>	<H4>3.7.14.1 nt:nodeType</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:nodeType]</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:nodeTypeName (NAME) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:supertypes (NAME) protected multiple</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:isAbstract (BOOLEAN) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- jcr:isQueryable (BOOLEAN)
	protected mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:isMixin (BOOLEAN) protected mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:hasOrderableChildNodes (BOOLEAN) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:primaryItemName (NAME) protected</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+
	jcr:propertyDefinition (nt:propertyDefinition)</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">=
	nt:propertyDefinition protected sns</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ jcr:childNodeDefinition
	(nt:childNodeDefinition)</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">=
	nt:childNodeDefinition protected sns</FONT></P>
	<P>This node type is used
	to store a node type definition. Property and child node definitions
	within the node type definition are stored as same-name sibling
	nodes of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:propertyDefinition</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:childNodeDefinition</FONT></FONT>.</P>
<a name="3.7.14.2 nt:propertyDefinition"></a>	<H4>3.7.14.2 nt:propertyDefinition</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:propertyDefinition]</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- jcr:name
	(NAME) protected</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:autoCreated (BOOLEAN) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:mandatory (BOOLEAN) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:onParentVersion (STRING) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'COPY', 'VERSION',
	'INITIALIZE', 'COMPUTE',</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">'IGNORE', 'ABORT'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:protected (BOOLEAN) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:requiredType (STRING) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt;
	'STRING', 'URI', 'BINARY', 'LONG', 'DOUBLE',<BR> 'DECIMAL',
	'BOOLEAN', 'DATE', 'NAME', 'PATH',<BR> 'REFERENCE',
	'WEAKREFERENCE', 'UNDEFINED'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:valueConstraints (STRING) protected
	multiple</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:defaultValues (UNDEFINED) protected
	multiple</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:multiple (BOOLEAN) protected mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:availableQueryOperators (NAME) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">multiple</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:isFullTextSearchable (BOOLEAN) protected
	mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:isQueryOrderable (BOOLEAN) protected
	mandatory</FONT></P>
	<P>This node type used to
	store a property definition within a node type definition, which
	itself is stored as an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:nodeType</FONT></FONT>
	node.</P>
<a name="3.7.14.3 nt:childNodeDefinition"></a>	<H4>3.7.14.3 nt:childNodeDefinition</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:childNodeDefinition]</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- jcr:name
	(NAME) protected</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:autoCreated (BOOLEAN) protected mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:mandatory (BOOLEAN) protected mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:onParentVersion (STRING) protected mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'COPY', 'VERSION',
	'INITIALIZE', 'COMPUTE',</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">'IGNORE', 'ABORT'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:protected (BOOLEAN) protected mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:requiredPrimaryTypes (NAME) = 'nt:base' protected<BR> 
	mandatory multiple</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:defaultPrimaryType (NAME) protected</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:sameNameSiblings (BOOLEAN) protected mandatory</FONT></P>
	<P>This node type used to
	store a child node definition within a node type definition, which
	itself is stored as an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:nodeType</FONT></FONT>
	node.</P>
<a name="3.7.14.4 Representing Null Attributes"></a>	<H4>3.7.14.4 Representing Null Attributes</H4>
	<P>The attributes that
	make up a node type definition may in some cases have no set value
	(for example, some child node definitions may not define a <I>default
	primary type</I>). To store this information (i.e., the lack of a
	value) in an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:nodeType</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:childNodeDefinition</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:propertyDefinition</FONT></FONT>
	node the property representing that attribute must simply be not
	present, since null values for single-value properties are not
	permitted (see §10.4.2.4 <I>No Null Values</I>).</P>
<a name="3.7.14.5 Representing Residual Items"></a>	<H4>3.7.14.5 Representing Residual Items</H4>
	<P>To indicate that a
	property or child node definition is residual, the value returned by
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>ItemDefinition.getName()</FONT></FONT>
	is “<FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>”.
	However, “<FONT FACE="Courier New, monospace"><FONT SIZE=2>*</FONT></FONT>”
	is not a valid value for the property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:name</FONT></FONT>
	in an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:propertyDefinition</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:childNodeDefinition</FONT></FONT>
	node (because <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:name</FONT></FONT>
	it is a <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	property, not a <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>).
	As a result, an in-content definition of a residual item will simply
	not have a <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:name</FONT></FONT>
	property.</P>
<a name="3.7.15 Repository Feature Node Types"></a>	<H3>3.7.15 Repository Feature Node Types</H3>
	<P>JCR
	defines a number of node types in order to support specific
	repository features. Descriptions of these node types are found in
	their corresponding feature sections. The following list summarizes
	the node types and their associated features:</P>
	<P><B>Referenceable
	Nodes</B>: <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:referenceable</FONT></FONT>
	(see §3.8 <I>Referenceable Nodes</I>).</P>
	<P><B>Locking</B>:
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:lockable</FONT></FONT>
	(see §17 <I>Locking</I>).</P>
	<P><B>Shareable Nodes</B>:
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:shareable</FONT></FONT>
	(see §3.9 <I>Shareable Nodes Model</I>).</P>
	<P><B>Lifecycles</B>:
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:lifecycle</FONT></FONT>
	(see §18 <I>Lifecycle Management</I>).</P>
	<P><B>Versioning</B>:
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:simpleVersionable</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:frozenNode</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionLabels</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionedChild</FONT></FONT>
	(see §3.13 <I>Versioning Model</I>).</P>
<a name="3.7.16 JCR Node Type Variants"></a>	<H3>3.7.16 JCR Node Type Variants</H3>
	<P>An implementation <I>may</I>
	provide a variant of a JCR node type as a built-in under certain
	conditions.</P>
	<H5>3.7.16.1.1 Replacing the Canonical Type  </H5>
	<P>Such a variant must
	have the same name as the canonically defined type and thus replace
	it in that implementation's set of available node types. 
	</P>
	<H5>3.7.16.1.2 Additions to the Hierarchy</H5>
	<P>An implementation may
	alter the definition of a JCR node type by adding supertypes. These
	additional supertypes may be either JCR mixin node types or
	implementation-specific mixin or primary node types. For example, a
	repository may require that all nodes of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>
	be, additionally, <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>.
	In such a repository the definition of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>,
	when introspected, would report an additional supertype of
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>.</P>
	<P>This extension
	mechanism is distinct from the automatic addition of mixin types
	that may be done on node creation (see §10.10.3.3 <I>Automatic
	Addition and Removal of Mixins</I>). Though the two features may
	both be employed in the same repository, they differ in that one
	affects the actual hierarchy of the supported node types, while the
	other works on a node-by-node basis.</P>
	<H5>3.7.16.1.3 Abstract Node Types</H5>
	<P>An implementation may
	make abstract a JCR node type that is not canonically abstract. For
	example, some implementations might use <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>
	as is, whereas others might subtype it in order to introduce
	implementation specific item definitions. Such implementations would
	therefore designate <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:file</FONT></FONT>
	as abstract.</P>
	<H5>3.7.16.1.4 Variant Attributes</H5>
	<P>An implementation may
	vary the value of a node type or child definition attribute that is
	explicitly indicated as a variant in the node type definitions given
	in this specification. For example, any node type defined in this
	specification may be either queryable or non-queryable, depending on
	the implementation. Also, the protected and OPV settings of the
	properties of the metadata mixins (<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:title</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:created</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:lastModified</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:language</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:mimeType</FONT></FONT>)
	are also variant.</P>
<a name="3.7.17 External Node Types"></a>	<H3>3.7.17 External Node Types</H3>
	<P>An <I>external node
	type</I> is one defined outside this specification. It may be either
	an implementation-specific type built into a repository or a node
	type defined and registered by a user (see §19 <I>Node Type
	Management</I>).</P>
<a name="3.7.17.1 Restrictions"></a>	<H4>3.7.17.1 Restrictions</H4>
	<P>The following
	restrictions apply to all external node types:</P>
	<UL>
		<LI><P>An implementation
		<I>must not</I> allow external node types with node type names in
		the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt</FONT></FONT>,
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix</FONT></FONT>,
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr</FONT></FONT>
		or <FONT FACE="Courier New, monospace"><FONT SIZE=2>xml</FONT></FONT>
		namespaces.</P>
		<LI><P>An implementation
		may allow external node types which have item definitions in the
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr</FONT></FONT>
		namespace. Such an item definition must only reuse an item
		definition from a JCR-defined node type.</P>
		<LI><P>Any jcr
		namespaced item definition <I>D'</I> in an external node type <I>T'</I>
		must not be invalid with respect to the JCR-defined definition <I>D</I>
		in the JCR-defined node <I>T</I> (with <I>D</I>, <I>D'</I>, <I>T</I>
		and <I>T'</I> as above, see §3.7.6.8 <I>Item Definitions in
		Subtypes</I>).</P>
		<LI><P>Any jcr
		namespaced item definition in an external node type must be used
		for a purpose equivalent to its JCR use. 
		</P>
		<LI><P>All custom node
		types must adhere to semantics of subtyping (see §3.7.6.6
		<I>Semantics of Subtyping</I>)</P>
	</UL>
<a name="3.8 Referenceable Nodes"></a>	<H2>3.8 Referenceable Nodes</H2>
	<P>A repository may
	support <I>referenceable nodes</I>. A node must be referenceable to
	serve as the target of a <I>reference property</I>, which is either
	a <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>.
	To be referenceable a node must be of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:referenceable</FONT></FONT>.</P>
<a name="3.8.1.1 mix:referenceable"></a>	<H4>3.8.1.1 mix:referenceable</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:referenceable]</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- jcr:uuid
	(STRING) mandatory autocreated protected</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">INITIALIZE</FONT></P>
	<P>This node type adds an
	auto-created, mandatory, protected <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	property to the node, called <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>,
	which exposes the identifier of the node. Note that the term “UUID”
	is used for backward compatibility with JCR 1.0 and does not
	necessarily imply the use of the UUID syntax, or global uniqueness.</P>
	<P>The identifier of a
	referenceable node must be a <I>referenceable identifier</I>.
	Referenceable identifiers must fulfill a number of constraints
	beyond the minimum required of standard identifiers (see §3.8.3
	<I>Referenceable Identifiers</I>).</P>
	<P>A reference property
	is a property that holds the referenceable identifier of a
	referenceable node and therefore serves as a pointer to that node.
	The two types of reference properties, <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	differ in that the former enforces referential integrity while the
	latter does not (see §3.8.2 <I>Referential Integrity</I>). A
	repository may support only <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	or both <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property types.</P>
<a name="3.8.2 Referential Integrity"></a>	<H3>3.8.2 Referential Integrity</H3>
	<P>Given a property <FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
	with value <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	in workspace <FONT FACE="Courier New, monospace"><FONT SIZE=2>W:</FONT></FONT></P>
	<P>If <FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
	is of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	then there must exist a node in <FONT FACE="Courier New, monospace"><FONT SIZE=2>W</FONT></FONT>
	with identifier <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>.</P>
	<P>If <FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
	is of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>,
	no such restriction exists.</P>
	<P>In a read-only context
	the only difference between the types is that a workspace cannot
	contain a dangling <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	while it may contain a dangling <FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>.</P>
<a name="3.8.2.1 Exceptions to Referential Integrity"></a>	<H4>3.8.2.1 Exceptions to Referential Integrity</H4>
	<P>In a repository that
	exposes version storage in content, such as one that supports <I>full
	versioning</I>, an exception is made to the referential integrity
	rule when the <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property in question is part of the frozen state of a version stored
	in version storage. In that case the frozen <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property may hold the identifier of a node that is no longer in the
	workspace (see §3.13.3.7 <I>References in a Frozen Node</I>).</P>
<a name="3.8.3 Referenceable Identifiers"></a>	<H3>3.8.3 Referenceable Identifiers</H3>
	<P>Every node has an
	identifier, where an identifier is a string which is the most stable
	available. A <I>referenceable</I> node, however, must have a
	<I>referenceable identifier</I>, which is subject to a number of
	further constraints:</P>
<a name="3.8.3.1 Identifier Assignment"></a>	<H4>3.8.3.1 Identifier Assignment</H4>
	<P>As with any identifier, a
	referenceable node's identifier must be assigned <I>at the latest</I>
	when the node is first persisted. However, the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>
	property of the node must be created immediately upon the node
	becoming referenceable, which may be upon node creation or upon a
	later mixin addition. Consequently, the value of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>
	property before the first persist is not guaranteed to be the
	identifier of the node.</P>
<a name="3.8.3.2 Identifier Immutable across Move and Clone"></a>	<H4>3.8.3.2 Identifier Immutable across Move and Clone</H4>
	<P>The identifier is immutable during the
	lifetime of the node, that is, until the node is deleted though a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>remove</FONT></FONT>
	operation. In particular, the identifier is immutable across <FONT FACE="Courier New, monospace"><FONT SIZE=2>move</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>clone</FONT></FONT>
	operations. Note that non-referenceable identifiers are <I>not</I>
	required to be immutable across these operations. As in the
	non-referenceable case, the referenceable identifier is not
	immutable across <FONT FACE="Courier New, monospace"><FONT SIZE=2>copy</FONT></FONT>
	operations. This operation results in the creation of a new node
	with a new identifier.</P>
<a name="3.8.3.3 Implementation Variations"></a>	<H4>3.8.3.3 Implementation Variations</H4>
	<P>These are the minimum requirements for
	a referenceable identifier, but implementations are free to exceed
	these requirements. 
	</P>
<a name="3.9 Shareable Nodes Model"></a>	<H2>3.9 Shareable Nodes Model</H2>
	<P>The ability to address
	the same piece of data via more than one path is a common feature of
	many content storage systems. In JCR this feature is supported
	through <I>shareable nodes</I>.</P>
	<P>Two or more shareable
	nodes in the same workspace may belong to a shared set. Each node
	within that set has its own unique path within the workspace but all
	share exactly the same set of child nodes and properties. This means
	that while the shared nodes are distinct from a path perspective,
	they are effectively the same node for purposes of operations that
	access their common subgraph.</P>
<a name="3.9.1 mix:shareable"></a>	<H3>3.9.1 mix:shareable</H3>
	<P>In order to be
	shareable, a node must of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:shareable</FONT></FONT>:
		</P>
	<P>
	<FONT FACE="Courier New, monospace">[mix:shareable] &gt;
	mix:referenceable mixin</FONT></P>
	<P>All shareable nodes
	are referenceable.</P>
<a name="3.9.2 Shared Set"></a>	<H3>3.9.2 Shared Set</H3>
	<P>Given two distinct
	shareable nodes <I>A</I> and <I>B</I> where <I>A</I> shares with <I>B</I>,
	the following facts hold:</P>
	<UL>
		<LI><P><I>A</I> and <I>B</I>
		are in the same shared set.</P>
		<LI><P><I>B</I> shares
		with <I>A</I> (sharing is a symmetric relation).</P>
		<LI><P>If <I>B</I>
		shares with <I>C</I> then <I>A</I> shares with <I>C</I> (sharing is
		a transitive relation).</P>
		<LI><P>If item <I>I</I>
		is a child of <I>A</I> then <I>I</I> is also a child of <I>B</I>
		and has the same name relative to both <I>A</I> and <I>B</I>.</P>
		<LI><P><I>A</I> and <I>B</I>
		have the same identifier.</P>
		<LI><P><I>A</I> and <I>B</I>
		are in the same workspace 
		</P>
		<LI><P><I>A</I> and <I>B</I>
		have distinct paths.</P>
	</UL>
<a name="3.9.3 Child Nodes of Shared Nodes"></a>	<H3>3.9.3 Child Nodes of Shared Nodes</H3>
	<P>Each node in a shared
	set shares the same child nodes. In particular, the addition or
	removal of a child from a shared node <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	automatically adds or removes that child from all the nodes in the
	shared set of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>.</P>
	<P>For example, suppose
	the following nodes exist:</P>
	<P>
	<FONT FACE="Courier New, monospace">		<I>/x</I></FONT></P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/y</I></FONT></P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/y/z</I></FONT></P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/y/z/n1</I></FONT></P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/y/z/n2</I></FONT></P>
	<P>Suppose a shared node
	at <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>
	is created and shares with the shareable node at <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y</FONT></FONT>.
	Since the children of <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y</FONT></FONT>
	are automatically added to <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>,
	a child named “<FONT FACE="Courier New, monospace"><FONT SIZE=2>z</FONT></FONT>”
	is automatically added to <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>.
	Therefore, as a result of creating <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>,
	the following paths are associated with nodes:</P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/a</I></FONT></P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/a/z</I></FONT></P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/a/z/n1</I></FONT></P>
	<P>
	<FONT FACE="Courier New, monospace"><I>		/x/a/z/n2</I></FONT></P>
	<P>where <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>
	is a new node that shares with <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a/z</FONT></FONT>
	identifies the same node as <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y/z</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a/z/n1</FONT></FONT>
	identifies the same node as <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y/z/n1</FONT></FONT>,
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a/z/n2</FONT></FONT>
	identifies the same node as <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y/z/n2</FONT></FONT>.</P>
	<P>Subsequently, when a
	new child named “<FONT FACE="Courier New, monospace"><FONT SIZE=2>w</FONT></FONT>”
	is added to either <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>,
	that child is automatically added to both <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>.
	Conversely, when a child named “<FONT FACE="Courier New, monospace"><FONT SIZE=2>w</FONT></FONT>”
	is removed from either <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y</FONT></FONT>
	or <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>,
	the child named “<FONT FACE="Courier New, monospace"><FONT SIZE=2>w</FONT></FONT>”
	is removed from both <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/y</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>/x/a</FONT></FONT>.</P>
<a name="3.9.4 Properties of Shared Nodes"></a>	<H3>3.9.4 Properties of Shared Nodes</H3>
	<P>E<IMG SRC="jcr-spec_html_4b66204b.png" NAME="graphics2" ALIGN=LEFT HSPACE=14 WIDTH=628 HEIGHT=408 BORDER=0><BR CLEAR=LEFT>ach
	node in shared set shares the same properties and their respective
	property values. When a change, addition or removal of a property of
	one node in a shared set is made, that change, addition or removal
	is immediately reflected in the properties of each node in the
	shared set.</P>
<a name="3.9.5 Shared Nodes Diagram"></a>	<H3>3.9.5 Shared Nodes Diagram</H3>
	<P>The
	above diagram shows a share set of three nodes, <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>B</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>,
	which share the child nodes <FONT FACE="Courier New, monospace"><FONT SIZE=2>D</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>F</FONT></FONT>
	and the property <FONT FACE="Courier New, monospace"><FONT SIZE=2>G</FONT></FONT>.</P>
<a name="3.9.6 Deemed Path"></a>	<H3>3.9.6 Deemed Path</H3>
	<P>A descendant item of a
	shared set will have more than one valid path (assuming the shared
	set has at least two members). When the parent node or path of such
	a descendant item is requested, an implementation must choose a
	<I>deemed path</I> to return.</P>
	<P>How the deemed path is
	chosen and its stability both over time and across the set of
	descendent items is an implementation issue.</P>
	<P>In particular, it is
	permissible for an implementation to choose deemed paths for two
	sibling items where those paths differ by more than just the last
	element. It is also permissible for the deemed path of an item to
	change from one request to the next on the same item within the same
	session.</P>
	<P>Though most
	implementations are expected to support deemed paths which are more
	stable than this, flexibility of the deemed path is provided to
	facilitate implementations which would otherwise not be able to
	support shareable nodes.</P>
	<P> 
	</P>
	<P>
	<BR><BR>
	</P>
<a name="3.9.7 Ancestors of Shared Nodes"></a>	<H3>3.9.7 Ancestors of Shared Nodes</H3>
	<P>Given the following
	situation:</P>
	<UL>
		<LI><P>Node <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
		is an ancestor of node <FONT FACE="Courier New, monospace"><FONT SIZE=2>N.</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
		is in the shared set <FONT FACE="Courier New, monospace"><FONT SIZE=2>S.</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>N'</FONT></FONT>
		is also in the shared set <FONT FACE="Courier New, monospace"><FONT SIZE=2>S.</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
		is an ancestor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N.</FONT></FONT></P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>D</FONT></FONT>
		is a descendent of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N.</FONT></FONT></P>
	</UL>
	<P>The following
	terminology applies:</P>
	<UL>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
		is an <I>ancestor</I> of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
		(as usual).</P>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
		is a <I>share-ancestor</I> of the set <FONT FACE="Courier New, monospace"><FONT SIZE=2>S</FONT></FONT>
		and of the individual nodes, <FONT FACE="Courier New, monospace"><FONT SIZE=2>N'</FONT></FONT>
		and (trivially), <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>.</P>
		<LI><P>Since <FONT FACE="Courier New, monospace"><FONT SIZE=2>D</FONT></FONT>
		is a <I>descendent</I> of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
		it is also a <I>descendent</I> of every node in <FONT FACE="Courier New, monospace"><FONT SIZE=2>S</FONT></FONT>
		(<FONT FACE="Courier New, monospace"><FONT SIZE=2>N'</FONT></FONT>,
		for example). We also say that it is a <I>descendent</I> of the set
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>S</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><B>.</B></FONT></FONT></P>
		<LI><P>Since <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
		is a <I>share-ancestor</I> of <FONT FACE="Courier New, monospace"><FONT SIZE=2>S</FONT></FONT>
		and <FONT FACE="Courier New, monospace"><FONT SIZE=2>D</FONT></FONT>
		is a <I>descendent</I> of <FONT FACE="Courier New, monospace"><FONT SIZE=2>S</FONT></FONT>,
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
		is an <I>ancestor</I> (proper) of <FONT FACE="Courier New, monospace"><FONT SIZE=2>D</FONT></FONT>.</P>
	</UL>
	<P>Note that the term
	<I>share-ancestor</I> does not mean <I>shared</I> ancestor. The
	ancestor (proper) of a member of a shared set is not necessarily an
	ancestor (proper) of any other member of that set.</P>
<a name="3.9.8 Identifiers"></a>	<H3>3.9.8 Identifiers</H3>
	<P>When a node is
	requested by identifier and that identifier references a shared set
	of nodes with more than one member the repository must return one
	member of that set. How this node is chosen is an implementation
	issue. In general, a user that interacts with repositories that
	support shareable nodes must be prepared to deal with different
	nodes having the same identifier.</P>
<a name="3.9.9 Share Cycle"></a>	<H3>3.9.9 Share Cycle</H3>
	<P>A <I>share cycle</I>
	occurs when a node is in the same shared set as one of its
	ancestors. A repository implementation <I>may</I> prevent the
	occurrence of share cycles. In such implementations any method call
	that would cause a cycle will fail.</P>
<a name="3.10 Corresponding Nodes"></a>	<H2>3.10 Corresponding Nodes</H2>
	<P>In a repository with
	more than one workspace, a node in one workspace <I>may</I> have
	<I>corresponding nodes</I> in one or more other workspaces.</P>
	<P>Given a repository <I>R</I>
	with workspaces <I>W</I><SUB><I>0</I></SUB>, <I>W</I><SUB><I>1</I></SUB>,...<I>W</I><SUB><I>k</I></SUB>
	and a node <I>N</I><SUB><I>0</I></SUB> in <I>W</I><SUB><I>0</I></SUB>
	with identifier <I>I</I><SUB><I>0</I></SUB> then for each workspace
	<I>W</I><SUB><I>x</I></SUB> in <I>R</I>, if <I>W</I><SUB><I>x</I></SUB>
	has a node <I>N</I><SUB><I>x</I></SUB> with identifier <I>I</I><SUB><I>0</I></SUB>,
	<I>N</I><SUB><I>x</I></SUB> is a corresponding node of <I>N</I><SUB><I>0</I></SUB>.
	Some corollaries include:</P>
	<UL>
		<LI><P>Every node corresponds to itself.</P>
		<LI><P>A non-shared node has at most one
		corresponding node per workspace. In repositories that support
		<I>shareable nodes</I> the nodes within a shared-set have the same
		identifier and therefore a node in another workspace with that
		identifier will have more than one corresponding node in that
		workspace (see §3.9 <I>Shareable Nodes Model</I>).</P>
	</UL>
	<P>Apart from having the
	same identifier, corresponding nodes need have nothing else in
	common. They can have different sets of properties and child nodes,
	for example.</P>
<a name="3.10.1.1 Root Node Correspondence"></a>	<H4>3.10.1.1 Root Node Correspondence</H4>
	<P>The root nodes of all
	workspaces in a repository all have the same identifier, and
	therefore correspond to one another.</P>
<a name="3.10.1.2 Correspondence Semantics"></a>	<H4>3.10.1.2 Correspondence Semantics</H4>
	<P>The
	mechanism of correspondence allows two nodes in separate workspaces
	to be related by a common identifier while maintaining distinct
	states. This relation is used to model cases where copies of a
	common content structure must be maintained separately.</P>
<a name="3.10.1.3 Cross-Workspace Operations"></a>	<H4>3.10.1.3 Cross-Workspace Operations</H4>
	<P>JCR
	provides methods for transferring state between workspaces through
	<I>clone</I> and
	<I>update</I>
	(see §10.7.2 <I>Copying Across Workspaces</I> and §10.8
	<I>Cloning and Updating Nodes</I>).</P>
<a name="3.10.1.4 Versioning and Corresponding Nodes"></a>	<H4>3.10.1.4 Versioning and Corresponding Nodes</H4>
	<P>In
	systems that support versioning, corresponding nodes in separate
	workspaces share the same version history (see §3.13.7 <I>Versioning
	and Multiple Workspaces</I>).</P>
<a name="3.10.1.5 Corresponding Nodes Diagram"></a>	<H4>3.10.1.5 Corresponding Nodes Diagram</H4>
	<P>T<IMG SRC="jcr-spec_html_m7e6edee5.png" NAME="graphics3" ALIGN=LEFT HSPACE=14 WIDTH=628 HEIGHT=686 BORDER=0><BR CLEAR=LEFT>he
	above diagram depicts two workspaces <FONT FACE="Courier New, monospace"><FONT SIZE=2>W</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>W'</FONT></FONT>.
	Node <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	in <FONT FACE="Courier New, monospace"><FONT SIZE=2>W</FONT></FONT>
	and node <FONT FACE="Courier New, monospace"><FONT SIZE=2>C'</FONT></FONT>
	in <FONT FACE="Courier New, monospace"><FONT SIZE=2>W'</FONT></FONT>
	are corresponding nodes. Note that the subgraphs of corresponding
	nodes may differ, as they do in this case.</P>
<a name="3.11 System Node"></a>	<H2>3.11 System Node</H2>
	<P>The location
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system</FONT></FONT>
	is reserved for use as a “system folder”. Some implementations
	may use this location to expose repository-internal data as content.
		</P>
	<P>If a repository
	exposes node type definitions in content, then those node type
	definitions <I>should</I> be located at <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:nodeTypes</FONT></FONT>
	(see §3.7.14 <I>Node Type Definition Storage</I>).</P>
	<P>If a repository
	supports full versioning, then it <I>must</I> expose the version
	storage at <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:versionStorage</FONT></FONT>.
	If it supports only simple versioning then it <I>may</I> expose the
	version storage (see §3.13.8 <I>Version Storage</I>).</P>
	<P>Similarly, if an
	implementation supports activities (see §15.12 <I>Activities</I>)
	or configurations and baselines (see §15.13 <I>Configurations and
	Baselines</I>), the in-content representations of these entities are
	stored under <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:activities</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:configurations</FONT></FONT>,
	respectively.</P>
	<P>If <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system</FONT></FONT>
	is supported, its node type is left up to the implementation.</P>
<a name="3.12 Unfiled Content"></a>	<H2>3.12 Unfiled Content</H2>
	<P>Implementers that
	build a JCR repository on top of an existing repository that
	supports content objects which exist outside of a hierarchical
	structure may expose these objects as nodes below
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:unfiled</FONT></FONT>
	(see §3.11 <I>System Node</I>).</P>
	<P>The hierarchical
	structure below <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:unfiled</FONT></FONT>
	is implementation-dependent.</P>
	<P>JCR implementers may
	disallow discovery (listing) of the nodes beneath this folder. In
	such a case a call to <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node.getNodes</FONT></FONT>()
	on the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:unfiled</FONT></FONT>
	node would throw a <FONT FACE="Courier New, monospace"><FONT SIZE=2>RepositoryException</FONT></FONT>.</P>
	<P>JCR implementers may
	expose the nodes below <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:unfiled</FONT></FONT>
	to search through the query mechanism (see §6 <I>Query</I>).</P>
<a name="3.13 Versioning Model"></a>	<H2>3.13 Versioning Model</H2>
	<P>Versioning enables a
	user to record the state of a node and its subgraph and restore that
	state at a later time. A repository that supports versioning may
	support either the complete set of versioning features, referred to
	as <I>full versioning</I>, or a specific subset defined here, which
	is referred to as <I>simple versioning</I>. This section describes
	the concepts, data structures and node types of the full versioning
	model as well as which parts of that model apply under simple
	versioning. Discussion of the versioning API and its behavior under
	both levels of support is found in §15 <I>Versioning</I>.</P>
<a name="3.13.1 Overview"></a>	<H3>3.13.1 Overview</H3>
<a name="3.13.1.1 Versionable Nodes"></a>	<H4>3.13.1.1 Versionable Nodes</H4>
	<P>For its state to be
	recorded in a version, a node must be <I>versionable</I>.</P>
<a name="3.13.1.2 Check-In"></a>	<H4>3.13.1.2 Check-In</H4>
	<P>When a versionable
	node is <I>checked-in,</I> a new <I>version</I> of that node is
	created which contains a (typically partial) copy of its subgraph.
	The part of a node’s subgraph that is to be copied to a version is
	referred to as its <I>versionable state</I>. A node’s versionable
	state is determined by the <I>on-parent-version</I> attribute of
	each of its subitems, as defined in its node type (see §3.7.2.5
	<I>On-Parent-Version</I>).</P>
<a name="3.13.1.3 Version History"></a>	<H4>3.13.1.3 Version History</H4>
	<P>Once created, a
	version is stored in a <I>version history</I>. Within a given
	workspace, each non-shared versionable node has its own version
	history which contains a <I>version graph</I> that records the
	position of each version in relation to its direct predecessor and
	direct successor versions.</P>
<a name="3.13.1.4 Successor and Predecessor"></a>	<H4>3.13.1.4 Successor and Predecessor</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>V'</FONT></FONT>
	is a <I>direct successor</I> of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	if and only if <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	is a <I>direct predecessor</I> of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V'</FONT></FONT>.</P>
	<P>A version <FONT FACE="Courier New, monospace"><FONT SIZE=2>V’</FONT></FONT>
	is an <I>eventual successor</I> of a version <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	if and only if <FONT FACE="Courier New, monospace"><FONT SIZE=2>V’</FONT></FONT>
	is a direct successor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	or there exists a version <FONT FACE="Courier New, monospace"><FONT SIZE=2>V*</FONT></FONT>
	such that <FONT FACE="Courier New, monospace"><FONT SIZE=2>V'</FONT></FONT>
	is a direct successor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V*</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V*</FONT></FONT>
	is an eventual successor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>.</P>
	<P>Similarly, a version
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V’</FONT></FONT>
	is an <I>eventual predecessor</I> of a version <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	if and only if <FONT FACE="Courier New, monospace"><FONT SIZE=2>V’</FONT></FONT>
	is a direct predecessor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	or there exists a version <FONT FACE="Courier New, monospace"><FONT SIZE=2>V*</FONT></FONT>
	such that <FONT FACE="Courier New, monospace"><FONT SIZE=2>V'</FONT></FONT>
	is a direct predecessor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V*</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V*</FONT></FONT>
	is an eventual predecessor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>.</P>
	<P>When the terms
	<I>successor</I> and <I>predecessor</I> are used without
	qualification they mean <I>direct successor</I> and <I>direct
	predecessor</I>, respectively.</P>
<a name="3.13.1.5 Simple and Full Versioning  "></a>	<H4>3.13.1.5 Simple and Full Versioning  </H4>
	<P>Under simple
	versioning, each new version is always added as the unique direct
	successor of the previous version, thus maintaining a linear series
	of versions. 
	</P>
	<P>Under full versioning,
	a new version may be added as the direct successor of a version that
	already has another direct successor, thus producing a <I>branch</I>.
	A new version may also be added as the direct successor of more than
	one existing version, thus producing a <I>merge</I>.</P>
<a name="3.13.1.6 Version Storage"></a>	<H4>3.13.1.6 Version Storage</H4>
	<P>Version histories are
	stored in a repository-wide <I>version storage</I>. Under full
	versioning this store is exposed both through the Java objects of
	the versioning API as well as in a read-only subgraph reflected in
	each workspace. Within that subgraph version histories are
	represented as nodes of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	and versions as nodes of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>.
	Under simple versioning, the version store is exposed through the
	versioning API but is not required to be exposed as a node subgraph.</P>
<a name="3.13.1.7 Check-Out"></a>	<H4>3.13.1.7 Check-Out</H4>
	<P>Once checked-in, a versionable node
	and its versionable subgraph become <I>read-only</I>. To alter a
	checked-in node or its versionable subgraph, the node must first be
	<I>checked-out</I>. It can then be changed and checked-in again,
	creating a new version.</P>
<a name="3.13.1.8 Restore"></a>	<H4>3.13.1.8 Restore</H4>
	<P>A versionable node and its versionable
	subgraph can also be <I>restored</I> to the state recorded in one of
	its versions.</P>
<a name="3.13.2 Versionable Nodes"></a>	<H3>3.13.2 Versionable Nodes</H3>
	<P>Under simple
	versioning, a versionable node must be <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:simpleVersionable</FONT></FONT>.
	Under full versioning, it must be <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>.</P>
<a name="3.13.2.1 mix:simpleVersionable"></a>	<H4>3.13.2.1 mix:simpleVersionable</H4>
	<P>
	<FONT FACE="Courier New, monospace">[mix:simpleVersionable] mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:isCheckedOut (BOOLEAN) = 'true'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">mandatory
	autocreated protected IGNORE</FONT></P>
	<P>The
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:simpleVersionable</FONT></FONT>
	type exposes the node’s <I>checked-out status</I> as a <FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>
	property.</P>
<a name="3.13.2.2 Checked-In or Checked-Out"></a>	<H4>3.13.2.2 Checked-In or Checked-Out</H4>
	<P>A new version of a
	versionable node is created by <I>checking-in</I> a versionable node
	(see §15.2 <I>Check-In: Creating a Version</I>). In this state the
	node and its <I>versionable subgraph</I> are <I>read-only</I> (see
	§15.2.2 <I>Read-Only on Check-In</I>). The node can then be
	<I>checked-out </I>(see 15.3 <I>Check-Out</I>), at which point it
	becomes writable again.</P>
	<P>Under both simple and
	full versioning, this status is accessible through
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionManager.isCheckedOut</FONT></FONT>
	(see §15.3.1.1 <I>Testing for Checked-Out Status</I>) and the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>BOOLEAN</FONT></FONT>
	property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:isCheckedOut</FONT></FONT>.</P>
<a name="3.13.2.3 mix:versionable"></a>	<H4>3.13.2.3 mix:versionable</H4>
	<P>
	 <FONT FACE="Courier New, monospace">[mix:versionable] &gt;
	mix:simpleVersionable, mix:referenceable<BR> mixin</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:versionHistory (REFERENCE) mandatory protected IGNORE</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'nt:versionHistory'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:baseVersion (REFERENCE) mandatory protected IGNORE</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'nt:version'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:predecessors (REFERENCE) mandatory protected multiple</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">IGNORE
	&lt; 'nt:version'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:mergeFailed (REFERENCE) protected multiple ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt;
	'nt:version'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:activity (REFERENCE) protected IGNORE &lt; 'nt:activity'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:configuration (REFERENCE) protected IGNORE<BR> &lt;
	'nt:configuration'</FONT></P>
	<P>The mixin
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>
	is a subtype of <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:simpleVersionable</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:referenceable</FONT></FONT>,
	and adds properties exposing a number of additional
	versioning-related attributes.</P>
<a name="3.13.2.4 Version History Reference"></a>	<H4>3.13.2.4 Version History Reference</H4>
	<P>Apart from nodes
	within the same shared set, which share the same version history,
	each versionable node within a persistent workspace has its own
	version history. 
	</P>
	<P>Under both simple and
	full versioning the version history of a node is accessed through
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionManager.getVersionHistory</FONT></FONT>,
	which returns a <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory</FONT></FONT>
	object (see §15.1.1 <I>VersionHistory Object</I>). Under full
	versioning it is also represented by the <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:versionHistory</FONT></FONT>,
	which points to an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node (see §3.13.5.1 <I>nt:versionHistory</I>).</P>
<a name="3.13.2.5 Base Version Reference"></a>	<H4>3.13.2.5 Base Version Reference</H4>
	<P>Each versionable node
	has a <I>base version</I> within its version history. When a new
	version of a node is created, it is placed in that node’s version
	history as a direct successor of the base version. That version
	itself then becomes the new base version (see §3.13.6.2 <I>Base
	Version</I>).</P>
	<P>Under simple
	versioning, the base version of a versionable node is always the
	<I>most recent version</I> in its version history. 
	</P>
	<P>Under full versioning,
	corresponding versionable nodes in different workspaces, while
	having the same version history, may have different base versions
	<I>within</I> that history. Therefore, the base version of a full
	versionable node may not be the most recent version in that node's
	version history (see §3.13.6.2 <I>Base Version</I>).</P>
	<P>The base version is
	accessed through <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionManager.getBaseVersion</FONT></FONT>
	(see §15.1.2 <I>Getting the Base Version</I>) which returns a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	object (see 15.2.1 <I>Version Object</I>). Under full versioning the
	connection to the base version is also represented by the <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:baseVersion</FONT></FONT>,
	which points to an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node (see §3.13.2.3 <I>mix:versionable</I>).</P>
<a name="3.13.2.6 Predecessors"></a>	<H4>3.13.2.6 Predecessors</H4>
	<P>Under full versioning,
	a versionable node <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	has one or more versions in its version history that will become
	direct predecessors of the new version <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>
	created on the next check-in of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>.
	For convenience these versions can also be referred to as the direct
	predecessors of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	(i.e., not just the direct predecessor of the hypothetical <FONT FACE="Courier New, monospace"><FONT SIZE=2>V)</FONT></FONT>.</P>
	<P>The base version of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	is always <I>one</I> of these direct predecessors, but <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	may have additional direct predecessors as well. If so, on check-in
	of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>,
	all of these become direct predecessors of the newly created version
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT>,
	thus forming a merge within the version graph (see §15.9 <I>Merge</I>).</P>
	<P>A node’s direct
	predecessors are exposed by the multi-value <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:predecessors</FONT></FONT>
	(see §3.13.2.3 <I>mix:versionable</I>) which points to one or more
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	nodes (see §3.13.3.1 <I>nt:version</I>). 
	</P>
	<P>There is no dedicated
	API for accessing the direct predecessors of a <I>versionable</I>
	<I>node</I>; access is provided through the property only (this
	should not be confused with access to the direct predecessors of a
	<I>version</I>, which is exposed through the API, see §3.13.2.6
	<I>Predecessors</I>).</P>
	<P>Under simple
	versioning, the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:predecessors</FONT></FONT>
	attribute is not needed (and hence not present on
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:simpleVersionable</FONT></FONT>)
	since a versionable node will only ever have one direct predecessor,
	which is its base version.</P>
<a name="3.13.2.7 Merge Failed"></a>	<H4>3.13.2.7 Merge Failed</H4>
	<P>Under full versioning,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:mergeFailed
	</FONT></FONT>is a multi-value <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property that is used to mark merge failures (see §15.9 <I>Merge</I>).
	Under simple versioning, merges are not supported. There is no
	dedicated API for accessing merge failures; access is provided only
	through this property.</P>
<a name="3.13.2.8 Activity"></a>	<H4>3.13.2.8 Activity</H4>
	<P>Under full versioning,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:activity</FONT></FONT>
	is a <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property used to support the activities feature (see §15.12
	<I>Activities</I>). Under simple versioning, activities are not
	supported. There is no dedicated API for retrieving the activity
	associated with a given versionable node; access is provided only
	through this property.</P>
<a name="3.13.2.9 Configuration"></a>	<H4>3.13.2.9 Configuration</H4>
	<P>Under full versioning,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:configuration</FONT></FONT>
	is a <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property used to support the configurations and baselines feature
	(see §15.13 <I>Configurations and Baselines</I>). Under simple
	versioning, configurations are not supported. There is no dedicated
	API for retrieving the configuration associated with a given
	versionable node; access is provided only through this property.</P>
<a name="3.13.3 Versions"></a>	<H3>3.13.3 Versions</H3>
	<P>Under simple
	versioning, a version is represented by a <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	object (see §15.2.1 <I>Version Object</I>) and the attributes of
	the version are accessible only through methods of that class. 
	</P>
	<P>Under full versioning
	a version is represented by both a <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	object and a node of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	within the version storage (see §3.13.7 <I>Version Storage</I>).
	The attributes of a version are accessible both through methods of
	the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	class and through the properties of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>.</P>
	<P>Each version has a
	name unique within its version history that is assigned
	automatically on creation of the version. The format of the name is
	implementation-dependant. Under full versioning this is the name of
	the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node representing the version. Under simple versioning this is
	simply the name returned when <FONT FACE="Courier New, monospace"><FONT SIZE=2>Item.getName()</FONT></FONT>
	is called on the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	object.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	is a subclass of <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node</FONT></FONT>.
	However, since under simple versioning a version is not represented
	by a node, most of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node</FONT></FONT>
	methods inherited by <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	are not required to function. The single exception is <FONT FACE="Courier New, monospace"><FONT SIZE=2>Item.getName()</FONT></FONT>
	as mentioned above. Under full versioning the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node</FONT></FONT>
	methods inherited by <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	function as expected on the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node.</P>
	<P>Under full versioning
	the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	nodes representing the versions within a given history are always
	created as direct child nodes of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node representing that history.</P>
<a name="3.13.3.1 nt:version"></a>	<H4>3.13.3.1 nt:version</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:version] &gt;
	mix:referenceable</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:created (DATE) mandatory autocreated protected</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:predecessors (REFERENCE) protected multiple ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'nt:version'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:successors (REFERENCE) protected multiple ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'nt:version'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:activity (REFERENCE) protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'nt:activity'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+
	jcr:frozenNode (nt:frozenNode) protected ABORT</FONT></P>
	<P>
	<BR>
	</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	inherits the <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>
	from <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:referenceable</FONT></FONT>,
	making every <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node referenceable. Additionally, it defines properties that expose
	the following attributes.</P>
<a name="3.13.3.2 Creation Date"></a>	<H4>3.13.3.2 Creation Date</H4>
	<P>Each version records
	its creation date, which is accessible through <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version.getCreated</FONT></FONT>
	and, under full versioning, through the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:created</FONT></FONT>
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>DATE</FONT></FONT>
	property of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>.</P>
<a name="3.13.3.3 Predecessors"></a>	<H4>3.13.3.3 Predecessors</H4>
	<P>Each version has zero or more direct
	predecessor versions within its version history, accessible though
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>Version.getPredecessors</FONT></FONT>.
	Under simple versioning, a version will have either zero direct
	predecessors (if it is the root version of a history) or one direct
	predecessor. Under full versioning, a version may have zero, one, or
	more direct predecessors, which are exposed through the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:predecessors</FONT></FONT>
	multi-value <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>.</P>
<a name="3.13.3.4 Successors"></a>	<H4>3.13.3.4 Successors</H4>
	<P>Each version has zero or more direct
	successor versions within its version history, accessible though
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>Version.getSuccessors</FONT></FONT>.
	Under simple versioning, a version will have either zero or one
	direct successors. Under full versioning, a version may have zero,
	one, or more direct successors, which are exposed through the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:successors</FONT></FONT>
	multi-value <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>.</P>
<a name="3.13.3.5 Frozen Node"></a>	<H4>3.13.3.5 Frozen Node</H4>
	<P>Each version records
	the versionable state of its versionable node at the time of
	check-in in a <I>frozen node</I>, attached to the version and
	accessed though <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version.getFrozenNode</FONT></FONT>.
	Under simple versioning, the frozen node is isolated, having no
	parent in any workspace. Under full versioning, it is a subnode of
	the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node in the version storage subgraph. In both cases the node is of
	type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:frozenNode</FONT></FONT>
	(see §3.13.4.1 <I>nt:frozenNode</I>).</P>
<a name="3.13.3.6 Activity"></a>	<H4>3.13.3.6 Activity</H4>
	<P>Under full versioning a version may be
	bound to an activity. This relationship is recorded by the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:activity</FONT></FONT>
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	pointing to <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:activity</FONT></FONT>
	node that represents the activity under which this version was
	created (see §15.12 <I>Activities</I>). Under simple versioning
	activities are not supported.</P>
<a name="3.13.4 Frozen Nodes"></a>	<H3>3.13.4 Frozen Nodes</H3>
	<P>When a version is
	created, the <I>versionable subgraph</I> of its versionable node is
	copied to a <I>frozen node</I> within the new version. On check-in
	the child nodes and properties that constitute the versionable
	subgraph are copied and placed as child items of the frozen node
	under the same names as they had under the versionable node.</P>
	<P>Which child nodes and
	properties are copied, and in the case of child nodes, the depth of
	the subgraph to be copied, constitutes the versionable state of the
	node and is determined by the on-parent-version settings defined in
	the node type of the versionable node (see §3.7.2.5
	<I>On-Parent-Version</I>).</P>
	<P>Regardless of the node
	type of the original versionable, all frozen nodes are of the type
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:frozenNode</FONT></FONT>.
	Under both simple and full versioning, the frozen node of a version
	is accessible directly from the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	object (see §15.2.1 <I>Version Object</I>). Under full versioning,
	the frozen node is also accessible as the child node <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenNode</FONT></FONT>
	of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node. Under simple versioning the frozen node is a <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node</FONT></FONT>
	object but does not have a parent, and consequently methods called
	on the frozen node that depend upon having a parent will throw an
	exception. Under full versioning the frozen node's parent is the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node to which it belongs.</P>
	<P>A frozen node always
	has the name <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenNode</FONT></FONT>.
	Under full versioning this is the name under which it exists as a
	child of its <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	node. Under simple versioning this is simply the name returned when
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>Item.getName()</FONT></FONT>
	is called on the frozen node.</P>
<a name="3.13.4.1 nt:frozenNode"></a>	<H4>3.13.4.1 nt:frozenNode</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:frozenNode] orderable</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:frozenPrimaryType (NAME) mandatory autocreated<BR> 
	protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:frozenMixinTypes (NAME) protected multiple ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:frozenUuid (STRING) protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- *
	(UNDEFINED) protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- *
	(UNDEFINED) protected multiple ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ *
	(nt:base) protected sns ABORT</FONT></P>
	<P>
	<BR>
	</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:frozenNode</FONT></FONT>
	defines the following properties and child nodes.</P>
<a name="3.13.4.2 Frozen Primary Type"></a>	<H4>3.13.4.2 Frozen Primary Type</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenPrimaryType</FONT></FONT>
	is a <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	property that stores the primary node type of the versionable node.</P>
<a name="3.13.4.3 Frozen Mixin Types"></a>	<H4>3.13.4.3 Frozen Mixin Types</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenMixinTypes</FONT></FONT>
	is a multi-value <FONT FACE="Courier New, monospace"><FONT SIZE=2>NAME</FONT></FONT>
	property that stores the mixin types of the versionable node, if
	any.</P>
<a name="3.13.4.4 Frozen Identifier"></a>	<H4>3.13.4.4 Frozen Identifier</H4>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenUuid</FONT></FONT>
	is a <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	property that stores the referenceable identifier of the versionable
	node. Note that the term “UUID” is used for backwards
	compatibility with JCR 1.0 and does not necessarily the use of the
	UUID syntax, or global uniqueness.</P>
<a name="3.13.4.5 Residual Properties and Child Nodes"></a>	<H4>3.13.4.5 Residual Properties and Child Nodes</H4>
	<P>A set of residual
	definitions are defined for the copies of the properties and child
	nodes that make up the versionable state of the versionable node. In
	repositories that do not support residual item definitions (see
	§3.7.2.1.2 <I>Item Definition Name and Residual Definitions</I>)
	these must be implemented as a special case for the frozen node.</P>
<a name="3.13.4.6 References in a Frozen Node"></a>	<H4>3.13.4.6 References in a Frozen Node</H4>
	<P>A <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	property stored in the frozen node of a version does not enforce
	referential integrity. Under simple versioning this follows from the
	fact that a <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	within a frozen node does not appear within the workspace in any
	case, it only appears when the frozen node is explicitly retrieved
	through the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>
	object (see §15.2.1 <I>Version Object</I>). Under full versioning a
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	within a frozen node will appear in the workspace within the
	read-only version storage (see §3.13.8 <I>Version Storage</I>) so
	the referential integrity requirement must be lifted as a special
	case.</P>
<a name="3.13.5 Version History"></a>	<H3>3.13.5 Version History</H3>
	<P>Under simple
	versioning a version history is represented by a <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory</FONT></FONT>
	object (see §15.1.1 <I>VersionHistory Object</I>). Under full
	versioning a version history is represented by both a <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory</FONT></FONT>
	object and a node of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>.</P>
	<P>A version history is
	created upon creation of a new versionable node. Under full
	versioning this results that an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node being created automatically within the version storage subgraph
	in an implementation determined location and with an
	implementation-determined name.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory</FONT></FONT>
	is a subclass of <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node</FONT></FONT>.
	However, since under simple versioning a version history is not
	represented by a node, the <FONT FACE="Courier New, monospace"><FONT SIZE=2>Node</FONT></FONT>
	methods inherited by <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory</FONT></FONT>
	are not required to function. Under full versioning those methods
	will function as expected on the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node representing the history.</P>
<a name="3.13.5.1 nt:versionHistory"></a>	<H4>3.13.5.1 nt:versionHistory</H4>
	<P>
	<FONT FACE="Courier New, monospace">[nt:versionHistory] &gt;
	mix:referenceable</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:versionableUuid (STRING) mandatory autocreated</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">protected
	ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:copiedFrom (WEAKREFERENCE) protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'nt:version'</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ jcr:rootVersion (nt:version)
	= nt:version mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">autocreated
	protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ jcr:versionLabels
	(nt:versionLabels)</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">=
	nt:versionLabels protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">+ *
	(nt:version) = nt:version protected ABORT</FONT></P>
	<P>This type inherits the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>
	from <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:referenceable</FONT></FONT>,
	making every <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node referenceable. It also defines properties and child nodes
	representing the following attributes.</P>
<a name="3.13.5.2 Root Version"></a>	<H4>3.13.5.2 Root Version</H4>
	<P>Each version history
	has a <I>root version</I>, which is a null version that stores no
	state; it simply serves as the eventual predecessor of all
	subsequent versions.</P>
	<P>The root version is
	accessed through <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory.getRootVersion</FONT></FONT>
	(see 15.1.1.1 <I>Root Version</I>). Under full versioning it is also
	represented as an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	child node of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node, called <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:rootVersion</FONT></FONT>.</P>
<a name="3.13.5.3 Versions"></a>	<H4>3.13.5.3 Versions</H4>
	<P>In addition to the
	root version, a version history also holds all the versions that
	have been created through check-ins of its versionable node (or
	nodes, in the case of corresponding or shared nodes). These versions
	are accessible through <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory.getAllVersions</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory.getAllLinearVersions</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory.getVersion</FONT></FONT>.</P>
	<P>Under full versioning
	these versions are also accessible as <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	child nodes of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node, under their respective implementation-determined names.</P>
<a name="3.13.5.4 Versionable Identifier"></a>	<H4>3.13.5.4 Versionable Identifier</H4>
	<P>Each version history
	also stores the identifier of its versionable node (or nodes in the
	case of corresponding or shared nodes). 
	</P>
	<P>This attribute is
	accessible through <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory.getVersionableIdentifier</FONT></FONT>
	and, under full versioning, through the <FONT FACE="Courier New, monospace"><FONT SIZE=2>STRING</FONT></FONT>
	property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:versionableUuid</FONT></FONT>
	of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>.
	Note that the term “UUID” is used for backward compatibility
	with JCR 1.0 and does not necessarily imply the use of the UUID
	syntax, or global uniqueness.</P>
<a name="3.13.5.5 Version Labels"></a>	<H4>3.13.5.5 Version Labels</H4>
	<P>A version label is a
	JCR name, unique among the labels within a version history, that
	identifies a single version within that history. A version can have
	zero or more labels. 
	</P>
	<P>Labels are can be
	assigned, removed and retrieved through the API. Versions can also
	be retrieved by label (see §15.4 <I>Version Labels</I>). 
	</P>
	<P>Under full versioning
	labels are also exposed through an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionLabels</FONT></FONT>
	child node of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	called <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:versionLabels</FONT></FONT>.
	This node holds a set of reference properties that record all labels
	that have been assigned to the versions within this version history.
	Each label is represented by a single reference property which uses
	the label itself as its name and points to that <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	child node to which the label applies (see §15.4.1.2 <I>Adding a
	Version Label</I>). The <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionLabels</FONT></FONT>
	node type has the following definition:</P>
	<P>
	<FONT FACE="Courier New, monospace">[nt:versionLabels]</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">- *
	(REFERENCE) protected ABORT &lt; 'nt:version'</FONT></P>
<a name="3.13.5.6 Copied From"></a>	<H4>3.13.5.6 Copied From</H4>
	<P>When a full
	versionable node is copied to a new location and the repository
	preserves the <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>
	mixin (see §10.7 <I>Copying Nodes</I>), the copy gets a new version
	history and that history records the base version of the node from
	which the copy was created. This information, known as the node's
	<I>lineage</I>, is recorded in the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:copiedFrom</FONT></FONT>
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>WEAKREFERENCE</FONT></FONT>
	property of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	(see §15.1.4<I> Copying Versionable Nodes and Version Lineage</I>).</P>
<a name="3.13.6 Version Graph"></a>	<H3>3.13.6 Version Graph</H3>
	<P>The versions within a
	version history form a <I>version graph</I> where the versions are
	the vertices and each <I>direct successor/direct predecessor</I>
	pair are joined by a directed edge.</P>
	<P>Under simple
	versioning, branching and merging are not supported, so the version
	graph is always a linear series of successive versions.</P>
	<P>Under full versioning
	branching and merging are supported, so a version may have multiple
	direct predecessors, multiple direct successors, or both. Also,
	under full versioning, the version graph is exposed in content with
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:version</FONT></FONT>
	nodes as the vertices and the edges defined by the <FONT FACE="Courier New, monospace"><FONT SIZE=2>REFERENCE</FONT></FONT>
	properties <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:successors</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:predecessors</FONT></FONT>.
		</P>
<a name="3.13.6.1 Root Version"></a>	<H4>3.13.6.1 Root Version</H4>
	<P>The version graph
	always contains at least the root version. This is a null version
	that stores no state and simply serves as the eventual predecessor
	of all subsequent versions. Its frozen node does not contain any
	state information about the versionable other than the node type and
	identifier information found in the properties
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenPrimaryType</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenMixinTypes</FONT></FONT>,
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenUuid</FONT></FONT>.</P>
<a name="3.13.6.2 Base Version"></a>	<H4>3.13.6.2 Base Version</H4>
	<P>For a given
	versionable node, one version within its version history is its <I>base
	version. </I>Conceptually, the base version of a versionable node is
	that version relative to which the current state of the checked-out
	versionable node constitutes a versionable change. 
	</P>
	<P>On check-in, the newly
	created version becomes a direct successor of the current base
	version and then itself becomes the <I>new</I> base version. 
	</P>
	<P>Under full versioning,
	corresponding versionable nodes in different workspaces, while
	sharing the same version history, may have distinct base versions
	within that history. This means that when one versionable node is
	checked-in, its version will become direct successor of a particular
	existing version but when one of its correspondees is checked in,
	that new version may become direct successor to a <I>different</I>
	existing version within the same version history.</P>
	<P>Under simple
	versioning the linearity of the version graph guarantees that the
	current base version is always the most recent version. On check-in
	it becomes the unique direct predecessor of the newly created
	version, which then becomes the new base version.</P>
	<P>Under full versioning,
	the presence of branches and merges means that the current base
	version for a given versionable node is not guaranteed to be the
	most recent version.</P>
<a name="3.13.7 Versioning and Multiple Workspaces"></a>	<H3>3.13.7 Versioning and Multiple Workspaces</H3>
	<P>As
	mentioned (see 3.13.2.5 <I>Base
	Version Reference</I> and 3.13.6.2 <I>Base
	Version</I>), under full versioning,
	corresponding versionable nodes in different workspaces all have a
	single common version history, though within that history each may
	have a distinct base version at any given time.</P>
	<P>The
	intended semantics of the correspondence relationship is that
	corresponding nodes represent copies of a common content structure
	which while identical at one level (i.e., as determined by
	<I>identifier</I>),
	can be maintained in distinct states (see §3.10.1.2 <I>Correspondence
	Semantics</I>).</P>
	<P>The
	relation of corresponding versionable nodes to the same version
	history reflects these semantics in that when different copies of
	the same content entity are changed and checked-in from different
	workspaces the resulting versions are all recorded within the same
	version graph and, depending on their individual base versions,
	extending that graph at different points.</P>
<a name="3.13.8 Version Storage"></a>	<H3>3.13.8 Version Storage</H3>
	<P>Version histories are
	stored in a single, repository-wide version storage mutable and
	readable through the versioning API.</P>
	<P>Under full versioning
	the version storage data must, additionally, be reflected in each
	workspace as a protected (see §3.7.2.2 <I>Protected</I>) subgraph
	of nodes of type <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	located below <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:versionStorage</FONT></FONT>
	(see §3.11 <I>System Node</I>). Because it is protected, the
	subgraph cannot be altered through the core write methods of JCR
	(see §10.2 <I>Core Write Methods</I>) but only through though the
	methods of the versioning API.</P>
	<P>Though the general repository-wide
	version history is reflected in each workspace, the access that a
	particular <FONT FACE="Courier New, monospace"><FONT SIZE=2>Session</FONT></FONT>
	gets to that subgraph is governed by that <FONT FACE="Courier New, monospace"><FONT SIZE=2>Session</FONT></FONT>'s
	authorization, just as for any other part of the workspace.</P>
	<P>The <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	nodes below <FONT FACE="Courier New, monospace"><FONT SIZE=2>/jcr:system/jcr:versionStorage</FONT></FONT>,
	may all be direct children of the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:versionStorage</FONT></FONT>
	node or may be organized in a deeper substructure of intervening
	subnodes that sort the version histories by some
	implementation-specific criteria.</P>
	<P>The node type of the node
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:versionStorage</FONT></FONT>
	and any structural nodes used within the subgraph are left up to the
	implementation.</P>
<a name="3.13.9 Versionable State"></a>	<H3>3.13.9 Versionable State</H3>
	<P>The <I>versionable
	state</I> of a versionable node <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	is typically a <I>subset</I> of its subgraph. The extent of this
	subset is defined in the node type of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT><I>
	</I>through the <I>on-parent-version attribute</I> (<I>OPV</I>) of
	each of its child items (see §3.7.2.5 <I>On-Parent-Version</I>).</P>
	<P>A frozen node <FONT FACE="Courier New, monospace"><FONT SIZE=2>F</FONT></FONT>
	storing the versionable state of the node <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	is constructed as follows:</P>
	<OL>
		<LI><P>The primary type
		of <I>N</I> is copied from the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:primaryType</FONT></FONT>
		property of <I>N</I> to the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenPrimaryType</FONT></FONT>
		property of <I>F</I>.</P>
		<LI><P>The mixin types
		of <I>N </I>(if any) are copied from the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:mixinTypes</FONT></FONT>
		property of <I>N</I> to the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenMixinTypes</FONT></FONT>
		property of <I>F</I>.</P>
		<LI><P>The referenceable
		identifier of <I>N</I> is copied from the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>
		property of <I>N </I>to the <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:frozenUuid</FONT></FONT>
		property of <I>F</I>.</P>
		<LI><P>For each property
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
		of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
		other than <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:primaryType</FONT></FONT>,
		<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:mixinTypes</FONT></FONT>
		and <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:uuid</FONT></FONT>
		where</P>
		<UL>
			<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
			has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>COPY</FONT></FONT>
			<I>or</I></P>
			<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
			has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>VERSION</FONT></FONT>,</P>
		</UL>
	</OL>
	<P>a
	copy of <FONT FACE="Courier New, monospace"><FONT SIZE=2>P</FONT></FONT>
	is added to the frozen node, preserving its name and value (or
	values).</P>
	<OL START=5>
		<LI><P>For each child
		node <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
		of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
		where</P>
	</OL>
	<UL>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
		has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>COPY</FONT></FONT>,</P>
	</UL>
	<P>a
	copy of the entire subgraph rooted at <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	(regardless of the OPV values of the sub-items) is added to the
	frozen node, preserving the name of <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	and the names and values of all its sub-items.</P>
	<P>In
	a repository that supports orderable child nodes, the relative
	ordering of the set of child nodes <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	that are copied to the frozen node is preserved. As is the ordering
	within the subgraph of each of these child nodes <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>.</P>
	<OL START=6>
		<LI><P>For each child
		node <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
		of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
		where:</P>
	</OL>
	<UL>
		<LI><P><FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
		has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>VERSION</FONT></FONT>
				</P>
	</UL>
	<P>Under
	simple versioning, the same behavior as <FONT FACE="Courier New, monospace"><FONT SIZE=2>COPY</FONT></FONT>.</P>
	<P>Under
	full versioning, if <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	is not <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>,
	the same behavior as <FONT FACE="Courier New, monospace"><FONT SIZE=2>COPY</FONT></FONT>.
		</P>
	<P>Under
	full versioning, if <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	is <FONT FACE="Courier New, monospace"><FONT SIZE=2>mix:versionable</FONT></FONT>,
	then a special <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionedChild</FONT></FONT>
	node with a reference to the version history of <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	is substituted in place of <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	as a child of the frozen node. The <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionedChild</FONT></FONT>
	node has the same name as <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	and, in a repository that supports orderable child nodes, the
	relative ordering of any such child node <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	is preserved. The definition of <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionedChild</FONT></FONT>
	is:</P>
	<P>
	<FONT FACE="Courier New, monospace">[nt:versionedChild]</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">-
	jcr:childVersionHistory (REFERENCE) mandatory</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">autocreated
	protected ABORT</FONT></P>
	<P>
	 <FONT FACE="Courier New, monospace">&lt; 'nt:versionHistory'</FONT></P>
	<P>The
	property <FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:childVersionedHistory</FONT></FONT>
	points to the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	of <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>.</P>
	<P><BR><BR>
	</P>
<a name="3.13.10 FullVersioning Diagram"></a>	<H3>3.13.10 FullVersioning Diagram</H3>
	<P>
		<IMG SRC="jcr-spec_html_5c14fe0.png" NAME="graphics4" ALIGN=LEFT HSPACE=14 WIDTH=628 HEIGHT=753 BORDER=0><BR CLEAR=LEFT><BR><BR>
	</P>
	<P>The above diagram
	depicts the main elements of the full versioning model. A workspace
	contains a versionable node <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	with child nodes <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	and property <FONT FACE="Courier New, monospace"><FONT SIZE=2>B</FONT></FONT>.
	The on-parent-version settings of each child are shown. <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
	has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>COPY</FONT></FONT>
	while <FONT FACE="Courier New, monospace"><FONT SIZE=2>B</FONT></FONT>
	has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>IGNORE</FONT></FONT>.
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	is itself versionable and has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>VERSION</FONT></FONT>.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>VH</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>N</SUB></FONT></FONT>
	is the <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node holding the version history of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	which, in the situation depicted, consists of the versions <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>0</SUB></FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>1</SUB></FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>1.1</SUB></FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>3</SUB></FONT></FONT>,
	where <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>0</SUB></FONT></FONT>
	is the root version, <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>1</SUB></FONT></FONT>
	is the successor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>0</SUB></FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>1.1</SUB></FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>
	are both successors of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>1</SUB></FONT></FONT>
	(constituting a <I>branch</I>) and <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>3</SUB></FONT></FONT>
	is the successor of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>.</P>
	<P><FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><IMG SRC="jcr-spec_html_1e68867c.png" NAME="graphics5" ALIGN=LEFT HSPACE=14 WIDTH=628 HEIGHT=495 BORDER=0><BR CLEAR=LEFT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>
	is the current base version of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	and is shown in detail. As defined by the OPV values of the children
	of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>
	contains a partial copy of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>'s
	subtree in its frozen node. This partial copy consists of the
	subtree rooted at <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
	(since <FONT FACE="Courier New, monospace"><FONT SIZE=2>A</FONT></FONT>
	in <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>COPY</FONT></FONT>)
	but does not include the property <FONT FACE="Courier New, monospace"><FONT SIZE=2>B</FONT></FONT>
	(since <FONT FACE="Courier New, monospace"><FONT SIZE=2>B</FONT></FONT>
	in <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>IGNORE</FONT></FONT>).
	Since <FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	is itself versionable it has its own, separate, version history at
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>VH</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>C</SUB></FONT></FONT>
	and since it has an OPV of <FONT FACE="Courier New, monospace"><FONT SIZE=2>VERSION</FONT></FONT>,
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>C</FONT></FONT>
	is represented in the frozen subtree of <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>
	by an <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionedChild</FONT></FONT>
	node that points to <FONT FACE="Courier New, monospace"><FONT SIZE=2>VH</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>C</SUB></FONT></FONT>.</P>
<a name="3.13.11 Simple Versioning Diagram"></a>	<H3>3.13.11 Simple Versioning Diagram</H3>
	<P><BR><BR>
	</P>
	<P>The above diagram
	depicts the main elements of the simple versioning model. Unlike
	under full versioning, the connections from the versionable node to
	the version history and the base version are not mediated by
	reference properties but through API methods only. As well, the
	version history and its contained versions are represented only by
	Java object instances (of classes <FONT FACE="Courier New, monospace"><FONT SIZE=2>VersionHistory</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>Version</FONT></FONT>,
	respectively) not by nodes. Finally, as the diagram indicates, under
	simple versioning the version history is always linear and the
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>VERSION</FONT></FONT>
	on-parent-version setting and associated structures are not
	supported.</P>
	<P>
	<IMG SRC="jcr-spec_html_m204c0a49.png" NAME="graphics6" ALIGN=LEFT HSPACE=14 WIDTH=628 HEIGHT=698 BORDER=0><BR CLEAR=LEFT><BR><BR>
	</P>
<a name="3.13.12 Versioning and Corresponding Nodes Diagram"></a>	<H3>3.13.12 Versioning and Corresponding Nodes Diagram</H3>
	<P>The above diagram
	depicts two workspaces, <FONT FACE="Courier New, monospace"><FONT SIZE=2>W</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>W'</FONT></FONT>
	containing corresponding nodes <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	and <FONT FACE="Courier New, monospace"><FONT SIZE=2>N'</FONT></FONT>,
	both versionable. Because the two versionable nodes correspond, they
	share the same version history, as shown by their respective
	<FONT FACE="Courier New, monospace"><FONT SIZE=2>jcr:versionHistory</FONT></FONT>
	references both pointing to the same <FONT FACE="Courier New, monospace"><FONT SIZE=2>nt:versionHistory</FONT></FONT>
	node. Despite sharing the same history, at any given time,
	corresponding nodes may have distinct base versions within that
	history. In this diagram the base version of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N</FONT></FONT>
	is <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>1.1</SUB></FONT></FONT>
	while the base version of <FONT FACE="Courier New, monospace"><FONT SIZE=2>N'</FONT></FONT>
	is <FONT FACE="Courier New, monospace"><FONT SIZE=2>V</FONT></FONT><FONT FACE="Courier New, monospace"><FONT SIZE=2><SUB>2</SUB></FONT></FONT>.</P>
<script type="text/javascript" src="footer.js"></script></body></html>