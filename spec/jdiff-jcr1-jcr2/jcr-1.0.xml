<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Sun Dec 13 00:56:04 CET 2009 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="jcr-1.0"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath C:\DevTools\jdiff-1.1.1\jdiff.jar;C:\DevTools\jdiff-1.1.1\xerces.jar -d C:\DevTools\jdiff-1.1.1\jcr-1.0-2.0-report -classpath C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-launcher.jar;C:\DevTools\jdiff-1.1.1\antjdiff.jar;C:\DevTools\jdiff-1.1.1\jdiff.jar;C:\DevTools\jdiff-1.1.1\xerces.jar;C:\DevTools\jdiff-1.1.1;C:\DevTools\Java\jre6\lib\ext\QTJava.zip;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-antlr.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-apache-bsf.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-apache-resolver.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-commons-logging.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-commons-net.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-icontract.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jai.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-bcel.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-log4j.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-oro.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-regexp.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-javamail.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jdepend.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jmf.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jsch.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-junit.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-netrexx.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-nodeps.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-starteam.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-stylebook.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-swing.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-trax.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-vaj.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-weblogic.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-xalan1.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-xalan2.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-xslp.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\xercesImpl.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\xml-apis.jar;C:\DevTools\Java\jdk1.6.0_10\lib\tools.jar -sourcepath C:\Projects\Grundfos\apps\cq-521\crx-quickstart\docs\crx-docs\docs\development\jsr170-1.0\src -apiname jcr-1.0 -baseURI http://www.w3.org -apidir C:\DevTools\jdiff-1.1.1\jcr-1.0-2.0-report -source 1.5 -->
<package name="javax.jcr">
  <!-- start class javax.jcr.AccessDeniedException -->
  <class name="AccessDeniedException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessDeniedException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="AccessDeniedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="AccessDeniedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="AccessDeniedException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by access-related methods.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.AccessDeniedException -->
  <!-- start interface javax.jcr.Credentials -->
  <interface name="Credentials"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <doc>
    <![CDATA[Interface for all credentials that may be passed to the
 {@link Repository#login(Credentials credentials, String workspaceName)} method.
 Serves as a marker interface that all repositories must implement when
 providing a credentials class. See {@link SimpleCredentials} for one example
 of such a class.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Credentials -->
  <!-- start interface javax.jcr.ImportUUIDBehavior -->
  <interface name="ImportUUIDBehavior"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="IMPORT_UUID_CREATE_NEW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IMPORT_UUID_COLLISION_REMOVE_EXISTING" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IMPORT_UUID_COLLISION_REPLACE_EXISTING" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IMPORT_UUID_COLLISION_THROW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The possible actions specified by the <code>uuidBehavior</code>
 parameter in {@link Workspace#importXML}, {@link Session#importXML},
 {@link Workspace#getImportContentHandler} and {@link Session#getImportContentHandler}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.ImportUUIDBehavior -->
  <!-- start class javax.jcr.InvalidItemStateException -->
  <class name="InvalidItemStateException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidItemStateException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidItemStateException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidItemStateException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidItemStateException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by the write methods of <code>Node</code> and <code>Property</code>
 and by save and refresh if an attempted change would conflict with a
 change to the persistent workspace made through another
 <code>Session</code>. Also thrown by methods of <code>Node</code> and <code>Property</code> if that
 object represents an item that has been removed from the workspace.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.InvalidItemStateException -->
  <!-- start class javax.jcr.InvalidSerializedDataException -->
  <class name="InvalidSerializedDataException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidSerializedDataException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidSerializedDataException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidSerializedDataException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidSerializedDataException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by the deserialization methods of <code>Session</code>
 if the serialized data being input has an invalid format.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.InvalidSerializedDataException -->
  <!-- start interface javax.jcr.Item -->
  <interface name="Item"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the absolute path to this item.
 If the path includes items that are same-name sibling nodes properties
 then those elements in the path will include the appropriate
 "square bracket" index notation (for example, <code>/a/b[3]/c</code>).

 @return the path of this <code>Item</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the name of this <code>Item</code>. The name of an item is the
 last element in its path, minus any square-bracket index that may exist.
 If this <code>Item</code> is the root node of the workspace (i.e., if
 <code>this.getDepth() == 0</code>), an empty string will be returned.
 <p>

 @return the (or a) name of this <code>Item</code> or an empty string
 if this <code>Item</code> is the root node.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getAncestor" return="javax.jcr.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="depth" type="int"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the ancestor of the specified depth.
 An ancestor of depth <i>x</i> is the <code>Item</code> that is <i>x</i>
 levels down along the path from the root node to <i>this</i>
 <code>Item</code>.
 <ul>
 <li><i>depth</i> = 0 returns the root node.
 <li><i>depth</i> = 1 returns the child of the root node along the path
 to <i>this</i> <code>Item</code>.
 <li><i>depth</i> = 2 returns the grandchild of the root node along the
 path to <i>this</i> <code>Item</code>.
 <li>And so on to <i>depth</i> = <i>n</i>, where <i>n</i> is the depth
 of <i>this</i> <code>Item</code>, which returns <i>this</i>
 <code>Item</code> itself.
 </ul>
 If <i>depth</i> &gt; <i>n</i> is specified then a
 <code>ItemNotFoundException</code> is thrown.
 <p>

 @param depth An integer, 0 &lt;= <i>depth</i> &lt;= <i>n</i> where <i>n</i> is the depth
 of <i>this</i> <code>Item</code>.

 @return The ancestor of this
 <code>Item</code> at the specified <code>depth</code>.

 @throws ItemNotFoundException if <i>depth</i> &lt; 0 or
 <i>depth</i> &gt; <i>n</i> where <i>n</i> is the is the depth of
 this item.

 @throws AccessDeniedException if the current session does not have
 sufficient access rights to retrieve the specified node.

 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getParent" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the parent of this <code>Item</code>.

 @return The parent of this <code>Item</code>.

 @throws ItemNotFoundException if there is no parent.  This only happens
 if this item is the root node of a workspace.

 @throws AccessDeniedException if the current session does not have
 sufficient access rights to retrieve the parent of this item.

 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getDepth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the depth of this <code>Item</code> in the workspace tree.
 Returns the depth below the root node of <i>this</i> <code>Item</code>
 (counting <i>this</i> <code>Item</code> itself).
 <ul>
 <li>The root node returns 0.
 <li>A property or child node of the root node returns 1.
 <li>A property or child node of a child node of the root returns 2.
 <li>And so on to <i>this</i> <code>Item</code>.
 </ul>

 @return The depth of this <code>Item</code> in the workspace hierarchy.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getSession" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>Session</code> through which this <code>Item</code>
 was acquired.
 Every <code>Item</code> can ultimately be traced back through a series
 of method calls to the call <code>{@link Session#getRootNode}</code>,
 <code>{@link Session#getItem}</code> or
 <code>{@link Session#getNodeByUUID}</code>. This method returns that
 <code>Session</code> object.

 @return the <code>Session</code> through which this <code>Item</code> was
 acquired.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="isNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this <code>Item</code> is a <code>Node</code> or a
 <code>Property</code>.
 Returns <code>true</code> if this <code>Item</code> is a <code>Node</code>;
 Returns <code>false</code> if this <code>Item</code> is a <code>Property</code>.

 @return <code>true</code> if this <code>Item</code> is a
 <code>Node</code>, <code>false</code> if it is a <code>Property</code>.]]>
      </doc>
    </method>
    <method name="isNew" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is a new item, meaning that it exists only in transient
 storage on the <code>Session</code> and has not yet been saved. Within a transaction,
 <code>isNew</code> on an <code>Item</code> may return <code>false</code> (because the item
 has been saved) even if that <code>Item</code> is not in persistent storage (because the
 transaction has not yet been committed).
 <p>
 Note that if an item returns <code>true</code> on <code>isNew</code>,
 then by definition is parent will return <code>true</code> on <code>isModified</code>.
 <p>
 Note that in level 1 (that is, read-only) implementations,
 this method will always return <code>false</code>.

 @return <code>true</code> if this item is new; <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="isModified" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Item</code> has been saved but has subsequently
 been modified through the current session and therefore the state of this item as recorded
 in the session differs from the state of this item as saved. Within a transaction,
 <code>isModified</code> on an <code>Item</code> may return <code>false</code> (because the
 <code>Item</code> has been saved since the modification) even if the modification in question
 is not in persistent storage (because the transaction has not yet been committed).
 <p>
 Note that in level 1 (that is, read-only) implementations,
 this method will always return <code>false</code>.

 @return <code>true</code> if this item is modified; <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="isSame" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherItem" type="javax.jcr.Item"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Item</code> object
 (the Java object instance) represents the same actual repository item as the
 object <code>otherItem</code>.
 <p>
 This method does not compare the <i>states</i> of the two items. For example,
 if two <code>Item</code> objects representing the same actual repository item
 have been retrieved through two different sessions and one has been modified,
 then this method will still return <code>true</code> for these two objects.
 Note that if two <code>Item</code> objects representing the same repository item
 are retrieved through the <i>same</i> session they will always reflect the
 same state (see section 6.3.1 <i>Reflecting Item State</i> in the specification
 document) so comparing state is not an issue.

 @param otherItem the <code>Item</code> object to be tested for identity with this <code>Item</code>.

 @return <code>true</code> if this <code>Item</code> object and <code>otherItem</code> represent the same actual repository
 item; <code>false</code> otherwise.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="javax.jcr.ItemVisitor"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Accepts an <code>ItemVistor</code>.
 Calls the appropriate <code>ItemVistor</code>
 <code>visit</code> method of the according to whether <i>this</i>
 <code>Item</code> is a <code>Node</code> or a <code>Property</code>.

 @param visitor The ItemVisitor to be accepted.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="ReferentialIntegrityException" type="javax.jcr.ReferentialIntegrityException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Validates all pending changes currently recorded in this <code>Session</code> that apply to this <code>Item</code>
 or any of its descendants (that is, the subtree rooted at this Item). If validation of <i>all</i>
 pending changes succeeds, then this change information is cleared from the <code>Session</code>.
 If the <code>save</code> occurs outside a transaction, the changes are persisted and thus
 made visible to other <code>Sessions</code>. If the <code>save</code> occurs within a transaction,
 the changes are not persisted until the transaction is committed.
 <p>
 If validation fails, then no pending changes are saved and they remain recorded on the <code>Session</code>.
 There is no best-effort or partial save.
 <p>
 When an item is saved the item in persistent storage to which pending changes are written is
 determined as follows:
 <ul>
   <li>
     If the transient item has a UUID, then the changes are written to the persistent item with the same UUID.
   </li>
   <li>
     If the transient item does not have a UUID then its nearest ancestor with a UUID, or the root node
     (whichever occurs first) is found, and the relative path from the node in persistent node with that UUID is
     used to determine the item in persistent storage to which the changes are to be written.
   </li>
 </ul>
 As a result of these rules, a <code>save</code> of an item that has a UUID will succeed even if that item has,
 in the meantime, been moved in persistent storage to a new location (that is, its path has changed). However, a
 <code>save</code> of a non-UUID item will fail (throwing an <code>InvalidItemStateException</code>) if it has,
 in the meantime, been moved in persistent storage to a new location. A <code>save</code> of a non-UUID item will
 also fail if it has, in addition to being moved, been replaced in its original position by a UUID-bearing item.
 <p>
 Note that <code>save</code> uses the same rules to match items between transient storage and persistent storage
 as {@link Node#update} does to match nodes between two workspaces.
 <p>
 An <code>AccessDeniedException</code> will be thrown if any of the changes
 to be persisted would violate the access privileges of this
 <code>Session</code>.
 <p>
 If any of the changes to be persisted would cause the removal of a node
 that is currently the target of a <code>REFERENCE</code> property then a
 <code>ReferentialIntegrityException</code> is thrown, provided that this <code>Session</code> has
 read access to that <code>REFERENCE</code> property. If, on the other hand, this
 <code>Session</code> does not have read access to the <code>REFERENCE</code> property in question,
 then an <code>AccessDeniedException</code> is thrown instead.
 <p>
 An <code>ItemExistsException</code> will be thrown if any of the changes
 to be persisted would be prevented by the presence of an already existing
 item in the workspace.
 <p>
 A <code>ConstraintViolationException</code> will be thrown if any of the
 changes to be persisted would violate a node type restriction.
 Additionally, a repository may use this exception to enforce
 implementation- or configuration-dependant restrictions.
 <p>
 An <code>InvalidItemStateException</code> is thrown if any of the
 changes to be persisted conflicts with a change already persisted
 through another session and the implementation is such that this
 conflict can only be detected at save-time and therefore was not
 detected earlier, at change-time.
 <p>
 A <code>VersionException</code> is thrown if the <code>save</code> would make a result in
 a change to persistent storage that would violate the read-only status of a
 checked-in node.
 <p>
 A <code>LockException</code> is thrown if the <code>save</code> would result in a
 change to persistent storage that would violate a lock.
 <p>
 A <code>NoSuchNodeTypeException</code> is thrown if the <code>save</code> would result in the
 addition of a node with an unrecognized node type.
 <p>
 A <code>RepositoryException</code> will be thrown if another error
 occurs.

 @throws AccessDeniedException if any of the changes to be persisted would violate
 the access privileges of the this <code>Session</code>. Also thrown if any of the
 changes to be persisted would cause the removal of a node that is currently
 referenced by a <code>REFERENCE</code> property that this Session
 <i>does not</i> have read access to.
 @throws ItemExistsException if any of the changes
 to be persisted would be prevented by the presence of an already existing
 item in the workspace.
 @throws ConstraintViolationException if any of the changes to be persisted would
 violate a node type or restriction. Additionally, a repository may use this
 exception to enforce implementation- or configuration-dependent restrictions.
 @throws InvalidItemStateException if any of the
 changes to be persisted conflicts with a change already persisted
 through another session and the implementation is such that this
 conflict can only be detected at save-time and therefore was not
 detected earlier, at change-time.
 @throws ReferentialIntegrityException if any of the
 changes to be persisted would cause the removal of a node that is currently
 referenced by a <code>REFERENCE</code> property that this <code>Session</code>
 has read access to.
 @throws VersionException if the <code>save</code> would make a result in
 a change to persistent storage that would violate the read-only status of a
 checked-in node.
 @throws LockException if the <code>save</code> would result in a
 change to persistent storage that would violate a lock.
 @throws  NoSuchNodeTypeException if the <code>save</code> would result in the
 addition of a node with an unrecognized node type.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keepChanges" type="boolean"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If <code>keepChanges</code> is <code>false</code>, this method discards all pending changes
 currently recorded in this <code>Session</code> that apply to this Item or any of its descendants
 (that is, the subtree rooted at this Item)and returns all items to reflect the current
 saved state. Outside a transaction this state is simple the current state of persistent storage.
 Within a transaction, this state will reflect persistent storage as modified by changes that have
 been saved but not yet committed.
 <p>
 If <code>keepChanges</code> is true then pending change are not discarded but items that do not
 have changes pending have their state refreshed to reflect the current saved state, thus revealing
 changes made by other sessions.
 <p>
 An <code>InvalidItemStateException</code> is thrown if this <code>Item</code> object represents a
 workspace item that has been removed (either by this session or another).

 @throws InvalidItemStateException if this
 <code>Item</code> object represents a workspace item that has been
 removed (either by this session or another).

 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes <code>this</code> item (and its subtree).
 <p/>
 To persist a removal, a <code>save</code> must be
 performed that includes the (former) parent of the
 removed item within its scope.
 <p/>
 A <code>ReferentialIntegrityException</code> will be thrown on <code>save</code>
 if this item or an item in its subtree is currently the target of a <code>REFERENCE</code>
 property located in this workspace but outside this item's subtree and the current <code>Session</code>
 has read access to that <code>REFERENCE</code> property.
 <p/>
 An <code>AccessDeniedException</code> will be thrown on <code>save</code>
 if this item or an item in its subtree is currently the target of a <code>REFERENCE</code>
 property located in this workspace but outside this item's subtree and the current <code>Session</code>
 <i>does not</i> have read access to that <code>REFERENCE</code> property.
 <p/>
 A <code>ConstraintViolationException</code> will be thrown either immediately
 or on <code>save</code>, if removing this item would violate a node type or implementation-specific
 constraint. Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately
 or on <code>save</code>, if the parent node of this item is versionable and checked-in
 or is non-versionable but its nearest versionable ancestor is checked-in. Implementations
 may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the removal of this item. Implementations may differ on when this validation is performed.

 @throws VersionException if the parent node of this item is versionable and checked-in
 or is non-versionable but its nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the removal of this item and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if removing the specified item would violate a node type or
 implementation-specific constraint and this implementation performs this validation immediately
 instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>Item</code> is the base interface of <code>{@link Node}</code>
 and <code>{@link Property}</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Item -->
  <!-- start class javax.jcr.ItemExistsException -->
  <class name="ItemExistsException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ItemExistsException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ItemExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ItemExistsException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ItemExistsException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An exception thrown when an attempt is made to place an item in a position
 where another item already exists.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ItemExistsException -->
  <!-- start class javax.jcr.ItemNotFoundException -->
  <class name="ItemNotFoundException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ItemNotFoundException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ItemNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ItemNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ItemNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by methods of <code>{@link Item}</code>, <code>{@link Node}</code>
 and <code>{@link Workspace}</code> when an item is not found.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ItemNotFoundException -->
  <!-- start interface javax.jcr.ItemVisitor -->
  <interface name="ItemVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method is called when the <code>ItemVisitor</code> is
 passed to the <code>accept</code> method of a <code>Property</code>.
 If this method throws an exception the visiting process is aborted.

 @param property The <code>Property</code> that is accepting this visitor.

 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method is called when the <code>ItemVisitor</code> is
 passed to the <code>accept</code> method of a <code>Node</code>.
 If this method throws an exception the visiting process is aborted.

 @param node The <code>Node</code that is accepting this visitor.

 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface defines two signatures of the
 <code>visit</code> method; one taking a <code>Node</code>, the other a
 <code>Property</code>. When an object implementing this interface is passed
 to <code>{@link Item#accept(ItemVisitor visitor)}</code> the appropriate
 <code>visit</code> method is automatically called, depending on whether the
 <code>Item</code> in question is a <code>Node</code> or a
 <code>Property</code>. Different implementations of this interface can be
 written for different purposes. It is, for example, possible for the
 <code>{@link #visit(Node node)}</code> method to call <code>accept</code> on the
 children of the passed node and thus recurse through the tree performing some
 operation on each <code>Item</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.ItemVisitor -->
  <!-- start class javax.jcr.LoginException -->
  <class name="LoginException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LoginException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="LoginException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="LoginException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="LoginException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by <code>{@link Repository#login(Credentials, String)}</code>
 and <code>{@link Session#impersonate(Credentials)}</code> if the specified
 credentials are invalid.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.LoginException -->
  <!-- start class javax.jcr.MergeException -->
  <class name="MergeException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MergeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="MergeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="MergeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="MergeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by {@link Node#merge(String srcWorkspace, boolean isDeep)}.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.MergeException -->
  <!-- start class javax.jcr.NamespaceException -->
  <class name="NamespaceException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NamespaceException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="NamespaceException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="NamespaceException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="NamespaceException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by <code>{@link Session#setNamespacePrefix(String prefix, String uri)}</code>
 if the specified <code>uri</code> is not registered in the {@link NamespaceRegistry}]]>
    </doc>
  </class>
  <!-- end class javax.jcr.NamespaceException -->
  <!-- start interface javax.jcr.NamespaceRegistry -->
  <interface name="NamespaceRegistry"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="registerNamespace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets a one-to-one mapping between prefix and URI in the global namespace registry of this repository.
 Assigning a new prefix to a URI that already exists in the namespace registry erases the old prefix.
 In general this can almost always be done, though an implementation is free to prevent particular
 remappings by throwing a <code>NamespaceException</code>.
 <p>
 On the other hand, taking a prefix that is already assigned to a URI and re-assigning it to a new URI
 in effect unregisters that URI. Therefore, the same restrictions apply to this operation as to
 <code>NamespaceRegistry.unregisterNamespace</code>:
 <ul>
 <li>
 Attempting to re-assign a built-in prefix (<code>jcr</code>, <code>nt</code>, <code>mix</code>,
 <code>sv</code>, <code>xml</code>, or the empty prefix) to a new URI will throw a
 <code>NamespaceException</code>.
 </li>
 <li>
 Attempting to re-assign a prefix that is currently assigned to a URI that is present in content
 (either within an item name or within the value of a <code>NAME</code> or <code>PATH</code> property)
 will throw a <code>NamespaceException</code>. This includes prefixes in use within in-content node type
 definitions.
 </li>
 <li>
 Attempting to register a namespace with a prefix that begins with the characters "<code>xml</code>"
 (in any combination of case) will throw a <code>NamespaceException</code>.
 </li>
 <li>
 An implementation may prevent the re-assignment of any other namespace prefixes for
 implementation-specific reasons by throwing a <code>NamespaceException</code>.
 </li>
 </ul>
 In a level 1 implementation, this method always throws an
 <code>UnsupportedRepositoryOperationException</code>.
 <p/>
 If the session associated with the <code>Workspace</code> object through which this registry was acquired does not have sufficient permissions to register the
 namespace an <code>AccessDeniedException</code> is thrown.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @param prefix The prefix to be mapped.
 @param uri The URI to be mapped.
 @throws NamespaceException if an illegal attempt is made to register a mapping.
 @throws UnsupportedRepositoryOperationException in a level 1 implementation
 @throws AccessDeniedException if the session associated with the <code>Workspace</code> object through which this registry was acquired does not have sufficient permissions to register the namespace.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="unregisterNamespace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes a namespace mapping from the registry. The following restriction apply:
 <ul>
 <li>
 Attempting to unregister a built-in namespace (<code>jcr</code>, <code>nt</code>,
 <code>mix</code>, <code>sv</code>, <code>xml</code> or the empty namespace) will
 throw a <code>NamespaceException</code>.
 </li>
 <li>
 Attempting to unregister a namespace that is currently present in content (either within an
 item name or within the value of a <code>NAME</code> or <code>PATH</code> property)
 will throw a <code>NamespaceException</code>. This includes prefixes in use within in-content node type
 definitions.
 </li>
 <li>
 An attempt to unregister a namespace that is not currently registered will throw a
 <code>NamespaceException</code>.
 </li>
 <li>
 An implementation may prevent the unregistering of any other namespace for
 implementation-specific reasons by throwing a <code>NamespaceException</code>.
 </li>
 </ul>
 In a level 1 implementation, this method always throws an
 <code>UnsupportedRepositoryOperationException</code>.
 <p/>
 If the session associated with the <code>Workspace</code> object through which this registry was acquired
 does not have sufficient permissions to unregister the
 namespace an <code>AccessDeniedException</code> is thrown.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @param prefix The prefix of the mapping to be removed.
 @throws NamespaceException if an illegal attempt is made to remove a mapping.
 @throws UnsupportedRepositoryOperationException in a level 1 implementation
 @throws AccessDeniedException if the session associated with the <code>Workspace</code> object through which this registry was acquired does not have sufficient permissions
 to unregister the namespace.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getPrefixes" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array holding all currently registered prefixes.
 @return a string array
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getURIs" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array holding all currently registered URIs.
 @return a string array
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getURI" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the URI to which the given prefix is mapped.
 @param prefix a string
 @return a string
 @throws NamespaceException if the prefix is unknown.
 @throws RepositoryException is another error occurs]]>
      </doc>
    </method>
    <method name="getPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the prefix to which the given URI is mapped

 @param uri a string
 @return a string
 @throws NamespaceException if the URI is unknown.
 @throws RepositoryException is another error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<code>NamespaceRegistry</code> represents the global persistent namespace
 registry of the JCR Repository.

 @see Workspace#getNamespaceRegistry]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.NamespaceRegistry -->
  <!-- start interface javax.jcr.Node -->
  <interface name="Node"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Item"/>
    <method name="addNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new node at <code>relPath</code>. The new node will only be
 persisted on <code>save()</code> if it meets the constraint
 criteria of the parent node's node type.
 <p/>
 In order to save a newly added node, <code>save</code> must be called
 either on the <code>Session</code>, or on the new node's parent or higher-order
 ancestor (grandparent, etc.). An attempt to call <code>save</code> <i>only</i>
 on the newly added node will throw a <code>RepositoryException</code>.
 <p/>
 In the context of this method the <code>relPath</code> provided must not
 have an index on its final element. If it does then a <code>RepositoryException</code>
 is thrown.
 <p/>
 Strictly speaking, the parameter is actually a relative path to the parent node
 of the node to be added, appended with the name desired for the
 new node (if the a node is being added directly below <code>this</code> node then only
 the name need be specified). It does not specify a position within the child node
 ordering. If ordering is supported by the node type of
 the parent node then the new node is appended to the end of the
 child node list.
 <p/>
 Since this signature does not allow explicit node type assignment, the new
 node's primary node type will be determined (either immediately or on
 <code>save</code>, depending on the implementation) by the child node definitions in
 the node types of its parent.
 <p/>
 An <code>ItemExistsException</code> will be thrown either immediately (by this
 method), or on <code>save</code>, if an item at the specified path already exists and
 same-name siblings are not allowed. Implementations may differ on when
 this validation is performed.
 <p/>
 A <code>PathNotFoundException</code> will be thrown
 either immediately,  or on <code>save</code>, if the specified path
 implies intermediary nodes that do not exist. Implementations may differ
 on when this validation is performed.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if adding the
 node would violate a node type or implementation-specific constraint or
 if an attempt is made to add a node as the child of a property.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately  or
 on <code>save</code>, if the node to which the new child is being added is versionable
 and checked-in or is non-versionable but its nearest versionable ancestor
 is checked-in. Implementations may differ on when this validation is
 performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately (by this
 method), or on <code>save</code>, if a lock prevents the addition of the node.
 Implementations may differ on when this validation is performed.

 @param relPath The path of the new node to be created.

 @return The node that was added.

 @throws ItemExistsException if an item at the specified path already exists,
 same-name siblings are not allowed and this implementation performs this
 validation immediately instead of waiting until <code>save</code>.

 @throws PathNotFoundException if the specified path implies intermediary
 <code>Node</code>s that do not exist or the last element of
 <code>relPath</code> has an index, and this implementation performs this
 validation immediately instead of waiting until <code>save</code>.

 @throws ConstraintViolationException if a node type or implementation-specific constraint
 is violated or if an attempt is made to add a node as the child of a property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws VersionException if the node to which the new child is being added is versionable and
 checked-in or is non-versionable but its nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws LockException if a lock prevents the addition of the node and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws RepositoryException If the last element of <code>relPath</code> has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="addNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <param name="primaryNodeTypeName" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new node at <code>relPath</code> of the specified node type.
 The same as <code>{@link #addNode(String relPath)}</code> except that the primary
 node type of the new node is explictly specified.
 <p/>
 An <code>ItemExistsException</code> will be thrown either immediately (by this
 method), or on <code>save</code>, if an item at the specified path already exists and
 same-name siblings are not allowed. Implementations may differ on when
 this validation is performed.
 <p/>
 A <code>PathNotFoundException</code> will be thrown
 either immediately,  or on <code>save</code>, if the specified path
 implies intermediary nodes that do not exist. Implementations may differ
 on when this validation is performed.
 <p/>
 A NoSuchNodeTypeException will be thrown either immediately
 or on <code>save</code>, if the specified node type is not recognized.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if adding the
 node would violate a node type or implementation-specific constraint or
 if an attempt is made to add a node as the child of a property.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately  or
 on <code>save</code>, if the node to which the new child is being added is versionable
 and checked-in or is non-versionable but its nearest versionable ancestor
 is checked-in. Implementations may differ on when this validation is
 performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately (by this
 method), or on <code>save</code>, if a lock prevents the addition of the node.
 Implementations may differ on when this validation is performed.

 @param relPath the path of the new node to be created.

 @param primaryNodeTypeName The name of the primary node type of the new node.

 @return the node that was added.

 @throws ItemExistsException if an item at the specified path already exists,
 same-name siblings are not allowed and this implementation performs this
 validation immediately instead of waiting until <code>save</code>.

 @throws PathNotFoundException if the specified path implies intermediary
 <code>Node</code>s that do not exist or the last element of
 <code>relPath</code> has an index, and this implementation performs this
 validation immediately instead of waiting until <code>save</code>.

 @throws NoSuchNodeTypeException if the specified node type is not recognized and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws ConstraintViolationException if a node type or implementation-specific constraint
 is violated or if an attempt is made to add a node as the child of a property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws VersionException if the node to which the new child is being added is versionable and
 checked-in or is non-versionable but its nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws LockException if a lock prevents the addition of the node and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws RepositoryException if the last element of <code>relPath</code> has an index or if
 another error occurs.]]>
      </doc>
    </method>
    <method name="orderBefore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcChildRelPath" type="java.lang.String"/>
      <param name="destChildRelPath" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this node supports child node ordering, this method inserts the child node at
 <code>srcChildRelPath</code> before its sibling, the child node at <code>destChildRelPath</code>,
 in the child node list.
 <p/>
 To place the node <code>srcChildRelPath</code> at the end of the list, a <code>destChildRelPath</code>
 of <code>null</code> is used.
 <p/>
 Note that (apart from the case where <code>destChildRelPath</code> is <code>null</code>) both of these
 arguments must be relative paths of depth one, in other words they are the names of the child nodes,
 possibly suffixed with an index.
 <p/>
 If <code>srcChildRelPath</code> and <code>destChildRelPath</code> are the same, then no change is made.
 <p/>
 Changes to ordering of child nodes are persisted on <code>save</code> of the parent node. But, if this node
 does not support child node ordering, then a <code>UnsupportedRepositoryOperationException</code>
 thrown.
 <p/>
 If <code>srcChildRelPath</code> is not the relative path to a child node of this node then an
 <code>ItemNotFoundException</code> is thrown.
 <p/>
 If <code>destChildRelPath</code> is neither the relative path to a child node of this node nor
 <code>null</code>, then an <code>ItemNotFoundException</code> is also thrown.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if this operation would
 violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately  or
 on <code>save</code>, if this node is versionable
 and checked-in or is non-versionable but its nearest versionable ancestor
 is checked-in. Implementations may differ on when this validation is
 performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately (by this
 method), or on <code>save</code>, if a lock prevents the re-ordering.
 Implementations may differ on when this validation is performed.

 @param srcChildRelPath  the relative path to the child node (that is, name plus possible index)
 to be moved in the ordering
 @param destChildRelPath the the relative path to the child node (that is, name plus possible index)
 before which the node <code>srcChildRelPath</code> will be placed.
 @throws UnsupportedRepositoryOperationException if ordering is not supported.
 @throws ConstraintViolationException if an implementation-specific ordering restriction is violated
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ItemNotFoundException        if either parameter is not the relative path of a child node of this node.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this implementation performs this validation immediately instead
 of waiting until <code>save</code>..
 @throws LockException if a lock prevents the re-ordering and this implementation performs this validation
 immediately instead of waiting until <code>save</code>..
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Value"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified (single-value) property of this node to the specified
 <code>value</code>. If the property does not yet exist, it is created.
 The property type of the property will be that specified by the node type
 of this node.
 <p/>
 If the property type of the supplied <code>Value</code> object is different
 from that required, then a best-effort conversion is attempted. If the
 conversion fails, a <code>ValueFormatException</code> is thrown. If another
 error occurs, a <code>RepositoryException</code> is thrown.
 <p/>
 If the node type of this node does not indicate a specific property
 type, then the property type of the supplied <code>Value</code> object
 is used and if the property already exists it assumes both the new value
 and new property type.
 <p/>
 If the property is multi-valued, a <code>ValueFormatException</code>
 is thrown.
  <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (Value)null)</code> would remove
 property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to be assigned
 @return The updated <code>Property</code> object

 @throws ValueFormatException if <code>value</code> cannot be converted to the type of the specified
 property or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Value"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified (single-value) property to the specified value.
 If the property does not yet exist, it is created.
 <p/>
 The type of the new property is determined by the <code>type</code> parameter specified.
 <p/>
 If the property type of the supplied <code>Value</code> object is different from that
 required, then a best-effort conversion is attempted. If the conversion fails, a
 <code>ValueFormatException</code> is thrown.
 <p/>
 If the property is not single-valued then a <code>ValueFormatException</code> is also thrown.
 <p/>
 If the property already exists it assumes both the new value and the new property type.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (Value)null, type)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 To persist the addition or removal of a property, <code>save</code> must be called
 on the <code>Session</code>, this <code>Node</code>, or an ancestor of this <code>Node</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name the name of the property to be set.
 @param value a <code>Value</code> object.
 @param type the type of the property.

 @return the <code>Property</code> object set, or <code>null</code>
 if this method was used to remove a property (by setting its value to <code>null</code>).

 @throws ValueFormatException  if <code>value</code> cannot be converted to the specified type
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="javax.jcr.Value[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified (multi-value) property to the specified array of values.
 If the property does not yet exist, it is created. Same as
 {@link #setProperty(String name, Value value)} except that an array of
 <code>Value</code> objects is assigned instead of a single <code>Value</code>.
 <p/>
 The property type of the property will be that specified by the node type of this node.
 If the property type of the supplied <code>Value</code> objects is different from that
 required, then a best-effort conversion is attempted. If the conversion fails, a
 <code>ValueFormatException</code> is thrown.
 <p/>
 All <code>Value</code> objects in the array must be of the same type, otherwise a
 <code>ValueFormatException</code> is thrown. If the property is not multi-valued
 then a <code>ValueFormatException</code> is also thrown. If another error occurs,
 a <code>RepositoryException</code> is thrown.
 <p/>
 If the node type of this node does not indicate a specific property type, then the
 property type of the supplied <code>Value</code> objects is used and if the
 property already exists it assumes both the new values and the new property type.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (Value[])null)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 Note that this is different from passing an array that contains <code>null</code>
 elements. In such a case, the array is compacted by removing the <code>null</code>s.
 The resulting set of values never contains nulls. However, the set may be empty:
 <code>N.setProperty("P", new Value[]{null})</code> would set the property to
 the empty set of values.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name   the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is not multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="javax.jcr.Value[]"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified (multi-value) property to the specified array of values.
 If the property does not yet exist, it is created. The type of the property
 is determined by the <code>type</code> parameter specified.
 <p/>
 If the property type of the supplied <code>Value</code> objects is different from that
 specified, then a best-effort conversion is attempted. If the conversion fails, a
 <code>ValueFormatException</code> is thrown.
 <p/>
 If the property already exists it assumes both the new values and the new property type.
 <p/>
 All <code>Value</code> objects in the array must be of the same type, otherwise a
 <code>ValueFormatException</code> is thrown. If the property is not multi-valued
 then a <code>ValueFormatException</code> is also thrown. If another error occurs,
 a <code>RepositoryException</code> is thrown.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (Value[])null, type)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 Note that this is different from passing an array that contains <code>null</code>
 elements. In such a case, the array is compacted by removing the <code>null</code>s.
 The resulting set of values never contains nulls. However, the set may be empty:
 <code>N.setProperty("P", new Value[]{null}, type)</code> would set the property to
 the empty set of values.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name   the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @param type   the type of the property.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException  if <code>value</code> cannot be converted to the specified type
 or if the property already exists and is not multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified array of values.
 Same as {@link #setProperty(String name, Value[] values)}
 except that the values are specified as <code>String</code>
 objects instead of <code>Value</code> objects.

 @param name   the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is not multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified array of values and to the specified type.
 Same as {@link #setProperty(String name, Value[] values, int type)}
 except that the values are specified as <code>String</code>
 objects instead of <code>Value</code> objects.

 @param name the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @param type the type of the property.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException  if <code>value</code> cannot be converted to the specified type
 or if the property already exists and is not multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified value.
 If the property does not yet exist, it is created.
 The property type of the property being set is determined
 by the node type of <code>this</code> node (the one on which
 this method is being called). If this is something other than
 <code>PropertyType.STRING</code>, a best-effort conversion is attempted.
 If the conversion fails, a <code>ValueFormatException</code> is
 thrown. If the property is multi-valued, a <code>ValueFormatException</code> is
 also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p/>
 If the node type of <code>this</code> node does not
 specify a particular property type for the property being set
 then <code>PropertyType.STRING</code> is used and,
 if the property already exists, it assumes both the new value
 and type <code>PropertyType.STRING</code>.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (String)null)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          If another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified (single-value) property to the specified value.
 If the property does not yet exist, it is created.
 <p/>
 The type of the property is determined by the <code>type</code> parameter specified.
 <p/>
 If the property type specified is not <code>PropertyType.STRING</code>,
 then a best-effort conversion is attempted. If the conversion fails, a
 <code>ValueFormatException</code> is thrown.
 <p/>
 If the property is not single-valued then a <code>ValueFormatException</code> is also thrown.
 <p/>
 If the property already exists it assumes both the new value and the new property type.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (Value)null, type)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name the name of the property to be set.
 @param value a <code>String</code> object.
 @param type the type of the property.

 @return the <code>Property</code> object set, or <code>null</code>
 if this method was used to remove a property (by setting its value to <code>null</code>).

 @throws ValueFormatException  if <code>value</code> cannot be converted to the specified type
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.io.InputStream"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified value.
 If the property does not yet exist, it is created.
 The property type of the property being set is determined
 by the node type of <code>this</code> node (the one on which
 this method is being called). If this is something other than
 <code>PropertyType.BINARY</code>, a best-effort conversion is attempted.
 If the conversion fails, a <code>ValueFormatException</code> is
 thrown. If the property is multi-valued, a <code>ValueFormatException</code> is
 also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p/>
 If the node type of <code>this</code> node does not
 specify a particular property type for the property being set
 then <code>PropertyType.BINARY</code> is used and,
 if the property already exists, it assumes both the new value
 and type <code>PropertyType.BINARY</code>.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (InputStream)null)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          If another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified value.
 If the property does not yet exist, it is created.
 The property type of the property being set is determined
 by the node type of <code>this</code> node (the one on which
 this method is being called). If this is something other than
 <code>PropertyType.BOOLEAN</code>, a best-effort conversion is attempted.
 If the conversion fails, a <code>ValueFormatException</code> is
 thrown. If the property is multi-valued, a <code>ValueFormatException</code> is
 also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p/>
 If the node type of <code>this</code> node does not
 specify a particular property type for the property being set
 then <code>PropertyType.BOOLEAN</code> is used and,
 if the property already exists, it assumes both the new value
 and type <code>PropertyType.BOOLEAN</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          If another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified value.
 If the property does not yet exist, it is created.
 The property type of the property being set is determined
 by the node type of <code>this</code> node (the one on which
 this method is being called). If this is something other than
 <code>PropertyType.DOUBLE</code>, a best-effort conversion is attempted.
 If the conversion fails, a <code>ValueFormatException</code> is
 thrown. If the property is multi-valued, a <code>ValueFormatException</code> is
 also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p/>
 If the node type of <code>this</code> node does not
 specify a particular property type for the property being set
 then <code>PropertyType.DOUBLE</code> is used and,
 if the property already exists, it assumes both the new value
 and type <code>PropertyType.DOUBLE</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          If another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified value.
 If the property does not yet exist, it is created.
 The property type of the property being set is determined
 by the node type of <code>this</code> node (the one on which
 this method is being called). If this is something other than
 <code>PropertyType.LONG</code>, a best-effort conversion is attempted.
 If the conversion fails, a <code>ValueFormatException</code> is
 thrown. If the property is multi-valued, a <code>ValueFormatException</code> is
 also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p/>
 If the node type of <code>this</code> node does not
 specify a particular property type for the property being set
 then <code>PropertyType.LONG</code> is used and,
 if the property already exists, it assumes both the new value
 and type <code>PropertyType.LONG</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          If another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.util.Calendar"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified value.
 If the property does not yet exist, it is created.
 The property type of the property being set is determined
 by the node type of <code>this</code> node (the one on which
 this method is being called). If this is something other than
 <code>PropertyType.DATE</code>, a best-effort conversion is attempted.
 If the conversion fails, a <code>ValueFormatException</code> is
 thrown. If the property is multi-valued, a <code>ValueFormatException</code> is
 also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p/>
 If the node type of <code>this</code> node does not
 specify a particular property type for the property being set
 then <code>PropertyType.DATE</code> is used and,
 if the property already exists, it assumes both the new value
 and type <code>PropertyType.DATE</code>.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (Calendar)null)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          If another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Node"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified (<code>REFERENCE</code>)property
 to refer to the specified <code>Node</code>.
 If the property does not yet exist, it is created.
 The property type of the property being set is determined
 by the node type of <code>this</code> node (the one on which
 this method is being called). If the property type of this property is
 something other than either <code>PropertyType.REFERENCE</code> or undefined
 then a <code>ValueFormatException</code> is
 thrown. If the property is multi-valued, a <code>ValueFormatException</code> is
 also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p/>
 If the node type of <code>this</code> node does not
 specify a particular property type for the property being set
 then <code>PropertyType.REFERENCE</code> is used and,
 if the property already exists, it assumes both the new value
 and type <code>PropertyType.REFERENCE</code>.
 <p/>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the <code>Property</code>
 object itself. For example, <code>N.setProperty("P", (Node)null)</code>
 would remove property called <code>"P"</code> of the node in <code>N</code>.
 <p/>
 To save the addition or removal of a property, a <code>save</code> call must be
 performed that includes the parent of the property in its scope, that is,
 a <code>save</code> on either the session, this node, or an ancestor of this node. To
 save a change to an existing property, a <code>save</code> call that includes that
 property in its scope is required. This means that in addition to the
 above-mentioned <code>save</code> options, a <code>save</code> on the changed property
 itself will also work.
 <p/>
 A <code>ConstraintViolationException</code> will
 be thrown either immediately or on <code>save</code> if the change
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its nearest versionable ancestor is
 checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately or on <code>save</code>
 if a lock prevents the setting of the property. Implementations may differ on when this validation is performed.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException  if <code>value</code> cannot be converted to the type of the specified property
 or if the property already exists and is multi-valued.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException          If another error occurs.]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node at <code>relPath</code> relative to this node.
 <p/>
 If <code>relPath</code> contains a path element that refers to a node with same-name sibling nodes without
 explicitly including an index using the array-style notation (<code>[x]</code>), then the index [1] is assumed
 (indexing of same name siblings begins at 1, not 0, in order to preserve compatibility with XPath).
 <p/>
 Within the scope of a single <code>Session</code> object, if a <code>Node</code> object has been acquired,
 any subsequent call of getNode reacquiring the same node must return a <code>Node</code> object reflecting
 the same state as the earlier <code>Node</code> object. Whether this object is actually the same <code>Node</code>
 instance, or simply one wrapping the same state, is up to the implementation.

 @param relPath The relative path of the node to retrieve.
 @return The node at <code>relPath</code>.
 @throws PathNotFoundException If no node exists at the
                               specified path.
 @throws RepositoryException   If another error occurs.]]>
      </doc>
    </method>
    <method name="getNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>NodeIterator</code> over all child <code>Node</code>s of
 this <code>Node</code>. Does <i>not</i> include properties of this
 <code>Node</code>. The same reacquisition
 semantics apply as with {@link #getNode(String)}.
 If this node has no child nodes, then an empty iterator is returned.

 @return A <code>NodeIterator</code> over all child <code>Node</code>s of
         this <code>Node</code>.
 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <method name="getNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namePattern" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Gets all child nodes of this node that match <code>namePattern</code>.
 The pattern may be a full name or a partial name with one or more
 wildcard characters ("<code>*</code>"), or a disjunction (using the
 "<code>|</code>" character to represent logical <code>OR</code>) of
 these. For example,
 <p/>
 <code>N.getNodes("jcr:* | myapp:report | my doc")</code>
 <p/>
 would return a <code>NodeIterator</code> holding all child nodes of
 <code>N</code> that are either called '<code>myapp:report</code>', begin
 with the prefix '<code>jcr:</code>' or are called '<code>my doc</code>'.
 <p/>
 Note that leading and trailing whitespace around a disjunct is ignored,
 but whitespace within a disjunct forms part of the pattern to be matched.
 <p/>
 The EBNF for <code>namePattern</code> is:
 <p/>
 <code>
 namePattern ::= disjunct {'|' disjunct}<br>
 disjunct ::= name [':' name]<br>
 name ::= '*' | ['*'] fragment {'*' fragment} ['*']<br>
 fragment ::= char {char}<br>
 char ::= nonspace | ' '<br>
 nonspace ::= (* Any Unicode character except: '/', ':', '[', ']', '*', ''', '"', '|'
 or any whitespace character *)
 </code>
 <p/>
 The pattern is matched against the names (not the paths)
 of the immediate child nodes of this node.
 <p/>
 If this node has no matching child nodes, then an empty iterator is returned.
 <p/>
 The same reacquisition
 semantics apply as with <code>{@link #getNode(String)}</code>.

 @param namePattern a name pattern
 @return a <code>NodeIterator</code>
 @throws RepositoryException If an unexpected error occurs.]]>
      </doc>
    </method>
    <method name="getProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the property at <code>relPath</code> relative to <code>this</code>
 node. The same reacquisition
 semantics apply as with <code>{@link #getNode(String)}</code>.

 @param relPath The relative path of the property to retrieve.
 @return The property at <code>relPath</code>.
 @throws PathNotFoundException If no property exists at the
                               specified path.
 @throws RepositoryException   If another error occurs.]]>
      </doc>
    </method>
    <method name="getProperties" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all properties of this node.
 Returns a <code>PropertyIterator</code> over all properties
 of this node. Does <i>not</i> include child <i>nodes</i> of this
 node. The same reacquisition
 semantics apply as with <code>{@link #getNode(String)}</code>.
 If this node has no properties, then an empty iterator is returned.

 @return A <code>PropertyIterator</code>.
 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <method name="getProperties" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namePattern" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Gets all properties of this node that match <code>namePattern</code>.
 The pattern may be a full name or a partial name with one or more
 wildcard characters ("<code>*</code>"), or a disjunction (using the
 "<code>|</code>" character to represent logical <code>OR</code>) of
 these. For example,
 <p/>
 <code>N.getProperties("jcr:* | myapp:name | my doc")</code>
 <p/>
 would return a <code>PropertyIterator</code> holding all properties of
 <code>N</code> that are either called '<code>myapp:name</code>', begin
 with the prefix '<code>jcr:</code>' or are called '<code>my doc</code>'.
 <p/>
 Note that leading and trailing whitespace around a disjunct is ignored,
 but whitespace within a disjunct forms part of the pattern to be matched.
 <p/>
 The EBNF for <code>namePattern</code> is:
 <p/>
 <code>
 namePattern ::= disjunct {'|' disjunct}<br>
 disjunct ::= name [':' name]<br>
 name ::= '*' | ['*'] fragment {'*' fragment} ['*']<br>
 fragment ::= char {char}<br>
 char ::= nonspace | ' '<br>
 nonspace ::= (* Any Unicode character except: '/', ':', '[', ']', '*', ''', '"', '|'
 or any whitespace character *)
 </code>
 <p/>
 The pattern is matched against the names (not the paths)
 of the immediate child properties of this node.
 <p/>
 If this node has no matching properties, then an empty iterator is returned.
 <p/>
 The same reacquisition
 semantics apply as with <code>{@link #getNode(String)}</code>.

 @param namePattern a name pattern
 @return a <code>PropertyIterator</code>
 @throws RepositoryException If an unexpected error occurs.]]>
      </doc>
    </method>
    <method name="getPrimaryItem" return="javax.jcr.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the primary child item of this node.
 The primary node type of this node may specify one child item (child node or property)
 of this node as the <i>primary child item</i>.
 This method returns that item. If this node does not have a primary item,
 either because none is declared in the node type or
 because a declared primary item is not present on this node instance,
 then this method throws an <code>ItemNotFoundException</code>.
 The same reacquisition semantics apply as with <code>{@link #getNode(String)}</code>.

 @return the primary child item.
 @throws ItemNotFoundException if this node does not have a primary
 child item, either because none is declared in the node type or
 because a declared primary item is not present on this node instance.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getUUID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the UUID of this node as recorded in this node's <code>jcr:uuid</code>
 property. This method only works on nodes of mixin node type
 <code>mix:referenceable</code>. On nonreferenceable nodes, this method
 throws an <code>UnsupportedRepositoryOperationException</code>. To avoid throwing an exception
 to determine whether a node has a UUID, a call to {@link #isNodeType(String) isNodeType("mix:referenceable")}
 can be made.

 @return the UUID of this node
 @throws UnsupportedRepositoryOperationException
                             If this node nonreferenceable.
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="getIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns the index of this node within the ordered set of its same-name
 sibling nodes. This index is the one used to address same-name siblings using the
 square-bracket notation, e.g., <code>/a[3]/b[4]</code>. Note that the index always starts
 at 1 (not 0), for compatibility with XPath. As a result, for nodes that do not have
 same-name-siblings, this method will always return 1.

 @return The index of this node within the ordered set of its same-name sibling nodes.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getReferences" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all <code>REFERENCE</code> properties that refer to this node.
 <p/>
 Some level 2 implementations may only return properties that have been
 saved (in a transactional setting this includes both those properties
 that have been saved but not yet committed, as well as properties that
 have been committed). Other level 2 implementations may additionally
 return properties that have been added within the current
 <code>Session</code> but are not yet saved.
 <p/>
 In implementations that support versioing, this method does not return
 <code>REFERENCE</code> propertiesthat are part of the frozen state of a
 version in version storage.
 <p/>
 If this node has no references, an empty iterator is returned.

 @return A <code>PropertyIterator</code>.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="hasNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether a node exists at <code>relPath</code>
 Returns <code>true</code> if a node exists at <code>relPath</code> and
 <code>false</code> otherwise.

 @param relPath The path of a (possible) node.
 @return <code>true</code> if a node exists at <code>relPath</code>;
         <code>false</code> otherwise.
 @throws RepositoryException If an unspecified error occurs.]]>
      </doc>
    </method>
    <method name="hasProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether a property exists at <code>relPath</code>
 Returns <code>true</code> if a property exists at <code>relPath</code> and
 <code>false</code> otherwise.

 @param relPath The path of a (possible) property.
 @return <code>true</code> if a property exists at <code>relPath</code>;
         <code>false</code> otherwise.
 @throws RepositoryException If an unspecified error occurs.]]>
      </doc>
    </method>
    <method name="hasNodes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether this node has child nodes.
 Returns <code>true</code> if this node has one or more child nodes;
 <code>false</code> otherwise.

 @return <code>true</code> if this node has one or more child nodes;
         <code>false</code> otherwise.
 @throws RepositoryException If an unspecified error occurs.]]>
      </doc>
    </method>
    <method name="hasProperties" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether this node has properties.
 Returns <code>true</code> if this node has one or more properties;
 <code>false</code> otherwise.

 @return <code>true</code> if this node has one or more properties;
         <code>false</code> otherwise.
 @throws RepositoryException If an unspecified error occurs.]]>
      </doc>
    </method>
    <method name="getPrimaryNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the primary node type of this node. Which node type is returned when this method is called on the root
 node of a workspace is up to the implementation, though the returned type must, of course, be
 consistent with ther child nodes and properties of the root node.

 @return a <code>NodeType</code> object.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getMixinNodeTypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of NodeType objects representing the mixin node types
 assigned to this node. This includes only those mixin types explicitly
 assigned to this node, and therefore listed in the property
 <code>jcr:mixinTypes</code>. It does not include mixin types inherited
 through the additon of supertypes to the primary type hierarchy.

 @return an array of  <code>NodeType</code> objects.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="isNodeType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether this node is of the specified node type.
 Returns <code>true</code> if this node is of the specified node type
 or a subtype of the specified node type. Returns <code>false</code> otherwise.

 @param nodeTypeName the name of a node type.
 @return true if this node is of the specified node type
         or a subtype of the specified node type; returns false otherwise.
 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <method name="addMixin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mixinName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds the specified mixin node type to this node.
 Also adds <code>mixinName</code> to this node's <code>jcr:mixinTypes</code>
 property immediately. Semantically, the mixin node type assignment may take
 effect immediately and at the very least, it must take effect on <code>save</code>.
 <p/>
 A <code>ConstraintViolationException</code> is thrown either immediately or on <code>save</code>
 if a conflict with another assigned mixin or the primary node type or for an implementation-specific
 reason. Implementations may differ on when this validation is done.
 <p/>
 In some implementations it may only be possible to add mixin types before a
 a node is first saved, and not after. I such cases any later calls to
 <code>addMixin</code> will throw a <code>ConstraintViolationException</code>
 either immediately or on <code>save</code>.
 <p/>
 A <code>NoSuchNodeTypeException</code> is thrown either immediately or on <code>save</code>
 if the specified <code>mixinName</code> is not recognized.
 Implementations may differ on when this validation is done.
 <p/>
 A <code>VersionException</code> is thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in.
 Implementations may differ on when this validation is done.
 <p/>
 A <code>LockException</code> is thrown either immediately or on <code>save</code>
 if a lock prevents the addition of the mixin.
 Implementations may differ on when this validation is done.

 @param mixinName the name of the mixin node type to be added
 @throws NoSuchNodeTypeException If the specified <code>mixinName</code>
 is not recognized and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException If the specified mixin node type
 is prevented from being assigned.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
 nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws LockException if a lock prevents the addition of the mixin and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="removeMixin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mixinName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified mixin node type from this node. Also removes <code>mixinName</code>
 from this node's <code>jcr:mixinTypes</code> property immediately. Semantically, the mixin
 node type removal may take effect immediately and at the very least, it must
 take effect on <code>save</code>.
 <p/>
 If this node does not have the specified mixin, a <code>NoSuchNodeTypeException</code> is thrown
 either immediately or on <code>save</code>. Implementations may differ on when this validation is done.
 <p/>
 A <code>ConstraintViolationException</code> will be thrown either immediately or on <code>save</code>
 if the removal of a mixin is not allowed. Implementations are free to enforce any policy they
 like with regard to mixin removal and may differ on when this validation is done.
 <p/>
 A <code>VersionException</code> is thrown either immediately or on <code>save</code>
 if this node is versionable and checked-in or is
 non-versionable but its nearest versionable ancestor is checked-in.
 Implementations may differ on when this validation is done.
 <p/>
 A <code>LockException</code> is thrown either immediately or on <code>save</code>
 if a lock prevents the removal of the mixin.
 Implementations may differ on when this validation is done.

 @param mixinName the name of the mixin node type to be removed.
 @throws NoSuchNodeTypeException if the specified <code>mixinName</code>
 is not currently assigned to this node and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the specified mixin node type
 is prevented from being removed and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws VersionException if this node is versionable and checked-in or is non-versionable but its
  nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the removal of the mixin and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="canAddMixin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mixinName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if the specified mixin node type, <code>mixinName</code>,
 can be added to this node. Returns <code>false</code> otherwise. A result of
 <code>false</code> must be returned in each of the following cases:
 <ul>
 <li>
 The mixin's definition conflicts with an existing primary or mixin node type of this node.
 </li>
 <li>
 This node is versionable and checked-in or is non-versionable and its nearest versionable
 ancestor is checked-in.
 </li>
 <li>
 This node is protected (as defined in this node's <code>NodeDefinition</code>,
 found in the node type of this node's parent).
 </li>
 <li>
 An access control restriction would prevent the addition of the mixin.
 </li>
 <li>
 A lock would prevent the addition of the mixin.
 </li>
 <li>
 An implementation-specific restriction would prevent the addition of the mixin.
 </li>
 </ul>
 A <code>NoSuchNodeTypeException</code> is thrown if the specified mixin node type name is not recognized.

 @param mixinName The name of the mixin to be tested.
 @return <code>true</code> if the specified mixin node type,
         <code>mixinName</code>, can be added to this node; <code>false</code> otherwise.
 @throws NoSuchNodeTypeException if the specified mixin node type name is not recognized.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getDefinition" return="javax.jcr.nodetype.NodeDefinition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node definition that applies to this node. In some cases there may appear
 to be more than one definition that could apply to this node. However, it is assumed that upon
 creation of this node, a single particular definition was used and it is <i>that</i> definition that
 this method returns. How this governing definition is selected upon node creation from among others
 which may have been applicable is an implementation issue and is not covered by this specification.
 The <code>NodeDefinition</code> returned when this method is called on the root node of a workspace
 is also up to the implementation.

 @return a <code>NodeDefinition</code> object.
 @throws RepositoryException if an error occurs.
 @see NodeType#getChildNodeDefinitions]]>
      </doc>
    </method>
    <method name="checkin" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new version with a system generated version name and returns that version
 (which will be the new base version of this node). Sets the <code>jcr:checkedOut</code>
 property to false thus putting the node into the <i>checked-in</i> state. This means
 that this node and its <i>connected non-versionable subtree</i> become read-only.
 A node's connected non-versionable subtree is the set of non-versionable descendant nodes
 reachable from that node through child links without encountering any versionable nodes.
 In other words, the read-only status flows down from the checked-in node along every child
 link until either a versionable node is encountered or an item with no children is encountered.
 <p/>
 Read-only status means that an item cannot be altered by the client using standard API methods
 (addNode, setProperty, etc.). The only exceptions to this rule are the {@link Node#restore}
 (all signatures), {@link Workspace#restore}, {@link Node#merge} and {@link Node#update}
 operations; these do not respect read-only status due to check-in. Note that <code>remove</code>
 of a read-only node is possible, as long as its parent is not read-only (since removal is an
 alteration of the parent node).
 <p/>
 If this node is already checked-in, this method has no effect but returns the current base version
 of this node.
 <p/>
 If this node is not versionable, an <code>UnsupportedRepositoryOperationException</code> is thrown.
 <p/>
 A <code>VersionException</code> is thrown or if a child item of this node has an
 <code>OnParentVersion</code> status of <code>ABORT</code>. This includes the case where
 an unresolved merge failure exists on this node, as indicated by the presence of the
 <code>jcr:mergeFailed</code> property.
 <p/>
 If there are unsaved changes pending on this node, an <code>InvalidItemStateException</code>
 is thrown.
 <p/>
 Throws a <code>LockException</code> if a lock prevents the checkin.
 <p/>
 If <code>checkin</code> succeeds, the change to the <code>jcr:checkedOut</code> property is
 automatically saved (there is no need to do an additional <code>save</code>).
 <p/>

 @return a <code>Version</code> object
 @throws VersionException          if jcr:predecessors does not contain at least one value or if
                                   a child item of this node has an <code>OnParentVersion</code> status of <code>ABORT</code>.
                                   This includes the case where an unresolved merge failure exists on this node, as indicated
                                   by the presence of a <code>jcr:mergeFailed</code> property.
 @throws UnsupportedRepositoryOperationException
                                   If this node is not versionable.
 @throws InvalidItemStateException If unsaved changes exist on this node.
 @throws LockException             if a lock prevents the checkin.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="checkout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets this versionable node to checked-out status by setting its
 <code>jcr:isCheckedOut</code> property to true and adds to the
 <code>jcr:predecessors</code> (multi-value) property a reference to the current
 base version (the same value as held in <code>jcr:baseVersion</code>).
 This method puts the node into the <i>checked-out</i> state, making it and its
 connected non-versionable subtree no longer
 read-only (see {@link #checkin} for an explanation of the term
 "connected non-versionable subtree").
 <p/>
 If successful, these changes are persisted immediately,
 there is no need to call <code>save</code>.
 <p/>
 If this node is already checked-out, this method has no effect.
 </p>
 If this node is not versionable, an <code>UnsupportedRepositoryOperationException</code> is thrown.
 <p/>
 Throws a <code>LockException</code> if a lock prevents the checkout.

 @throws UnsupportedRepositoryOperationException
                             If this node is not versionable.
 @throws LockException       if a lock prevents the checkout.
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="doneMerge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Completes the merge process with respect to this node and the specified <code>version</code>.
 <p/>
 When the {@link #merge} method is called on a node, every versionable node in that
 subtree is compared with its corresponding node in the indicated other workspace and
 a "merge test result" is determined indicating one of the following:
 <ol>
 <li>
 This node will be updated to the state of its correspondee (if the base version
 of the correspondee is more recent in terms of version history)
 </li>
 <li>
 This node will be left alone (if this node's base version is more recent in terms of
 version history).
 </li>
 <li>
 This node will be marked as having failed the merge test (if this node's base version
 is on a different branch of the version history from the base version of its
 corresponding node in the other workspace, thus preventing an automatic determination
 of which is more recent).
 </li>
 </ol>
 (See {@link #merge} for more details)
 <p/>
 In the last case the merge of the non-versionable subtree
 (the "content") of this node must be done by the application (for example, by
 providing a merge tool for the user).
 <p/>
 Additionally, once the content of the nodes has been merged, their version graph
 branches must also be merged. The JCR versioning system provides for this by
 keeping a record, for each versionable node that fails the merge test, of the
 base verison of the corresponding node that caused the merge failure. This record
 is kept in the <code>jcr:mergeFailed</code> property of this node. After a
 <code>merge</code>, this property will contain one or more (if
 multiple merges have been performed) <code>REFERENCE</code>s that point
 to the "offending versions".
 <p/>
 To complete the merge process, the client calls <code>doneMerge(Version v)</code>
 passing the version object referred to be the <code>jcr:mergeFailed</code> property
 that the client wishes to connect to <code>this</code> node in the version graph.
 This has the effect of moving the reference to the indicated version from the
 <code>jcr:mergeFailed</code> property of <code>this</code> node to the
 <code>jcr:predecessors</code>.
 <p/>
 If the client chooses not to connect this node to a particular version referenced in
 the <code>jcr:mergeFailed</code> property, he calls {@link #cancelMerge(Version version)}.
 This has the effect of removing the reference to the specified <code>version</code> from
 <code>jcr:mergeFailed</code> <i>without</i> adding it to <code>jcr:predecessors</code>.
 <p/>
 Once the last reference in <code>jcr:mergeFailed</code> has been either moved to
 <code>jcr:predecessors</code> (with <code>doneMerge</code>) or just removed
 from <code>jcr:mergeFailed</code> (with <code>cancelMerge</code>) the <code>jcr:mergeFailed</code>
 property is automatically removed, thus enabling <code>this</code>
 node to be checked-in, creating a new version (note that before the <code>jcr:mergeFailed</code>
 is removed, its <code>OnParentVersion</code> setting of <code>ABORT</code> prevents checkin).
 This new version will have a predecessor connection to each version for which <code>doneMerge</code>
 was called, thus joining those branches of the version graph.
 <p/>
 If successful, these changes are persisted immediately,
 there is no need to call <code>save</code>.
 <p/>
 A <code>VersionException</code> is thrown if the <code>version</code> specified is
 not among those referecned in this node's <code>jcr:mergeFailed</code> property.
 <p/>
 If there are unsaved changes pending on this node, an <code>InvalidItemStateException</code> is thrown.
 <p/>
 An <code>UnsupportedRepositoryOperationException</code> is thrown if this node is not versionable.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @param version a version referred to by this node's <code>jcr:mergeFailed</code> property.
 @throws VersionException if the version specifed is not among those referenced in this node's <code>jcr:mergeFailed</code> or if this node is currently checked-in.
 @throws InvalidItemStateException if there are unsaved changes pending on this node.
 @throws UnsupportedRepositoryOperationException if this node is not versionable.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="cancelMerge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Cancels the merge process with respect to this node and specified <code>version</code>.
 <p/>
 See {@link #doneMerge} for a full explanation. Also see {@link #merge} for
 more details.
 <p/>
 If successful, these changes are persisted immediately,
 there is no need to call <code>save</code>.
 <p/>
 A <code>VersionException</code> is thrown if the <code>version</code> specified is
 not among those referecned in this node's <code>jcr:mergeFailed</code>.
 <p/>
 An <code>UnsupportedRepositoryOperationException</code> is thrown if this nod is not versionable.
 <p/>
 If there are unsaved changes pending on this node, an <code>InvalidItemStateException</code> is thrown.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @param version a version referred to by this node's <code>jcr:mergeFailed</code> property.
 @throws VersionException if the version specified is not among those referenced in this node's <code>jcr:mergeFailed</code> or if this node is currently checked-in.
 @throws InvalidItemStateException if there are unsaved changes pending on this node.
 @throws UnsupportedRepositoryOperationException if this node is not versionable.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcWorkspaceName" type="java.lang.String"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this node does have a corresponding node in the workspace <code>srcWorkspaceName</code>,
 then this replaces this node and its subtree with a clone of the corresponding node and its
 subtree.
 <p/>
 If this node does not have a corresponding node in the workspace
 <code>srcWorkspaceName</code>, then the <code>update</code> method
 has no effect.
 <p/>
 The <i>corresponding node</i> is defined as the node in <code>srcWorkspace</code>
 with the same UUID as this node or, if this node has no UUID, the same
 path relative to the nearest ancestor that <i>does</i>  have a UUID,
 or the root node, whichever comes first. This is qualified by the requirment that
 referencable nodes only correspond with other referencables and non-referenceables
 with other non-referenceables.
 <p/>
 If the update succeeds the changes made are persisted immediately, there is
 no need to call <code>save</code>.
 <p/>
 Note that <code>update</code> does not respect the checked-in status of nodes.
 An <code>update</code> may change a node even if it is currently checked-in
 (This fact is only relevant in an implementation that supports versioning).
 <p/>
 If the specified <code>srcWorkspace</code> does not exist, a
 <code>NoSuchWorkspaceException</code> is thrown.
 <p/>
 If the current session does not have sufficient rights to perform the operation, then an
 <code>AccessDeniedException</code> is thrown.
 <p/>
 An InvalidItemStateException is thrown if this <code>Session</code> (not necessarily this
 <code>Node</code>) has pending unsaved changes.
 <p/>
 Throws a <code>LockException</code> if a lock prevents the update.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @param srcWorkspaceName the name of the source workspace.
 @throws NoSuchWorkspaceException  If <code>srcWorkspace</code> does not exist.
 @throws InvalidItemStateException if this <code>Session</code> (not necessarily this <code>Node</code>) has pending unsaved changes.
 @throws AccessDeniedException     If the current session does not have sufficient rights to perform the operation.
 @throws LockException             if a lock prevents the update.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="merge" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="bestEffort" type="boolean"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="MergeException" type="javax.jcr.MergeException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method can be thought of as a version-sensitive update (see 7.1.7
 Updating and Cloning Nodes across Workspaces in the specification).
 <p/>
 It recursively tests each
 versionable node in the subtree of this node against its corresponding
 node in <code>srcWorkspace</code> with respect to the relation between their
 respective base versions and either updates the node in question or not,
 depending on the outcome of the test. For details see 8.2.10 Merge in the
 specification.
 A <code>MergeException</code> is thrown if <code>bestEffort</code> is false
 and a versionable node is encountered whose corresponding node's base
 version is on a divergent branch from this node's base version.
 <p/>
 If successful, the changes are persisted immediately, there is no need to
 call <code>save</code>.
 <p/>
 This method returns a <code>NodeIterator</code> over all versionable nodes
 in the subtree that received a merge result of fail.
 <p/>
 If <code>bestEffort</code> is false, this iterator will be empty
 (since if it merge returns successfully, instead of throwing an exception,
 it will be because no failures were encountered).
 <p/>
 If <code>bestEffort</code> is <code>true</code>, this iterator will
 contain all nodes that received a fail during the course of this merge
 operation.
 <p/>
 If the specified <code>srcWorkspace</code> does not exist, a
 <code>NoSuchWorkspaceException</code> is thrown.
 <p/>
 If the current session does not have
 sufficient permissions to perform the operation, then an
 <code>AccessDeniedException</code> is thrown.
 <p/>
 An <code>InvalidItemStateException</code> is thrown
 if this session (not necessarily this node) has pending unsaved changes.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the merge.

 @param srcWorkspace the name of the source workspace.
 @param bestEffort a boolean
 @return iterator over all nodes that received a merge result of "fail" in the course
 of this operation.
 @throws MergeException if <code>bestEffort</code> is <code>false</code> and a failed merge
 result is encountered.
 @throws InvalidItemStateException if this session (not necessarily this
 node) has pending unsaved changes.
 @throws NoSuchWorkspaceException if <code>srcWorkspace</code> does not exist.
 @throws AccessDeniedException if the current session does not have sufficient
 rights to perform the operation.
 @throws LockException if a lock prevents the merge.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getCorrespondingNodePath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="workspaceName" type="java.lang.String"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the absolute path of the node in the specified workspace that
 corresponds to <code>this</code> node.
 <p/>
 The <i>corresponding node</i> is defined as the node in <code>srcWorkspace</code>
 with the same UUID as this node or, if this node has no UUID, the same
 path relative to the nearest ancestor that <i>does</i>  have a UUID,
 or the root node, whichever comes first. This is qualified by the requirement that
 referencable nodes only correspond with other referencables and non-referenceables
 with other non-referenceables.
 <p/>
 If no corresponding node exists then an <code>ItemNotFoundException</code> is thrown.
 <p/>
 If the specified workspace does not exist then a <code>NoSuchWorkspaceException</code> is thrown.
 <p/>
 If the current <code>Session</code> does not have sufficent rights to perform this operation,
 an <code>AccessDeniedException</code> is thrown.

 @param workspaceName
 @return the absolute path to the corresponding node.
 @throws ItemNotFoundException    if no corresponding node is found.
 @throws NoSuchWorkspaceException if the workspace is unknown.
 @throws AccessDeniedException    if the current <code>session</code> has insufficent rights to perform this operation.
 @throws RepositoryException      if another error occurs.]]>
      </doc>
    </method>
    <method name="isCheckedOut" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns true if this node is either
 <ul>
 <li/>versionable and currently checked-out,
 <li/>non-versionable and its nearest versionable ancestor is checked-out or
 <li/>non-versionable and it has no versionable ancestor.
 </ul>
 Returns false if this node is either
 <ul>
 <li/>versionable and currently checked-in or
 <li/>non-versionable and its nearest versionable ancestor is checked-in.
 </ul>

 @return a boolean
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores <code>this</code> node to the state defined by the
 version with the specified <code>versionName</code>.
 <p/>
 If this node is not versionable, an
 <code>UnsupportedRepositoryOperationException</code> is thrown.
 <p/>
 If successful, the change is persisted immediately and there is no
 need to call <code>save</code>.
 <p/>
 A <code>VersionException</code> is thrown if no version with the specified <code>versionName</code>
 exists in this node's version history or if an attempt is made to restore the root version
 (<code>jcr:rootVersion</code>).
 <p/>
 An InvalidItemStateException is thrown if this <code>Session</code> (not necessarily this
 <code>Node</code>) has pending unsaved changes.
 <p/>
 A LockException is thrown if a lock prevents the addition of the mixin.
 <p/>
 This method will work regardless of whether this node is checked-in or not.
 <p/>
 A UUID collision occurs when a node exists <i>outside the subtree rooted at this node</i>
 with the same UUID as a node that would be introduced by the <code>restore</code>
 operation <i>into the subtree at this node</i>. The result in such a case is governed by
 the <code>removeExisting</code> flag. If <code>removeExisting</code> is <code>true</code>,
 then the incoming node takes precedence, and the existing node (and its subtree) is removed.
 If <code>removeExisting</code> is <code>false</code>, then a <code>ItemExistsException</code>
 is thrown and no changes are made. Note that this applies not only to cases where the restored
 node itself conflicts with an existing node but also to cases where a conflict occurs with any
 node that would be introduced into the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have <code>OnParentVersion</code> settings of
 <code>COPY</code> or <code>VERSION</code> are also governed by the <code>removeExisting</code> flag.

 @param versionName    a <code>Version</code> object
 @param removeExisting a boolean flag that governs what happens in case of a UUID collision.
 @throws UnsupportedRepositoryOperationException if this node is not versionable.
 @throws VersionException if the specified <code>version</code> is not part of this node's version history
 or if an attempt is made to restore the root version (<code>jcr:rootVersion</code>).
 @throws ItemExistsException       if <code>removeExisting</code> is <code>false</code> and a UUID collision occurs.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not necessarily this <code>Node</code>) has pending unsaved changes.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores <code>this</code> node to the state defined by the specified
 <code>version</code>.
 <p/>
 If this node is not versionable, an
 <code>UnsupportedRepositoryOperationException</code> is thrown.
 <p/>
 If successful, the change is persisted immediately and there is no
 need to call <code>save</code>.
 <p/>
 A <code>VersionException</code> is thrown if the specified <code>version</code>
 is not part of this node's version history or if an attempt is made to restore the root version (<code>jcr:rootVersion</code>).
 <p/>
 An InvalidItemStateException is thrown if this <code>Session</code> (not necessarily this
 <code>Node</code>) has pending unsaved changes.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the restore.
 <p/>
 This method will work regardless of whether this node is checked-in or not.
 <p/>
 A UUID collision occurs when a node exists <i>outside the subtree rooted at this node</i>
 with the same UUID as a node that would be introduced by the <code>restore</code>
 operation <i>into the subtree at this node</i>. The result in such a case is governed by
 the <code>removeExisting</code> flag. If <code>removeExisting</code> is <code>true</code>,
 then the incoming node takes precedence, and the existing node (and its subtree) is removed.
 If <code>removeExisting</code> is <code>false</code>, then a <code>ItemExistsException</code>
 is thrown and no changes are made. Note that this applies not only to cases where the restored
 node itself conflicts with an existing node but also to cases where a conflict occurs with any
 node that would be introduced into the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have <code>OnParentVersion</code> settings of
 <code>COPY</code> or <code>VERSION</code> are also governed by the <code>removeExisting</code> flag.

 @param version a <code>Version</code> object
 @param removeExisting a boolean flag that governs what happens in case of a UUID collision.
 @throws UnsupportedRepositoryOperationException if this node is not versionable.
 @throws VersionException if the specified <code>version</code> is not part of this node's version history
 or if an attempt is made to restore the root version (<code>jcr:rootVersion</code>).
 @throws ItemExistsException if <code>removeExisting</code> is <code>false</code> and a UUID collision occurs.
 @throws InvalidItemStateException if this <code>Session</code> (not necessarily this <code>Node</code>)
 has pending unsaved changes.
 @throws LockException if a lock prevents the restore.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="relPath" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the specified version to <code>relPath</code>, relative to this node.
 <p/>
 A node need not exist at relPath, though the parent of <code>relPath</code>
 must exist, otherwise a <code>PathNotFoundException</code> is thrown.
 <p/>
 If a node <i>does</i> exist at relPath then it must correspond to the version being restored
 (the version must be a version <i>of that node</i>) and must not be a root version
 (<code>jcr:rootVersion</code>), otherwise a <code>VersionException</code>
 is thrown.
 <p/>
 If no node exists at <code>relPath</code> then a <code>VersionException</code> is thrown if
 the parent node of <code>relPath</code> is versionable and checked-in or is non-versionable but
 its nearest versionable ancestor is checked-in.
 <p/>
 If there <i>is</i> a node at <code>relPath</code> then the checked-in status of that node
 itself and the checked-in status of its parent are irrelevant. The restore will work even if
 one or both are checked-in.
 <p/>
 A UUID collision occurs when a node exists <i>outside the subtree rooted at <code>relPath</code></i>
 with the same UUID as a node that would be introduced by the <code>restore</code> operation
 <i>into the subtree at <code>relPath</code></i> (Note that in cases where there is no node at
 <code>relPath</code>, this amounts to saying that a UUID collsion occurs if there exists
 a node <i>anywhere</i> in this workspace with the same UUID as a node that would be introduced by
 the <code>restore</code>). The result in such a case is governed by the <code>removeExisting</code>
 flag. If <code>removeExisting</code> is <code>true</code>, then the incoming node takes precedence,
 and the existing node (and its subtree) is removed. If <code>removeExisting</code> is
 <code>false</code>, then a <code>ItemExistsException</code> is thrown and no changes are made.
 Note that this applies not only to cases where the restored
 node itself conflicts with an existing node but also to cases where a conflict occurs with any
 node that would be introduced into the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have <code>OnParentVersion</code> settings of
 <code>COPY</code> or <code>VERSION</code> are also governed by the <code>removeExisting</code> flag.
 <p/>
 If the would-be parent of the location <code>relPath</code> is actually a property, or if a node type
 restriction would be violated, then a <code>ConstraintViolationException</code> is thrown.
 <p/>
 If the <code>restore</code> succeeds, the changes made to this node are persisted
 immediately, there is no need to call <code>save</code>.
 <p/>
 An InvalidItemStateException is thrown if this <code>Session</code> (not necessarily this
 <code>Node</code>) has pending unsaved changes.
 <p/>
 An <code>UnsupportedRepositoryOperationException</code> is thrown if this node is not versionable.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the restore.

 @param version a version object
 @param relPath the path to which the version is to be restored
 @param removeExisting overns what happens on UUID collision.
 @throws PathNotFoundException if the parent of <code>relPath</code> does not exist.
 @throws ItemExistsException if removeExisting is false and a UUID collision occurs
 @throws ConstraintViolationException If the would-be parent of the location <code>relPath</code> is
 actually a property, or if a node type restriction would be violated
 @throws VersionException if the parent node of <code>relPath</code> is versionable and checked-in or is
 non-versionable but its nearest versionable ancestor is checked-in or if a node exists at relPath that is not
 the node corresponding to the specified <code>version</code> or if an attempt is made to restore the root version
 (<code>jcr:rootVersion</code>).
 @throws UnsupportedRepositoryOperationException if this node is not versionable.
 @throws LockException if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not necessarily this <code>Node</code>) has pending unsaved changes.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="restoreByLabel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionLabel" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the version of this node with the specified version label.
 If this node is not versionable, an
 <code>UnsupportedRepositoryOperationException</code> is thrown.
 If successful, the change is persisted immediately and there is no
 need to call <code>save</code>.
 <p/>
 A <code>VersionException</code> is thrown if the specified <code>versionLabel</code>
 does not exist in this node's version history.
 <p/>
 An InvalidItemStateException is thrown if this <code>Session</code> (not necessarily this
 <code>Node</code>) has pending unsaved changes.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the restore.
 <p/>
 This method will work regardless of whether this node is checked-in or not.
 <p/>
 A UUID collision occurs when a node exists <i>outside the subtree rooted at this node</i>
 with the same UUID as a node that would be introduced by the <code>restoreByLabel</code>
 operation <i>into the subtree at this node</i>. The result in such a case is governed by
 the <code>removeExisting</code> flag. If <code>removeExisting</code> is <code>true</code>,
 then the incoming node takes precedence, and the existing node (and its subtree) is removed.
 If <code>removeExisting</code> is <code>false</code>, then a <code>ItemExistsException</code>
 is thrown and no changes are made. Note that this applies not only to cases where the restored
 node itself conflicts with an existing node but also to cases where a conflict occurs with any
 node that would be introduced into the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have <code>OnParentVersion</code> settings of
 <code>COPY</code> or <code>VERSION</code> are also governed by the <code>removeExisting</code> flag.

 @param versionLabel   a String
 @param removeExisting a boolean flag that governs what happens in case of a UUID collision.
 @throws UnsupportedRepositoryOperationException if this node is not verisonable.
 @throws VersionException          if the specified <code>versionLabel</code>
                                   does not exist in this node's version history.
 @throws ItemExistsException       if <code>removeExisting</code> is <code>false</code> and a UUID collision occurs.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not necessarily this <code>Node</code>) has pending unsaved changes.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="getVersionHistory" return="javax.jcr.version.VersionHistory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>VersionHistory</code> object of this node.
 This object provides access to the <code>nt:versionHistory</code>
 node holding this node's versions.
 <p/>
 If this node is not versionable, an <code>UnsupportedRepositoryOperationException</code> is thrown.

 @return a <code>VersionHistory</code> object
 @throws UnsupportedRepositoryOperationException if this node is not versionable.
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="getBaseVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the current base version of this versionable node.
 <p/>
 If this node is not versionable, an <code>UnsupportedRepositoryOperationException</code> is thrown.

 @return a <code>Version</code> object.
 @throws UnsupportedRepositoryOperationException
                             if this node is not versionable.
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="lock" return="javax.jcr.lock.Lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isDeep" type="boolean"/>
      <param name="isSessionScoped" type="boolean"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Places a lock on this node. If successful, this node is said to <i>hold</i> the lock.
 <p/>
 If <code>isDeep</code> is <code>true</code> then the lock applies to this node and all its descendant nodes;
 if <code>false</code>, the lock applies only to this, the holding node.
 <p/>
 If <code>isSessionScoped</code> is <code>true</code> then this lock will expire upon the expiration of the current
 session (either through an automatic or explicit <code>Session.logout</code>); if <code>false</code>, this lock
 does not expire until explicitly unlocked or automatically unlocked due to a implementation-specific limitation,
 such as a timeout.
 <p/>
 Returns a <code>Lock</code> object reflecting the state of the new lock and including a lock token. See, in
 contrast, {@link Node#getLock}, which returns the <code>Lock</code> <i>without</i> the lock token.
 <p/>
 The lock token is also automatically added to the set of lock tokens held by the current <code>Session</code>.
 <p/>
 If successful, then the property <code>jcr:lockOwner</code> is created and set to the value of
 <code>Session.getUserID</code> for the current session and the property <code>jcr:lockIsDeep</code> is set to the
 value passed in as <code>isDeep</code>. These changes are persisted automatically; there is no need to call
 <code>save</code>.
 <p/>
 Note that it is possible to lock a node even if it is checked-in (the lock-related properties will be changed
 despite the checked-in status).
 <p/>
 If this node is not of mixin node type <code>mix:lockable</code> then an
 <code>LockException</code> is thrown.
 <p/>
 If this node is already locked (either because it holds a lock or a lock above it applies to it),
 a <code>LockException</code> is thrown.
 <p/>
 If <code>isDeep</code> is <code>true</code> and a descendant node of this node already holds a lock, then a
 <code>LockException</code> is thrown.
 <p/>
 If the current session does not have sufficient privileges to place the lock, an
 <code>AccessDeniedException</code> is thrown.
 <p/>
 An <code>UnsupportedRepositoryOperationException</code> is thrown if this implementation does not support locking.
 <p/>
 An InvalidItemStateException is thrown if this node has pending unsaved changes.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @param isDeep if <code>true</code> this lock will apply to this node and all its descendants; if
 <code>false</code>, it applies only to this node.
 @param isSessionScoped if <code>true</code>, this lock expires with the current session; if <code>false</code> it
 expires when explicitly or automatically unlocked for some other reason.
 @return A <code>Lock</code> object containing a lock token.
 @throws UnsupportedRepositoryOperationException if this implementation does not support locking.
 @throws LockException if this node is not <code>mix:lockable</code> or this node is already locked or
 <code>isDeep</code> is <code>true</code> and a descendant node of this node already holds a lock.
 @throws AccessDeniedException if this session does not have permission to lock this node.
 @throws InvalidItemStateException if this node has pending unsaved changes.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getLock" return="javax.jcr.lock.Lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>Lock</code> object that applies to this node. This may be either a lock on this node itself
 or a deep lock on a node above this node.
 <p/>
 If this <code>Session</code> (the one through which this <code>Node</code> was acquired)
 holds the lock token for this lock, then the returned <code>Lock</code> object contains
 that lock token (accessible through <code>Lock.getLockToken</code>). If this <code>Session</code>
 does not hold the applicable lock token, then the returned <code>Lock</code> object will not
 contain the lock token (its <code>Lock.getLockToken</code> method will return <code>null</code>).
 <p/>
 If this node is not locked (no lock applies to this node), a <code>LockException</code> is thrown.
 <p/>
 If the current session does not have sufficient privileges to get the lock, an <code>AccessDeniedException</code>
 is thrown.
 <p/>
 An <code>UnsupportedRepositoryOperationException</code> is thrown if this implementation does not support locking.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return The applicable <code>Lock</code> object, without a contained lock token.
 @throws UnsupportedRepositoryOperationException if this implementation does not support locking.
 @throws LockException if no lock applies to this node.
 @throws AccessDeniedException if the curent session does not have pernmission to get the lock.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the lock on this node. Also removes the properties <code>jcr:lockOwner</code> and
 <code>jcr:lockIsDeep</code> from this node. These changes are persisted automatically; there is no need to call
 <code>save</code>.
 <p/>
 If this node does not currently hold a lock or
 holds a lock for which this Session does not have the correct lock token,
 then a <code>LockException</code> is thrown. Note however that the system
 may give permission to some users to unlock locks for which they do not have
 the lock token. Typically such #lock-superuser# capability is intended to
 facilitate administrational clean-up of orphaned open-scoped locks.
 <p/>
 Note that it is possible to unlock a node even if it is checked-in (the lock-related properties will be changed
 despite the checked-in status).
 <p/>
 If the current session does not
 have sufficient privileges to remove the lock, an <code>AccessDeniedException</code> is thrown.
 <p/>
 An <code>InvalidItemStateException</code> is thrown if this node has pending unsaved changes.
 <p/>
 An <code>UnsupportedRepositoryOperationException</code> is thrown if this implementation does not support locking.
 <p/>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @throws UnsupportedRepositoryOperationException if this implementation does not support locking.
 @throws LockException if this node does not currently hold a lock or holds a lock for which this Session does not have the correct lock token
 @throws AccessDeniedException if the current session does not have permission to unlock this node.
 @throws InvalidItemStateException if this node has pending unsaved changes.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="holdsLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node holds a lock; otherwise returns <code>false</code>. To <i>hold</i> a
 lock means that this node has actually had a lock placed on it specifically, as opposed to just having a lock
 <i>apply</i> to it due to a deep lock held by a node above.

 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="isLocked" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node is locked either as a result of a lock held by this node or by a deep
 lock on a node above this node; otherwise returns <code>false</code>.

 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>Node</code> interface represents a node in the hierarchy that
 makes up the repository.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Node -->
  <!-- start interface javax.jcr.NodeIterator -->
  <interface name="NodeIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Node</code> in the iteration.

 @return the next <code>Node</code> in the iteration.
 @throws java.util.NoSuchElementException if iteration has no more <code>Node</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Node</code>s
 with <code>nextNode</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.NodeIterator -->
  <!-- start class javax.jcr.NoSuchWorkspaceException -->
  <class name="NoSuchWorkspaceException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoSuchWorkspaceException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchWorkspaceException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchWorkspaceException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="NoSuchWorkspaceException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by <code>{@link Repository#login(Credentials, String)}</code>
 when a specific workspace is not found.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.NoSuchWorkspaceException -->
  <!-- start class javax.jcr.PathNotFoundException -->
  <class name="PathNotFoundException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathNotFoundException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="PathNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="PathNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="PathNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when no <code>Item</code> exists at the specified path
 or when the specified path implies intermediary <code>Node</code>s that do
 not exist.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.PathNotFoundException -->
  <!-- start interface javax.jcr.Property -->
  <interface name="Property"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Item"/>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Value"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>.
 If this property's property type is not constrained by the node type of
 its parent node, then the property type is changed to that of the supplied
 <code>value</code>. If the property type is constrained, then a
 best-effort conversion is attempted. If conversion fails, a
 <code>ValueFormatException</code> is thrown immediately (not on <code>save</code>).
 The change will be persisted (if valid) on <code>save</code>
 <p/>
 A <code>ConstraintViolationException</code> will be thrown either immediately
 or on <code>save</code>, if the change would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately
 or on <code>save</code>, if this property belongs to a node that is versionable and
 checked-in or is non-versionable but whose nearest versionable ancestor is checked-in.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately
 or on <code>save</code>, if a lock prevents the setting of the value.
 Implementations may differ on when this validation is performed.

 @param value The new value to set the property to.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="javax.jcr.Value[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to the <code>values</code> array.
 If this property's property type is not constrained by the node type of
 its parent node, then the property type is changed to that of the supplied
 <code>values</code>. If the property type is constrained, then a
 best-effort conversion is attempted. If conversion fails, a
 <code>ValueFormatException</code> is thrown immediately (not on <code>save</code>).
 If this property is not a multi-valued then a <code>ValueFormatException</code> is
 thrown immediately. The change will be persisted (if valid) on <code>save</code>.
 <p/>
 A <code>ConstraintViolationException</code> will be thrown either immediately
 or on <code>save</code>, if the change would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately
 or on <code>save</code>, if this property belongs to a node that is versionable and
 checked-in or is non-versionable but whose nearest versionable ancestor is checked-in.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately
 or on <code>save</code>, if a lock prevents the setting of the value.
 Implementations may differ on when this validation is performed.

 @param values The new values to set the property to.
 @throws ValueFormatException if the type or format of the specified values
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>.
 Same as <code>{@link #setValue(Value value)}</code> except that the
 value is specified as a <code>String</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.String[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to the <code>values</code> array.
 Same as <code>{@link #setValue(Value[] values)}</code> except that the
 values are specified as a <code>String[]</code>.

 @param values The new values to set the property to.
 @throws ValueFormatException if the type or format of the specified values
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.io.InputStream"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>.
 Same as <code>{@link #setValue(Value value)}</code> except that the
 value is specified as a <code>InputStream</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>.
 Same as <code>{@link #setValue(Value value)}</code> except that the
 value is specified as a <code>long</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>.
 Same as <code>{@link #setValue(Value value)}</code> except that the
 value is specified as a <code>double</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.Calendar"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>.
 Same as <code>{@link #setValue(Value value)}</code> except that the
 value is specified as a <code>Calendar</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>.
 Same as <code>{@link #setValue(Value value)}</code> except that the
 value is specified as a <code>boolean</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Node"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets this REFERENCE property to refer to the specified node. If
 this property is not of type REFERENCE or the specified node is
 not referenceable (i.e., is not of mixin node type
 <code>mix:referenceable</code> and therefore does not have a UUID) then a
 <code>ValueFormatException</code> is thrown.

 @param value The node to which this REFERENCE property will refer.
 @throws ValueFormatException if the type or format of the specified value
 is incompatible with the type of this property.
 @throws VersionException if this property belongs to a node that is versionable and checked-in
 or is non-versionable but whose nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if a lock prevents the setting of the value and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the change would violate a node-type or other constraint
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the value of this  property as a generic
 <code>Value</code> object.
 <p>
 If the property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p/>
 The object returned is a copy of the stored value and is immutable.

 @throws ValueFormatException if the property is multi-valued.
 @throws RepositoryException if another error occurs.

 @return the value]]>
      </doc>
    </method>
    <method name="getValues" return="javax.jcr.Value[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of all the values of this property. Used to access
 multi-value properties. If the property is single-valued, this method throws a
 <code>ValueFormatException</code>. The array returned is a copy of the stored
 values, so changes to it are not reflected in internal storage.

 @throws ValueFormatException if the property is single-valued.
 @throws RepositoryException if another error occurs.

 @return a <code>Value</code> array]]>
      </doc>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>String</code> representation of the value of this
 property. A shortcut for
 <code>Property.getValue().getString()</code>. See {@link Value}.
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p>
 If the value of this property cannot be converted to a
 string, a <code>ValueFormatException</code> is thrown.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A string representation of the value of this property.
 @throws ValueFormatException if conversion to a string is not possible or if the
 property is multi-valued.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>InputStream</code> representation of the value of this
 property. A shortcut for
 <code>Property.getValue().getStream()</code>. See {@link Value}.
 <p>
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A stream representation of the value of this property.
 @throws ValueFormatException if the property is multi-valued.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>long</code> representation of the value of this
 property. A shortcut for
 <code>Property.getValue().getLong()</code>. See {@link Value}.
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p>
 If the value of this property cannot be converted to a
 <code>long</code>, a <code>ValueFormatException</code> is thrown.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A <code>long</code> representation of the value of this property.
 @throws ValueFormatException if conversion to a string is not possible or if the
 property is multi-valued.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>double</code> representation of the value of this
 property. A shortcut for
 <code>Property.getValue().getDouble()</code>. See {@link Value}.
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p>
 If the value of this property cannot be converted to a
 double, a <code>ValueFormatException</code> is thrown.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A double representation of the value of this property.
 @throws ValueFormatException if conversion to a string is not possible or if the
 property is multi-valued.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getDate" return="java.util.Calendar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Calendar</code> representation of the value of this
 property. A shortcut for
 <code>Property.getValue().getDate()</code>. See {@link Value}.
 <p/>
 The object returned is a copy of the stored value, so changes to it are not reflected in internal storage.
 <p/>
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p>
 If the value of this property cannot be converted to a
 date, a <code>ValueFormatException</code> is thrown.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A date (<code>Calendar</code> object)  representation of the value of this property.
 @throws ValueFormatException if conversion to a string is not possible or if the
 property is multi-valued.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>boolean</code> representation of the value of this
 property. A shortcut for
 <code>Property.getValue().getBoolean()</code>. See {@link Value}.
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p>
 If the value of this property cannot be converted to a
 boolean, a <code>ValueFormatException</code> is thrown.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A boolean representation of the value of this property.
 @throws ValueFormatException if conversion to a string is not possible or if the
 property is multi-valued.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this property is of type <code>REFERENCE</code>
 this method returns the node to which this property refers.
 <p>
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.
 <p>
 If this property cannot be coverted to a reference, then a <code>ValueFormatException</code> is thrown.
 <p>
 If this property is a REFERENCE property but is currently part of the frozen state of a version in version
 storage, this method will throw a <code>ValueFormatException</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return the referenced Node
 @throws ValueFormatException if this property cannot be converted to a reference, if the
 property is multi-valued or if this property is a REFERENCE property but is currently part of the frozen
 state of a version in version storage.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the length of the value of this property.
 <p>
 Returns the length in bytes if the value is a
 <code>PropertyType.BINARY</code>, otherwise it returns the number of
 characters needed to display the value in its string form.
 <p/>
 Returns #1 if the implementation cannot determine the length.
 <p/>
 If this property is multi-valued, this method throws a <code>ValueFormatException</code>.

 @return an <code>long</code>.
 @throws ValueFormatException if this property is multi-valued.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getLengths" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array holding the lengths of the values of this (multi-value) property in bytes
 if the values are <code>PropertyType.BINARY</code>, otherwise it returns the number of
 characters needed to display the value in its string form. The order of the
 length values corresponds to the order of the values in the property.
 <p/>
 Returns a <code>#1</code> in the appropriate position if the implementation cannot determine
 the length of a value.
 <p/>
 If this property is single-valued, this method throws a <code>ValueFormatException</code>.
 <p/>
 A RepositoryException is thrown if another error occurs.
 @return an array of lengths
 @throws ValueFormatException if this property is single-valued.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getDefinition" return="javax.jcr.nodetype.PropertyDefinition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the property definition that applies to this property. In some cases there may appear to
 be more than one definition that could apply to this node. However, it is assumed that upon
 creation of this property, a single particular definition was used and it is <i>that</i>
 definition that this method returns. How this governing definition is selected upon property
 creation from among others which may have been applicable is an implementation issue and is not
 covered by this specification.

 @see javax.jcr.nodetype.NodeType#getPropertyDefinitions
 @throws RepositoryException if an error occurs.
 @return a <code>PropertyDefinition</code> object.]]>
      </doc>
    </method>
    <method name="getType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the type of this <code>Property</code>. One of:
 <ul>
 <li><code>PropertyType.STRING</code></li>
 <li><code>PropertyType.BINARY</code></li>
 <li><code>PropertyType.DATE</code></li>
 <li><code>PropertyType.DOUBLE</code></li>
 <li><code>PropertyType.LONG</code></li>
 <li><code>PropertyType.BOOLEAN</code></li>
 <li><code>PropertyType.NAME</code></li>
 <li><code>PropertyType.PATH</code></li>
 <li><code>PropertyType.REFERENCE</code></li>
 </ul>
 The type returned is that which was set at property creation. Note that for some property <code>p</code>,
 the type returned by <code>p.getType()</code> may differ from the type returned by
 <code>p.getDefinition.getRequiredType()</code> only in the case where the latter returns <code>UNDEFINED</code>.
 The type of a property instance is never <code>UNDEFINED</code> (it must always have some actual type).

 @return an int
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>Property</code> object represents the smallest granularity of content
 storage. A property must have one and only one parent node. A property does
 not have children. When we say that node A "has" property B it means that B
 is a child of A.
 <p>
 A property consists of a name and a value. See <code>{@link Value}</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Property -->
  <!-- start interface javax.jcr.PropertyIterator -->
  <interface name="PropertyIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Property</code> in the iteration.

 @return the next <code>Property</code> in the iteration.
 @throws java.util.NoSuchElementException if iteration has no more <code>Property</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Property</code>s
 with <code>nextProperty</code> as well as a <code>skip</code> method.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.PropertyIterator -->
  <!-- start class javax.jcr.PropertyType -->
  <class name="PropertyType" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nameFromValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="int"/>
      <doc>
      <![CDATA[Returns the name of the specified <code>type</code>,
 as used in serialization.

 @param type the property type
 @return the name of the specified <code>type</code>
 @throws IllegalArgumentException if <code>type</code>
                                  is not a valid property type.]]>
      </doc>
    </method>
    <method name="valueFromName" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the numeric constant value of the type with the specified name.

 @param name the name of the property type
 @return the numeric constant value
 @throws IllegalArgumentException if <code>name</code>
                                  is not a valid property type name.]]>
      </doc>
    </method>
    <field name="STRING" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BINARY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DATE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BOOLEAN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NAME" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PATH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="REFERENCE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNDEFINED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_STRING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_BINARY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_LONG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_DOUBLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_DATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_BOOLEAN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_REFERENCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TYPENAME_UNDEFINED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The property types supported by the JCR standard.
 <p/>
 <p>This interface defines following property types:
 <ul>
 <li><code>STRING</code>
 <li><code>BINARY</code>
 <li><code>LONG</code>
 <li><code>DOUBLE</code>
 <li><code>DATE</code>
 <li><code>BOOLEAN</code>
 <li><code>NAME</code>
 <li><code>PATH</code>
 <li><code>REFERENCE</code>
 </ul>]]>
    </doc>
  </class>
  <!-- end class javax.jcr.PropertyType -->
  <!-- start interface javax.jcr.RangeIterator -->
  <interface name="RangeIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="skipNum" type="long"/>
      <doc>
      <![CDATA[Skip a number of elements in the iterator.

 @param skipNum the non-negative number of elements to skip
 @throws java.util.NoSuchElementException
          if skipped past the last element in the iterator.]]>
      </doc>
    </method>
    <method name="getSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of elements in the iterator.
 If this information is unavailable, returns -1.

 @return a long]]>
      </doc>
    </method>
    <method name="getPosition" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current position within the iterator. The number
 returned is the 0-based index of the next element in the iterator,
 i.e. the one that will be returned on the subsequent <code>next</code> call.
 <p/>
 Note that this method does not check if there is a next element,
 i.e. an empty iterator will always return 0.

 @return a long]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Extends <code>Iterator</code> with the <code>skip</code>, <code>getSize</code>
 and <code>getPosition</code> methods. The base interface of all type-specific
 iterators in the <code>javax.jcr</code> and its subpackages.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.RangeIterator -->
  <!-- start class javax.jcr.ReferentialIntegrityException -->
  <class name="ReferentialIntegrityException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReferentialIntegrityException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ReferentialIntegrityException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ReferentialIntegrityException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ReferentialIntegrityException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown on referential integrity violation.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ReferentialIntegrityException -->
  <!-- start interface javax.jcr.Repository -->
  <interface name="Repository"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDescriptorKeys" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string array holding all descriptor keys available for this implementation.
 This set must contain at least the built-in keys defined by the string constants in
 this interface.Used in conjunction with {@link #getDescriptor(String name)}
 to query information about this repository implementation.]]>
      </doc>
    </method>
    <method name="getDescriptor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the descriptor for the specified key. Used to query information about this
 repository implementation. The set of available keys can be found by calling
 {@link #getDescriptorKeys}. If the specifed key is not found, <code>null</code> is returned.

 @param key a string corresponding to a descriptor for this repository implementation.
 @return a descriptor string]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="credentials" type="javax.jcr.Credentials"/>
      <param name="workspaceName" type="java.lang.String"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Authenticates the user using the supplied <code>credentials</code>.
 <p>
 If <code>workspaceName</code> is recognized as the name of an existing workspace in the repository and
 authorization to access that workspace is granted, then a new <code>Session</code> object is returned.
 The format of the string <code>workspaceName</code> depends upon the implementation.
 <p>
 If <code>credentials</code> is <code>null</code>, it is assumed that authentication is handled by a
 mechanism external to the repository itself (for example, through the JAAS framework) and that the
 repository implementation exists within a context (for example, an application server) that allows
 it to handle authorization of the request for access to the specified workspace.
 <p>
 If <code>workspaceName</code> is <code>null</code>, a default workspace is automatically selected by
 the repository implementation. This may, for example, be the "home workspace" of the user whose
 credentials were passed, though this is entirely up to the configuration and implementation of the
 repository. Alternatively, it may be a "null workspace" that serves only to provide the method
 {@link Workspace#getAccessibleWorkspaceNames}, allowing the client to select from among available "real"
 workspaces.
 <p>
 If authentication or authorization for the specified workspace fails, a <code>LoginException</code> is
 thrown.
 <p>
 If <code>workspaceName</code> is not recognized, a <code>NoSuchWorkspaceException</code> is thrown.

 @param credentials   The credentials of the user
 @param workspaceName the name of a workspace.
 @return a valid session for the user to access the repository.
 @throws LoginException  If the login fails.
 @throws NoSuchWorkspaceException If the specified <code>workspaceName</code> is not recognized.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="credentials" type="javax.jcr.Credentials"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>login(credentials, null)</code>.

 @param credentials   The credentials of the user
 @return a valid session for the user to access the repository.
 @throws LoginException  If the login authentication fails.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="workspaceName" type="java.lang.String"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>login(null, workspaceName)</code>.

 @param workspaceName the name of a workspace.
 @return a valid session for the user to access the repository.
 @throws LoginException  If the login authentication fails.
 @throws NoSuchWorkspaceException If the specified <code>workspaceName</code> is not recognized.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>login(null, null)</code>.

 @return a valid session for the user to access the repository.
 @throws LoginException  If the login authentication fails.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <field name="SPEC_VERSION_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the version of the specification
 that this repository implements.]]>
      </doc>
    </field>
    <field name="SPEC_NAME_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the name of the specification
 that this repository implements.]]>
      </doc>
    </field>
    <field name="REP_VENDOR_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the name of the repository vendor.]]>
      </doc>
    </field>
    <field name="REP_VENDOR_URL_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the URL of the repository vendor.]]>
      </doc>
    </field>
    <field name="REP_NAME_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the name of this repository implementation.]]>
      </doc>
    </field>
    <field name="REP_VERSION_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the version of this repository implementation.]]>
      </doc>
    </field>
    <field name="LEVEL_1_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that this implementation supports
 all level 1 features. This key will always be present.]]>
      </doc>
    </field>
    <field name="LEVEL_2_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that this implementation supports
 all level 2 features.]]>
      </doc>
    </field>
    <field name="OPTION_TRANSACTIONS_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that this implementation supports transactions.]]>
      </doc>
    </field>
    <field name="OPTION_VERSIONING_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that this implementation supports versioning.]]>
      </doc>
    </field>
    <field name="OPTION_OBSERVATION_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that this implementation supports observation.]]>
      </doc>
    </field>
    <field name="OPTION_LOCKING_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that this implementation supports locking.]]>
      </doc>
    </field>
    <field name="OPTION_QUERY_SQL_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that this implementation supports the SQL query language.]]>
      </doc>
    </field>
    <field name="QUERY_XPATH_POS_INDEX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that the index position notation for
 same-name siblings is supported within XPath queries.]]>
      </doc>
    </field>
    <field name="QUERY_XPATH_DOC_ORDER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The presence of this key indicates that XPath queries return results in document order.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The entry point into the content repository.
 Represents the entry point into the content repository. Typically the object
 implementing this interface will be acquired from a JNDI-compatible
 naming and directory service.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Repository -->
  <!-- start class javax.jcr.RepositoryException -->
  <class name="RepositoryException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RepositoryException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="RepositoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="RepositoryException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="RepositoryException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the detail message, including the message from the nested
 exception if there is one.

 @return the detail message (which may be <code>null</code>).]]>
      </doc>
    </method>
    <method name="getLocalizedMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the localized message, including the localized message from the
 nested exception if there is one.

 @return The localized description of this exception.]]>
      </doc>
    </method>
    <method name="getCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the cause of this exception or <code>null</code> if the
 cause is nonexistent or unknown. (The cause is the throwable that
 caused this exception to get thrown.)

 @return the cause of this exception or <code>null</code> if the
         cause is nonexistent or unknown.]]>
      </doc>
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prints this <code>RepositoryException</code> and its backtrace to the
 standard error stream.]]>
      </doc>
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.io.PrintStream"/>
      <doc>
      <![CDATA[Prints this <code>RepositoryException</code> and its backtrace to the
 specified print stream.

 @param s <code>PrintStream</code> to use for output]]>
      </doc>
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.io.PrintWriter"/>
      <doc>
      <![CDATA[Prints this <code>RepositoryException</code> and its backtrace to
 the specified print writer.

 @param s <code>PrintWriter</code> to use for output]]>
      </doc>
    </method>
    <field name="rootCause" type="java.lang.Throwable"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Root failure cause]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Main exception thrown by classes in this package. May contain an error
 message and/or another nested exception.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.RepositoryException -->
  <!-- start interface javax.jcr.Session -->
  <interface name="Session"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRepository" return="javax.jcr.Repository"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>Repository</code> object through which this session was
 acquired.

 @return a <code>{@link Repository}</code> object.]]>
      </doc>
    </method>
    <method name="getUserID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the user ID that was used to acquire this session. This method is free to return an
 "anonymous user id" or <code>null</code> if the <code>Credentials</code> used to acquire this session happens not
 to have provided a real user ID (for example,  if instead of <code>SimpleCredentials</code> some other
 implementation of <code>Credentials</code> was used).

 @return the user id from the credentials used to acquire this session.]]>
      </doc>
    </method>
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the value of the named attribute as an <code>Object</code>, or <code>null</code> if no attribute of the
 given name exists. See {@link Session#getAttributeNames}.

 @param name the name of an attribute passed in the credentials used to acquire this session.

 @return the value of the attribute.]]>
      </doc>
    </method>
    <method name="getAttributeNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the attributes set in this session as a result of the <code>Credentials</code> that were
 used to acquire it. Not all <code>Credentials</code> implementations will contain attributes (though, for example,
 <code>SimpleCredentials</code> does allow for them). This method returns an empty array if the
 <code>Credentials</code> instance used to acquire this <code>Session</code> did not provide attributes.

 @return A string array containing the names of all attributes passed in the credentials used to acquire this session.]]>
      </doc>
    </method>
    <method name="getWorkspace" return="javax.jcr.Workspace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>Workspace</code> attached to this <code>Session</code>.

 @return a <code>{@link Workspace}</code> object.]]>
      </doc>
    </method>
    <method name="impersonate" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="credentials" type="javax.jcr.Credentials"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a new session in accordance with the specified (new) Credentials.
 Allows the current user to "impersonate" another using incomplete
 credentials (perhaps including a user name but no password, for example),
 assuming that their original session gives them that permission.
 <p/>
 The new <code>Session</code> is tied to a new <code>Workspace</code> instance.
 In other words, <code>Workspace</code> instances are not re-used. However,
 the <code>Workspace</code> instance returned represents the same actual
 persistent workspace entity in the repository as is represented by the
 <code>Workspace</code> object tied to this <code>Session</code>.
 <p/>
 Throws a <code>LoginException</code> if the current session does not have
 sufficient rights.

 @param credentials A <code>Credentials</code> object
 @return a <code>Session</code> object
 @throws LoginException if the current session does not have
 sufficient rights.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getRootNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the root node of the workspace.
 The root node, "/", is the main access point to the content of the
 workspace.

 @return The root node of the workspace: a <code>Node</code> object.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getNodeByUUID" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.lang.String"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node specifed by the given UUID. Only applies to nodes that
 expose a UUID, in other words, those of mixin node type
 <code>mix:referenceable</code>

 @param uuid A universally unique identifier.
 @return A <code>Node</code>.
 @throws ItemNotFoundException if the specified UUID is not found.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getItem" return="javax.jcr.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the item at the specified absolute path in the workspace.

 @param absPath An absolute path.
 @return An <code>Item</code>.
 @throws PathNotFoundException if the specified path cannot be found.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="itemExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if an item exists at <code>absPath</code>; otherwise returns <code>false</code>.
 Also returns <code>false</code> if the specified <code>absPath</code> is malformed.

 @param absPath an absolute path
 @return <code>true</code> if an item exists at <code>absPath</code>; otherwise returns <code>false</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Moves the node at <code>srcAbsPath</code> (and its entire subtree) to the new location
 at <code>destAbsPath</code>.
 <p>
 In order to persist the change, a <code>save</code>
 must be called on either the session or a common ancestor to both the source and destination locations.
 <p/>
 A <code>ConstraintViolationException</code> is thrown either immediately or on <code>save</code>
 if performing this operation would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p>
 As well, a <code>ConstraintViolationException</code> will be thrown on
 <code>save</code> if an attempt is made to seperately <code>save</code>
 either the source or destination node.
 <p>
 Note that this behaviour differs from that of
 {@link Workspace#move}, which operates directly in the persistent
 workspace and does not require a <code>save</code>.
 <p/>
 The <code>destAbsPath</code> provided must not
 have an index on its final element. If it does then a <code>RepositoryException</code>
 is thrown. Strictly speaking, the <code>destAbsPath</code> parameter is actually an <i>absolute path</i>
 to the parent node of the new location, appended with the new <i>name</i> desired for the
 moved node. It does not specify a position within the child node
 ordering (if such ordering is supported). If ordering is supported by the node type of
 the parent node of the new location, then the newly moved node is appended to the end of the
 child node list.
 <p/>
 This method cannot be used to move just an individual property by itself.
 It moves an entire node and its subtree (including, of course, any properties
 contained therein).
 <p/>
 If no node exists at <code>srcAbsPath</code> or no node exists one level above <code>destAbsPath</code>
 (in other words, there is no node that will serve as the parent of the moved item) then a
 <code>PathNotFoundException</code> is thrown either immediately or on <code>save</code>.
 Implementations may differ on when this validation is performed.
 <p/>
 An <code>ItemExistsException</code> is thrown either immediately or on <code>save</code>
 if a property already exists at <code>destAbsPath</code> or a node already exists there and same-name siblings
 are not allowed. Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> is thrown either immediately or on <code>save</code>
 if the parent node of <code>destAbsPath</code> or the parent node of <code>srcAbsPath] is versionable and
 checked-in, or is non-versionable and its nearest versionable ancestor is checked-in.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> is thrown either immediately or on <code>save</code>
 if a lock prevents the <code>move</code>. Implementations may differ on when this validation is performed.

 @param srcAbsPath the root of the subtree to be moved.
 @param destAbsPath the location to which the subtree is to be moved.
 @throws ItemExistsException if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws PathNotFoundException if either <code>srcAbsPath</code> or <code>destAbsPath</code> cannot be found and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws VersionException if the parent node of <code>destAbsPath</code> or the parent node of <code>srcAbsPath</code>
 is versionable and checked-in, or or is non-verionable and its nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if a node-type or other constraint violation is detected immediately and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws LockException if the move operation would violate a lock and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException if the last element of <code>destAbsPath</code> has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Validates all pending changes currently recorded in this <code>Session</code>. If validation of all
 pending changes succeeds, then this change information is cleared from the <code>Session</code>.
 If the <code>save</code> occurs outside a transaction, the changes are persisted and thus
 made visible to other <code>Sessions</code>. If the <code>save</code> occurs within a transaction,
 the changes are not persisted until the transaction is committed.
 <p>
 If validation fails, then no pending changes are saved and they remain recorded on the <code>Session</code>.
 There is no best-effort or partial save.
 <p>
 When an item is saved the item in persistent storage to which pending changes are written is
 determined as follows:
 <ul>
   <li>
     If the transient item has a UUID, then the changes are written to the persistent item with the same UUID.
   </li>
   <li>
     If the transient item does not have a UUID then its nearest ancestor with a UUID, or the root node
     (whichever occurs first) is found, and the relative path from the node in persistent node with that UUID is
     used to determine the item in persistent storage to which the changes are to be written.
   </li>
 </ul>
 As a result of these rules, a <code>save</code> of an item that has a UUID will succeed even if that item has,
 in the meantime, been moved in persistent storage to a new location (that is, its path has changed). However, a
 <code>save</code> of a non-UUID item will fail (throwing an <code>InvalidItemStateException</code>) if it has,
 in the meantime, been moved in persistent storage to a new location. A <code>save</code> of a non-UUID item will
 also fail if it has, in addition to being moved, been replaced in its original position by a UUID-bearing item.
 <p>
 Note that <code>save</code> uses the same rules to match items between transient storage and persistent storage
 as {@link Node#update} does to match nodes between two workspaces.
 <p>
 An <code>AccessDeniedException</code> will be thrown if any of the changes
 to be persisted would violate the access privileges of this
 <code>Session</code>.
 <p>
 If any of the changes to be persisted would cause the removal of a node
 that is currently the target of a <code>REFERENCE</code> property then a
 <code>ReferentialIntegrityException</code> is thrown, provided that this <code>Session</code> has
 read access to that <code>REFERENCE</code> property. If, on the other hand, this
 <code>Session</code> does not have read access to the <code>REFERENCE</code> property in question,
 then an <code>AccessDeniedException</code> is thrown instead.
 <p>
 An <code>ItemExistsException</code> will be thrown if any of the changes
 to be persisted would be prevented by the presence of an already existing
 item in the workspace.
 <p>
 A <code>ConstraintViolationException</code> will be thrown if any of the
 changes to be persisted would violate a node type restriction.
 Additionally, a repository may use this exception to enforce
 implementation- or configuration-dependant restrictions.
 <p>
 A <code>LockException</code> is thrown if any of the changes to be
 persisted would violate a lock.
 <p>
 An <code>InvalidItemStateException</code> is thrown if any of the
 changes to be persisted conflicts with a change already persisted
 through another session and the implementation is such that this
 conflict can only be detected at save-time and therefore was not
 detected earlier, at change-time.
 <p>
 A <code>VersionException</code> is thrown if the <code>save</code> would make a result in
 a change to persistent storage that would violate the read-only status of a
 checked-in node.
 <p>
 A <code>LockException</code> is thrown if the <code>save</code> would result in a
 change to persistent storage that would violate a lock.
 <p>
 A <code>NoSuchNodeTypeException</code> is thrown if the <code>save</code> would result in the
 addition of a node with an unrecognized node type.
 <p>
 A <code>RepositoryException</code> will be thrown if another error
 occurs.

 @throws AccessDeniedException if any of the changes to be persisted would violate
 the access privileges of the this <code>Session</code>. Also thrown if  any of the
 changes to be persisted would cause the removal of a node that is currently
 referenced by a <code>REFERENCE</code> property that this Session
 <i>does not</i> have read access to.
 @throws ItemExistsException if any of the changes
 to be persisted would be prevented by the presence of an already existing
 item in the workspace.
 @throws LockException if any of the changes to be persisted would violate a lock.
 @throws ConstraintViolationException if any of the changes to be persisted would
 violate a node type or restriction. Additionally, a repository may use this
 exception to enforce implementation- or configuration-dependent restrictions.
 @throws InvalidItemStateException if any of the
 changes to be persisted conflicts with a change already persisted
 through another session and the implementation is such that this
 conflict can only be detected at save-time and therefore was not
 detected earlier, at change-time.
 @throws ReferentialIntegrityException if any of the
 changes to be persisted would cause the removal of a node that is currently
 referenced by a <code>REFERENCE</code> property that this <code>Session</code>
 has read access to.
 @throws VersionException if the <code>save</code> would make a result in
 a change to persistent storage that would violate the read-only status of a
 checked-in node.
 @throws LockException if the <code>save</code> would result in a
 change to persistent storage that would violate a lock.
 @throws NoSuchNodeTypeException if the <code>save</code> would result in the
 addition of a node with an unrecognized node type.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keepChanges" type="boolean"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If <code>keepChanges</code> is <code>false</code>, this method discards all pending changes
 currently recorded in this <code>Session</code> and returns all items to reflect the current
 saved state. Outside a transaction this state is simply the current state of persistent storage.
 Within a transaction, this state will reflect persistent storage as modified by changes that have
 been saved but not yet committed.
 <p>
 If <code>keepChanges</code> is true then pending change are not discarded but items that do not
 have changes pending have their state refreshed to reflect the current saved state, thus revealing
 changes made by other sessions.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="hasPendingChanges" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this session holds pending (that is, unsaved) changes;
 otherwise returns <code>false</code>.

 @return a boolean
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getValueFactory" return="javax.jcr.ValueFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns a <code>ValueFactory</code> that is used to create <code>Value</code> objects
 for use when setting repository properties.
 <p/>
 If writing to the repository is not supported (because this is a level 1-only
 implementation, for example) an <code>UnsupportedRepositoryOperationException</code>
 will be thrown.

 @return a <code>ValueFactory</code>
 @throws UnsupportedRepositoryOperationException if writing to the repository is not supported.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="checkPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="actions" type="java.lang.String"/>
      <exception name="AccessControlException" type="java.security.AccessControlException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Determines whether this <code>Session</code> has permission to perform the specified actions
 at the specified <code>absPath</code>. This method quietly returns if the access request is
 permitted, or throws a suitable <code>java.security.AccessControlException</code> otherwise.
 <p/>
 The <code>actions</code> parameter is a comma separated list of action strings. The following
 action strings are defined:
 <ul>
 <li>
 <code>add_node</code>: If <code>checkPermission(path, "add_node")</code> returns quietly, then
 this <code>Session</code> has permission to add a node at <code>path</code>, otherwise permission
 is denied.
 </li>
 <li>
 <code>set_property</code>: If <code>checkPermission(path, "set_property")</code> returns quietly,
 then this <code>Session</code> has permission to set (add or change) a property at <code>path</code>,
 otherwise permission is denied.
 </li>
 <li>
 <code>remove</code>: If <code>checkPermission(path, "remove")</code> returns quietly, then this
 <code>Session</code> has permission to remove an item at <code>path</code>, otherwise permission is denied.
 </li>
 <li>
 <code>read</code>: If <code>checkPermission(path, "read")</code> returns quietly, then this
 <code>Session</code> has permission to retrieve (and read the value of, in the case of a property)
 an item at <code>path</code>, otherwise permission is denied.
 </li>
 </ul>
 When more than one action is specified in the <code>actions</code> parameter, this method will only
 return quietly if this <code>Session</code> has permission to perform <i>all</i> of the listed
 actions at the specified path.
 <p/>
 The information returned through this method will only reflect access control policies
 and not other restrictions that may exist. For example, even though <code>checkPermission</code>
 may indicate that a particular <code>Session</code> may add a property at <code>/A/B/C</code>,
 the node type of the node at <code>/A/B</code> may prevent the addition of a property called
 <code>C</code>.

 @throws java.security.AccessControlException If permission is denied.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getImportContentHandler" return="org.xml.sax.ContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>org.xml.sax.ContentHandler</code> which can be used to
 push SAX events into the repository. If the incoming XML stream (in the
 form of SAX events) does not appear to be a JCR <i>system view</i> XML
 document then it is interpreted as a JCR <i>document view</i> XML
 document.
 <p/>
 The incoming XML is deserialized into a subtree of items immediately
 below the node at <code>parentAbsPath</code>.
 <p/>
 This method simply returns the <code>ContentHandler</code> without
 altering the state of the session; the actual deserialization to the
 session transient space is done through the methods of the
 <code>ContentHandler</code>. Invalid XML data
 will cause the <code>ContentHandler</code> to throw a
 <code>SAXException</code>.
 <p/>
 As SAX events are fed into the <code>ContentHandler</code>, the tree of
 new items is built in the transient storage of the session. In order to
 persist the new content, <code>save</code> must be called. The advantage
 of this through-the-session method is that (depending on which constraint
 checks the implementation leaves until <code>save</code>) structures that
 violate node type constraints can be imported, fixed and then saved. The
 disadvantage is that a large import will result in a large cache of
 pending nodes in the session. See
 {@link Workspace#getImportContentHandler} for a version of this
 method that does not go through the session.
 <p/>
 The flag <code>uuidBehavior</code> governs how the UUIDs of incoming
 (deserialized) nodes are handled. There are four options:
 <ul>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}: Incoming referenceable
 nodes are added in the same way that new node is added with
 <code>Node.addNode</code>. That is, they are either assigned newly
 created UUIDs upon addition or upon <code>save</code> (depending on the
 implementation). In either case, UUID collisions will not occur.
 </li>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}: If an
 incoming referenceable node has the same UUID as a node already existing
 in the workspace then the already existing node (and its subtree) is
 removed from wherever it may be in the workspace before the incoming node
 is added. Note that this can result in nodes #disappearing# from
 locations in the workspace that are remote from the location to which the
 incoming subtree is being written. Both the removal and the new addition
 will be persisted on <code>save</code>.
 </li>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}: If an
 incoming referenceable node has the same UUID as a node already existing
 in the workspace, then the already-existing node is replaced by the
 incoming node in the same position as the existing node. Note that this
 may result in the incoming subtree being disaggregated and #spread
 around# to different locations in the workspace. In the most extreme case
 this behavior may result in no node at all being added as child of
 <code>parentAbsPath</code>. This will occur if the topmost element of the
 incoming XML has the same UUID as an existing node elsewhere in the
 workspace. The change will be persisted on <code>save</code>.
 </li>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If an incoming
 referenceable node has the same UUID as a node already existing in the
 workspace then a <code>SAXException</code> is thrown by the
 <code>ContentHandler</code> during deserialization.
 </li>
 </ul>
 Unlike <code>Workspace.getImportContentHandler</code>, this method does not necessarily
 enforce all node type constraints during deserialization. Those that
 would be immediately enforced in a normal write method (<code>Node.addNode</code>,
 <code>Node.setProperty</code> etc.) of this implementation cause the returned
 <code>ContentHandler</code> to throw an immediate <code>SAXException</code> during deserialization.
 All other constraints are checked on save, just as they are in normal
 write operations. However, which node type constraints are enforced depends upon whether node type
 information in the imported data is respected, and this is an implementation-specific issue.
 <p/>
 A <code>SAXException</code> will also be thrown by the returned
 <code>ContentHandler</code> during deserialization if <code>uuidBehavior</code> is set to
 <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code> and an incoming node has the same
 UUID as the node at <code>parentAbsPath</code> or one of its ancestors.
 <p/>
 A <code>PathNotFoundException</code> is thrown either immediately or on <code>save</code>
 if no node exists at <code>parentAbsPath</code>. Implementations may differ on when this
 validation is performed
 <p/>
 A <code>ConstraintViolationException</code> is thrown either immediately or on <code>save</code>
 if the new subtree cannot be added to the node at parentAbsPath due to node-type or other
 implementation-specific constraints, and this can be determined before the first SAX event is sent.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> is thrown either immediately or on <code>save</code> if the node at
 <code>parentAbsPath</code> is versionable and checked-in, or is non-versionable but
 its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> is thrown either immediately or on <code>save</code>
 if a lock prevents the addition of the subtree. Implementations may differ on when this validation is performed.

 @param parentAbsPath the absolute path of a node under which (as child) the imported subtree will be
 built.
 @param uuidBehavior a four-value flag that governs how incoming UUIDs are handled.
 @return an org.xml.sax.ContentHandler whose methods may be called to feed SAX events
 into the deserializer.
 @throws PathNotFoundException if no node exists at <code>parentAbsPath</code> and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if the new subtree cannot be added to the node at
 <code>parentAbsPath</code> due to node-type or other implementation-specific constraints,
 and this implementation performs this validation immediately instead of waiting until <code>save</code>.
 @throws VersionException if the node at <code>parentAbsPath</code> is versionable
 and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws LockException if a lock prevents the addition of the subtree and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="importXML"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="in" type="java.io.InputStream"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidSerializedDataException" type="javax.jcr.InvalidSerializedDataException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Deserializes an XML document and adds the resulting item subtree as a
 child of the node at parentAbsPath.
 <p/>
 If the incoming XML stream does not appear to be a JCR <i>system view</i>
 XML document then it is interpreted as a <i>document view</i> XML
 document.
 <p/>
 The tree of new items is built in the transient storage of the Session.
 In order to persist the new content, <code>save</code> must be called.
 The advantage of this through-the-session method is that (depending on
 what constraint checks the implementation leaves until <code>save</code>)
 structures that violate node type constraints can be imported, fixed and
 then saved. The disadvantage is that a large import will result in a
 large cache of pending nodes in the session. See {@link
 Workspace#importXML} for a version of this method that does not go
 through the <code>Session</code>.
 <p/>
 The flag <code>uuidBehavior</code> governs how the UUIDs of incoming
 (deserialized) nodes are handled. There are four options:
 <ul>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}: Incoming referenceable nodes
 are added in the same way that new node is added with
 <code>Node.addNode</code>. That is, they are either assigned newly
 created UUIDs upon addition or upon <code>save</code> (depending on the
 implementation). In either case, UUID collisions will not occur.
 </li>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}: If an incoming
 referenceable node has the same UUID as a node already existing in the
 workspace then the already existing node (and its subtree) is removed
 from wherever it may be in the workspace before the incoming node is
 added. Note that this can result in nodes #disappearing# from locations
 in the workspace that are remote from the location to which the incoming
 subtree is being written. Both the removal and the new addition will be
 persisted on <code>save</code>.
 </li>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}: If an incoming
 referenceable node has the same UUID as a node already existing in the
 workspace, then the already-existing node is replaced by the incoming
 node in the same position as the existing node. Note that this may result
 in the incoming subtree being disaggregated and #spread around# to
 different locations in the workspace. In the most extreme case this
 behavior may result in no node at all being added as child of
 <code>parentAbsPath</code>. This will occur if the topmost element of the
 incoming XML has the same UUID as an existing node elsewhere in the
 workspace. The change will only be persisted on <code>save</code>.
 </li>
 <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If an incoming
 referenceable node has the same UUID as a node already existing in the
 workspace then an <code>ItemExistsException</code> is thrown.
 </li>
 </ul>
 Unlike {@link Workspace#importXML}, this method does not necessarily
 enforce all node type constraints during deserialization. Those that
 would be immediately enforced in a normal write method
 (<code>Node.addNode</code>, <code>Node.setProperty</code> etc.) of this
 implementation cause an immediate
 <code>ConstraintViolationException</code> during deserialization. All
 other constraints are checked on <code>save</code>, just as they are in
 normal write operations. However, which node type constraints are enforced
 depends upon whether node type information in the imported data is respected,
 and this is an implementation-specific issue.
 <p/>
 A <code>ConstraintViolationException</code> will also be thrown
 immediately if <code>uuidBehavior</code> is set to
 <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code> and an incoming node
 has the same UUID as the node at <code>parentAbsPath</code> or one of its
 ancestors.
 <p/>
 A <code>PathNotFoundException</code> is thrown either immediately or on <code>save</code>
 if no node exists at <code>parentAbsPath</code>. Implementations may differ on when this
 validation is performed
 <p/>
 A <code>ConstraintViolationException</code> is thrown either immediately or on <code>save</code>
 if the new subtree cannot be added to the node at parentAbsPath due to node-type or other
 implementation-specific constraints, and this can be determined before the first SAX event is sent.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> is thrown either immediately or on <code>save</code> if the node at
 <code>parentAbsPath</code> is versionable and checked-in, or is non-versionable but
 its nearest versionable ancestor is checked-in. Implementations may differ on when this validation is performed.
 <p/>
 A <code>LockException</code> is thrown either immediately or on <code>save</code>
 if a lock prevents the addition of the subtree. Implementations may differ on when this validation is performed.

 @param parentAbsPath the absolute path of the node below which the deserialized subtree is added.
 @param in The <code>Inputstream</code> from which the XML to be deserilaized is read.
 @param uuidBehavior a four-value flag that governs how incoming UUIDs are handled.

 @throws java.io.IOException if an error during an I/O operation occurs.
 @throws PathNotFoundException if no node exists at <code>parentAbsPath</code> and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws ItemExistsException if deserialization would overwrite an existing item and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws ConstraintViolationException if a node type or other implementation-specific
 constraint is violated that would be checked on a normal write method or if
 <code>uuidBehavior</code> is set to <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code>
 and an incoming node has the same UUID as the node at <code>parentAbsPath</code> or one
 of its ancestors.
 @throws VersionException if the node at <code>parentAbsPath</code> is versionable
 and checked-in, or its nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws InvalidSerializedDataException if incoming stream is not a valid XML document.
 @throws LockException if a lock prevents the addition of the subtree and this
 implementation performs this validation immediately instead of waiting until <code>save</code>..
 @throws RepositoryException is another error occurs.]]>
      </doc>
    </method>
    <method name="exportSystemView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="contentHandler" type="org.xml.sax.ContentHandler"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="SAXException" type="org.xml.sax.SAXException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subtree) at <code>absPath</code> into a series of SAX events by
 calling the methods of the supplied <code>org.xml.sax.ContentHandler</code>.
 The resulting XML is in the system view form. Note that <code>absPath</code>
 must be the path of a node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of <code>PropertyType.BINARY</code> will be
 serialized as if they are empty. That is, the existence of the property
 will be serialized, but its content will not appear in the serialized
 output (the <code>&lt;sv:value&gt;</code> element will have no content). Note that in the
 case of multi-value <code>BINARY</code> properties, the number of values in the
 property will be reflected in the serialized output, though they will all
 be empty. If <code>skipBinary</code> is false then the actual value(s) of each <code>BINARY</code>
 property is recorded using Base64 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the entire subtree
 rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's
 point of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to
 node type constraints) and the current session-mapping of namespaces
 are reflected in the output.
 <p>
 A <code>PathNotFoundException</code> is thrown if no node exists at <code>absPath</code>.
 <p>
 A <code>SAXException</code> is thrown if an error occurs while feeding events to the
 <code>ContentHandler</code>.

 @param absPath The path of the root of the subtree to be serialized.
 This must be the path to a node, not a property
 @param contentHandler The  <code>org.xml.sax.ContentHandler</code> to
 which the SAX events representing the XML serialization of the subtree
 will be output.
 @param skipBinary A <code>boolean</code> governing whether binary
 properties are to be serialized.
 @param noRecurse A <code>boolean</code> governing whether the subtree at
 absPath is to be recursed.

 @throws PathNotFoundException if no node exists at <code>absPath</code>.
 @throws org.xml.sax.SAXException if an error occurs while feeding events to the
 <code>org.xml.sax.ContentHandler</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="exportSystemView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subtree) at <code>absPath</code> as an XML stream and outputs it to
 the supplied <code>OutputStream</code>. The resulting XML is in the system
 view form. Note that <code>absPath</code> must be the path of a node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of <code>PropertyType.BINARY</code> will be
 serialized as if they are empty. That is, the existence of the property
 will be serialized, but its content will not appear in the serialized
 output (the <code>&lt;sv:value&gt;</code> element will have no content). Note that in the
 case of multi-value <code>BINARY</code> properties, the number of values in the
 property will be reflected in the serialized output, though they will all
 be empty. If <code>skipBinary</code> is false then the actual value(s) of each <code>BINARY</code>
 property is recorded using Base64 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the entire subtree
 rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's
 point of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to
 node type constraints) and the current session-mapping of namespaces
 are reflected in the output.
 <p>
 A <code>PathNotFoundException</code> is thrown if no node exists at <code>absPath</code>.
 <p>
 A <code>SAXException</code> is thrown if an error occurs while feeding events to the
 <code>ContentHandler</code>.

 @param absPath The path of the root of the subtree to be serialized.
 This must be the path to a node, not a property
 @param out The <code>OutputStream</code> to which the XML
 serialization of the subtree will be output.
 @param skipBinary A <code>boolean</code> governing whether binary
 properties are to be serialized.
 @param noRecurse A <code>boolean</code> governing whether the subtree at
 absPath is to be recursed.

 @throws PathNotFoundException if no node exists at <code>absPath</code>.
 @throws IOException if an error during an I/O operation occurs.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="exportDocumentView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="contentHandler" type="org.xml.sax.ContentHandler"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="SAXException" type="org.xml.sax.SAXException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subtree) at <code>absPath</code> into a series of SAX events by
 calling the methods of the supplied <code>org.xml.sax.ContentHandler</code>.
 The resulting XML is in the document view form. Note that <code>absPath</code>
 must be the path of a node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of <code>PropertyType.BINARY</code> will be
 serialized as if they are empty. That is, the existence of the property
 will be serialized, but its content will not appear in the serialized
 output (the value of the attribute will be empty). If <code>skipBinary</code> is false
 then the actual value(s) of each <code>BINARY</code> property is recorded using Base64
 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the entire subtree
 rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's
 point of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to
 node type constraints) and the current session-mapping of namespaces
 are reflected in the output.
 <p>
 A <code>PathNotFoundException</code> is thrown if no node exists at <code>absPath</code>.
 <p>
 A <code>SAXException</code> is thrown if an error occurs while feeding events to the
 <code>ContentHandler</code>.

 @param absPath The path of the root of the subtree to be serialized.
 This must be the path to a node, not a property
 @param contentHandler The  <code>org.xml.sax.ContentHandler</code> to
 which the SAX events representing the XML serialization of the subtree
 will be output.
 @param skipBinary A <code>boolean</code> governing whether binary
 properties are to be serialized.
 @param noRecurse A <code>boolean</code> governing whether the subtree at
 absPath is to be recursed.

 @throws PathNotFoundException if no node exists at <code>absPath</code>.
 @throws org.xml.sax.SAXException if an error occurs while feeding events to the
 <code>org.xml.sax.ContentHandler</code>.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="exportDocumentView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subtree) at <code>absPath</code> as an XML stream and outputs it to
 the supplied <code>OutputStream</code>. The resulting XML is in the document
 view form. Note that <code>absPath</code> must be the path of a node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of <code>PropertyType.BINARY</code> will be
 serialized as if they are empty. That is, the existence of the property
 will be serialized, but its content will not appear in the serialized
 output (the value of the attribute will be empty). If <code>skipBinary</code> is false
 then the actual value(s) of each <code>BINARY</code> property is recorded using Base64
 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the entire subtree
 rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's
 point of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to
 node type constraints) and the current session-mapping of namespaces
 are reflected in the output.
 <p>
 A <code>PathNotFoundException</code> is thrown if no node exists at <code>absPath</code>.
 <p>
 A <code>SAXException</code> is thrown if an error occurs while feeding events to the
 <code>ContentHandler</code>.

 @param absPath The path of the root of the subtree to be serialized.
 This must be the path to a node, not a property
 @param out The <code>OutputStream</code> to which the XML
 serialization of the subtree will be output.
 @param skipBinary A <code>boolean</code> governing whether binary
 properties are to be serialized.
 @param noRecurse A <code>boolean</code> governing whether the subtree at
 absPath is to be recursed.

 @throws PathNotFoundException if no node exists at <code>absPath</code>.
 @throws IOException if an error during an I/O operation occurs.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="setNamespacePrefix"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Within the scope of this session, rename a persistently registered
 namespace URI to the new prefix.  The renaming only affects operations
 done through this session. To clear all renamings the client must acquire
 a new session.
 <p>
 A prefix that is currently already mapped to some URI (either
 persistently in the repository <code>NamespaceRegistry</code> or transiently within
 this <code>Session</code>) cannot be remapped to a new URI using this method, since
 this would make any content stored using the old URI unreadable. An
 attempt to do this will throw a <code>NamespaceException</code>.
 <p>
 As well, a <code>NamespaceException</code> will be thrown if an attempt is made
 to remap an existing namespace URI to a prefix beginning with the characters "<code>xml</code>"
 (in any combination of case).
 <p>
 A <code>NamespaceException</code> will also be thrown if
 the specified uri is not among those registered in the NamespaceRegistry.

 @param prefix a string
 @param uri a string
 @throws NamespaceException if the specified uri is not registered or an attempt is
 made to remap to an illegal prefix.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getNamespacePrefixes" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all prefixes currently set for this session. This includes all
 those registered in the <code>NamespaceRegistry</code> but <i>not
 over-ridden</i> by a <code>Session.setNamespacePrefix</code>, plus those
 currently set locally by <code>Session.setNamespacePrefix</code>.

 @throws RepositoryException if an error occurs
 @return a string array]]>
      </doc>
    </method>
    <method name="getNamespaceURI" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[For a given prefix, returns the URI to which it is mapped as currently
 set in this <code>Session</code>. If the prefix is unknown, a <code>NamespaceException</code> is thrown.

 @param prefix a string
 @return a string
 @throws NamespaceException if the prefix is unknown.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getNamespacePrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the prefix to which the given URI is mapped

 @param uri a string
 @return a string
 @throws NamespaceException if the URI is unknown.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="logout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Releases all resources associated with this <code>Session</code>. This method should be called when a
 <code>Session</code> is no longer needed.]]>
      </doc>
    </method>
    <method name="isLive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Session</code> object is usable
 by the client. Otherwise, returns <code>false</code>. A usable
 <code>Session</code> is one that is neither logged-out, timed-out nor in
 any other way disconnected from the repository.

 @return <code>true</code> if this <code>Session</code> is usable,
  <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="addLockToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lt" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the specified lock token to this session. Holding a lock token allows the <code>Session</code> object of the
 lock owner to alter nodes that are locked by the lock specified by that particular lock token.

 @param lt a lock token (a string)]]>
      </doc>
    </method>
    <method name="getLockTokens" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing all lock tokens currently held by this session.

 @return an array of lock tokens (strings)]]>
      </doc>
    </method>
    <method name="removeLockToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lt" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes the specified lock token from this session.
 @param lt a lock token (a string)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>Session</code> object provides read and (in level 2) write access to the content of a
 particular workspace in the repository.
 <p/>
 The <code>Session</code> object is returned by {@link Repository#login}.
 It encapsulates both the authorization settings of a particular user (as specified by the
 passed <code>Credentials</code>)and a binding to the workspace specified by the
 <code>workspaceName</code> passed on <code>login</code>.
 <p/>
 Each <code>Session</code> object is associated one-to-one with a <code>Workspace</code> object.
 The <code>Workspace</code> object represents a "view" of an actual repository workspace entity
 as seen through the authorization settings of its associated <code>Session</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Session -->
  <!-- start class javax.jcr.SimpleCredentials -->
  <class name="SimpleCredentials" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Credentials"/>
    <constructor name="SimpleCredentials" type="java.lang.String, char[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new <code>SimpleCredentials</code> object, given a user ID
 and password.
 <p/>
 Note that the given password is cloned before it is stored
 in the new <code>SimpleCredentials</code> object. This should
 avoid the risk of having unnecessary references to password data
 lying around in memory.
 <p/>

 @param userID   the user ID
 @param password the user's password]]>
      </doc>
    </constructor>
    <method name="getPassword" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user password.
 <p/>
 Note that this method returns a reference to the password.
 It is the caller's responsibility to zero out the password information
 after it is no longer needed.

 @return the password]]>
      </doc>
    </method>
    <method name="getUserID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user ID.

 @return the user ID.]]>
      </doc>
    </method>
    <method name="setAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Stores an attribute in this credentials instance.

 @param name  a <code>String</code> specifying the name of the attribute
 @param value the <code>Object</code> to be stored]]>
      </doc>
    </method>
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the value of the named attribute as an <code>Object</code>,
 or <code>null</code> if no attribute of the given name exists.

 @param name a <code>String</code> specifying the name of the attribute
 @return	an <code>Object</code> containing the value of the attribute,
 or <code>null</code> if the attribute does not exist]]>
      </doc>
    </method>
    <method name="removeAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes an attribute from this credentials instance.

 @param name a <code>String</code> specifying the name of the attribute
             to remove]]>
      </doc>
    </method>
    <method name="getAttributeNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the attributes available to this
 credentials instance. This method returns an empty array
 if the credentials instance has no attributes available to it.

 @return a string array containing the names of the stored attributes]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<code>SimpleCredentials</code> implements the <code>Credentials</code>
 interface and represents simple user ID/password credentials.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.SimpleCredentials -->
  <!-- start class javax.jcr.UnsupportedRepositoryOperationException -->
  <class name="UnsupportedRepositoryOperationException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnsupportedRepositoryOperationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="UnsupportedRepositoryOperationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="UnsupportedRepositoryOperationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="UnsupportedRepositoryOperationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown by methods that are not supported by a particluar implementation]]>
    </doc>
  </class>
  <!-- end class javax.jcr.UnsupportedRepositoryOperationException -->
  <!-- start interface javax.jcr.Value -->
  <interface name="Value"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>String</code> representation of this value.
 <p>
 If this value cannot be converted to a string, a
 <code>ValueFormatException</code> is thrown.
 <p>
 If <code>getStream</code> has previously been called on this
 <code>Value</code> instance, an <code>IllegalStateException</code> is thrown.
 In this case a new <code>Value</code> instance must be acquired in order to
 successfully call <code>getString</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A <code>String</code> representation of the value of this property.
 @throws ValueFormatException if conversion to a <code>String</code> is not possible.
 @throws IllegalStateException if <code>getStream</code> has previously
 been called on this <code>Value</code> instance.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>InputStream</code> representation of this value.
 Uses the standard conversion to binary (see JCR specification)<p>
 <p>
 If a non-stream <code>get</code> method has previously been called on this
 <code>Value</code> instance, an <code>IllegalStateException</code> is thrown.
 In this case a new <code>Value</code> instance must be acquired in order to successfully call
 <code>getStream</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return An <code>InputStream</code> representation of this value.
 @throws IllegalStateException if a non-stream <code>get</code> method has previously
 been called on this <code>Value</code> instance.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>long</code> representation of this value.
 <p>
 If this value cannot be converted to a <code>long</code>,
 a <code>ValueFormatException</code> is thrown.
 <p>
 If <code>getStream</code> has previously been called on this
 <code>Value</code> instance, an <code>IllegalStateException</code> is thrown.
 In this case a new <code>Value</code> instance must be acquired in order to
 successfully call <code>getLong</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A <code>long</code> representation of this value.
 @throws ValueFormatException if conversion to an <code>long</code> is not possible.
 @throws IllegalStateException if <code>getStream</code> has previously
 been called on this <code>Value</code> instance.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>double</code> representation of this value.
 <p>
 If this value cannot be converted to a <code>double</code>, a
 <code>ValueFormatException</code> is thrown.
 <p>
 If <code>getStream</code> has previously been called on this
 <code>Value</code> instance, an <code>IllegalStateException</code> is thrown.
 In this case a new <code>Value</code> instance must be acquired in order to
 successfully call <code>getDouble</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A <code>double</code> representation of this value.
 @throws ValueFormatException if conversion to a <code>double</code> is not possible.
 @throws IllegalStateException if <code>getStream</code> has previously
 been called on this <code>Value</code> instance.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getDate" return="java.util.Calendar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Calendar</code> representation of this value.
 <p>
 The object returned is a copy of the stored value, so changes to it are not reflected in internal storage.
 <p>
 If this value cannot be converted to a <code>Calendar</code>, a
 <code>ValueFormatException</code> is thrown.
 <p>
 If <code>getStream</code> has previously been called on this
 <code>Value</code> instance, an <code>IllegalStateException</code> is thrown.
 In this case a new <code>Value</code> instance must be acquired in order to
 successfully call <code>getDate</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A <code>Calendar</code> representation of this value.
 @throws ValueFormatException if conversion to a <code>Calendar</code> is not possible.
 @throws IllegalStateException if <code>getStream</code> has previously
 been called on this <code>Value</code> instance.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Boolean</code> representation of this value.
 <p>
 If this value cannot be converted to a <code>Boolean</code>, a
 <code>ValueFormatException</code> is thrown.
 <p>
 If <code>getStream</code> has previously been called on this
 <code>Value</code> instance, an <code>IllegalStateException</code> is thrown.
 In this case a new <code>Value</code> instance must be acquired in order to
 successfully call <code>getBoolean</code>.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @return A <code>Boolean</code> representation of this value.
 @throws ValueFormatException if conversion to a <code>Boolean</code> is not possible.
 @throws IllegalStateException if <code>getStream</code> has previously
 been called on this <code>Value</code> instance.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>type</code> of this <code>Value</code>.
 One of:
 <ul>
 <li><code>PropertyType.STRING</code></li>
 <li><code>PropertyType.DATE</code></li>
 <li><code>PropertyType.BINARY</code></li>
 <li><code>PropertyType.DOUBLE</code></li>
 <li><code>PropertyType.LONG</code></li>
 <li><code>PropertyType.BOOLEAN</code></li>
 <li><code>PropertyType.NAME</code></li>
 <li><code>PropertyType.PATH</code></li>
 <li><code>PropertyType.REFERENCE</code></li>
 </ul>
 See <code>{@link PropertyType}</code>.
 <p>
 The type returned is that which was set at property creation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A generic holder for the value of a property. A <code>Value</code> object can be used without knowing the actual
 property type (<code>STRING</code>, <code>DOUBLE</code>, <code>BINARY</code> etc.).
 <p>
 Any implementation of this interface must adhere to the following behavior:
 <ul>
   <li>
     A <code>Value</code> object can be read using type-specific
     <code>get</code> methods. These methods are divided into two groups:
     <ul>
       <li>
         The non-stream <code>get</code> methods <code>getString()</code>, <code>getDate()</code>,
         <code>getLong()</code>, <code>getDouble()</code> and <code>getBoolean()</code>.
       </li>
       <li>
          <code>getStream()</code>.
       </li>
     </ul>
    </li>
   <li>
     Once a <code>Value</code> object has been read once using <code>getStream()</code>, all subsequent calls to
     <code>getStream()</code> will return the same <code>Stream</code> object. This may mean, for example, that the
     stream returned is fully or partially consumed. In order to get a fresh stream the <code>Value</code> object
     must be reacquired via {@link Property#getValue()} or {@link Property#getValues()}.
   </li>
   <li>
     Once a <code>Value</code> object has been read once using <code>getStream()</code>, any subsequent call to any
     of the non-stream <code>get</code> methods will throw an <code>IllegalStateException</code>. In order to
     successfully invoke a non-stream <code>get</code> method, the <code>Value</code> must be reacquired.
   </li>
   <li>
     Once a <code>Value</code> object has been read once using a non-stream get method, any subsequent call to
     <code>getStream()</code> will throw an <code>IllegalStateException</code>. In order to successfully invoke
     <code>getStream()</code>, the <code>Value</code> must be reacquired.
 </ul>
 <p/>
 Two <code>Value</code> instances, <code>v1</code> and <code>v2</code>, are considered equal if and only if:
 <ul>
 <li><code>v1.getType() == v2.getType()</code>, and,</li>
 <li><code>v1.getString().equals(v2.getString())</code></li>
 </ul>
 Actually comparing two <code>Value</code> instances by converting them to
 string form may not be practical in some cases (for example, if the values are very large
 binaries). Consequently, the above is intended as a normative definition of <code>Value</code> equality
 but not as a procedural test of equality. It is assumed that implementations will have efficient means
 of determining equality that conform with the above definition.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Value -->
  <!-- start interface javax.jcr.ValueFactory -->
  <interface name="ValueFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#STRING}
 with the specified <code>value</code>.

 @param value a <code>String</code>
 @return a <code>Value</code> of {@link PropertyType#STRING}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of the {@link PropertyType} specified by <code>type</code>
 with the specified <code>value</code>.

 A <code>ValueFormatException</code> is thrown if the specified <code>value</code> cannot
 be converted to the specifed <code>type</code>.

 @param value a <code>String</code>
 @param type one of the constants defined in {@link PropertyType}.
 @return a <code>Value</code> of {@link PropertyType} <code>type</code>.
 @throws ValueFormatException if the specified <code>value</code> cannot
 be converted to the specifed <code>type</code>.]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#LONG}
 with the specified <code>value</code>.

 @param value a <code>long</code>
 @return a <code>Value</code> of {@link PropertyType#LONG}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#DOUBLE}
 with the specified <code>value</code>.

 @param value a <code>double</code>
 @return a <code>Value</code> of {@link PropertyType#DOUBLE}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#BOOLEAN}
 with the specified <code>value</code>.

 @param value a <code>boolean</code>
 @return a <code>Value</code> of {@link PropertyType#BOOLEAN}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.Calendar"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#DATE}
 with the specified <code>value</code>.

 @param value a <code>Calendar</code>
 @return a <code>Value</code> of {@link PropertyType#DATE}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of <code>PropertyType.BINARY</code>
 with a value consisting of the content of the specified <code>InputStream</code>.

 @param value an <code>InputStream</code>
 @return a <code>Value</code> of {@link PropertyType#BINARY}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Node"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#REFERENCE}
 that holds the UUID of the specified <code>Node</code>. This <code>Value</code>
 object can then be used to set a property that will be a reference to that
 <code>Node</code>.<p/>
 <p/>
 A <code>RepositoryException</code> is thrown if the specified <code>Node</code>
 is not referencable, the current <code>Session</code> is no longer active, or another
 error occurs.

 @param value a <code>Node</code>
 @return a <code>Value</code> of {@link PropertyType#REFERENCE}
 @throws RepositoryException if the specified <code>Node</code>
 is not referencable, the current <code>Session</code> is no longer active, or another
 error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>ValueFactory</code> object provides methods for the creation Value objects that can then
 be used to set properties.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.ValueFactory -->
  <!-- start class javax.jcr.ValueFormatException -->
  <class name="ValueFormatException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ValueFormatException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ValueFormatException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ValueFormatException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ValueFormatException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when an attempt is made to assign a
 value to a property that has an invalid format, given the type of the
 property. Also thrown if an attempt is made to read the value of
 a property using a type-specific read method of a type into which it is not
 convertable.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ValueFormatException -->
  <!-- start interface javax.jcr.Workspace -->
  <interface name="Workspace"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSession" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>Session</code> object through which this <code>Workspace</code>
 object was acquired.

 @return a <code>{@link Session}</code> object.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the actual persistent workspace represented by this
 <code>Workspace</code> object.

 @return the name of this workspace.]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method copies the node at <code>srcAbsPath</code> to the new location at
 <code>destAbsPath</code>. If successful, the change is persisted immediately,
 there is no need to call <code>save</code>.
 <p/>
 Copies of referenceable nodes (nodes with UUIDs) are automatically given new UUIDs.
 <p/>
 The <code>destAbsPath</code> provided must not
 have an index on its final element. If it does then a <code>RepositoryException</code>
 is thrown. Strictly speaking, the <code>destAbsPath</code> parameter is actually an <i>absolute path</i>
 to the parent node of the new location, appended with the new <i>name</i> desired for the
 copied node. It does not specify a position within the child node
 ordering. If ordering is supported by the node type of
 the parent node of the new location, then the new copy of the node is appended to the end of the
 child node list.
 <p/>
 This method cannot be used to copy just an individual property by itself.
 It copies an entire node and its subtree (including, of course, any properties contained therein).
 <p/>
 A <code>ConstraintViolationException</code> is thrown if the operation would violate a node-type
 or other implementation-specific constraint.
 <p/>
 A <code>VersionException</code> is thrown if the parent node of <code>destAbsPath</code> is
 versionable and checked-in, or is non-versionable but its nearest versionable ancestor is
 checked-in.
 <p/>
 An <code>AccessDeniedException</code> is thrown if the current session (i.e. the session that
 was used to acquire this <code>Workspace</code> object) does not have sufficient access rights
 to complete the operation.
 <p/>
 A <code>PathNotFoundException</code> is thrown if the node at <code>srcAbsPath</code> or the
 parent of <code>destAbsPath</code> does not exist.
 <p/>
 An <code>ItemExistException</code> is thrown if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the copy.

 @param srcAbsPath the path of the node to be copied.
 @param destAbsPath the location to which the node at <code>srcAbsPath</code>
 is to be copied.
 @throws ConstraintViolationException if the operation would violate a
 node-type or other implementation-specific constraint.
 @throws VersionException if the parent node of <code>destAbsPath</code> is
 versionable and checked-in, or is non-versionable but its nearest versionable ancestor is
 checked-in.
 @throws AccessDeniedException if the current session does not have
 sufficient access rights to complete the operation.
 @throws PathNotFoundException if the node at <code>srcAbsPath</code> or
 the parent of <code>destAbsPath</code> does not exist.
 @throws ItemExistsException if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed.
 @throws LockException if a lock prevents the copy.
 @throws RepositoryException if the last element of <code>destAbsPath</code>
 has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method copies the subtree at <code>srcAbsPath</code> in <code>srcWorkspace</code>
 to <code>destAbsPath</code> in <code>this</code> workspace. Unlike <code>clone</code>,
 this method <i>does</i> assign new UUIDs to the new copies of referenceable nodes.
 This operation is performed entirely within the persistent workspace, it does not involve
 transient storage and therefore does not require a <code>save</code>.
 <p/>
 The <code>destAbsPath</code> provided must not
 have an index on its final element. If it does then a <code>RepositoryException</code>
 is thrown. Strictly speaking, the <code>destAbsPath</code> parameter is actually an <i>absolute path</i>
 to the parent node of the new location, appended with the new <i>name</i> desired for the
 copied node. It does not specify a position within the child node
 ordering. If ordering is supported by the node type of
 the parent node of the new location, then the new copy of the node is appended to the end of the
 child node list.
 <p/>
 This method cannot be used to copy just an individual property by itself.
 It copies an entire node and its subtree (including, of course, any properties contained therein).
 <p/>
 A <code>NoSuchWorkspaceException</code> is thrown if <code>srcWorkspace</code> does not
 exist or if the current Session does not have permission to access it.
 <p/>
 A <code>ConstraintViolationException</code> is thrown if the operation would violate a node-type
 or other implementation-specific constraint.
 <p/>
 A <code>VersionException</code> is thrown if the parent node of <code>destAbsPath</code> is
 versionable and checked-in, or is non-versionable but its nearest versionable ancestor is
 checked-in.
 <p/>
 An <code>AccessDeniedException</code> is thrown if the current session (i.e. the session that
 was used to acquire this <code>Workspace</code> object) does not have sufficient access rights
 to complete the operation.
 <p/>
 A <code>PathNotFoundException</code> is thrown if the node at <code>srcAbsPath</code> in
 <code>srcWorkspace</code> or the parent of <code>destAbsPath</code> in this workspace does not exist.
 <p/>
 An <code>ItemExistException</code> is thrown if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the copy.

 @param srcWorkspace the name of the workspace from which the copy is to be made.
 @param srcAbsPath the path of the node to be copied.
 @param destAbsPath the location to which the node at <code>srcAbsPath</code>
 is to be copied in <code>this</code> workspace.
 @throws NoSuchWorkspaceException if <code>srcWorkspace</code> does not
 exist or if the current <code>Session</code> does not have permission to access it.
 @throws ConstraintViolationException if the operation would violate a
 node-type or other implementation-specific constraint
 @throws VersionException if the parent node of <code>destAbsPath</code> is
 versionable and checked-in, or is non-versionable but its nearest versionable ancestor is
 checked-in.
 @throws AccessDeniedException if the current session does have permission to access
 <code>srcWorkspace</code> but otherwise does not have sufficient access rights to
 complete the operation.
 @throws PathNotFoundException if the node at <code>srcAbsPath</code> in <code>srcWorkspace</code> or
 the parent of <code>destAbsPath</code> in this workspace does not exist.
 @throws ItemExistsException if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed.
 @throws LockException if a lock prevents the copy.
 @throws RepositoryException if the last element of <code>destAbsPath</code>
 has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="clone"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Clones the subtree at the node <code>srcAbsPath</code> in <code>srcWorkspace</code> to the new location at
 <code>destAbsPath</code> in <code>this</code> workspace. This method does not assign new UUIDs to
 the new nodes but preserves the UUIDs (if any) of their respective source nodes.
 <p/>
 If <code>removeExisting</code> is true and an existing node in this workspace
 (the destination workspace) has the same UUID as a node being cloned from
 <code>srcWorkspace</code>, then the incoming node takes precedence, and the
 existing node (and its subtree) is removed. If <code>removeExisting</code>
 is false then a UUID collision causes this method to throw a
 <code>ItemExistsException</code> and no changes are made.
 <p/>
 If successful, the change is persisted immediately, there is no need to call <code>save</code>.
 <p/>
 The <code>destAbsPath</code> provided must not
 have an index on its final element. If it does then a <code>RepositoryException</code>
 is thrown. Strictly speaking, the <code>destAbsPath</code> parameter is actually an <i>absolute path</i>
 to the parent node of the new location, appended with the new <i>name</i> desired for the
 cloned node. It does not specify a position within the child node
 ordering. If ordering is supported by the node type of the parent node of the new
 location, then the new clone of the node is appended to the end of the child node list.
 <p/>
 This method cannot be used to clone just an individual property by itself. It clones an
 entire node and its subtree (including, of course, any properties contained therein).
 <p/>
 A <code>NoSuchWorkspaceException</code> is thrown if <code>srcWorkspace</code> does not
 exist or if the current <code>Session</code> does not have permission to access it.
 <p/>
 A <code>ConstraintViolationException</code> is thrown if the operation would violate a node-type
 or other implementation-specific constraint.
 <p/>
 A <code>VersionException</code> is thrown if the parent node of <code>destAbsPath</code> is
 versionable and checked-in, or is non-versionable but its nearest versionable ancestor is
 checked-in. This exception will also be thrown if <code>removeExisting</code> is <code>true</code>,
 and a UUID conflict occurs that would require the moving and/or altering of a node that is checked-in.
 <p/>
 An <code>AccessDeniedException</code> is thrown if the current session (i.e. the session that
 was used to acquire this <code>Workspace</code> object) does not have sufficient access rights
 to complete the operation.
 <p/>
 A <code>PathNotFoundException</code> is thrown if the node at <code>srcAbsPath</code> in
 <code>srcWorkspace</code> or the parent of <code>destAbsPath</code> in this workspace does not exist.
 <p/>
 An <code>ItemExistsException</code> is thrown if a node or property already exists at
 <code>destAbsPath</code>
 <p/>
 An <code>ItemExistException</code> is thrown if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed or if <code>removeExisting</code> is false and a
 UUID conflict occurs.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the clone.

 @param srcWorkspace The name of the workspace from which the node is to be copied.
 @param srcAbsPath the path of the node to be copied in <code>srcWorkspace</code>.
 @param destAbsPath the location to which the node at <code>srcAbsPath</code>
 is to be copied in <code>this</code> workspace.
 @param removeExisting if <code>false</code> then this method throws an
 <code>ItemExistsException</code> on UUID conflict with an incoming node.
 If <code>true</code> then a UUID conflict is resolved by removing the existing node
 from its location in this workspace and cloning (copying in) the one from
 <code>srcWorkspace</code>.

 @throws NoSuchWorkspaceException if <code>destWorkspace</code> does not exist.
 @throws ConstraintViolationException if the operation would violate a
 node-type or other implementation-specific constraint.
 @throws VersionException if the parent node of <code>destAbsPath</code> is
 versionable and checked-in, or is non-versionable but its nearest versionable ancestor is
 checked-in. This exception will also be thrown if <code>removeExisting</code> is <code>true</code>,
 and a UUID conflict occurs that would require the moving and/or altering of a node that is checked-in.
 @throws AccessDeniedException if the current session does not have
 sufficient access rights to complete the operation.
 @throws PathNotFoundException if the node at <code>srcAbsPath</code> in
 <code>srcWorkspace</code> or the parent of <code>destAbsPath</code> in this workspace does not exist.
 @throws ItemExistsException if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed or if <code>removeExisting</code> is false and a
 UUID conflict occurs.
 @throws LockException if a lock prevents the clone.
 @throws RepositoryException if the last element of <code>destAbsPath</code>
 has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Moves the node at <code>srcAbsPath</code> (and its entire subtree) to the
 new location at <code>destAbsPath</code>. If successful,
 the change is persisted immediately, there is no need to call <code>save</code>.
 Note that this is in contrast to {@link Session#move} which operates within the
 transient space and hence requires a <code>save</code>.
 <p/>
 The <code>destAbsPath</code> provided must not
 have an index on its final element. If it does then a <code>RepositoryException</code>
 is thrown. Strictly speaking, the <code>destAbsPath</code> parameter is actually an <i>absolute path</i>
 to the parent node of the new location, appended with the new <i>name</i> desired for the
 moved node. It does not specify a position within the child node
 ordering. If ordering is supported by the node type of
 the parent node of the new location, then the newly moved node is appended to the end of the
 child node list.
 <p/>
 This method cannot be used to move just an individual property by itself.
 It moves an entire node and its subtree (including, of course, any properties contained therein).
 <p/>
 A <code>ConstraintViolationException</code> is thrown if the operation would violate a node-type
 or other implementation-specific constraint.
 <p/>
 A <code>VersionException</code> is thrown if the parent node of <code>destAbsPath</code>
 or the parent node of <code>srcAbsPath</code> is versionable and checked-in, or is
 non-versionable but its nearest versionable ancestor is checked-in.
 <p/>
 An <code>AccessDeniedException</code> is thrown if the current session (i.e. the session that
 was used to acquire this <code>Workspace</code> object) does not have sufficient access rights
 to complete the operation.
 <p/>
 A <code>PathNotFoundException</code> is thrown if the node at <code>srcAbsPath</code> or the
 parent of <code>destAbsPath</code> does not exist.
 <p/>
 An <code>ItemExistException</code> is thrown if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed.
 <p/>
 A <code>LockException</code> if a lock prevents the move.

 @param srcAbsPath the path of the node to be moved.
 @param destAbsPath the location to which the node at <code>srcAbsPath</code>
 is to be moved.
 @throws ConstraintViolationException if the operation would violate a
 node-type or other implementation-specific constraint
 @throws VersionException if the parent node of <code>destAbsPath</code>
 or the parent node of <code>srcAbsPath</code> is versionable and checked-in,
 or is non-versionable but its nearest versionable ancestor is checked-in.
 @throws AccessDeniedException if the current session (i.e. the session that
 was used to aqcuire this <code>Workspace</code> object) does not have
 sufficient access rights to complete the operation.
 @throws PathNotFoundException if the node at <code>srcAbsPath</code> or
 the parent of <code>destAbsPath</code> does not exist.
 @throws ItemExistsException if a property already exists at
 <code>destAbsPath</code> or a node already exist there, and same name
 siblings are not allowed.
 @throws LockException if a lock prevents the move.
 @throws RepositoryException if the last element of <code>destAbsPath</code>
 has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versions" type="javax.jcr.version.Version[]"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores a set of versions at once. Used in cases where a "chicken and egg" problem of
 mutually referring <code>REFERENCE</code> properties would prevent the restore in any
 serial order.
 <p>
 If the restore succeeds the changes made to <code>this</code> node are
 persisted immediately, there is no need to call <code>save</code>.
 <p>
 The following restrictions apply to the set of versions specified:
 <p>
 If <code>S</code> is the set of versions being restored simultaneously,
 <ul>
   <li>
    For every version <code>V</code> in <code>S</code> that corresponds to
     a <i>missing</i> node, there must also be a parent of V in S.
   </li>
   <li>
     <code>S</code> must contain at least one version that corresponds to
     an existing node in the workspace.
   </li>
   <li>
     No <code>V</code> in <code>S</code> can be a root version (<code>jcr:rootVersion</code>).
   </li>
 </ul>
 If any of these restrictions does not hold, the restore will fail
 because the system will be unable to determine the path locations to which
 one or more versions are to be restored. In this case a
 <code>VersionException</code> is thrown.
 <p/>
 The versionable nodes in this workspace that correspond to the versions being restored
 define a set of (one or more) subtrees. A UUID collision occurs when this workspace
 contains a node <i>outside these subtrees</i> that has the same UUID as one of the nodes
 that would be introduced by the <code>restore</code> operation <i>into one of these subtrees</i>.
 The result in such a case is governed by the <code>removeExisting</code> flag.
 If <code>removeExisting</code> is <code>true</code> then the incoming node takes precedence,
 and the existing node (and its subtree) is removed. If <code>removeExisting</code>
 is <code>false</code> then a <code>ItemExistsException</code> is thrown and no changes are made.
 Note that this applies not only to cases where the restored
 node itself conflicts with an existing node but also to cases where a conflict occurs with any
 node that would be introduced into the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have <code>OnParentVersion</code> settings of
 <code>COPY</code> or <code>VERSION</code> are also governed by the <code>removeExisting</code> flag.
 <p/>
 An <code>UnsupportedRepositoryOperationException</code> is thrown if one or more of the nodes to be restored
 is not versionable.
 <p/>
 An <code>InvalidItemStateException</code> is thrown if this <code>Session</code> (not necessarily this <code>Node</code>)
 has pending unsaved changes.
 <p/>
 A <code>LockException</code> is thrown if a lock prevents the restore.

 @param versions The set of versions to be restored
 @param removeExisting governs what happens on UUID collision.

 @throws ItemExistsException if <code>removeExisting</code> is <code>false</code>
 and a UUID collision occurs with a node being restored.
 @throws UnsupportedRepositoryOperationException if one or more of the nodes to be
 restored is not versionable.
 @throws VersionException if the set of versions to be restored is such that the
 original path location of one or more of the versions cannot be determined or
 if the <code>restore</code> would change the state of a existing verisonable
 node that is currently checked-in or if a root version (<code>jcr:rootVersion</code>)
 is among those being restored.
 @throws LockException if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not necessarily this <code>Node</code>) has pending unsaved changes.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getQueryManager" return="javax.jcr.query.QueryManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Gets the <code>QueryManager</code>.
 Returns the <code>QueryManager</code> object, through search methods are accessed.

 @throws RepositoryException if an error occurs.
 @return the <code>QueryManager</code> object.]]>
      </doc>
    </method>
    <method name="getNamespaceRegistry" return="javax.jcr.NamespaceRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>NamespaceRegistry</code> object, which is used to access information
 and (in level 2) set the mapping between namespace prefixes and URIs.

 @throws RepositoryException if an error occurs.
 @return the <code>NamespaceRegistry</code>.]]>
      </doc>
    </method>
    <method name="getNodeTypeManager" return="javax.jcr.nodetype.NodeTypeManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>NodeTypeManager</code> through which node type
 information can be queried. There is one node type registry per
 repository, therefore the <code>NodeTypeManager</code> is not
 workspace-specific; it provides introspection methods for the
 global, repository-wide set of available node types.

 @throws RepositoryException if an error occurs.
 @return a <code>NodeTypeManager</code> object.]]>
      </doc>
    </method>
    <method name="getObservationManager" return="javax.jcr.observation.ObservationManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If the the implementation supports observation
 this method returns the <code>ObservationManager</code> object;
 otherwise it throws an <code>UnsupportedRepositoryOperationException</code>.

 @throws UnsupportedRepositoryOperationException if the implementation does not support observation.
 @throws RepositoryException if an error occurs.

 @return an <code>ObservationManager</code> object.]]>
      </doc>
    </method>
    <method name="getAccessibleWorkspaceNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an string array containing the names of all workspaces
 in this repository that are accessible to this user, given the
 <code>Credentials</code> that were used to get the <code>Session</code>
 tied to this <code>Workspace</code>.
 <p/>
 In order to access one of the listed workspaces, the user performs another
 <code>Repository.login</code>, specifying the name of the desired workspace,
 and receives a new <code>Session</code> object.

 @return string array of names of accessible workspaces.
 @throws RepositoryException]]>
      </doc>
    </method>
    <method name="getImportContentHandler" return="org.xml.sax.ContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>org.xml.sax.ContentHandler</code> which can be used to push SAX events into the repository.
 If the incoming XML stream (in the form of SAX events) does not appear to be a JCR system view XML document then it is
 interpreted as a document view XML document.
 <p>
 The incoming XML is deserialized into a subtree of items immediately below the node at
 <code>parentAbsPath</code>.
 <p>
 This method simply returns the <code>ContentHandler</code> without altering the state of the
 repository; the actual deserialization is done through the methods of the <code>ContentHandler</code>.
 Invalid XML data will cause the <code>ContentHandler</code> to throw a <code>SAXException</code>.
 <p>
 As SAX events are fed into the <code>ContentHandler</code>, changes are made directly at the
 workspace level, without going through the <code>Session</code>. As a result, there is not need
 to call <code>save</code>. The advantage of this
 direct-to-workspace method is that a large import will not result in a large cache of pending
 nodes in the <code>Session</code>. The disadvantage is that structures that violate node type constraints
 cannot be imported, fixed and then saved. Instead, a constraint violation will cause the
 <code>ContentHandler</code> to throw a <code>SAXException</code>. See <code>Session.getImportContentHandler</code> for a version of
 this method that <i>does</i> go through the <code>Session</code>.
 <p>
 The flag <code>uuidBehavior</code> governs how the UUIDs of incoming (deserialized) nodes are
 handled. There are four options:
 <ul>
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}: Incoming referenceable nodes are assigned newly
 created UUIDs upon additon to the workspace. As a result UUID collisions never occur.
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}: If an incoming referenceable node
 has the same UUID as a node already existing in the workspace, then the already exisitng node
 (and its subtree) is removed from wherever it may be in the workspace before the incoming node
 is added. Note that this can result in nodes "disappearing" from locations in the workspace that
 are remote from the location to which the incoming subtree is being written.
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}: If an incoming referenceable node
 has the same UUID as a node already existing in the workspace then the already existing node
 is replaced by the incoming node in the same position as the existing node. Note that this may
 result in the incoming subtree being disaggregated and "spread around" to different locations
 in the workspace. In the most extreme case this behavior may result in no node at all
 being added as child of <code>parentAbsPath</code>. This will occur if the topmost element
 of the incoming XML has the same UUID as an existing node elsewhere in the workspace.
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If an incoming referenceable node
 has the same UUID as a node already existing in the workspace then a SAXException
 is thrown by the returned <code>ContentHandler</code> during deserialization.
 </ul>
 A <code>SAXException</code> will be thrown by the returned <code>ContentHandler</code>
 during deserialization if the top-most element of the incoming XML would deserialize to
 a node with the same name as an existing child of <code>parentAbsPath</code> and that
 child does not allow same-name siblings.
 <p>
 A <code>SAXException</code> will also be thrown by the returned <code>ContentHandler</code>
 during deserialzation if <code>uuidBehavior</code> is set to
 <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code> and an incoming node has the same UUID as
 the node at <code>parentAbsPath</code> or one of its ancestors.
 <p>
 A <code>PathNotFoundException</code> is thrown if no node exists at <code>parentAbsPath</code>.
 <p>
 A <code>ConstraintViolationException</code> is thrown if the new subtree cannot be added to the node at
 <code>parentAbsPath</code> due to node-type or other implementation-specific constraints, and this can
 be determined before the first SAX event is sent. Unlike {@link Session#getImportContentHandler},
 this method also enforces node type constraints by throwing <code>SAXException</code>s during
 deserialization. However, which node type constraints are enforced depends upon whether node type
 information in the imported data is respected, and this is an implementation-specific issue.
 <p/>
 A <code>VersionException</code> is thrown if the node at <code>parentAbsPath</code> is versionable
 and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
 <p>
 A <code>LockException</code> is thrown if a lock prevents the addition ofthe subtree.
 <p>
 An <code>AccessDeniedException</code> is thrown if the session associated with this <code>Workspace</code> object does not have
 sufficient permissions to perform the import.

 @param parentAbsPath the absolute path of a node under which (as child) the imported subtree will be built.
 @param uuidBehavior a four-value flag that governs how incoming UUIDs are handled.
 @return an org.xml.sax.ContentHandler whose methods may be called to feed SAX events into the deserializer.

 @throws PathNotFoundException if no node exists at <code>parentAbsPath</code>.
 @throws ConstraintViolationException if the new subtree cannot be added to the node at
 <code>parentAbsPath</code> due to node-type or other implementation-specific constraints,
 and this can be determined before the first SAX event is sent.
 @throws VersionException if the node at <code>parentAbsPath</code> is versionable
 and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
 @throws LockException if a lock prevents the addition of the subtree.
 @throws AccessDeniedException if the session associated with this <code>Workspace</code> object does not have
 sufficient permissions to perform the import.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="importXML"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="in" type="java.io.InputStream"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="InvalidSerializedDataException" type="javax.jcr.InvalidSerializedDataException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Deserializes an XML document and adds the resulting item subtree as a child of the node at
 <code>parentAbsPath</code>.
 <p>
 If the incoming XML stream does not appear to be a JCR system view XML document then it is interpreted as a
 <b>document view</b> XML document.
 <p>
 Changes are made directly at the workspace level, without going through the <code>Session</code>.
 As a result, there is not need to call <code>save</code>. The advantage of this
 direct-to-workspace method is that a large import will not result in a large cache of
 pending nodes in the <code>Session</code>. The disadvantage is that invalid data cannot
 be imported, fixed and then saved. Instead, invalid data will cause this method to throw an
 <code>InvalidSerializedDataException</code>. See <code>Session.importXML</code> for
 a version of this method that <i>does</i> go through the <code>Session</code>.
 <p/>
 The flag <code>uuidBehavior</code> governs how the UUIDs of incoming (deserialized) nodes are
 handled. There are four options:
 <ul>
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}: Incoming referenceable nodes are assigned newly
 created UUIDs upon additon to the workspace. As a result UUID collisions never occur.
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}: If an incoming referenceable node
 has the same UUID as a node already existing in the workspace then the already exisitng node
 (and its subtree) is removed from wherever it may be in the workspace before the incoming node
 is added. Note that this can result in nodes "disappearing" from locations in the workspace that
 are remote from the location to which the incoming subtree is being written. If an incoming node
 has the same UUID as the existing root node of this workspace then
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}: If an incoming referenceable node
 has the same UUID as a node already existing in the workspace then the already existing node
 is replaced by the incoming node in the same position as the existing node. Note that this may
 result in the incoming subtree being disaggregated and "spread around" to different locations
 in the workspace. In the most extreme edge case this behavior may result in no node at all
 being added as child of <code>parentAbsPath</code>. This will occur if the topmost element
 of the incoming XML has the same UUID as an existing node elsewhere in the workspace.
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If an incoming referenceable node
 has the same UUID as a node already existing in the workspace then an <code>ItemExistsException</code>
 is thrown.
 </ul>
 An <code>ItemExistsException</code> will be thrown if <code>uuidBehavior</code>
 is set to <code>IMPORT_UUID_CREATE_NEW</code> or <code>IMPORT_UUID_COLLISION_THROW</code>
 and the import would would overwrite an existing child of <code>parentAbsPath</code>.
 <p>
 An IOException is thrown if an I/O error occurs.
 <p>
 If no node exists at <code>parentAbsPath</code>, a <code>PathNotFoundException</code> is thrown.
 <p>
 An ItemExisitsException is thrown if the top-most element of the incoming XML would deserialize
 to a node with the same name as an existing child of <code>parentAbsPath</code> and that
 child does not allow same-name siblings, or if a <code>uuidBehavior</code> is set to
 <code>IMPORT_UUID_COLLISION_THROW</code> and a UUID collision occurs.
 <p>
 If node-type or other implementation-specific constraints
 prevent the addition of the subtree, a <code>ConstraintViolationException</code> is thrown.
 <p>
 A <code>ConstraintViolationException</code> will also be thrown if <code>uuidBehavior</code>
 is set to <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code> and an incoming node has the same
 UUID as the node at <code>parentAbsPath</code> or one of its ancestors.
 <p>
 A <code>VersionException</code> is thrown if the node at <code>parentAbsPath</code> is versionable
 and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
 <p>
 A <code>LockException</code> is thrown if a lock prevents the addition of the subtree.
 <p>
 An <code>AccessDeniedException</code> is thrown if the session associated with this <code>Workspace</code> object does not have
 sufficient permissions to perform the import.

 @param parentAbsPath the absolute path of the node below which the deserialized subtree is added.
 @param in The <code>Inputstream</code> from which the XML to be deserilaized is read.
 @param uuidBehavior a four-value flag that governs how incoming UUIDs are handled.

 @throws java.io.IOException if an error during an I/O operation occurs.
 @throws PathNotFoundException if no node exists at <code>parentAbsPath</code>.
 @throws ConstraintViolationException if node-type or other implementation-specific constraints
 prevent the addition of the subtree or if <code>uuidBehavior</code>
 is set to <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code> and an incoming node has the same
 UUID as the node at <code>parentAbsPath</code> or one of its ancestors.
 @throws VersionException if the node at <code>parentAbsPath</code> is versionable
 and checked-in, or is non-versionable but its nearest versionable ancestor is checked-in.
 @throws InvalidSerializedDataException if incoming stream is not a valid XML document.
 @throws ItemExistsException if the top-most element of the incoming XML would deserialize
 to a node with the same name as an existing child of <code>parentAbsPath</code> and that
 child does not allow same-name siblings, or if a <code>uuidBehavior</code> is set to
 <code>IMPORT_UUID_COLLISION_THROW</code> and a UUID collision occurs.
 @throws LockException if a lock prevents the addition of the subtree.
 @throws AccessDeniedException if the session associated with this <code>Workspace</code> object does not have
 sufficient permissions to perform the import.
 @throws RepositoryException is another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>Workspace</code> object represents a "view" of an actual repository workspace
 entity as seen through the authorization settings of its associated <code>Session</code>.
 Each <code>Workspace</code> object is associated one-to-one with a <code>Session</code>
 object. The <code>Workspace</code> object can be acquired by calling
 <code>{@link Session#getWorkspace()}</code> on the associated <code>Session</code> object.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Workspace -->
</package>
<package name="javax.jcr.lock">
  <!-- start interface javax.jcr.lock.Lock -->
  <interface name="Lock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getLockOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user ID of the user who owns this lock. This is the value of the
 <code>jcr:lockOwner</code> property of the lock-holding node. It is also the
 value returned by <code>Session.getUserID</code> at the time that the lock was
 placed. The lock owner's identity is only provided for informational purposes.
 It does not govern who can perform an unlock or make changes to the locked nodes;
 that depends entirely upon who the token holder is.
 @return a user ID.]]>
      </doc>
    </method>
    <method name="isDeep" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is a deep lock; <code>false</code> otherwise.

 @return a boolean]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lock holding node. Note that <code>N.getLock().getNode()</code>
 (where <code>N</code> is a locked node) will only return <code>N</code>
 if <code>N</code> is the lock holder. If <code>N</code> is in the subtree
 of the lock holder, <code>H</code>, then this call will return <code>H</code>.

 @return an <code>Node</code>.]]>
      </doc>
    </method>
    <method name="getLockToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[May return the lock token for this lock.
 <p/>
 If this <code>Session</code> holds the lock token for this lock, then this method will
 return that lock token. If this <code>Session</code> does not hold the applicable lock
 token then this method will return null.

 @return a <code>String</code>.]]>
      </doc>
    </method>
    <method name="isLive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns true if this <code>Lock</code> object represents a lock that is currently in effect.
 If this lock has been unlocked either explicitly or due to an implementation-specific limitation
 (like a timeout) then it returns <code>false</code>. Note that this method is intended for
 those cases where one is holding a <code>Lock</code> Java object and wants to find out
 whether the lock (the JCR-level entity that is attached to the lockable node) that this
 object originally represented still exists. For example, a timeout or explicit
 <code>unlock</code> will remove a lock from a node but the <code>Lock</code>
 Java object corresponding to that lock may still exist, and in that case its
 <code>isLive</code> method will return <code>false</code>.
 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="isSessionScoped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is a session-scoped lock.
 Returns <code>false</code> if this is an open-scoped lock.
 @return a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this lock's time-to-live is governed by a timer, this method resets that timer so that the
 lock does not timeout and expire. If this lock's time-to-live is not governed by a timer,
 then this method has no effect.
 <p/>
 A LockException is thrown if this <code>Session</code> does not hold the correct lock token for this lock.
 @throws LockException if this <code>Session</code> does not hold the correct lock token for this lock.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a lock placed on an item.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.lock.Lock -->
  <!-- start class javax.jcr.lock.LockException -->
  <class name="LockException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LockException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="LockException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="LockException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="LockException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by {@link Node#save()} and {@link Session#save()} when
 persisting a change would conflict with a lock.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.lock.LockException -->
</package>
<package name="javax.jcr.nodetype">
  <!-- start class javax.jcr.nodetype.ConstraintViolationException -->
  <class name="ConstraintViolationException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConstraintViolationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ConstraintViolationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ConstraintViolationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ConstraintViolationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when an action would violate
 a constraint on repository structure. For example, when an attempt is made
 to persistently add an item to a node that would violate that node's node type.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.nodetype.ConstraintViolationException -->
  <!-- start interface javax.jcr.nodetype.ItemDefinition -->
  <interface name="ItemDefinition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDeclaringNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the node type that contains the declaration of <i>this</i>
 <code>ItemDefinition</code>.

 @return a <code>NodeType</code> object.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the child item. If <code>"*"</code>, this
 <code>ItemDefinition</code> defines a residual set of child items. That is,
 it defines the characteristics of all those child items with names apart
 from the names explicitly used in other child item definitions.

 @return a <code>String</code> denoting the name or <code>"*"</code>.]]>
      </doc>
    </method>
    <method name="isAutoCreated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether the item is to be automatically created when its parent node is created.
 If <code>true</code>, then this <code>ItemDefinition</code> will necessarily not be a residual
 set definition but will specify an actual item name (in other words getName() will not
 return #*#).

 @return a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="isMandatory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether the item is mandatory. A mandatory item is one that,
 if its parent node exists, must also exist.
<p/>
 This means that a mandatory single-value property
 must have a value (since there is no such thing a <code>null</code> value).
 In the case of multi-value properties this means that the property must exist,
 though it can have zero or more values.
 <p/>
 An attempt to save a node that has a mandatory child item without first
 creating that child item  will throw a
 <code>ConstraintViolationException</code> on <code>save</code>.

 @return a <code>boolean</code>]]>
      </doc>
    </method>
    <method name="getOnParentVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the on-parent-version status of the child item. This governs what to do if
 the parent node of this child item is versioned; an
 {@link javax.jcr.version.OnParentVersionAction}.

 @return an <code>int</code>.]]>
      </doc>
    </method>
    <method name="isProtected" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether the child item is protected. In level 2 implementations, a protected item is one that cannot be removed
 (xcept by removing its parent) or modified through the the standard write methods of this API (that is, <code>Item.remove</code>,
 <code>Node.addNode</code>, <code>Node.setProperty</code> and <code>Property.setValue</code>).
 <p/>
 A protected node may be removed or modified (in a level 2 implementation), however, through some
 mechanism not defined by this specification or as a side-effect of operations other than
 the standard write methods of the API.

 @return a <code>boolean</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Superinterface of {@link NodeDefinition} and {@link PropertyDefinition}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.ItemDefinition -->
  <!-- start interface javax.jcr.nodetype.NodeDefinition -->
  <interface name="NodeDefinition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.ItemDefinition"/>
    <method name="getRequiredPrimaryTypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum set of primary node types that the child node must have.
 Returns an array to support those implementations with multiple inheritance.
 This method never returns an empty array. If this node definition places no
 requirements on the primary node type, then this method will return an array
 containing only the <code>NodeType</code> object representing <code>nt:base</code>,
 which is the base of all primary node types and therefore constitutes the least
 restrictive node type requirement. Note that any particular node instance still
 has only one assigned primary node type, but in multiple-inheritance-supporting
 implementations the <code>RequiredPrimaryTypes</code> attribute can be used to
 restrict that assigned node type to be a subtype of <i>all<i> of a specified set
 of node types.

 @return an array of <code>NodeType</code> objects.]]>
      </doc>
    </method>
    <method name="getDefaultPrimaryType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default primary node type that will be assigned to the child
 node if it is created without an explicitly specified primary node type.
 This node type must be a subtype of (or the same type as) the node types
 returned by <code>getRequiredPrimaryTypes</code>.
 <p/>
 If <code>null</code> is returned this indicates that no default primary
 type is specified and that therefore an attempt to create this node without
 specifying a node type will throw a <code>ConstraintViolationException</code>.

 @return a <code>NodeType</code>.]]>
      </doc>
    </method>
    <method name="allowsSameNameSiblings" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether this child node can have same-name siblings. In other
 words, whether the parent node can have more than one child node of this
 name.

 @return a boolean.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A node definition. Used in node type definitions.

 @see NodeType#getChildNodeDefinitions
 @see javax.jcr.Node#getDefinition]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeDefinition -->
  <!-- start interface javax.jcr.nodetype.NodeType -->
  <interface name="NodeType"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the node type.

 @return the name of the node type]]>
      </doc>
    </method>
    <method name="isMixin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this node type is a mixin node type.
 Returns <code>false</code> if this node type is a primary node type.

 @return a boolean]]>
      </doc>
    </method>
    <method name="hasOrderableChildNodes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if nodes of this type must support orderable child nodes; returns <code>false</code>
 otherwise. If a node type returns <code>true</code> on a call to this method, then all nodes of that node type
 <i>must</i> support the method {@link javax.jcr.Node#orderBefore}. If a node type returns <code>false</code>
 on a call to this method, then nodes of that node type <i>may</i> support these ordering methods. Only the primary
 node type of a node controls that node's status in this regard. This setting on a mixin node type will not have any effect
 on the node.

 @return Returns <code>true</code> if nodes of this type must support orderable child nodes; returns
 <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="getPrimaryItemName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the primary item (one of the child items of the nodes of this node type).
 If this node has no primary item, then this method returns <code>null</code>.
 This indicator is used by the method {@link javax.jcr.Node#getPrimaryItem()}.

 @return the name of the primary item.]]>
      </doc>
    </method>
    <method name="getSupertypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all supertypes of this node type in the node type inheritance hierarchy.
 For primary types apart from <code>nt:base</code>, this list will always include
 at least <code>nt:base</code>. For mixin types, there is no required supertype.

 @see #getDeclaredSupertypes

 @return an array of <code>NodeType</code> objects.]]>
      </doc>
    </method>
    <method name="getDeclaredSupertypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <i>direct</i> supertypes of this node type in the node type inheritance hierarchy,
 that is, those actually declared in this node type. In single-inheritance systems, this
 will always be an array of size 0 or 1. In systems that support multiple inheritance of
 node types this array may be of size greater than 1.

 @see #getSupertypes

 @return an array of <code>NodeType</code> objects.]]>
      </doc>
    </method>
    <method name="isNodeType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if this node type is <code>nodeTypeName</code>
 or a subtype of <code>nodeTypeName</code>, otherwise returns
 <code>false</code>.
 @param nodeTypeName the name of a node type.
 @return a boolean]]>
      </doc>
    </method>
    <method name="getPropertyDefinitions" return="javax.jcr.nodetype.PropertyDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the property definitions of this node type,
 including the property definitions inherited from supertypes of this node
 type.

 @see #getDeclaredPropertyDefinitions

 @return an array containing the property definitions.]]>
      </doc>
    </method>
    <method name="getDeclaredPropertyDefinitions" return="javax.jcr.nodetype.PropertyDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the property definitions explicitly specified
 in the declaration of <i>this</i> node type. This does <i>not</i> include
 property definitions inherited from supertypes of this node type.

 @see #getPropertyDefinitions

 @return an array containing the property definitions.]]>
      </doc>
    </method>
    <method name="getChildNodeDefinitions" return="javax.jcr.nodetype.NodeDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the child node definitions of this node type,
 including the child node definitions inherited from supertypes of this
 node type.

 @see #getDeclaredChildNodeDefinitions

 @return an array containing the child node definitions.]]>
      </doc>
    </method>
    <method name="getDeclaredChildNodeDefinitions" return="javax.jcr.nodetype.NodeDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the child node definitions explicitly
 specified in the declaration of <i>this</i> node type. This does
 <i>not</i> include child node definitions inherited from supertypes of
 this node type.

 @see #getChildNodeDefinitions
 @return an array containing the child node definitions.]]>
      </doc>
    </method>
    <method name="canSetProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Value"/>
      <doc>
      <![CDATA[Returns <code>true</code> if setting <code>propertyName</code> to
 <code>value</code> is allowed by this node type. Otherwise returns
 <code>false</code>.

 @param propertyName The name of the property
 @param value A <code>Value</code> object.]]>
      </doc>
    </method>
    <method name="canSetProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <param name="values" type="javax.jcr.Value[]"/>
      <doc>
      <![CDATA[Returns <code>true</code> if setting <code>propertyName</code> to
 <code>values</code> is allowed by this node type. Otherwise returns
 <code>false</code>.

 @param propertyName The name of the property
 @param values A <code>Value</code> array.]]>
      </doc>
    </method>
    <method name="canAddChildNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="childNodeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node type allows the addition of a
 child node called <code>childNodeName</code> without specific node type
 information (that is, given the definition of this parent node type, the
 child node name is sufficient to determine the intended child node type).
 Returns <code>false</code> otherwise.

 @param childNodeName The name of the child node.]]>
      </doc>
    </method>
    <method name="canAddChildNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="childNodeName" type="java.lang.String"/>
      <param name="nodeTypeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node type allows the addition of a
 child node called <code>childNodeName</code> of node type
 <code>nodeTypeName</code>. Returns <code>false</code> otherwise.

 @param childNodeName The name of the child node.
 @param nodeTypeName The name of the node type of the child node.]]>
      </doc>
    </method>
    <method name="canRemoveItem" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if removing the child item called <code>itemName</code> is allowed by this node type.
 Otherwise returns <code>false</code>.

 @param itemName The name of the child item]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a node type.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeType -->
  <!-- start interface javax.jcr.nodetype.NodeTypeIterator -->
  <interface name="NodeTypeIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>NodeType</code> in the iteration.

 @return the next <code>NodeType</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more <code>NodeType</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator for <code>NodeType</code> objects.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeTypeIterator -->
  <!-- start interface javax.jcr.nodetype.NodeTypeManager -->
  <interface name="NodeTypeManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the named node type.
 <p>
 Throws a <code>NoSuchNodeTypeException</code> if a node type by that name does not exist.
 <p>
 Throws a <code>RepositoryException</code> if another error occurs.

 @param nodeTypeName the name of an existing node type.
 @return A <code>NodeType</code> object.
 @throws NoSuchNodeTypeException if no node type by the given name exists.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getAllNodeTypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all available node types (primary and mixin).

 @return An <code>NodeTypeIterator</code>.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getPrimaryNodeTypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all available primary node types.

 @return An <code>NodeTypeIterator</code>.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getMixinNodeTypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all available mixin node types.
 If none are available, an empty iterator is returned.

 @return An <code>NodeTypeIterator</code>.

 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows for the retrieval of node types.
 Accessed via {@link Workspace#getNodeTypeManager}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeTypeManager -->
  <!-- start class javax.jcr.nodetype.NoSuchNodeTypeException -->
  <class name="NoSuchNodeTypeException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoSuchNodeTypeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchNodeTypeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchNodeTypeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="NoSuchNodeTypeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by node type-related methods.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.nodetype.NoSuchNodeTypeException -->
  <!-- start interface javax.jcr.nodetype.PropertyDefinition -->
  <interface name="PropertyDefinition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.ItemDefinition"/>
    <method name="getRequiredType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the required type of the property. One of:
 <ul>
   <li><code>PropertyType.STRING</code></li>
   <li><code>PropertyType.DATE</code></li>
   <li><code>PropertyType.BINARY</code></li>
   <li><code>PropertyType.DOUBLE</code></li>
   <li><code>PropertyType.LONG</code></li>
   <li><code>PropertyType.BOOLEAN</code></li>
   <li><code>PropertyType.NAME</code></li>
   <li><code>PropertyType.PATH</code></li>
   <li><code>PropertyType.REFERENCE</code></li>
   <li><code>PropertyType.UNDEFINED</code></li>
 </ul>
 <code>PropertyType.UNDEFINED</code> is returned if this property may be
 of any type.

 @return an int]]>
      </doc>
    </method>
    <method name="getValueConstraints" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the array of constraint strings. Each string in the array specifies
 a constraint on the value of the property. The constraints are OR-ed together,
 meaning that in order to be valid, the value must meet at least one of the
 constraints. For example, a constraint array of <code>["constraint1", "constraint2",
 "constraint3"]</code> has the interpretation: "the value of this property must
 meet either constraint1, constraint2 or constraint3".
 <p>
 Reporting of value constraints is optional. An implementation may return
 <code>null</code>, indicating that value constraint information is unavailable
 (though a constraint may still exist).
 <p/>
 Returning an empty array, on the other hand, indicates that value constraint information
 is available and that no constraints are placed on this value.
 <p>
 In the case of multi-value properties, the constraint string array
 returned applies to all the values of the property.
 <p>
 The constraint strings themselves having differing formats and interpretations
 depending on the type of the property in question. The following describes the
 value constraint syntax for each property type:
 <ul>
 <li>
 <code>STRING</code>: The constraint string is a regular expression pattern. For example the
 regular expression "<code>.*</code>" means "any string, including the empty string". Whereas
 a simple literal string (without any RE-specific meta-characters) like "<code>banana</code>"
 matches only the string "<code>banana</code>".
 </li>
 <li>
 <code>PATH</code>: The constraint string is a <i>JCR path</i> with an optional "<code>*</code>" character after
 the last "<code>/</code>" character. For example,  possible constraint strings for a property
 of type <code>PATH</code> include:
 <ol>
 <li>
 "<code>/myapp:products/myapp:televisions</code>"
 </li>
 <li>
 "<code>/myapp:products/myapp:televisions/</code>"
 </li>
 <li>
 "<code>/myapp:products/*</code>"
 </li>
 <li>
 "<code>myapp:products/myapp:televisions</code>"
 </li>
 <li>
 "<code>../myapp:televisions</code>"
 </li>
 <li>
 "<code>../myapp:televisions/*</code>"
 </li>
 </ol>
 The following principles apply:
 <ul>
 <li>
 The "*" means "matches descendants" not "matches any subsequent path". For example,
 <code>/a/*</code> does not match <code>/a/../c</code>.
 The constraint must match the normalized path.
 </li>
 <li>
 Relative path constraint only match relative path values and absolute path
 constraints only match absolute path values.
 </li>
 <li>
 A trailing "<code>/</code>" has no effect (hence, <code>1</code> and <code>2</code>, above, are equivalent).
 </li>
 <li>
 The trailing "<code>*</code>" character means that the value of the <code>PATH</code> property is
 restricted to the indicated subtree (in other words any additional relative path
 can replace the "<code>*</code>"). For example, 3, above would allow
 <code>/myapp:products/myapp:radios</code>, <code>/myapp:products/myapp:microwaves/X900</code>, and so
 forth.
 </li>
 <li>
 A constraint without a "<code>*</code>" means that the <code>PATH</code> property is restricted to that
 precise path. For example, <code>1</code>, above, would allow only the value
 <code>/myapp:products/myapp:televisions</code>.
 </li>
 <li>
 The constraint can indicate either a relative path or an absolute path
 depending on whether it includes a leading "<code>/</code>" character. <code>1</code> and <code>4</code>, above for
 example, are distinct.
 </li>
 <li>
 The string returned must reflect the namespace mapping in the current <code>Session</code>
 (i.e., the current state of the namespace registry overlaid with any
 session-specific mappings). Constraint strings for <code>PATH</code> properties should be
 stored in fully-qualified form (using the actual URI instead of the prefix) and
 then be converted to prefix form according to the current mapping upon the
 <code>PropertyDefinition.getValueConstraints</code> call.
 </li>
 </ul>
 </li>
 <li>
 <code>NAME</code>: The constraint string is a <i>JCR name</i> in prefix form. For example
 "<code>myapp:products</code>". No wildcards or other pattern matching are supported. As with
 <code>PATH</code> properties, the string returned must reflect the namespace mapping in the
 current <code>Session</code>. Constraint strings for <code>NAME</code> properties should be stored in
 fully-qualified form (using the actual URI instead of the prefix) and then be
 converted to prefix form according to the current mapping.
 </li>
 <li>
 <code>REFERENCE</code>: The constraint string is a <i>JCR name</i> in prefix form. This name is
 interpreted as a node type name and the <code>REFERENCE</code> property is restricted to
 referring only to nodes that have at least the indicated node type. For
 example, a constraint of "<code>mytype:document</code>" would indicate that the REFERENCE
 property in question can only refer to nodes that have at least the node type
 <code>mytype:document</code> (assuming this was the only constraint returned in the array,
 recall that the array of constraints are to be "OR-ed" together). No wildcards or other
 pattern matching are supported. As with <code>PATH</code> properties, the string returned
 must reflect the namespace mapping in the current <code>Session</code>. Constraint strings
 for <code>REFERENCE</code> properties should be stored in fully-qualified form (using the
 actual URI instead of the prefix) and then be converted to prefix form according to the
 current mapping.
 </li>
 <li>
 <code>BOOLEAN</code>: Either "<code>true</code>" or "<code>false</code>".
 </li>
 </ul>
 The remaining types all have value constraints in the form of inclusive or
 exclusive ranges: i.e., "<code>[min, max]</code>", "<code>(min, max)</code>",
 "<code>(min, max]</code>" or "<code>[min, max)</code>". Where "<code>[</code>"
 and "<code>]</code>" indicate "inclusive", while "<code>(</code>" and "<code>)</code>"
 indicate "exclusive". A missing <code>min</code> or <code>max</code> value
 indicates no bound in that direction. For example [,5] means no minimum but a
 maximum of 5 (inclusive) while [,] means simply that any value will suffice,
 The meaning of the <code>min</code> and <code>max</code> values themselves
 differ between types as follows:
 <ul>
 <li>
 <code>BINARY</code>: <code>min</code> and <code>max</code> specify the allowed
 size range of the binary value in bytes.
 </li>
 <li>
 <code>DATE</code>: <code>min</code> and <code>max</code> are dates specifying the
 allowed date range. The date strings must be in the ISO8601-compliant format:
 <code>YYYY-MM-DDThh:mm:ss.sssTZD</code>.
 </li>
 <li>
 <code>LONG</code>, <code>DOUBLE</code>: min and max are numbers.
 </li>
 </ul>
 Because constraints are returned as an array of disjunctive constraints,
 in many cases the elements of the array can serve directly as a "choice list".
 This may, for example, be used by an application to display options to the
 end user indicating the set of permitted values.

 @return a <code>String</code> array.]]>
      </doc>
    </method>
    <method name="getDefaultValues" return="javax.jcr.Value[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default value(s) of the property. These are the values
 that the property defined by this PropertyDefinition will be assigned if it
 is automatically created (that is, if {@link #isAutoCreated()}
 returns <code>true</code>).
 <p>
 This method returns an array of Value objects. If the property is
 multi-valued, then this array represents the full set of values
 that the property will be assigned upon being auto-created.
 Note that this could be the empty array. If the property is single-valued,
 then the array returned will be of size 1.
 <p/>
 If <code>null</code> is returned, then the property has no fixed default value.
 This does not exclude the possibility that the property still assumes some
 value automatically, but that value may be parameterized (for example,
 "the current date") and hence not expressable as a single fixed value.
 In particular, this <i>must</i> be the case if <code>isAutoCreated</code>
 returns <code>true</code> and this method returns <code>null</code>.

 @return an array of <code>Value</code> objects.]]>
      </doc>
    </method>
    <method name="isMultiple" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether this property can have multiple values. Note that the
 <code>isMultiple</code> flag is special in that a given node type may
 have two property definitions that are identical in every respect except
 for the their <code>isMultiple</code> status. For example, a node type
 can specify two string properties both called <code>X</code>, one of
 which is multi-valued and the other not.

 @return a <code>boolean</code>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A property definition. Used in node type definitions.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.PropertyDefinition -->
</package>
<package name="javax.jcr.observation">
  <!-- start interface javax.jcr.observation.Event -->
  <interface name="Event"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of this event: a constant defined by this interface.
 One of:
 <ul>
 <li><code>NODE_ADDED</code></li>
 <li><code>NODE_REMOVED</code></li>
 <li><code>PROPERTY_ADDED</code></li>
 <li><code>PROPERTY_REMOVED</code></li>
 <li><code>PROPERTY_CHANGED</code></li>
 </ul>

 @return the type of this event.]]>
      </doc>
    </method>
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the absolute path of the parent node connected with this event.
 The interpretation given to the returned path depends upon the type of the event:
 <ul>
   <li>
     If the event type is <code>NODE_ADDED</code> then this method returns the absolute path of
     the node that was added.
   </li>
   <li>
     If the event type is <code>NODE_REMOVED</code> then this method returns the absolute path of
     the node that was removed.
   </li>
   <li>
     If the event type is <code>PROPERTY_ADDED</code> then this method returns the absolute path of
     the property that was added.
   </li>
   <li>
     If the event type is <code>PROPERTY_REMOVED</code> then this method returns the absolute path of
     the property that was removed.
   </li>
   <li>
     If the event type is <code>PROPERTY_CHANGED</code> then this method returns the absolute path of
     of the changed property.
   </li>
 </ul>

 @throws RepositoryException if an error occurs.
 @return the absolute path of the parent node connected with this event.]]>
      </doc>
    </method>
    <method name="getUserID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user ID connected with this event. This is the string returned by getUserID of the session that
 caused the event.

 @return a <code>String</code>.]]>
      </doc>
    </method>
    <field name="NODE_ADDED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An event of this type is generated when a node is added.]]>
      </doc>
    </field>
    <field name="NODE_REMOVED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An event of this type is generated when a node is removed.]]>
      </doc>
    </field>
    <field name="PROPERTY_ADDED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An event of this type is generated when a property is added.]]>
      </doc>
    </field>
    <field name="PROPERTY_REMOVED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An event of this type is generated when a property is removed.]]>
      </doc>
    </field>
    <field name="PROPERTY_CHANGED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An event of this type is generated when a property is changed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An event fired by the observation mechanism. Also includes
 constants representing the  event types defined by the JCR standard. Each constant is a
 power of 2 so that sets of event types can be encoded as a bitmask
 in a <code>int</code> value.

 @author Tim Anderson]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.Event -->
  <!-- start interface javax.jcr.observation.EventIterator -->
  <interface name="EventIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextEvent" return="javax.jcr.observation.Event"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Event</code> in the iteration.

 @return the next <code>Event</code> in the iteration.
 @throws java.util.NoSuchElementException if iteration has no more <code>Event</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Event</code>s
 with <code>nextEvent</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.EventIterator -->
  <!-- start interface javax.jcr.observation.EventListener -->
  <interface name="EventListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onEvent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="events" type="javax.jcr.observation.EventIterator"/>
      <doc>
      <![CDATA[Gets called when an event occurs.

 @param events The event set recieved.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An event listener.
 <p>
 An <code>EventListener</code> can be registered via the
 <code>{@link javax.jcr.observation.ObservationManager}</code> object. Event listeners are
 notified asynchronously, and see events after they occur and the transaction
 is committed. An event listener only sees events for which the session that
 registered it has sufficient access rights.

 @author Tim Anderson]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.EventListener -->
  <!-- start interface javax.jcr.observation.EventListenerIterator -->
  <interface name="EventListenerIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextEventListener" return="javax.jcr.observation.EventListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>EventListener</code> in the iteration.

 @return the next <code>EventListener</code> in the iteration.
 @throws java.util.NoSuchElementException if iteration has no more <code>EventListener</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>EventListener</code>s
 with <code>nextEventListener</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.EventListenerIterator -->
  <!-- start interface javax.jcr.observation.ObservationManager -->
  <interface name="ObservationManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addEventListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="javax.jcr.observation.EventListener"/>
      <param name="eventTypes" type="int"/>
      <param name="absPath" type="java.lang.String"/>
      <param name="isDeep" type="boolean"/>
      <param name="uuid" type="java.lang.String[]"/>
      <param name="nodeTypeName" type="java.lang.String[]"/>
      <param name="noLocal" type="boolean"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds an event listener that listens for the specified <code>eventTypes</code> (a combination of one or more
 event types encoded as a bit mask value).
 <p>
 The set of events can be filtered by specifying restrictions based on characteristics of the node associated
 with the event. In the case of  event types <code>NODE_ADDED</code> and <code>NODE_REMOVED</code>, the node
 associated with an event is the node at (or formerly at) the path returned by <code>Event.getPath</code>.
 In the case of  event types <code>PROPERTY_ADDED</code>,  <code>PROPERTY_REMOVED</code> and
 <code>PROPERTY_CHANGED</code>, the node associated with an event is the parent node of the property at
 (or formerly at) the path returned by <code>Event.getPath</code>:
 <ul>
   <li>
     <code>absPath</code>, <code>isDeep</code>: Only events whose associated node is at
     <code>absPath</code> (or within its subtree, if <code>isDeep</code> is <code>true</code>) will be received.
     It is permissible to register a listener for a path where no node currently exists.
   </li>
   <li>
     <code>uuid</code>: Only events whose associated node has one of the UUIDs in this list will be
     received. If his parameter is <code>null</code> then no UUID-related restriction is placed on events
     received.
   </li>
   <li>
 	   <code>nodeTypeName</code>: Only events whose associated node has one of the node types
     (or a subtype of one of the node types) in this list will be received. If his parameter is
     <code>null</code> then no node type-related restriction is placed on events received.
   </li>
 </ul>
 The restrictions are "ANDed" together. In other words, for a particular node to be "listened to" it must meet all the restrictions.
 <p>
 Additionally, if <code>noLocal</code> is <code>true</code>, then events generated by the session through which
 the listener was registered are ignored. Otherwise, they are not ignored.
 <p>
 The filters of an already-registered <code>EventListener</code> can be changed at runtime by re-registering the
 same <code>EventListener</code> object (i.e. the same actual Java object) with a new set of filter arguments.
 The implementation must ensure that no events are lost during the changeover.

 @param listener an {@link EventListener} object.
 @param eventTypes A combination of one or more event type constants encoded as a bitmask.
 @param absPath an absolute path.
 @param isDeep a <code>boolean</code>.
 @param uuid array of UUIDs.
 @param nodeTypeName array of node type names.
 @param noLocal a <code>boolean</code>.

 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <method name="removeEventListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="javax.jcr.observation.EventListener"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Deregisters an event listener.
 <p>
 A listener may be deregistered while it is being executed. The
 deregistration method will block until the listener has completed
 executing. An exception to this rule is a listener which deregisters
 itself from within the <code>onEvent</code> method. In this case, the
 deregistration method returns immediately, but deregistration will
 effectively be delayed until the listener completes.

 @param listener The listener to deregister.

 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <method name="getRegisteredEventListeners" return="javax.jcr.observation.EventListenerIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all event listeners that have been registered through this session.
 If no listeners have been registered, an empty iterator is returned.

 @return an <code>EventListenerIterator</code>.
 @throws RepositoryException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The ObservationManager object.
 <p>
 Acquired via <code>{@link javax.jcr.Workspace#getObservationManager()}</code>.
 Allows for the registration and deregistration of event listeners.

 @author Tim Anderson]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.ObservationManager -->
</package>
<package name="javax.jcr.query">
  <!-- start class javax.jcr.query.InvalidQueryException -->
  <class name="InvalidQueryException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidQueryException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidQueryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidQueryException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidQueryException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown by methods of <code>Query</code>.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.query.InvalidQueryException -->
  <!-- start interface javax.jcr.query.Query -->
  <interface name="Query"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="execute" return="javax.jcr.query.QueryResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Executes this query and returns a <code>{@link QueryResult}</code>.

 @return a <code>QueryResult</code>
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getStatement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the statement set for this query.

 @return the query statement.]]>
      </doc>
    </method>
    <method name="getLanguage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the language set for this query. This will be one of the
 query language constants returned by
 {@link QueryManager#getSupportedQueryLanguages}.

 @return the query language.]]>
      </doc>
    </method>
    <method name="getStoredQueryPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this is a <code>Query</code> object that has been stored using
 {@link Query#storeAsNode} (regardless of whether it has been <code>save</code>d yet)
 or retrieved using {@link QueryManager#getQuery}), then this method
 returns the path of the <code>nt:query</code> node that stores the query.
 If this is a transient query (that is, a <code>Query</code> object created with
 {@link QueryManager#createQuery} but not yet stored) then this method throws an
 <code>ItemNotFoundException</code>.

 @return path of the node representing this query.
 @throws ItemNotFoundException if this query is not a stored query.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="storeAsNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a node representing this <code>Query</code> in content.
 <p/>
 In a level 1 repository this method throws an <code>UnsupportedRepositoryOperationException</code>.
 <p/>
 In a level 2 repository it creates a node of type <code>nt:query</code> at <code>absPath</code>
 and returns that node.
 <p/>
 In order to persist the newly created node, a <code>save</code> must be performed that includes <i>the
 parent</i> of this new node within its scope. In other words, either a <code>Session.save</code> or
 an <code>Item.save</code> on the parent or higher-degree ancestor of <code>absPath</code> must be performed.
 <p/>
 An <code>ItemExistsException</code> will be thrown either immediately (by
 this method), or on <code>save</code>, if an item at the specified path already exists
 and same-name siblings are not allowed. Implementations may differ on
 when this validation is performed.
 <p/>
 A <code>PathNotFoundException</code> will be thrown either immediately
,  or on <code>save</code>, if the specified path implies intermediary
 nodes that do not exist. Implementations may differ on when this validation is performed.
 <p/>
 A <code>ConstraintViolationException</code>will be thrown either immediately
 or on <code>save</code>, if adding the node would violate a node type or implementation-specific
 constraintor if an attempt is made to add a node as the child of a property.
 Implementations may differ on when this validation is performed.
 <p/>
 A <code>VersionException</code> will be thrown either immediately (by
 this method), or on <code>save</code>, if the node to which the new child is being
 added is versionable and checked-in or is non-versionable but its nearest
 versionable ancestor is checked-in. Implementations may differ on when
 this validation is performed.
 <p/>
 A <code>LockException</code> will be thrown either immediately (by
 this method), or on <code>save</code>, if a lock prevents the addition of the node.
 Implementations may differ on when this validation is performed.

 @return the newly created node.

 @throws ItemExistsException if an item at the specified path already exists,
 same-name siblings are not allowed and this implementation performs this
 validation immediately instead of waiting until <code>save</code>.

 @throws PathNotFoundException if the specified path implies intermediary
 <code>Node</code>s that do not exist or the last element of
 <code>relPath</code> has an index, and this implementation performs this
 validation immediately instead of waiting until <code>save</code>.

 @throws ConstraintViolationException if a node type or implementation-specific constraint
 is violated or if an attempt is made to add a node as the child of a property and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws VersionException if the node to which the new child is being added is versionable and
 checked-in or is non-versionable but its nearest versionable ancestor is checked-in and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws LockException if a lock prevents the addition of the node and this
 implementation performs this validation immediately instead of waiting until <code>save</code>.

 @throws UnsupportedRepositoryOperationException in a level 1 implementation.

 @throws RepositoryException if another error occurs or if the <code>relPath</code> provided has
 an index on its final element.]]>
      </doc>
    </method>
    <field name="XPATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A String constant representing the XPath query language applied to the <i>document view</i>
 XML mapping of the workspace.
 <p/>
 This language must be supported in level 1 repositories.
 <p/>
 Used when defining a query using {@link QueryManager#createQuery}.
 Also among the strings returned by {@link QueryManager#getSupportedQueryLanguages}.]]>
      </doc>
    </field>
    <field name="SQL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A String constant representing the SQL query language applied to the <i>database view</i>
 of the workspace.
 <p/>
 This language is optional.
 <p/>
 Used when defining a query using {@link QueryManager#createQuery}.
 Also among the strings returned by {@link QueryManager#getSupportedQueryLanguages}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A <code>Query</code> object.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.Query -->
  <!-- start interface javax.jcr.query.QueryManager -->
  <interface name="QueryManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createQuery" return="javax.jcr.query.Query"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statement" type="java.lang.String"/>
      <param name="language" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new query by specifying the query <code>statement</code> itself and the
 <code>language</code> in which the query is stated. If the query <code>statement</code> is
 syntactically invalid, given the language specified, an
 <code>InvalidQueryException</code> is thrown. The <code>language</code> must
 be a string from among those returned by QueryManager.getSupportedQueryLanguages();
 if it is not, then an <code>InvalidQueryException</code> is thrown.

 @throws InvalidQueryException if statement is invalid or language is unsupported.
 @throws RepositoryException if another error occurs
 @return A <code>Query</code> object.]]>
      </doc>
    </method>
    <method name="getQuery" return="javax.jcr.query.Query"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves an existing persistent query. If <code>node</code>
 is not a valid persisted query (that is, a node of type
 <code>nt:query</code>), an <code>InvalidQueryException</code>
 is thrown.
 <p/>
 Persistent queries are created by first using <code>QueryManager.createQuery</code>
 to create a <code>Query</code> object and then calling <code>Query.save</code> to
 persist the query to a location in the workspace.

 @param node a persisted query (that is, a node of type <code>nt:query</code>).
 @throws InvalidQueryException If <code>node</code> is not a valid persisted query
 (that is, a node of type <code>nt:query</code>).
 @throws RepositoryException if another error occurs
 @return a <code>Query</code> object.]]>
      </doc>
    </method>
    <method name="getSupportedQueryLanguages" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of strings representing all query languages supported by this repository.
 In level 1 this set must include the string represented by the constant {@link Query#XPATH}.
 If SQL is supported it must additionally include the string represented by the constant {@link Query#SQL}.
 An implementation may also support other languages as well.

 See {@link Query}.
 @return An string array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface encapsulates methods for the management of search queries.
 Provides methods for the creation and retrieval of search queries.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.QueryManager -->
  <!-- start interface javax.jcr.query.QueryResult -->
  <interface name="QueryResult"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getColumnNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of all the property names (column names) in this result set.

 @return a <code>PropertyIterator</code>
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getRows" return="javax.jcr.query.RowIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over the <code>Row</code>s of the query result table.
 If an <code>ORDER BY</code> clause was specified in the query, then the
 order of the returned properties in the iterator will reflect the order
 specified in that clause. If no items match, an empty iterator is returned.

 @return a <code>RowIterator</code>
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all nodes that match the query. If an <code>ORDER BY</code>
 clause was specified in the query, then the order of the returned nodes in the iterator
 will reflect the order specified in that clause. If no nodes match, an empty iterator
 is returned.

 @return a <code>NodeIterator</code>
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A QueryResult object. Returned by {@link javax.jcr.query.Query#execute()}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.QueryResult -->
  <!-- start interface javax.jcr.query.Row -->
  <interface name="Row"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getValues" return="javax.jcr.Value[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of all the values in the same order as the
 column names returned by {@link QueryResult#getColumnNames()}.

 @return a <code>Value</code> array.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the value of the indicated  property in this <code>Row</code>.
 <p/>
 If <code>propertyName</code> is not among the column names of the query result
 table, an <code>ItemNotFoundException</code> is thrown.

 @return a <code>Value</code>
 @throws ItemNotFoundException if <code>propertyName</code> s not among the
 column names of the query result table
 @throws RepositoryException if anopther error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A row in the query result table.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.Row -->
  <!-- start interface javax.jcr.query.RowIterator -->
  <interface name="RowIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextRow" return="javax.jcr.query.Row"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Row</code> in the iteration.

 @return the next <code>Row</code> in the iteration.
 @throws java.util.NoSuchElementException if iteration has no more <code>Row</code>s.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface javax.jcr.query.RowIterator -->
</package>
<package name="javax.jcr.util">
  <!-- start class javax.jcr.util.TraversingItemVisitor -->
  <class name="TraversingItemVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.ItemVisitor"/>
    <constructor name="TraversingItemVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class.
 <p/>
 The tree of <code>Item</code>s will be traversed in a
 depth-first manner (default behaviour).]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class.

 @param breadthFirst if <code>breadthFirst</code> is true then traversal
                     is done in a breadth-first manner; otherwise it is done in a
                     depth-first manner (which is the default behaviour).]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor" type="boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class.

 @param breadthFirst if <code>breadthFirst</code> is true then traversal
                     is done in a breadth-first manner; otherwise it is
                     done in a depth-first manner (which is the default
                     behaviour).
 @param maxLevel     the 0-based level up to which the hierarchy should be
                     traversed (if it's -1, the hierarchy will be traversed
                     until there are no more children of the current item)]]>
      </doc>
    </constructor>
    <method name="entering"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behaviour performed before a
 <code>Property</code> is visited.

 @param property the <code>Property</code> that is accepting this visitor.
 @param level    hierarchy level of this property (the root node starts at level 0)
 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <method name="entering"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behaviour performed before a
 <code>Node</code> is visited.

 @param node  the <code>Node</code> that is accepting this visitor.
 @param level hierarchy level of this node (the root node starts at level 0)
 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behaviour performed after a
 <code>Property</code> is visited.

 @param property the <code>Property</code> that is accepting this visitor.
 @param level    hierarchy level of this property (the root node starts at level 0)
 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behaviour performed after a
 <code>Node</code> is visited.

 @param node  the <code>Node</code> that is accepting this visitor.
 @param level hierarchy level of this node (the root node starts at level 0)
 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Called when the Visitor is passed to a <code>Property</code>.
 <p/>
 It calls <code>TraversingItemVisitor.entering(Property, int)</code> followed by
 <code>TraversingItemVisitor.leaving(Property, int)</code>. Implement these abstract methods to
 specify behaviour on 'arrival at' and 'after leaving' the <code>Property</code>.
 <p/>
 <p/>
 If this method throws, the visiting process is aborted.

 @param property the <code>Property</code> that is accepting this visitor.
 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Called when the Visitor is passed to a <code>Node</code>.
 <p/>
 It calls <code>TraversingItemVisitor.entering(Node, int)</code> followed by
 <code>TraversingItemVisitor.leaving(Node, int)</code>. Implement these abstract methods to
 specify behaviour on 'arrival at' and 'after leaving' the <code>Node</code>.
 <p/>
 If this method throws, the visiting process is aborted.

 @param node the <code>Node</code> that is accepting this visitor.
 @throws RepositoryException if an error occurrs]]>
      </doc>
    </method>
    <field name="breadthFirst" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[indicates if traversal should be done in a breadth-first
 manner rather than depth-first (which is the default)]]>
      </doc>
    </field>
    <field name="maxLevel" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the 0-based level up to which the hierarchy should be traversed
 (if it's -1, the hierarchy will be traversed until there are no
 more children of the current item)]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An implementation of <code>ItemVisitor</code>.
 <p/>
 <code>TraversingItemVisitor</code> is an abstract utility class
 which allows to easily traverse an <code>Item</code> hierarchy.
 <p/>
 <p><code>TraversingItemVisitor</code> makes use of the Visitor Pattern
 as described in the book 'Design Patterns' by the Gang Of Four
 (Gamma et al.).
 <p/>
 <p>Tree traversal is done observing the left-to-right order of
 child <code>Item</code>s if such an order is supported and exists.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.util.TraversingItemVisitor -->
  <!-- start class javax.jcr.util.TraversingItemVisitor.Default -->
  <class name="TraversingItemVisitor.Default" extends="javax.jcr.util.TraversingItemVisitor"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TraversingItemVisitor.Default"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see TraversingItemVisitor#TraversingItemVisitor()]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor.Default" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see TraversingItemVisitor#TraversingItemVisitor()]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor.Default" type="boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see TraversingItemVisitor#TraversingItemVisitor(boolean, int)]]>
      </doc>
    </constructor>
    <method name="entering"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#entering(Node, int)]]>
      </doc>
    </method>
    <method name="entering"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#entering(Property, int)]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#leaving(Node, int)]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#leaving(Property, int)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Convenience class providing default implementations of the abstract methods
 of <code>TraversingItemVisitor</code>.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.util.TraversingItemVisitor.Default -->
</package>
<package name="javax.jcr.version">
  <!-- start class javax.jcr.version.OnParentVersionAction -->
  <class name="OnParentVersionAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nameFromValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="int"/>
      <doc>
      <![CDATA[Returns the name of the specified <code>action</code>,
 as used in serialization.
 @param action the on-version action
 @return the name of the specified <code>action</code>
 @throws IllegalArgumentException if <code>action</code>
 is not a valid on-version action.]]>
      </doc>
    </method>
    <method name="valueFromName" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the numeric constant value of the on-version action with the
 specified name.
 @param name the name of the on-version action
 @return the numeric constant value
 @throws IllegalArgumentException if <code>name</code>
 is not a valid on-version action name.]]>
      </doc>
    </method>
    <field name="COPY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The action constants.]]>
      </doc>
    </field>
    <field name="VERSION" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INITIALIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COMPUTE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IGNORE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ABORT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_COPY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The names of the defined on-version actions,
 as used in serialization.]]>
      </doc>
    </field>
    <field name="ACTIONNAME_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_INITIALIZE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_COMPUTE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_IGNORE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_ABORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The possible actions specified by the <code>onParentVersion</code> attribute
 in a property definition within a node type definition.
 <p>
 This interface defines the following actions:
 <UL>
    <LI><code>COPY</code>
    <LI><code>VERSION</code>
    <LI><code>INITIALIZE</code>
    <LI><code>COMPUTE</code>
    <LI><code>IGNORE</code>
    <LI><code>ABORT</code>
 </UL>
 <p>
 Every item (node or property) in the repository has a status indicator that
 governs what happens to that item when its parent node is versioned. This
 status is defined by the <code>onParentVersion</code> attribute in
 the <code>PropertyDefinition</code> or <code>NodeDefinition</code> that applies to the
 item in question.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.version.OnParentVersionAction -->
  <!-- start interface javax.jcr.version.Version -->
  <interface name="Version"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Node"/>
    <method name="getContainingHistory" return="javax.jcr.version.VersionHistory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>VersionHistory</code> that contains this <code>Version</code>.
 @return the <code>VersionHistory</code> that contains this <code>Version</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getCreated" return="java.util.Calendar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the date this version was created. This corresponds to the value
 of the <code>jcr:created</code> property in the <code>nt:version</code>
 node that represents this version.

 @return a <code>Calendar</code> object
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getSuccessors" return="javax.jcr.version.Version[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the successor versions of this version. This corresponds to
 returning all the <code>nt:version</code> nodes referenced by the
 <code>jcr:successors</code> multi-value property in the
 <code>nt:version</code> node that represents this version.

 @return a <code>Version</code> array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getPredecessors" return="javax.jcr.version.Version[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the predecessor versions of this version. This corresponds to
 returning all the <code>nt:version</code> nodes whose
 <code>jcr:successors</code> property includes a reference to the
 <code>nt:version</code> node that represents this version.

 @return a <code>Version</code> array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>Version</code> object wraps an <code>nt:version</code> node. It
 provides convenient access to version information.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.version.Version -->
  <!-- start class javax.jcr.version.VersionException -->
  <class name="VersionException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="VersionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for
                later retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="VersionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message and root cause.

 @param message   the detail message. The detail message is saved for
                  later retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="VersionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by Version.addSuccessor if an invalid
 version graph operation is attempted.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.version.VersionException -->
  <!-- start interface javax.jcr.version.VersionHistory -->
  <interface name="VersionHistory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Node"/>
    <method name="getVersionableUUID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the UUID of the versionable node for which this is the version history.

 @return the UUID of the versionable node for which this is the version history.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getRootVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the root version of this version history.

 @return a <code>Version</code> object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getAllVersions" return="javax.jcr.version.VersionIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all the versions within this version history
 The order of the returned objects will not necessarily correspond to the
 order of versions in terms of the successor relation. To traverse the
 version graph one must traverse the <code>jcr:successor REFERENCE</code>
 properties starting with the root version. A version history will always
 have at least one version, the root version. Therefore, this method will
 always return an iterator of at least size 1.

 @return a <code>VersionIterator</code> object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves a particular version from this version history by version name.
 <p/>
 Throws a <code>VersionException</code> if the specified version is not in
 this version history.

 @param versionName a version name
 @return a <code>Version</code> object.
 @throws VersionException if the specified version is not in this version history.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getVersionByLabel" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves a particular version from this version history by version label.
 <p/>
 Throws a <code>VersionException</code> if the specified <code>label</code> is not in
 this version history.

 @param label a version label
 @return a <code>Version</code> object.
 @throws VersionException if the specified <code>label</code> is not in this version history.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="addVersionLabel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <param name="label" type="java.lang.String"/>
      <param name="moveLabel" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds the specified label to the specified version. This corresponds to adding a
 value to the <code>jcr:versionLabels</code> multi-value property of the
 <code>nt:version</code> node that represents the specified version.
 <p/>
 Note that this change is made immediately; there is no need to call <code>save</code>.
 In fact, since the the version storage is read-only with respect to normal repository
 methods, <code>save</code> does not even function in this context.
 <p/>
 Within a particular version history, a given label may appear a maximum of once.
 If the specified label is already assigned to a version in this history and
 <code>moveLabel</code> is <code>true</code> then the label is removed from its
 current location and added to the version with the specified <code>versionName</code>.
 If <code>moveLabel</code> is <code>false</code>, then an attempt to add a label that
 already exists in this version history will throw a <code>VersionException</code>.
 <p/>
 A <code>VersionException</code> is also thrown if the named version is not in this
 <code>VersionHistory</code> or if it is the root version (<code>jcr:rootVersion</code>)
 or if the <code>label</code> specified is not a valid JCR <code>NAME</code>.
 @param versionName the name of the version to which the label is to be added.
 @param label the label to be added.
 @param moveLabel if <code>true</code>, then if <code>label</code> is already assigned to a version in
 this version history, it is moved to the new version specified; if <code>false</code>, then attempting
 to assign an already used label will throw a <code>VersionException</code>.
 @throws VersionException if an attempt is made to add an existing label to a version history
 and <code>moveLabel</code> is <code>false</code> or if the specifed version does not exist in
 this version history or if the specified version is the root version (<code>jcr:rootVersion</code>).
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="removeVersionLabel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified label from among the labels of this version history.
 This corresponds to removing a property from the <code>jcr:versionLabels</code>
 child node of the <code>nt:versionHistory</code> node that represents this version
 history.
 <p/>
 Note that this change is made immediately; there is no need to call <code>save</code>.
 In fact, since the the version storage is read-only with respect to normal repository
 methods, <code>save</code> does not even function in this context.
 <p/>
 If a label is specified that does not exist in this version history,
 a <code>VersionException</code> is thrown.

 @param label a version label
 @throws VersionException if the name labvel does not exist in this version history.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="hasVersionLabel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if any version in the history has the given <code>label</code>.

 @param label a version label
 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="hasVersionLabel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="label" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns true if the given version has the given <code>label</code>.
 @param version a Version object
 @param label a version label
 @return a <code>boolean</code>.
 @throws VersionException if the specified <code>version</code> is not of this version history.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getVersionLabels" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all version labels of the history or an empty array if there are none.

 @return a <code>String</code> array containing all the labels of the version history.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getVersionLabels" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all version labels of the given <code>version</code> - empty array if none.
 Throws a <code>VersionException</code> if the specified <code>version</code> is not
 in this version history.
 @param version
 @return a <code>String</code> array containing all the labels of the given version
 @throws VersionException if the specified <code>version</code> is not in this version history.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="removeVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="ReferentialIntegrityException" type="javax.jcr.ReferentialIntegrityException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the named version from this version history and automatically
 repairs the version graph. If the version to be removed is <code>V</code>, <code>V</code>'s
 predecessor set is <code>P</code> and <code>V</code>'s successor set is <code>S</code>, then
 the version graph is repaired s follows:
 <ul>
 <li>For each member of <code>P</code>, remove the reference to <code>V</code> from its
 successor list and add references to each member of <code>S</code>.
 <li>For each member of <code>S</code>, remove the reference to <code>V</code> from its
 predecessor list and add references to each member of <code>P</code>.
 </ul>
 Note that this change is made immediately; there is no need to call <code>save</code>.
 In fact, since the the version storage is read-only with respect to normal repository
 methods, <code>save</code> does not even function in this context.
 <p/>
 A <code>ReferentialIntegrityException</code> will be thrown if the specified version is
 currently the target of a <code>REFERENCE</code> property elsewhere in the repository
 (not just in this workspace) and the current <code>Session</code> has read access to
 that <code>REFERENCE</code> property.
 <p/>
 An <code>AccessDeniedException</code> will be thrown if the current <code>Session</code>
 does not have permission to remove the specified version or if the specified version is
 currently the target of a <code>REFERENCE</code> property elsewhere in the repository
 (not just in this workspace) and the current <code>Session</code> does not have read
 access to that <code>REFERENCE</code> property.
 <p/>
 Throws an <code>UnsupportedRepositoryOperationException</code> if this operation is
 not supported by the implementation.
 <p/>
 Throws a <code>VersionException</code> if the named version is not in this <code>VersionHistory</code>.

 @param versionName the name of a version in this version history.
 @throws ReferentialIntegrityException if the specified version is currently the target of a
 <code>REFERENCE</code> property elsewhere in the repository (not necessarily in this workspace)
 and the current <code>Session</code> has read access to that <code>REFERENCE</code> property.
 @throws AccessDeniedException if the current Session does not have permission to remove the
 specified version or if the specified version is currently the target of a <code>REFERENCE</code>
 property elsewhere in the repository (not just in this workspace) and the current <code>Session</code>
 does not have read access to that <code>REFERENCE</code> property.
 @throws UnsupportedRepositoryOperationException if this operation is not supported by the implementation.
 @throws VersionException if the named version is not in this version history.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>VersionHistory</code> object wraps an <code>nt:versionHistory</code>
 node. It provides convenient access to version history information.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.version.VersionHistory -->
  <!-- start interface javax.jcr.version.VersionIterator -->
  <interface name="VersionIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Version</code> in the iteration.

 @return the next <code>Version</code> in the iteration.
 @throws java.util.NoSuchElementException if iteration has no more <code>Version</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Version</code>s objects
 with <code>nextVersion</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.version.VersionIterator -->
</package>

</api>
