<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Sun Dec 13 00:56:05 CET 2009 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="jcr-2.0"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath C:\DevTools\jdiff-1.1.1\jdiff.jar;C:\DevTools\jdiff-1.1.1\xerces.jar -d C:\DevTools\jdiff-1.1.1\jcr-1.0-2.0-report -classpath C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-launcher.jar;C:\DevTools\jdiff-1.1.1\antjdiff.jar;C:\DevTools\jdiff-1.1.1\jdiff.jar;C:\DevTools\jdiff-1.1.1\xerces.jar;C:\DevTools\jdiff-1.1.1;C:\DevTools\Java\jre6\lib\ext\QTJava.zip;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-antlr.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-apache-bsf.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-apache-resolver.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-commons-logging.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-commons-net.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-icontract.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jai.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-bcel.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-log4j.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-oro.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jakarta-regexp.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-javamail.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jdepend.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jmf.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-jsch.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-junit.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-netrexx.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-nodeps.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-starteam.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-stylebook.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-swing.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-trax.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-vaj.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-weblogic.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-xalan1.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-xalan2.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant-xslp.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\ant.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\xercesImpl.jar;C:\DevTools\Ant\apache-ant-1.6.1\lib\xml-apis.jar;C:\DevTools\Java\jdk1.6.0_10\lib\tools.jar -sourcepath C:\Projects\CQ53Coordination\docs\content_repository-2_0-final-spec\jsr-283-fcs\src\java -apiname jcr-2.0 -baseURI http://www.w3.org -apidir C:\DevTools\jdiff-1.1.1\jcr-1.0-2.0-report -source 1.5 -->
<package name="javax.jcr">
  <!-- start class javax.jcr.AccessDeniedException -->
  <class name="AccessDeniedException" extends="javax.jcr.security.AccessControlException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessDeniedException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="AccessDeniedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="AccessDeniedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="AccessDeniedException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by access-related methods.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.AccessDeniedException -->
  <!-- start interface javax.jcr.Binary -->
  <interface name="Binary"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an {@link InputStream} representation of this value. Each call to
 <code>getStream()</code> returns a new stream. The API consumer is
 responsible for calling <code>close()</code> on the returned stream.
 <p>
 If {@link #dispose()} has been called on this <code>Binary</code>
 object, then this method will throw the runtime exception
 {@link java.lang.IllegalStateException}.

 @return A stream representation of this value.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="position" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Reads successive bytes from the specified <code>position</code> in this
 <code>Binary</code> into the passed byte array until either the byte
 array is full or the end of the <code>Binary</code> is encountered.
 <p>
 If {@link #dispose()} has been called on this <code>Binary</code>
 object, then this method will throw the runtime exception
 {@link java.lang.IllegalStateException}.

 @param b        the buffer into which the data is read.
 @param position the position in this Binary from which to start reading
                 bytes.
 @return the number of bytes read into the buffer, or -1 if there is no
         more data because the end of the Binary has been reached.
 @throws IOException              if an I/O error occurs.
 @throws NullPointerException     if b is null.
 @throws IllegalArgumentException if offset is negative.
 @throws RepositoryException      if another error occurs.]]>
      </doc>
    </method>
    <method name="getSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the size of this <code>Binary</code> value in bytes.
 <p>
 If {@link #dispose()} has been called on this <code>Binary</code>
 object, then this method will throw the runtime exception
 {@link java.lang.IllegalStateException}.

 @return the size of this value in bytes.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Releases all resources associated with this <code>Binary</code> object
 and informs the repository that these resources may now be reclaimed.
 An application should call this method when it is finished with the
 <code>Binary</code> object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>Binary</code> object holds a JCR property value of type
 <code>BINARY</code>. The <code>Binary</code> interface and the related
 methods in {@link Property}, {@link Value} and {@link ValueFactory} replace
 the deprecated {@link Value#getStream} and {@link Property#getStream}
 methods.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Binary -->
  <!-- start interface javax.jcr.Credentials -->
  <interface name="Credentials"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <doc>
    <![CDATA[Interface for all credentials that may be passed to the {@link
 Repository#login(Credentials credentials, String workspaceName)} method.
 Serves as a marker interface that all repositories must implement when
 providing a credentials class. See {@link SimpleCredentials} and {@link
 GuestCredentials} for examples of such a class.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Credentials -->
  <!-- start class javax.jcr.GuestCredentials -->
  <class name="GuestCredentials" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Credentials"/>
    <constructor name="GuestCredentials"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The constructor creates a new <code>GuestCredentials</code> object.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[<code>GuestCredentials</code> implements the <code>Credentials</code>
 interface and is used to obtain a "guest", "public" or "anonymous" session.
 Note that the characteristics of the session created from the
 <code>GuestCredentials</code> remain implementation specific.

 @since JCR 2.0]]>
    </doc>
  </class>
  <!-- end class javax.jcr.GuestCredentials -->
  <!-- start interface javax.jcr.ImportUUIDBehavior -->
  <interface name="ImportUUIDBehavior"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="IMPORT_UUID_CREATE_NEW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IMPORT_UUID_COLLISION_REMOVE_EXISTING" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IMPORT_UUID_COLLISION_REPLACE_EXISTING" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IMPORT_UUID_COLLISION_THROW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The possible actions specified by the <code>uuidBehavior</code> parameter in
 {@link Workspace#importXML}, {@link Session#importXML}, {@link
 Workspace#getImportContentHandler} and {@link Session#getImportContentHandler}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.ImportUUIDBehavior -->
  <!-- start class javax.jcr.InvalidItemStateException -->
  <class name="InvalidItemStateException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidItemStateException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidItemStateException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidItemStateException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidItemStateException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by the write methods of {@link Node} and {@link Property}
 and by {@link Session#save} and {@link Session#refresh} if an attempted
 change would conflict with a change to the persistent workspace made through
 another {@link Session}. Also thrown by methods of <code>Node</code> and
 <code>Property</code> if that object represents an item that has been removed
 from the workspace.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.InvalidItemStateException -->
  <!-- start class javax.jcr.InvalidLifecycleTransitionException -->
  <class name="InvalidLifecycleTransitionException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidLifecycleTransitionException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidLifecycleTransitionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidLifecycleTransitionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidLifecycleTransitionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by Lifecycle management-related methods.

 @since JCR 2.0]]>
    </doc>
  </class>
  <!-- end class javax.jcr.InvalidLifecycleTransitionException -->
  <!-- start class javax.jcr.InvalidSerializedDataException -->
  <class name="InvalidSerializedDataException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidSerializedDataException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidSerializedDataException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidSerializedDataException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidSerializedDataException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by the deserialization methods of <code>Session</code> if
 the serialized data being input has an invalid format.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.InvalidSerializedDataException -->
  <!-- start interface javax.jcr.Item -->
  <interface name="Item"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the normalized absolute path to this item.

 @return the normalized absolute path of this <code>Item</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the name of this <code>Item</code> in qualified form. If this
 <code>Item</code> is the root node of the workspace, an empty string is
 returned.

 @return the name of this <code>Item</code> in qualified form or an empty
         string if this <code>Item</code> is the root node of a
         workspace.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getAncestor" return="javax.jcr.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="depth" type="int"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the ancestor of this <code>Item</code> at the specified depth. An
 ancestor of depth <i>x</i> is the <code>Item</code> that is <i>x</i>
 levels down along the path from the root node to <i>this</i>
 <code>Item</code>. <ul> <li><i>depth</i> = 0 returns the root node of a
 workspace. <li><i>depth</i> = 1 returns the child of the root node along
 the path to <i>this</i> <code>Item</code>. <li><i>depth</i> = 2 returns
 the grandchild of the root node along the path to <i>this</i>
 <code>Item</code>. <li>And so on to <i>depth</i> = <i>n</i>, where
 <i>n</i> is the depth of <i>this</i> <code>Item</code>, which returns
 <i>this</i> <code>Item</code> itself. </ul>
 <p>
 If this node has more than one path (i.e., if it is a descendant of a
 shared node) then the path used to define the ancestor is
 implementaion-dependent.

 @param depth An integer, 0 &lt;= <i>depth</i> &lt;= <i>n</i> where
              <i>n</i> is the depth of <i>this</i> <code>Item</code>.
 @return The ancestor of this <code>Item</code> at the specified
         <code>depth</code>.
 @throws ItemNotFoundException if <i>depth</i> &lt; 0 or <i>depth</i> &gt;
                               <i>n</i> where <i>n</i> is the is the depth of this item.
 @throws AccessDeniedException if the current session does not have
                               sufficent access to retrieve the specified node.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getParent" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the parent of this <code>Item</code>.

 @return The parent of this <code>Item</code>.
 @throws ItemNotFoundException if this <code>Item</code> is the root node
                               of a workspace.
 @throws AccessDeniedException if the current session does not have
                               sufficent access to retrieve the parent of this item.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getDepth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the depth of this <code>Item</code> in the workspace item graph.
 <ul> <li>The root node returns 0. <li>A property or child node of the
 root node returns 1. <li>A property or child node of a child node of the
 root returns 2. <li>And so on to <i>this</i> <code>Item</code>. </ul>

 @return The depth of this <code>Item</code> in the workspace item graph.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getSession" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>Session</code> through which this <code>Item</code> was
 acquired.

 @return the <code>Session</code> through which this <code>Item</code> was
         acquired.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="isNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this <code>Item</code> is a <code>Node</code> or a
 <code>Property</code>. Returns <code>true</code> if this
 <code>Item</code> is a <code>Node</code>; Returns <code>false</code> if
 this <code>Item</code> is a <code>Property</code>.

 @return <code>true</code> if this <code>Item</code> is a
         <code>Node</code>, <code>false</code> if it is a
         <code>Property</code>.]]>
      </doc>
    </method>
    <method name="isNew" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is a new item, meaning that it exists
 only in transient storage on the <code>Session</code> and has not yet
 been saved. Within a transaction, <code>isNew</code> on an
 <code>Item</code> may return <code>false</code> (because the item has
 been saved) even if that <code>Item</code> is not in persistent storage
 (because the transaction has not yet been committed).
 <p>
 Note that if an item returns <code>true</code> on <code>isNew</code>,
 then by definition is parent will return <code>true</code> on
 <code>isModified</code>.
 <p>
 Note that in read-only implementations, this method will always return
 <code>false</code>.

 @return <code>true</code> if this item is new; <code>false</code>
         otherwise.]]>
      </doc>
    </method>
    <method name="isModified" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Item</code> has been saved but
 has subsequently been modified through the current session and therefore
 the state of this item as recorded in the session differs from the state
 of this item as saved. Within a transaction, <code>isModified</code> on
 an <code>Item</code> may return <code>false</code> (because the
 <code>Item</code> has been saved since the modification) even if the
 modification in question is not in persistent storage (because the
 transaction has not yet been committed).
 <p>
 Note that in read-only implementations, this method will always return
 <code>false</code>.

 @return <code>true</code> if this item is modified; <code>false</code>
         otherwise.]]>
      </doc>
    </method>
    <method name="isSame" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherItem" type="javax.jcr.Item"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Item</code> object (the Java
 object instance) represents the same actual workspace item as the object
 <code>otherItem</code>.
 <p>
 Two <code>Item</code> objects represent the same workspace item if and
 only if all the following are true: <ul> <li>Both objects were acquired
 through <code>Session</code> objects that were created by the same
 <code>Repository</code> object.</li> <li>Both objects were acquired
 through <code>Session</code> objects bound to the same repository
 workspace.</li> <li>The objects are either both <code>Node</code> objects
 or both <code>Property</code> objects.</li> <li>If they are
 <code>Node</code> objects, they have the same identifier.</li> <li>If
 they are <code>Property</code> objects they have identical names and
 <code>isSame</code> is true of their parent nodes.</li> </ul> This method
 does not compare the <i>states</i> of the two items. For example, if two
 <code>Item</code> objects representing the same actual workspace item
 have been retrieved through two different sessions and one has been
 modified, then this method will still return <code>true</code> when
 comparing these two objects. Note that if two <code>Item</code> objects
 representing the same workspace item are retrieved through the
 <i>same</i> session they will always reflect the same state.

 @param otherItem the <code>Item</code> object to be tested for identity
                  with this <code>Item</code>.
 @return <code>true</code> if this <code>Item</code> object and
         <code>otherItem</code> represent the same actual repository item;
         <code>false</code> otherwise.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="javax.jcr.ItemVisitor"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Accepts an <code>ItemVisitor</code>. Calls the appropriate
 <code>ItemVisitor</code> <code>visit</code> method of the according to
 whether <i>this</i> <code>Item</code> is a <code>Node</code> or a
 <code>Property</code>.

 @param visitor The ItemVisitor to be accepted.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link Session#save()} should be used
             instead.">
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="ReferentialIntegrityException" type="javax.jcr.ReferentialIntegrityException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Validates all pending changes currently recorded in this
 <code>Session</code> that apply to this <code>Item</code> or any of its
 descendants (that is, the subgraph rooted at this Item). If validation of
 <i>all</i> pending changes succeeds, then this change information is
 cleared from the <code>Session</code>. If the <code>save</code> occurs
 outside a transaction, the changes are persisted and thus made visible to
 other <code>Sessions</code>. If the <code>save</code> occurs within a
 transaction, the changes are not persisted until the transaction is
 committed.
 <p>
 If validation fails, then no pending changes are saved and they remain
 recorded on the <code>Session</code>. There is no best-effort or partial
 save.
 <p>
 The item in persistent storage to which a transient item is saved is

 @throws AccessDeniedException         if any of the changes to be persisted would
                                       exceed the access capabilities of the the current session. Also thrown if
                                       any of the changes to be persisted would cause the removal of a node that
                                       is currently referenced by a <code>REFERENCE</code> property that the
                                       current session <i>does not</i> have read access to.
 @throws ItemExistsException           if any of the changes to be persisted would
                                       be prevented by the presence of an already existing item in the
                                       workspace.
 @throws ConstraintViolationException  if any of the changes to be
                                       persisted would violate a node type or restriction. Additionally, a
                                       repository may use this exception to enforce implementation- or
                                       configuration-dependent restrictions.
 @throws InvalidItemStateException     if any of the changes to be persisted
                                       conflicts with a change already persisted through another session and the
                                       implementation is such that this conflict can only be detected at
                                       <code>save</code>-time and therefore was not detected earlier, at
                                       change-time.
 @throws ReferentialIntegrityException if any of the changes to be
                                       persisted would cause the removal of a node that is currently referenced
                                       by a <code>REFERENCE</code> property that this <code>Session</code> has
                                       read access to.
 @throws VersionException              if the <code>save</code> would make a result in
                                       a change to persistent storage that would violate the read-only status of
                                       a checked-in node.
 @throws LockException                 if the <code>save</code> would result in a change
                                       to persistent storage that would violate a lock.
 @throws NoSuchNodeTypeException       if the <code>save</code> would result in
                                       the addition of a node with an unrecognized node type.
 @throws RepositoryException           if another error occurs.
 @deprecated As of JCR 2.0, {@link Session#save()} should be used
             instead.]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keepChanges" type="boolean"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If <code>keepChanges</code> is <code>false</code>, this method discards
 all pending changes currently recorded in this <code>Session</code> that
 apply to this Item or any of its descendants (that is, the subgraph
 rooted at this Item)and returns all items to reflect the current saved
 state. Outside a transaction this state is simple the current state of
 persistent storage. Within a transaction, this state will reflect
 persistent storage as modified by changes that have been saved but not
 yet committed.
 <p>
 If <code>keepChanges</code> is true then pending change are not discarded
 but items that do not have changes pending have their state refreshed to
 reflect the current saved state, thus revealing changes made by other
 sessions.

 @param keepChanges a boolean
 @throws InvalidItemStateException if this <code>Item</code> object
                                   represents a workspace item that has been removed (either by this session
                                   or another).
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes <code>this</code> item (and its subgraph).
 <p>
 To persist a removal, a <code>save</code> must be performed that includes
 the (former) parent of the removed item within its scope.
 <p>
 If a node with same-name siblings is removed, this decrements by one the
 indices of all the siblings with indices greater than that of the removed
 node. In other words, a removal compacts the array of same-name siblings
 and causes the minimal re-numbering required to maintain the original
 order but leave no gaps in the numbering.

 @throws VersionException             if the parent node of this item is versionable
                                      and checked-in or is non-versionable but its nearest versionable ancestor
                                      is checked-in and this implementation performs this validation
                                      immediately instead of waiting until <code>save</code>.
 @throws LockException                if a lock prevents the removal of this item and
                                      this implementation performs this validation immediately instead of
                                      waiting until <code>save</code>.
 @throws ConstraintViolationException if removing the specified item would
                                      violate a node type or implementation-specific constraint and this
                                      implementation performs this validation immediately instead of waiting
                                      until <code>save</code>.
 @throws AccessDeniedException        if this item or an item in its subgraph is
                                      currently the target of a <code>REFERENCE</code> property located in this
                                      workspace but outside this item's subgraph and the current
                                      <code>Session</code> <i>does not</i> have read access to that
                                      <code>REFERENCE</code> property or if the current <code>Session</code>
                                      does not have sufficent privileges to remove the item.
 @throws RepositoryException          if another error occurs.
 @see javax.jcr.Session#removeItem(String)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>Item</code> is the base interface of <code>{@link Node}</code> and
 <code>{@link Property}</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Item -->
  <!-- start class javax.jcr.ItemExistsException -->
  <class name="ItemExistsException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ItemExistsException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ItemExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ItemExistsException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ItemExistsException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An exception thrown when an attempt is made to place an item in a position
 where another item already exists.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ItemExistsException -->
  <!-- start class javax.jcr.ItemNotFoundException -->
  <class name="ItemNotFoundException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ItemNotFoundException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ItemNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ItemNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ItemNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by methods of <code>{@link Item}</code>, <code>{@link
 Node}</code> and <code>{@link Workspace}</code> when an item is not found.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ItemNotFoundException -->
  <!-- start interface javax.jcr.ItemVisitor -->
  <interface name="ItemVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method is called when the <code>ItemVisitor</code> is passed to the
 <code>accept</code> method of a <code>Property</code>. If this method
 throws an exception the visiting process is aborted.

 @param property The <code>Property</code> that is accepting this
                 visitor.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method is called when the <code>ItemVisitor</code> is passed to the
 <code>accept</code> method of a <code>Node</code>. If this method throws
 an exception the visiting process is aborted.

 @param node The <code>Node</code that is accepting this visitor.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface defines two signatures of the <code>visit</code> method; one
 taking a <code>Node</code>, the other a <code>Property</code>. When an object
 implementing this interface is passed to <code>{@link Item#accept(ItemVisitor
 visitor)}</code> the appropriate <code>visit</code> method is automatically
 called, depending on whether the <code>Item</code> in question is a
 <code>Node</code> or a <code>Property</code>. Different implementations of
 this interface can be written for different purposes. It is, for example,
 possible for the <code>{@link #visit(Node node)}</code> method to call
 <code>accept</code> on the children of the passed node and thus recurse
 through the tree performing some operation on each <code>Item</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.ItemVisitor -->
  <!-- start class javax.jcr.LoginException -->
  <class name="LoginException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LoginException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="LoginException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="LoginException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="LoginException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by <code>{@link Repository#login(Credentials,
 String)}</code> and <code>{@link Session#impersonate(Credentials)}</code> if
 the specified credentials are invalid.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.LoginException -->
  <!-- start class javax.jcr.MergeException -->
  <class name="MergeException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MergeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="MergeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="MergeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="MergeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by {@link Node#merge(String srcWorkspace, boolean isDeep)}.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.MergeException -->
  <!-- start class javax.jcr.NamespaceException -->
  <class name="NamespaceException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NamespaceException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="NamespaceException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="NamespaceException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="NamespaceException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by <code>{@link Session#setNamespacePrefix(String prefix,
 String uri)}</code> if the specified <code>uri</code> is not registered in
 the {@link NamespaceRegistry}.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.NamespaceException -->
  <!-- start interface javax.jcr.NamespaceRegistry -->
  <interface name="NamespaceRegistry"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="registerNamespace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets a one-to-one mapping between <code>prefix</code> and
 <code>uri</code> in the global namespace registry of this repository.
 <p>
 Assigning a new prefix to a URI that already exists in the namespace
 registry erases the old prefix. In general this can almost always be
 done, though an implementation is free to prevent particular remappings
 by throwing a <code>NamespaceException</code>.
 <p>
 On the other hand, taking a prefix that is already assigned to a URI and
 re-assigning it to a new URI in effect unregisters that URI. Therefore,
 the same restrictions apply to this operation as to
 <code>NamespaceRegistry.unregisterNamespace</code>.

 @param prefix The prefix to be mapped.
 @param uri    The URI to be mapped.
 @throws NamespaceException    If an attempt is made to re-assign a built-in
                               prefix to a new URI or, to register a namespace with a prefix that begins
                               with the characters "<code>xml</code>" (in any combination of case) or,
                               An attempt is made to perform a prefix re-assignment that is forbidden
                               for implementation-specific reasons.
 @throws UnsupportedRepositoryOperationException
                               if this repository does
                               not support namespace registry changes.
 @throws AccessDeniedException if the current session does not have
                               sufficent access to register the namespace.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="unregisterNamespace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes a namespace mapping from the registry.

 @param prefix The prefix of the mapping to be removed.
 @throws NamespaceException    if an attempt is made to unregister a built-in
                               namespace or a namespace that is not currently registered or a namespace
                               whose unregsitration is forbidden for implementation-specific reasons.
 @throws UnsupportedRepositoryOperationException
                               if this repository does
                               not support namespace registry changes.
 @throws AccessDeniedException if the current session does not have
                               sufficent access to unregister the namespace.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getPrefixes" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array holding all currently registered prefixes.

 @return a string array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getURIs" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array holding all currently registered URIs.

 @return a string array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getURI" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the URI to which the given <code>prefix</code> is mapped.

 @param prefix a string.
 @return a string.
 @throws NamespaceException  if a mapping with the specified
                             <code>prefix</code> does not exist.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the prefix which is mapped to the given <code>uri</code>.

 @param uri a string.
 @return a string.
 @throws NamespaceException  if a mapping with the specified
                             <code>uri</code> does not exist.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <field name="PREFIX_JCR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace prefix "jcr".]]>
      </doc>
    </field>
    <field name="PREFIX_NT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace prefix "nt".]]>
      </doc>
    </field>
    <field name="PREFIX_MIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace prefix "mix".]]>
      </doc>
    </field>
    <field name="PREFIX_XML" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace prefix "xml".]]>
      </doc>
    </field>
    <field name="PREFIX_EMPTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace prefix "" (the empty prefix).]]>
      </doc>
    </field>
    <field name="NAMESPACE_JCR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace mapped by default to the prefix
 "jcr".]]>
      </doc>
    </field>
    <field name="NAMESPACE_NT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace mapped by default to the prefix
 "nt".]]>
      </doc>
    </field>
    <field name="NAMESPACE_MIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace mapped by default to the prefix
 "mix".]]>
      </doc>
    </field>
    <field name="NAMESPACE_XML" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace mapped by default to the prefix
 "xml".]]>
      </doc>
    </field>
    <field name="NAMESPACE_EMPTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the predefined namespace mapped by default to the prefix
 "" (the empty prefix).]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Each repository has a single, persistent namespace registry represented by
 the <code>NamespaceRegistry</code> object, accessed via {@link
 Workspace#getNamespaceRegistry}. The namespace registry contains the default
 prefixes of the registered namespaces. The namespace registry may contain
 namespaces that are not used in repository content, and there may be
 repository content with namespaces that are not included in the registry.

 @see Workspace#getNamespaceRegistry]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.NamespaceRegistry -->
  <!-- start interface javax.jcr.Node -->
  <interface name="Node"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Item"/>
    <method name="addNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new node at <code>relPath</code>.
 <p>
 This is <i>session-write</i> method, meaning that the addition of the new
 node is dispatch upon {@link Session#save}.
 <p>
 The <code>relPath</code> provided must not have an index on its final
 element, otherwise a Repository
 <p>
 If ordering is supported by the node type of the parent node of the new
 node then the new node is appended to the end of the child node list.
 <p>
 The new node's primary node type will be determined by the child node
 definitions in the node types of its parent. This may occur either
 immediately, on dispatch (save, whether within or without transactions)
 or on persist (save without transactions, commit within a transaction),
 depending on the implementation.
 <p>
 An <code>ItemExistsException</code> will be thrown either immediately, on
 dispatch (save, whether within or without transactions) or on persist
 (save without transactions, commit within a transaction), if an item at
 the specified path already exists and same-name siblings are not allowed.
 Implementations may differ on when this validation is performed.
 <p>
 A <code>PathNotFoundException</code> will be thrown either immediately,
 on dispatch (save, whether within or without transactions) or on persist
 (save without transactions, commit within a transaction), if the
 specified path implies intermediary nodes that do not exist.
 Implementations may differ on when this validation is performed.
 <p>
 A <code>ConstraintViolationException</code> will be thrown either
 immediately, on dispatch (save, whether within or without transactions)
 or on persist (save without transactions, commit within a transaction),
 if adding the node would violate a node type or implementation-specific
 constraint or if an attempt is made to add a node as the child of a
 property. Implementations may differ on when this validation is
 performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch (save, whether within or without transactions) or on persist
 (save without transactions, commit within a transaction), if the node to
 which the new child is being added is read-only due to a checked-in node.
 Implementations may differ on when this validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch (save, whether within or without transactions) or on persist
 (save without transactions, commit within a transaction), if a lock
 prevents the addition of the node. Implementations may differ on when
 this validation is performed.

 @param relPath The path of the new node to be created.
 @return The node that was added.
 @throws ItemExistsException          if an item at the specified path already
                                      exists, same-name siblings are not allowed and this implementation
                                      performs this validation immediately.
 @throws PathNotFoundException        if the specified path implies intermediary
                                      <code>Node</code>s that do not exist or the last element of
                                      <code>relPath</code> has an index, and this implementation performs this
                                      validation immediately.
 @throws ConstraintViolationException if a node type or
                                      implementation-specific constraint is violated or if an attempt is made
                                      to add a node as the child of a property and this implementation performs
                                      this validation immediately.
 @throws VersionException             if the node to which the new child is being
                                      added is read-only due to a checked-in node and this implementation
                                      performs this validation immediately.
 @throws LockException                if a lock prevents the addition of the node and
                                      this implementation performs this validation immediately.
 @throws RepositoryException          If the last element of <code>relPath</code>
                                      has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="addNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <param name="primaryNodeTypeName" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new node at <code>relPath</code> of the specified node type.
 The behavior of this method is identical to {@link #addNode(String
 relPath)} except that the primary node type of the new node is explicitly
 specified.

 @param relPath             the path of the new node to be created.
 @param primaryNodeTypeName The name of the primary node type of the new
                            node.
 @return the node that was added.
 @throws ItemExistsException          if an item at the specified path already
                                      exists, same-name siblings are not allowed and this implementation
                                      performs this validation immediately instead of waiting until
                                      <code>save</code>.
 @throws PathNotFoundException        if the specified path implies intermediary
                                      <code>Node</code>s that do not exist or the last element of
                                      <code>relPath</code> has an index, and this implementation performs this
                                      validation immediately instead of waiting until <code>save</code>.
 @throws NoSuchNodeTypeException      if the specified node type is not
                                      recognized and this implementation performs this validation immediately
                                      instead of waiting until <code>save</code>.
 @throws ConstraintViolationException if a node type or
                                      implementation-specific constraint is violated or if an attempt is made
                                      to add a node as the child of a property and this implementation performs
                                      this validation immediately instead of waiting until <code>save</code>.
 @throws VersionException             if the node to which the new child is being
                                      added is read-only due to a checked-in node and this implementation
                                      performs this validation immediately instead of waiting until
                                      <code>save</code>.
 @throws LockException                if a lock prevents the addition of the node and
                                      this implementation performs this validation immediately instead of
                                      waiting until <code>save</code>.
 @throws RepositoryException          if the last element of <code>relPath</code>
                                      has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="orderBefore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcChildRelPath" type="java.lang.String"/>
      <param name="destChildRelPath" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this node supports child node ordering, this method inserts the child
 node at <code>srcChildRelPath</code> into the child node list at the
 position immediately the child node at <code>destChildRelPath</code>.
 <p>
 To place the node <code>srcChildRelPath</code> at the end of the list, a
 <code>destChildRelPath</code> of <code>null</code> is used.
 <p>
 Note that (apart from the case where <code>destChildRelPath</code> is
 <code>null</code>) both of these arguments must be relative paths of
 depth one, in other words they are the names of the child nodes, possibly
 suffixed with an index.
 <p>
 If <code>srcChildRelPath</code> and <code>destChildRelPath</code> are the
 same, then no change is made.
 <p>
 This is session-write method, meaning that a change made by this method
 is dispatched on <code>save</code>
 <p>
 A <code>ConstraintViolationException</code> will be thrown either
 immediately, on dispatch (save whether within or without transactions) or
 on persist (save without transactions, commit within a transaction), if
 this operation would violate a node type or implementation-specific
 constraint. Implementations may differ on when this validation is
 performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch (save whether within or without transactions) or on persist
 (save without transactions, commit within a transaction), if this node is
 read-only due to it or a node above it being checked-in Implementations
 may differ on when this validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately (by this
 method), or on <code>save</code>, if a lock prevents the re-ordering.
 Implementations may differ on when this validation is performed.

 @param srcChildRelPath  the relative path to the child node (that is, name
                         plus possible index) to be moved in the ordering
 @param destChildRelPath the the relative path to the child node (that is,
                         name plus possible index) before which the node <code>srcChildRelPath</code>
                         will be placed.
 @throws UnsupportedRepositoryOperationException
                                      if ordering is not
                                      supported on this node.
 @throws ConstraintViolationException if an implementation-specific
                                      ordering restriction is violated and this implementation performs this
                                      validation immediately.
 @throws ItemNotFoundException        if either parameter is not the relative
                                      path of a child node of this node.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the re-ordering and this
                                      implementation performs this validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Value"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the single-value property of this node called <code>name</code> to
 the specified <code>value</code>.
 <p>
 If the property does not yet exist, it is created and its property type
 determined by the by the node type of this node. If, based on the
 <code>name</code> and <code>value</code> passed, there is more than one
 property definition that applies, the repository chooses one definition
 according to some implementation-specific criteria. Once a property with
 name <code>P</code> has been created, the behavior of a subsequent
 <code>setProperty(P,V)</code> may differ across implementations. Some
 repositories may allow <code>P</code> to be dynamically re-bound to a
 different property definition (based for example, on the new value being
 of a different type than the original value) while other repositories may
 not allow such dynamic re-binding.
 <p>
 If the property type of the supplied <code>Value</code> object is
 different from that required, then a best-effort conversion is
 attempted.
 <p>
 If the node type of this node does not indicate a specific property type,
 then the property type of the supplied <code>Value</code> object is used
 and if the property already exists it assumes both the new value and new
 property type.
 <p>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the
 <code>Property</code> object itself.
 <p>
 This is a session-write method, meaning that changes made through this
 method are dispatched on {@link Session#save}.
 <p>
 A <code>ConstraintViolationException</code> will be thrown either
 immediately, on dispatch (save whether within or without transactions) or
 on persist (save without transactions, commit within a transaction), if
 the change would violate a node type or implementation-specific
 constraint. Implementations may differ on when this validation is
 performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch (save whether within or without transactions) or on persist
 (save without transactions, commit within a transaction), if this node is
 read-only due to a checked-in node. Implementations may differ on when
 this validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch (save whether within or without transactions) or on persist
 (save without transactions, commit within a transaction), if a lock
 prevents the setting of the property. Implementations may differ on when
 this validation is performed.

 @param name  The name of a property of this node
 @param value The value to be assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if the specified property is a
                                      <code>DATE</code> but the <code>value</code> cannot be expressed in the
                                      ISO 8601-based format defined in the JCR 2.0 specification and the
                                      implementation does not support dates incompatible with that format or if
                                      <code>value</code> cannot be converted to the type of the specified
                                      property or if the property already exists and is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Value"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the single-value property of this node called <code>name</code> to
 the specified <code>value</code> and the specified <code>type</code>.
 <p>
 The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the intended property
 type is explicitly specified.
 <p>
 If the property does not yet exist, it is created. If the property
 already exists it assumes both the new value and the new property type.

 @param name  the name of the property to be set.
 @param value a <code>Value</code> object.
 @param type  the type of the property.
 @return the <code>Property</code> object set, or <code>null</code> if
         this method was used to remove a property (by setting its value
         to <code>null</code>).
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the specified type or if the property already exists and is
                                      multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="javax.jcr.Value[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the multi-value property of this node called <code>name</code> to
 the specified array of values.
 <p>
 If the property does not yet exist, it is created.
 <p>
 The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that an array of
 <code>Value</code> objects is assigned instead of a single
 <code>Value</code>.
 <p>
 The property type of the property will be that specified by the node type
 of this node. If the property type of one or more of the supplied
 <code>Value</code> objects is different from that required, then a
 best-effort conversion is attempted, according to an
 implemention-dependent definition of "best effort". If the conversion
 fails, a <code>ValueFormatException</code> is thrown.
 <p>
 If the property is not multi-valued then a <code>ValueFormatException</code>
 is also thrown. If another error occurs, a <code>RepositoryException</code>
 is thrown.
 <p>
 If the node type of this node does not indicate a specific property type,
 then the property type of the supplied <code>Value</code> objects is used
 and if the property already exists it assumes both the new values and the
 new property type.
 <p>
 Passing a <code>null</code> as the second parameter removes the property.
 It is equivalent to calling <code>remove</code> on the
 <code>Property</code> object itself. Note that this is different from
 passing an array that contains <code>null</code> elements. In such a
 case, the array is compacted by removing the <code>null</code> values.
 The resulting set of values never contains a null. However, the set may
 be empty: <code>N.setProperty("P", new Value[]{null})</code> would set
 the property to the empty set of values.

 @param name   the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is not multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="javax.jcr.Value[]"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the multi-value property of this node called <code>name</code> to
 the specified array of values.
 <p>
 The behavior of this method is identical to that of {@link
 #setProperty(String name, Value[] values)} except that the type of the
 property is explicitly specified.
 <p>
 If the property does not yet exist, it is created. The type of the
 property is determined by the <code>type</code> parameter specified.
 <p>
 If the property type of one or more of the supplied <code>Value</code>
 objects is different from that specified, then a best-effort conversion
 is attempted, according to an implemention-dependent definition of "best
 effort". If the conversion fails, a <code>ValueFormatException</code> is
 thrown.
 <p>
 If the property already exists it assumes both the new values and the new
 property type.
 <p>

 @param name   the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @param type   the type of the property.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException         if a value cannot be converted to the
                                      specified type or if the property already exists and is not
                                      multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified array of values. Same as
 {@link #setProperty(String name, Value[] values)} except that the values
 are specified as <code>String</code> objects instead of
 <code>Value</code> objects.

 @param name   the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException         if a value cannot be converted to the type
                                      of the specified property or if the property already exists and is not
                                      multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified property to the specified array of values and to the
 specified type. Same as {@link #setProperty(String name, Value[] values,
 int type)} except that the values are specified as <code>String</code>
 objects instead of <code>Value</code> objects.

 @param name   the name of the property to be set.
 @param values an array of <code>Value</code> objects.
 @param type   the type of the property.
 @return the updated <code>Property</code> object.
 @throws ValueFormatException         if a value cannot be converted to the
                                      specified type or if the property already exists and is not
                                      multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified single-value property to the specified value. The
 behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a <code>String</code>. and, if possible, the type assigned
 to the property is <code>STRING</code>, otherwise a best-effort
 conversion is attempted.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the specified single-value property to the specified value. If the
 property does not yet exist, it is created.
 <p>
 The behavior of this method is identical to that of {@link
 #setProperty(String name, String value)} except that the intended type of
 the property is explicitly specified by the <code>type</code> parameter.

 @param name  the name of the property to be set.
 @param value a <code>String</code> object.
 @param type  the type of the property.
 @return the <code>Property</code> object set, or <code>null</code> if
         this method was used to remove a property (by setting its value
         to <code>null</code>).
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the specified type or if the property already exists and is
                                      multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #setProperty(String, Binary)} should be
             used instead.">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.io.InputStream"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a {@link InputStream} and, if possible, the type assigned to
 the property is <code>BINARY</code>, otherwise a best-effort conversion
 is attempted.
 <p>
 The passed stream is closed before this method returns either normally or
 because of an exception.
 <p>

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.
 @deprecated As of JCR 2.0, {@link #setProperty(String, Binary)} should be
             used instead.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Binary"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a {@link Binary} and, if possible, the type assigned to the
 property is <code>BINARY</code>, otherwise a best-effort conversion is
 attempted.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a <code>boolean</code> and, if possible, the type assigned
 to the property is <code>BOOLEAN</code>, otherwise a best-effort
 conversion is attempted.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a <code>double</code> and, if possible, the type assigned to
 the property is <code>DOUBLE</code>, otherwise a best-effort conversion
 is attempted.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.math.BigDecimal"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a {@link BigDecimal} and, if possible, the type assigned to
 the property is <code>DECIMAL</code>, otherwise a best-effort conversion
 is attempted.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a <code>long</code> and, if possible, the type assigned to
 the property is <code>LONG</code>, otherwise a best-effort conversion is
 attempted.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if <code>value</code> cannot be converted to
                                      the type of the specified property or if the property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.util.Calendar"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a {@link Calendar} and, if possible, the type assigned to
 the property is <code>DATE</code>, otherwise a best-effort conversion is
 attempted.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object
 @throws ValueFormatException         if the specified property is a
                                      <code>DATE</code> but the <code>value</code> cannot be expressed in the
                                      ISO 8601-based format defined in the JCR 2.0 specification (section
                                      3.6.4.3) and the implementation does not support dates incompatible with
                                      that format or if <code>value</code> cannot be converted to the type of
                                      the specified property or if the property already exists and is
                                      multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Node"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[The behavior of this method is identical to that of {@link
 #setProperty(String name, Value value)} except that the value is
 specified as a {@link Node} and, if possible, the type assigned to the
 property is <code>REFERENCE</code> or <code>WEAKREFERENCE</code>,
 otherwise a best-effort conversion is attempted.
 <p>
 The value to which the property is set is the identifier of the passed
 node.
 <p>
 If the named property does not yet exist and the repository cannot
 determine whether a <code>REFERENCE</code> or <code>WEAKREFERENCE</code>
 property is intended, then a <code>REFERENCE</code> property is created.

 @param name  The name of a property of this node
 @param value The value to assigned
 @return The updated <code>Property</code> object.
 @throws ValueFormatException         if this property is not of type
                                      <code>REFERENCE</code> or <code>WEAKREFERENCE</code> or the specified
                                      node is not referenceable or if the specified property already exists and
                                      is multi-valued.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the setting of the property and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node at <code>relPath</code> relative to this node.
 <p>
 If <code>relPath</code> contains a path element that refers to a node
 with same-name sibling nodes without explicitly including an index using
 the array-style notation (<code>[x]</code>), then the index [1] is
 assumed (indexing of same name siblings begins at 1, not 0, in order to
 preserve compatibility with XPath).
 <p>
 Within the scope of a single <code>Session</code> object, if a
 <code>Node</code> object has been acquired, any subsequent call of
 <code>getNode</code> reacquiring the same node must return a
 <code>Node</code> object reflecting the same state as the earlier
 <code>Node</code> object. Whether this object is actually the same
 <code>Node</code> instance, or simply one wrapping the same state, is up
 to the implementation.

 @param relPath The relative path of the node to retrieve.
 @return The node at <code>relPath</code>.
 @throws PathNotFoundException if no node exists at the specified path or
                               the current <code>Session</code> does not read access to the node at the
                               specified path.
 @throws RepositoryException   If another error occurs.]]>
      </doc>
    </method>
    <method name="getNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all child nodes of this node accessible through the current
 <code>Session</code>. Does <i>not</i> include properties of this
 <code>Node</code>. The same reacquisition semantics apply as with {@link
 #getNode(String)}. If this node has no accessible child nodes, then an
 empty iterator is returned.

 @return A <code>NodeIterator</code> over all child <code>Node</code>s of
         this <code>Node</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namePattern" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Gets all child nodes of this node accessible through the current
 <code>Session</code> that match <code>namePattern</code>. The pattern may
 be a full name or a partial name with one or more wildcard characters
 ("<code>*</code>"), or a disjunction (using the "<code>|</code>"
 character to represent logical <code>OR</code>) of these. For example,
 <p>
 <code>N.getNodes("jcr:* | myapp:report | my doc")</code>
 <p>
 would return a <code>NodeIterator</code> holding all accessible child
 nodes of <code>N</code> that are either called '<code>myapp:report</code>',
 begin with the prefix '<code>jcr:</code>' or are called '<code>my
 doc</code>'.
 <p>
 The substrings within the pattern that are delimited by "<code>|</code>"
 characters and which may contain wildcard characters ("<code>*</code>")
 are called <i>globs</i>.
 <p>
 Note that leading and trailing whitespace around a glob is ignored, but
 whitespace within a disjunct forms part of the pattern to be matched.
 <p>
 The pattern is matched against the names (not the paths) of the immediate
 child nodes of this node.
 <p>
 If this node has no accessible matching child nodes, then an empty
 iterator is returned.
 <p>
 The same reacquisition semantics apply as with <code>{@link
 #getNode(String)}</code>.

 @param namePattern a name pattern.
 @return a <code>NodeIterator</code>.
 @throws RepositoryException if an unexpected error occurs.]]>
      </doc>
    </method>
    <method name="getNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nameGlobs" type="java.lang.String[]"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Gets all child nodes of this node accessible through the current
 <code>Session</code> that match one or more of the <code>nameGlob</code>
 strings in the passed array.
 <p>
 A glob may be a full name or a partial name with one or more wildcard
 characters ("<code>*</code>"). For example,
 <p>
 <code>N.getNodes(new String[] {"jcr:*", "myapp:report", "my
 doc"})</code>
 <p>
 would return a <code>NodeIterator</code> holding all accessible child
 nodes of <code>N</code> that are either called '<code>myapp:report</code>',
 begin with the prefix '<code>jcr:</code>' or are called '<code>my
 doc</code>'.
 <p>
 Note that unlike in the case of the {@link #getNodes(String)} leading and
 trailing whitespace around a glob is <i>not</i> ignored.
 <p>
 The globs are matched against the names (not the paths) of the immediate
 child nodes of this node.
 <p>
 If this node has no accessible matching child nodes, then an empty
 iterator is returned.
 <p>
 The same reacquisition semantics apply as with <code>{@link
 #getNode(String)}</code>.

 @param nameGlobs an array of globbing strings.
 @return a <code>NodeIterator</code>.
 @throws RepositoryException if an unexpected error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the property at <code>relPath</code> relative to
 <code>this</code> node. The same reacquisition semantics apply as with
 <code>{@link #getNode(String)}</code>.

 @param relPath The relative path of the property to retrieve.
 @return The property at <code>relPath</code>.
 @throws PathNotFoundException if no property exists at the specified path
                               or if the current
                               <p>
                               <code>Session</code> does not have read access to the specified
                               property.
 @throws RepositoryException   If another error occurs.]]>
      </doc>
    </method>
    <method name="getProperties" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all properties of this node accessible through the current
 <code>Session</code>. Does <i>not</i> include child <i>nodes</i> of this
 node. The same reacquisition semantics apply as with <code>{@link
 #getNode(String)}</code>. If this node has no accessible properties, then
 an empty iterator is returned.

 @return A <code>PropertyIterator</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getProperties" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namePattern" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Gets all properties of this node accessible through the current
 <code>Session</code> that match <code>namePattern</code>. The pattern may
 be a full name or a partial name with one or more wildcard characters
 ("<code>*</code>"), or a disjunction (using the "<code>|</code>"
 character to represent logical <code>OR</code>) of these. For example,
 <p>
 <code>N.getProperties("jcr:* | myapp:name | my doc")</code>
 <p>
 would return a <code>PropertyIterator</code> holding all accessible
 properties of <code>N</code> that are either called
 '<code>myapp:name</code>', begin with the prefix '<code>jcr:</code>' or
 are called '<code>my doc</code>'.
 <p>
 <p>
 The substrings within the pattern that are delimited by "<code>|</code>"
 characters and which may contain wildcard characters ("<code>*</code>")
 are called <i>globs</i>.
 <p>
 Note that leading and trailing whitespace around a glob is ignored, but
 whitespace within a disjunct forms part of the pattern to be matched.
 <p>
 The pattern is matched against the names (not the paths) of the immediate
 child properties of this node.
 <p>
 If this node has no accessible matching properties, then an empty
 iterator is returned.
 <p>
 The same reacquisition semantics apply as with <code>{@link
 #getNode(String)}</code>.

 @param namePattern a name pattern.
 @return a <code>PropertyIterator</code>.
 @throws RepositoryException if an unexpected error occurs.]]>
      </doc>
    </method>
    <method name="getProperties" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nameGlobs" type="java.lang.String[]"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Gets all properties of this node accessible through the current
 <code>Session</code> that match one or more of the <code>nameGlob</code>
 strings in the passed array.
 <p>
 A glob may be a full name or a partial name with one or more wildcard
 characters ("<code>*</code>"). For example,
 <p>
 <code>N.getProperties(new String[] {"jcr:*", "myapp:report", "my
 doc"})</code>
 <p>
 would return a <code>PropertyIterator</code> holding all accessible
 properties of <code>N</code> that are either called
 '<code>myapp:report</code>', begin with the prefix '<code>jcr:</code>' or
 are called '<code>my doc</code>'.
 <p>
 Note that unlike in the case of the {@link #getProperties(String)}
 leading and trailing whitespace around a glob is <i>not</i> ignored.
 <p>
 The globs are matched against the names (not the paths) of the properties
 of this node.
 <p>
 If this node has no accessible matching properties, then an empty
 iterator is returned.
 <p>
 The same reacquisition semantics apply as with <code>{@link
 #getProperty(String)}</code>.

 @param nameGlobs an array of globbing strings.
 @return a <code>PropertyIterator</code>.
 @throws RepositoryException if an unexpected error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getPrimaryItem" return="javax.jcr.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the primary child item of this node. The primary node type of
 this node may specify one child item (child node or property) of this
 node as the <i>primary child item</i>. This method returns that item.
 <p>
 In cases where the primary child item specifies the name of a set
 same-name sibling child nodes, the node returned will be the one among
 the same-name siblings with index [1].
 <p>
 The same reacquisition semantics apply as with <code>{@link
 #getNode(String)}</code>.

 @return the primary child item.
 @throws ItemNotFoundException if this node does not have a primary child
                               item, either because none is declared in the node type or because a
                               declared primary item is not present on this node instance, or because
                               none is accessible through the current <code>Session</code>.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getUUID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #getIdentifier()} should be used
             instead.">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the UUID of this node as recorded in this node's
 <code>jcr:uuid</code> property. This method only works on nodes of mixin
 node type <code>mix:referenceable</code>.
 <p>
 On nonreferenceable nodes, this method throws an <code>UnsupportedRepositoryOperationException</code>.
 To avoid throwing an exception to determine whether a node has a UUID, a
 call to {@link #isNodeType(String) isNodeType("mix:referenceable")} can
 be made.

 @return the UUID of this node.
 @throws UnsupportedRepositoryOperationException
                             if this node
                             nonreferenceable.
 @throws RepositoryException if another error occurs.
 @deprecated As of JCR 2.0, {@link #getIdentifier()} should be used
             instead.]]>
      </doc>
    </method>
    <method name="getIdentifier" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the identifier of this node. Applies to both referenceable and
 non-referenceable nodes.
 <p>
 A <code>RepositoryException</code> is thrown if an error occurs.

 @return the identifier of this node.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns the index of this node within the ordered set of its
 same-name sibling nodes. This index is the one used to address same-name
 siblings using the square-bracket notation, e.g.,
 <code>/a[3]/b[4]</code>. Note that the index always starts at 1 (not 0),
 for compatibility with XPath. As a result, for nodes that do not have
 same-name-siblings, this method will always return 1.

 @return The index of this node within the ordered set of its same-name
         sibling nodes.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getReferences" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns all <code>REFERENCE</code> properties that refer to
 this node and that are accessible through the current
 <code>Session</code>. Equivalent to <code>Node.getReferences(null)</code>.
 <p>
 If this node has no referring <code>REFERENCE</code> properties, an
 empty iterator is returned. This includes the case where this node is not referenceable.

 @return A <code>PropertyIterator</code>.
 @throws RepositoryException if an error occurs.
 @see #getReferences(String).]]>
      </doc>
    </method>
    <method name="getReferences" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns all <code>REFERENCE</code> properties that refer to
 this node, have the specified <code>name</code> and that are accessible
 through the current <code>Session</code>.
 <p>
 If the <code>name</code> parameter is <code>null</code> then all
 referring <code>REFERENCES</code> are returned regardless of name.
 <p>
 Some implementations may only return properties that have been persisted.
 Some may return both properties that have been persisted and those that
 have been dispatched but not persisted (for example, those saved within a
 transaction but not yet committed) while others implementations may
 return these two categories of property as well as properties that are
 still pending and not yet dispatched.
 <p>
 In implementations that support versioning, this method does not return
 properties that are part of the frozen state of a version in version
 storage.
 <p>
 If this node has no referring <code>REFERENCE</code> properties with the specified name, an
 empty iterator is returned. This includes the case where this node is not referenceable.

 @param name name of referring <code>REFERENCE</code> properties to be
             returned; if <code>null</code> then all referring <code>REFERENCE</code>s
             are returned.
 @return A <code>PropertyIterator</code>.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getWeakReferences" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns all <code>WEAKREFERENCE</code> properties that refer
 to this node and that are accessible through the current
 <code>Session</code>. Equivalent to <code>Node.getWeakReferences(null)</code>.
 <p>
 If this node has no referring <code>WEAKREFERENCE</code> properties, an
 empty iterator is returned. This includes the case where this node is not referenceable.

 @return A <code>PropertyIterator</code>.
 @throws RepositoryException if an error occurs.
 @see #getWeakReferences(String).
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getWeakReferences" return="javax.jcr.PropertyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns all <code>WEAKREFERENCE</code> properties that refer
 to this node, have the specified <code>name</code> and that are
 accessible through the current <code>Session</code>.
 <p>
 If the <code>name</code> parameter is <code>null</code> then all
 referring <code>WEAKREFERENCE</code> are returned regardless of name.
 <p>
 Some implementations may only return properties that have been persisted.
 Some may return both properties that have been persisted and those that
 have been dispatched but not persisted (for example, those saved within a
 transaction but not yet committed) while others implementations may
 return these two categories of property as well as properties that are
 still pending and not yet dispatched.
 <p>
 In implementations that support versioning, this method does not return
 properties that are part of the frozen state of a version in version
 storage.
 <p>
 If this node has no referring <code>WEAKREFERENCE</code> properties with the specified name, an
 empty iterator is returned. This includes the case where this node is not referenceable.

 @param name name of referring <code>WEAKREFERENCE</code> properties to be
             returned; if <code>null</code> then all referring
             <code>WEAKREFERENCE</code>s are returned.
 @return A <code>PropertyIterator</code>.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="hasNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether a node exists at <code>relPath</code> Returns
 <code>true</code> if a node accessible through the current
 <code>Session</code> exists at <code>relPath</code> and
 <code>false</code> otherwise.

 @param relPath The path of a (possible) node.
 @return <code>true</code> if a node exists at <code>relPath</code>;
         <code>false</code> otherwise.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="hasProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether a property exists at <code>relPath</code> Returns
 <code>true</code> if a property accessible through the current
 <code>Session</code> exists at <code>relPath</code> and
 <code>false</code> otherwise.

 @param relPath The path of a (possible) property.
 @return <code>true</code> if a property exists at <code>relPath</code>;
         <code>false</code> otherwise.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="hasNodes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether this node has child nodes. Returns <code>true</code> if
 this node has one or more child nodes accessible through the current
 <code>Session</code>; <code>false</code> otherwise.

 @return <code>true</code> if this node has one or more child nodes;
         <code>false</code> otherwise.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="hasProperties" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Indicates whether this node has properties. Returns <code>true</code> if
 this node has one or more properties accessible through the current
 <code>Session</code>; <code>false</code> otherwise.

 @return <code>true</code> if this node has one or more properties;
         <code>false</code> otherwise.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getPrimaryNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the primary node type in effect for this node. Which
 <code>NodeType</code> is returned when this method is called on the root
 node of a workspace is up to the implementation.

 @return a <code>NodeType</code> object.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getMixinNodeTypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of <code>NodeType</code> objects representing the mixin
 node types in effect for this node. This includes only those mixin types
 explicitly assigned to this node. It does not include mixin types
 inherited through the addition of supertypes to the primary type
 hierarchy or through the addition of supertypes to the type hierarchy of
 any of the declared mixin types.

 @return an array of  <code>NodeType</code> objects.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="isNodeType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node is of the specified primary node
 type or mixin type, or a subtype thereof. Returns <code>false</code>
 otherwise.
 <p>
 This method respects the effective node type of the node.

 @param nodeTypeName the name of a node type.
 @return <code>true</code> If this node is of the specified primary node
         type or mixin type, or a subtype thereof. Returns
         <code>false</code> otherwise.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="setPrimaryType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Changes the primary node type of this node to <code>nodeTypeName</code>.
 Also immediately changes this node's <code>jcr:primaryType</code>
 property appropriately. Semantically, the new node type may take effect
 immediately or on dispatch but <i>must</i> take effect on persist. The
 behavior adopted must be the same as the behavior adopted for {@link
 #addMixin} and the behavior that occurs when a node is first created.
 <p>
 If the presence of an existing property or child node would cause an
 incompatibility with the new node type then a <code>ConstraintViolationException</code>
 is thrown either immediately, on dispatch or on persist.
 <p>
 If the new node type would cause this node to be incompatible with the
 node type of its parent then a <code>ConstraintViolationException</code>
 is thrown either immediately, on dispatch or on persist.
 <p>
 A <code>ConstraintViolationException</code> is also thrown either
 immediately, on dispatch or on persist if a conflict with an already
 assigned mixin occurs.
 <p>
 A <code>ConstraintViolationException</code> may also be thrown either
 immediately , on dispatch or on persist if the attempted change violates
 implementation-specific node type transition rules. A repository that
 disallows all primary node type changes would simple throw this exception
 in all cases.
 <p>
 If the specified node type is not recognized a <code>NoSuchNodeTypeException</code>
 is thrown either immediately, on dispatch or on persist.
 <p>
 A <code>VersionException</code> is thrown either immediately , on
 dispatch or on persist if this node is read-only dues to a check-in.
 <p>
 A <code>LockException</code> is thrown either immediately, on dispatch or
 on persist if a lock prevents the change of node type.

 @param nodeTypeName the name of the new node type.
 @throws ConstraintViolationException if the specified primary node type
                                      creates a type conflict and this implementation performs this validation
                                      immediately.
 @throws NoSuchNodeTypeException      If the specified <code>nodeTypeName</code>
                                      is not recognized and this implementation performs this validation
                                      immediately.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the change of the primary node
                                      type and this implementation performs this validation immediately.
 @throws RepositoryException          if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="addMixin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mixinName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds the mixin node type named <code>mixinName</code> to this node. If
 this node is already of type <code>mixinName</code> (either due to a
 previously added mixin or due to its primary type, through inheritance)
 then this method has no effect. Otherwise <code>mixinName</code> is added
 to this node's <code>jcr:mixinTypes</code> property.
 <p>
 Semantically, the new node type <i>may</i> take effect immediately, on
 dispatch or on persist. The behavior adopted must be the same as the
 behavior adopted for {@link #setPrimaryType} and the behavior that occurs
 when a node is first created.
 <p>
 A <code>ConstraintViolationException</code> is thrown either immediately,
 on dispatch or on persist, if a conflict with another assigned mixin or
 the primary node type or for an implementation-specific reason.
 Implementations may differ on when this validation is done.
 <p>
 In some implementations it may only be possible to add mixin types before
 a a node is persisted <i>for the first time</i>. I such cases any later
 calls to <code>addMixin</code> will throw a <code>ConstraintViolationException</code>
 either immediately, on dispatch or on persist.
 <p>
 A <code>NoSuchNodeTypeException</code> is thrown either immediately, on
 dispatch or on persist, if the specified <code>mixinName</code> is not
 recognized. Implementations may differ on when this validation is done.
 <p>
 A <code>VersionException</code> is thrown either immediately, on dispatch
 or on persist, if this node is read-only due to a checked-in node.
 Implementations may differ on when this validation is done.
 <p>
 A <code>LockException</code> is thrown either immediately, on dispatch or
 on persist, if a lock prevents the addition of the mixin. Implementations
 may differ on when this validation is done.

 @param mixinName the name of the mixin node type to be added
 @throws NoSuchNodeTypeException      If the specified <code>mixinName</code>
                                      is not recognized and this implementation performs this validation
                                      immediately.
 @throws ConstraintViolationException if the specified mixin node type
                                      creates a conflict and this implementation performs this validation
                                      immediately.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the addition of the mixin and
                                      this implementation performs this validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="removeMixin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mixinName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified mixin node type from this node and removes
 <code>mixinName</code> from this node's <code>jcr:mixinTypes</code>
 property. Both the semantic change in effective node type and the
 persistence of the change to the <code>jcr:mixinTypes</code> property
 occur on persist.
 <p>
 If this node does not have the specified mixin, a
 <code>NoSuchNodeTypeException</code> is thrown either immediately, on
 dispatch or on persist. Implementations may differ on when this
 validation is done.
 <p>
 A <code>ConstraintViolationException</code> will be thrown either
 immediately, on dispatch or on persist, if the removal of a mixin is not
 allowed. Implementations are free to enforce any policy with regard to
 mixin removal and may differ on when this validation is done.
 <p>
 A <code>VersionException</code> is thrown either immediately, on dispatch
 or on persist, if this node is read-only due to a checked-in node.
 Implementations may differ on when this validation is done.
 <p>
 A <code>LockException</code> is thrown either immediately or on
 <code>save</code> if a lock prevents the removal of the mixin.
 Implementations may differ on when this validation is done.

 @param mixinName the name of the mixin node type to be removed.
 @throws NoSuchNodeTypeException      if the specified <code>mixinName</code>
                                      is not currently assigned to this node and this implementation performs
                                      this validation immediately.
 @throws ConstraintViolationException if the specified mixin node type is
                                      prevented from being removed and this implementation performs this
                                      validation immediately.
 @throws VersionException             if this node is read-only due to a checked-in
                                      node and this implementation performs this validation immediately.
 @throws LockException                if a lock prevents the removal of the mixin and
                                      this implementation performs this validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="canAddMixin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mixinName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if calling {@link #addMixin} on this node
 with the mixn node type <code>mixinName</code> will not fail. Returns
 <code>false</code> otherwise.

 @param mixinName The name of the mixin to be tested.
 @return <code>true</code> if addMixin will not fail when called on this node with
 the specified <code>mixinName</code>;
         <code>false</code> otherwise.
 @throws NoSuchNodeTypeException if the specified mixin node type name is
                                 not recognized.
 @throws RepositoryException     if another error occurs.]]>
      </doc>
    </method>
    <method name="getDefinition" return="javax.jcr.nodetype.NodeDefinition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node definition that applies to this node. In some cases
 there may appear to be more than one definition that could apply to this
 node. However, it is assumed that upon creation of this node, a single
 particular definition was used and it is <i>that</i> definition that this
 method returns. How this governing definition is selected upon node
 creation from among others which may have been applicable is an
 implementation issue and is not covered by this specification. The
 <code>NodeDefinition</code> returned when this method is called on the
 root node of a workspace is also up to the implementation.

 @return a <code>NodeDefinition</code> object.
 @throws RepositoryException if an error occurs.
 @see NodeType#getChildNodeDefinitions]]>
      </doc>
    </method>
    <method name="checkin" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#checkin}
             should be used instead.">
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new version of this node and returns that {@link Version}
 object. The new version becomes the <i>base version</i> of this node. The
 name of the new version is implementaion determined.
 <p>
 This node becomes <i>checked-in</i> and its <code>jcr:checkedOut</code>
 property is set to false to reflect this. On a successful check-in the
 change to this property is made as a workspace-write, and therefore does
 not require a <code>save</code>.
 <p>
 The part of the subgraph of this node that is affected by check-in
 becomes read-only (see the specification for details).
 <p>
 If this node is already checked-in, this method has no effect but returns
 the current base version of this node.

 @return the created version.
 @throws VersionException          if a child item of this node has an
                                   <code>OnParentVersion</code> status of <code>ABORT</code>. This includes
                                   the case (under full versioning) where an unresolved merge failure exists
                                   on this node, as indicated by the presence of a <code>jcr:mergeFailed</code>
                                   property. Under full versioning this exception is also thrown if the
                                   <jcr:predecessors</code> property of the node has no values.
 @throws UnsupportedRepositoryOperationException
                                   if this node is not
                                   versionable.
 @throws InvalidItemStateException if unsaved changes exist on this node.
 @throws LockException             If a lock prevents the operation.
 @throws RepositoryException       If another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#checkin}
             should be used instead.]]>
      </doc>
    </method>
    <method name="checkout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#checkout}
             should be used instead.">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ActivityViolationException" type="javax.jcr.version.ActivityViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets this versionable node to checked-out status by setting its
 <code>jcr:isCheckedOut</code> property to <code>true</code>. Under full
 versioning it also sets the <code>jcr:predecessors</code> property to be
 a reference to the current base version (the same value as held in
 <code>jcr:baseVersion</code>). These changes are made by worksapce-write
 and therefore do require a <code>save</code>.
 <p>
 The part of the subgraph of this node that is affected by the checked-out
 status of this node becomes no longer read-only.
 <p>
 If this node is already checked-out, this method has no effect.

 @throws UnsupportedRepositoryOperationException
                                    if this node is not
                                    versionable.
 @throws LockException              if a lock prevents the checkout.
 @throws ActivityViolationException if the checkout conflicts with the
                                    activity present on the current session.
 @throws RepositoryException        if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#checkout}
             should be used instead.]]>
      </doc>
    </method>
    <method name="doneMerge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#doneMerge}
             should be used instead.">
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[<i>Support for this method is only required under full versioning.</i>
 <p>
 Completes the merge process with respect to this node and the specified
 <code>version</code>.
 <p>
 When the {@link #merge} method is called on a node, every versionable
 node in that subgraph is compared with its corresponding node in the
 indicated other workspace and a "merge test result" is determined
 indicating one of the following: <ol> <li> This node will be updated to
 the state of its correspondee (if the base version of the correspondee is
 more recent in terms of version history). </li> <li> This node will be
 left alone (if this node's base version is more recent in terms of
 version history). </li> <li> This node will be marked as having failed
 the merge test (if this node's base version is on a different branch of
 the version history from the base version of its corresponding node in
 the other workspace, thus preventing an automatic determination of which
 is more recent). </li> </ol> (See {@link #merge} for more details)
 <p>
 In the last case the merging of the subgraph of the versionable node in
 question must be done by the application (for example, by providing a
 merge tool for the user).
 <p>
 Additionally, once the subgraphs of the nodes has been merged, their
 version graph branches must also be merged. The JCR versioning system
 provides for this by keeping a record, for each versionable node that
 fails the merge test, of the base version of the corresponding node that
 caused the merge failure. This record is kept in the
 <code>jcr:mergeFailed</code> property of this node. After a
 <code>merge</code>, this property will contain one or more (if multiple
 merges have been performed) <code>REFERENCE</code>s that point to the
 "failed versions".
 <p>
 To complete the merge process, the client calls <code>doneMerge(Version
 v)</code> passing the version object referred to be the
 <code>jcr:mergeFailed</code> property that the client wishes to connect
 to <code>this</code> node in the version graph. This has the effect of
 moving the reference to the indicated version from the
 <code>jcr:mergeFailed</code> property of <code>this</code> node to the
 <code>jcr:predecessors</code>.
 <p>
 If the client chooses not to connect this node to a particular version
 referenced in the <code>jcr:mergeFailed</code> property, he calls {@link
 #cancelMerge(Version version)}. This has the effect of removing the
 reference to the specified <code>version</code> from
 <code>jcr:mergeFailed</code> <i>without</i> adding it to
 <code>jcr:predecessors</code>.
 <p>
 Once the last reference in <code>jcr:mergeFailed</code> has been either
 moved to <code>jcr:predecessors</code> (with <code>doneMerge</code>) or
 just removed from <code>jcr:mergeFailed</code> (with
 <code>cancelMerge</code>) the <code>jcr:mergeFailed</code> property is
 automatically removed, thus enabling <code>this</code> node to be
 checked-in, creating a new version (note that before the
 <code>jcr:mergeFailed</code> is removed, its <code>OnParentVersion</code>
 setting of <code>ABORT</code> prevents checkin). This new version will
 have a predecessor connection to each version for which
 <code>doneMerge</code> was called, thus joining those branches of the
 version graph.
 <p>
 If successful, these changes are persisted immediately, there is no need
 to call <code>save</code>.

 @param version a version referred to by this node's
                <code>jcr:mergeFailed</code> property.
 @throws VersionException          if the version specifed is not among those
                                   referenced in this node's <code>jcr:mergeFailed</code> or if this node is
                                   currently checked-in.
 @throws InvalidItemStateException if there are unsaved changes pending on
                                   this node.
 @throws UnsupportedRepositoryOperationException
                                   if this node is not
                                   versionable.
 @throws RepositoryException       if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#doneMerge}
             should be used instead.]]>
      </doc>
    </method>
    <method name="cancelMerge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#cancelMerge}
             should be used instead.">
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[<i>Support for this method is only required under full versioning.</i>
 <p>
 Cancels the merge process with respect to this node and specified
 <code>version</code>.
 <p>
 See {@link #doneMerge} for a full explanation. Also see {@link #merge}
 for more details.
 <p>
 If successful, these changes are persisted immediately, there is no need
 to call <code>save</code>.

 @param version a version referred to by this node's
                <code>jcr:mergeFailed</code> property.
 @throws VersionException          if the version specified is not among those
                                   referenced in this node's <code>jcr:mergeFailed</code> or if this node is
                                   currently checked-in.
 @throws InvalidItemStateException if there are unsaved changes pending on
                                   this node.
 @throws UnsupportedRepositoryOperationException
                                   if this node is not
                                   versionable.
 @throws RepositoryException       if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#cancelMerge}
             should be used instead.]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcWorkspace" type="java.lang.String"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this node does have a corresponding node in the workspace
 <code>srcWorkspace</code>, then this replaces this node and its subgraph
 with a clone of the corresponding node and its subgraph.
 <p>
 If this node does not have a corresponding node in the workspace
 <code>srcWorkspace</code>, then the <code>update</code> method has no
 effect.
 <p>
 If the <code>update</code> succeeds the changes made are persisted
 immediately, there is no need to call <code>save</code>.
 <p>
 Note that <code>update</code> does not respect the checked-in status of
 nodes. An <code>update</code> may change a node even if it is currently
 checked-in (This fact is only relevant in an implementation that supports
 versioning).

 @param srcWorkspace the name of the source workspace.
 @throws NoSuchWorkspaceException  If <code>srcWorkspace</code> does not
                                   exist.
 @throws InvalidItemStateException if this <code>Session</code> (not
                                   necessarily this <code>Node</code>) has pending unsaved changes.
 @throws AccessDeniedException     If the current session does not have
                                   sufficent access to perform the operation.
 @throws LockException             if a lock prevents the update.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="merge" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#merge}
             should be used instead.">
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="bestEffort" type="boolean"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="MergeException" type="javax.jcr.MergeException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[<i>Support for this method is only required under full versioning.</i>
 <p>
 This method can be thought of as a version-sensitive update.
 <p>
 It recursively tests each versionable node in the subgraph of this node
 against its corresponding node in <code>srcWorkspace</code> with respect
 to the relation between their respective base versions and either updates
 the node in question or not, depending on the outcome of the test.
 <p>
 A <code>MergeException</code> is thrown if <code>bestEffort</code> is
 <code>false</code> and a versionable node is encountered whose
 corresponding node's base version is on a divergent branch from this
 node's base version.
 <p>
 If successful, the changes are persisted immediately, there is no need to
 call <code>save</code>.
 <p>
 This method returns a <code>NodeIterator</code> over all versionable
 nodes in the subgraph that received a merge result of <i>fail</i>. If
 <code>bestEffort</code> is <code>false</code>, this iterator will be
 empty (since if <code>merge</code> returns successfully, instead of
 throwing an exception, it will be because no failures were encountered).
 If <code>bestEffort</code> is <code>true</code>, this iterator will
 contain all nodes that received a <i>fail</i> during the course of this
 <code>merge</code> operation.

 @param srcWorkspace the name of the source workspace.
 @param bestEffort   a boolean
 @return iterator over all nodes that received a merge result of "fail" in
         the course of this operation.
 @throws MergeException            if <code>bestEffort</code> is <code>false</code>
                                   and a failed merge result is encountered.
 @throws InvalidItemStateException if this session (not necessarily this
                                   <code>node</code>) has pending unsaved changes.
 @throws NoSuchWorkspaceException  if the specified
                                   <code>srcWorkspace</code> does not exist.
 @throws AccessDeniedException     if the current session does not have
                                   sufficient rights to perform the operation.
 @throws LockException             if a lock prevents the merge.
 @throws RepositoryException       if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#merge}
             should be used instead.]]>
      </doc>
    </method>
    <method name="getCorrespondingNodePath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="workspaceName" type="java.lang.String"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the absolute path of the node in the specified workspace that
 corresponds to <code>this</code> node.

 @param workspaceName the name of the workspace.
 @return the absolute path to the corresponding node.
 @throws ItemNotFoundException    if no corresponding node is found.
 @throws NoSuchWorkspaceException if the workspace is unknown.
 @throws AccessDeniedException    if the current <code>session</code> has
                                  insufficent access capabilities to perform this operation.
 @throws RepositoryException      if another error occurs.]]>
      </doc>
    </method>
    <method name="getSharedSet" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all nodes that are in the shared set of this
 node. If this node is not shared then the returned iterator contains only
 this node.

 @return a <code>NodeIterator</code>.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="removeSharedSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes this node and every other node in the shared set of this node.
 <p>
 This removal must be done atomically, i.e., if one of the nodes cannot be
 removed, the method throws the exception {@link Node#remove()} would have
 thrown in that case, and none of the nodes are removed.
 <p>
 If this node is not shared this method removes only this node.

 @throws VersionException             if the parent node of this item is versionable
                                      and checked-in or is non-versionable but its nearest versionable ancestor
                                      is checked-in and this implementation performs this validation
                                      immediately instead of waiting until <code>save</code>.
 @throws LockException                if a lock prevents the removal of this item and
                                      this implementation performs this validation immediately instead of
                                      waiting until <code>save</code>.
 @throws ConstraintViolationException if removing the specified item would
                                      violate a node type or implementation-specific constraint and this
                                      implementation performs this validation immediately instead of waiting
                                      until <code>save</code>.
 @throws RepositoryException          if another error occurs.
 @see #removeShare()
 @see Item#remove()
 @see javax.jcr.Session#removeItem(String)
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="removeShare"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes this node, but does not remove any other node in the shared set
 of this node.

 @throws VersionException             if the parent node of this item is versionable
                                      and checked-in or is non-versionable but its nearest versionable ancestor
                                      is checked-in and this implementation performs this validation
                                      immediately instead of waiting until <code>save</code>.
 @throws LockException                if a lock prevents the removal of this item and
                                      this implementation performs this validation immediately instead of
                                      waiting until <code>save</code>.
 @throws ConstraintViolationException if removing the specified item would
                                      violate a node type or implementation-specific constraint and this
                                      implementation performs this validation immediately instead of waiting
                                      until <code>save</code>.
 @throws RepositoryException          if  if this node cannot be removed without
                                      removing another node in the shared set of this node or another error
                                      occurs.
 @see #removeSharedSet()
 @see Item#remove()
 @see javax.jcr.Session#removeItem(String)
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isCheckedOut" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>false</code> if this node is currently in the checked-in state
 (either due to its own status as a versionable node or due to the effect of
 a versionable node being checked in above it). Otherwise this method returns
 <code>true</code>. This includes the case where the repository does not
 support versioning (and therefore all nodes are always "checked-out",
 by default).

 @return a boolean
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.">
      <param name="versionName" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores <code>this</code> node to the state defined by the version with
 the specified <code>versionName</code>.
 <p>
 This method will work regardless of whether this node is checked-in or
 not.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at this node</i> with the same identifier as a node that would be
 introduced by the <code>restore</code> operation <i>into the subgraph at
 this node</i>. The result in such a case is governed by the
 <code>removeExisting</code> flag. If <code>removeExisting</code> is
 <code>true</code>, then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed (if possible; otherwise a
 <code>RepositoryException</code> is thrown). If <code>removeExisting</code>
 is <code>false</code>, then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.

 @param versionName    a <code>Version</code> object
 @param removeExisting a boolean flag that governs what happens in case of
                       an identifier collision.
 @throws UnsupportedRepositoryOperationException
                                   if this node is not
                                   versionable.
 @throws VersionException          if the specified <code>version</code> is not
                                   part of this node's version history or if an attempt is made to restore
                                   the root version (<code>jcr:rootVersion</code>).
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not
                                   necessarily this <code>Node</code>) has pending unsaved changes.
 @throws RepositoryException       If another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.">
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores <code>this</code> node to the state defined by the specified
 <code>version</code>.
 <p>
 If successful, the change is persisted immediately and there is no need
 to call <code>save</code>.
 <p>
 This method will work regardless of whether this node is checked-in or
 not.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at this node</i> with the same identifier as a node that would be
 introduced by the <code>restore</code> operation <i>into the subgraph at
 this node</i>. The result in such a case is governed by the
 <code>removeExisting</code> flag. If <code>removeExisting</code> is
 <code>true</code>, then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed (if possible; otherwise a
 <code>RepositoryException</code> is thrown). If <code>removeExisting</code>
 is <code>false</code>, then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.

 @param version        a <code>Version</code> object
 @param removeExisting a boolean flag that governs what happens in case of
                       an identifier collision.
 @throws UnsupportedRepositoryOperationException
                                   if this node is not
                                   versionable.
 @throws VersionException          if the specified <code>version</code> is not
                                   part of this node's version history or if an attempt is made to restore
                                   the root version (<code>jcr:rootVersion</code>).
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs.
 @throws InvalidItemStateException if this <code>Session</code> (not
                                   necessarily this <code>Node</code>) has pending unsaved changes.
 @throws LockException             if a lock prevents the restore.
 @throws RepositoryException       if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.">
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="relPath" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the specified version to <code>relPath</code>, relative to this
 node.
 <p>
 If the <code>restore</code> succeeds, the changes made to this node are
 persisted immediately, there is no need to call <code>save</code>.
 <p>
 A node need not exist at relPath, though the parent of
 <code>relPath</code> must exist.
 <p>
 If a node <i>does</i> exist at relPath then it must correspond to the
 version being restored (the version must be a version <i>of that
 node</i>) and must not be a root version (<code>jcr:rootVersion</code>),
 otherwise a <code>VersionException</code> is thrown.
 <p>
 If no node exists at <code>relPath</code> then a <code>VersionException</code>
 is thrown if the parent node of <code>relPath</code> is read-only due to
 a check-in. However, If there <i>is</i> a node at <code>relPath</code>
 then the read-only status of that node itself and the read-only status of
 its parent are irrelevant. The restore will work even if one or both are
 read-only due to a checked-in node.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at <code>relPath</code></i> with the same identifier as a node
 that would be introduced by the <code>restore</code> operation <i>into
 the subgraph at <code>relPath</code></i> (Note that in cases where there
 is no node at <code>relPath</code>, this amounts to saying that an
 identifier collision occurs if there exists a node <i>anywhere</i> in
 this workspace with the same identifier as a node that would be
 introduced by the <code>restore</code>). The result in such a case is
 governed by the <code>removeExisting</code> flag. If
 <code>removeExisting</code> is <code>true</code>, then the incoming node
 takes precedence, and the existing node (and its subgraph) is removed (if
 possible; otherwise a <code>RepositoryException</code> is thrown). If
 <code>removeExisting</code> is <code>false</code>, then a
 <code>ItemExistsException</code> is thrown and no changes are made. Note
 that this applies not only to cases where the restored node itself
 conflicts with an existing node but also to cases where a conflict occurs
 with any node that would be introduced into the workspace by the restore
 operation. In particular, conflicts involving subnodes of the restored
 node that have <code>OnParentVersion</code> settings of <code>COPY</code>
 or <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.
 <p>

 @param version        a version object
 @param relPath        the path to which the version is to be restored
 @param removeExisting governs what happens on identifier collision.
 @throws PathNotFoundException        if the parent of <code>relPath</code> does
                                      not exist.
 @throws ItemExistsException          if removeExisting is false and an identifier
                                      collision occurs
 @throws ConstraintViolationException if the would-be parent of the
                                      location <code>relPath</code> is actually a property, or if a node type
                                      restriction would be violated
 @throws VersionException             if the parent node of <code>relPath</code> is
                                      read-only due to a checked-in node or if a node exists at relPath that is
                                      not the node corresponding to the specified <code>version</code> or if an
                                      attempt is made to restore the root version (<code>jcr:rootVersion</code>).
 @throws UnsupportedRepositoryOperationException
                                      if versioning is not
                                      supported.
 @throws LockException                if a lock prevents the restore.
 @throws InvalidItemStateException    if this <code>Session</code> (not
                                      necessarily this <code>Node</code>) has pending unsaved changes.
 @throws RepositoryException          if another error occurs
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.]]>
      </doc>
    </method>
    <method name="restoreByLabel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#restoreByLabel}
             should be used instead.">
      <param name="versionLabel" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the version of this node with the specified version label.
 <p>
 If successful, the change is persisted immediately and there is no need
 to call <code>save</code>.
 <p>
 This method will work regardless of whether this node is checked-in or
 not.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at this node</i> with the same identifier as a node that would be
 introduced by the <code>restoreByLabel</code> operation <i>into the
 subgraph at this node</i>. The result in such a case is governed by the
 <code>removeExisting</code> flag. If <code>removeExisting</code> is
 <code>true</code>, then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed (if possible; otherwise a
 <code>RepositoryException</code> is thrown). If <code>removeExisting</code>
 is <code>false</code>, then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.
 <p>
 Note the special behavior in case of chained versions where a child node
 of this node has an on <code>OnParentVersion</code>settings of
 <code>VERSION</code> and is mix:versionable: If there is a version of the
 child node with the specified label, then that version is restored;
 otherwise the determination depends on the configuration of the workspace
 and is defined by the implementation.

 @param versionLabel   a String
 @param removeExisting a boolean flag that governs what happens in case of
                       an identifier collision.
 @throws UnsupportedRepositoryOperationException
                                   if this node is not
                                   versionable.
 @throws VersionException          if the specified <code>versionLabel</code> does
                                   not exist in this node's version history.
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not
                                   necessarily this <code>Node</code>) has pending unsaved changes.
 @throws RepositoryException       If another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#restoreByLabel}
             should be used instead.]]>
      </doc>
    </method>
    <method name="getVersionHistory" return="javax.jcr.version.VersionHistory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#getVersionHistory}
             should be used instead.">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>VersionHistory</code> object of this node. Under full
 versioning this object provides access to the <code>nt:versionHistory</code>
 node holding this node's versions.

 @return a <code>VersionHistory</code> object
 @throws UnsupportedRepositoryOperationException
                             if this node is not
                             versionable.
 @throws RepositoryException if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#getVersionHistory}
             should be used instead.]]>
      </doc>
    </method>
    <method name="getBaseVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#getBaseVersion}
             should be used instead.">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the current base version of this versionable node.

 @return a <code>Version</code> object.
 @throws UnsupportedRepositoryOperationException
                             if this node is not
                             versionable.
 @throws RepositoryException if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#getBaseVersion}
             should be used instead.]]>
      </doc>
    </method>
    <method name="lock" return="javax.jcr.lock.Lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link LockManager#lock(String, boolean,
             boolean, long, String)} should be used instead.">
      <param name="isDeep" type="boolean"/>
      <param name="isSessionScoped" type="boolean"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Places a lock on this node. If successful, this node is said to
 <i>hold</i> the lock.
 <p>
 If <code>isDeep</code> is <code>true</code> then the lock applies to this
 node and all its descendant nodes; if <code>false</code>, the lock
 applies only to this, the holding node.
 <p>
 If <code>isSessionScoped</code> is <code>true</code> then this lock will
 expire upon the expiration of the current session (either through an
 automatic or explicit <code>Session.logout</code>); if
 <code>false</code>, this lock does not expire until explicitly unlocked
 or automatically unlocked due to a implementation-specific limitation,
 such as a timeout.
 <p>
 Returns a <code>Lock</code> object reflecting the state of the new lock.
 <p>
 If the lock is open-scoped the returned lock will include a lock token.
 <p>
 The lock token is also automatically added to the set of lock tokens held
 by the current <code>Session</code>.
 <p>
 If successful, then the property <code>jcr:lockOwner</code> is created
 and set to the value of <code>Session.getUserID</code> for the current
 session and the property <code>jcr:lockIsDeep</code> is set to the value
 passed in as <code>isDeep</code>. These changes are persisted
 automatically; there is no need to call <code>save</code>.
 <p>
 Note that it is possible to lock a node even if it is checked-in (the
 lock-related properties will be changed despite the checked-in status).

 @param isDeep          if <code>true</code> this lock will apply to this node and
                        all its descendants; if <code>false</code>, it applies only to this
                        node.
 @param isSessionScoped if <code>true</code>, this lock expires with the
                        current session; if <code>false</code> it expires when explicitly or
                        automatically unlocked for some other reason.
 @return A <code>Lock</code> object containing a lock token.
 @throws UnsupportedRepositoryOperationException
                                   if this implementation
                                   does not support locking.
 @throws LockException             if this node is not <code>mix:lockable</code> or
                                   this node is already locked or <code>isDeep</code> is <code>true</code>
                                   and a descendant node of this node already holds a lock or if this node
                                   has not yet been persisted.
 @throws AccessDeniedException     if this session does not have sufficient
                                   access capabilities to lock this node.
 @throws InvalidItemStateException if this node has pending unsaved
                                   changes.
 @throws RepositoryException       if another error occurs.
 @deprecated As of JCR 2.0, {@link LockManager#lock(String, boolean,
             boolean, long, String)} should be used instead.]]>
      </doc>
    </method>
    <method name="getLock" return="javax.jcr.lock.Lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link LockManager#getLock(String)} should be
             used instead.">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>Lock</code> object that applies to this node. This may
 be either a lock on this node itself or a deep lock on a node above this
 node.

 @return The applicable <code>Lock</code> object.
 @throws UnsupportedRepositoryOperationException
                               if this implementation
                               does not support locking.
 @throws LockException         if no lock applies to this node.
 @throws AccessDeniedException if the curent session does not have
                               sufficent access to get the lock.
 @throws RepositoryException   if another error occurs.
 @deprecated As of JCR 2.0, {@link LockManager#getLock(String)} should be
             used instead.]]>
      </doc>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link LockManager#unlock(String)} should be
             used instead.">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the lock on this node. Also removes the properties
 <code>jcr:lockOwner</code> and <code>jcr:lockIsDeep</code> from this
 node. These changes are persisted automatically; there is no need to call
 <code>save</code>. As well, the corresponding lock token is removed from
 the set of lock tokens held by the current <code>Session</code>.
 <p>
 If this node does not currently hold a lock or holds a lock for which
 this <code>Session</code> is not the owner, then a
 <code>LockException</code> is thrown. Note however that the system may
 give permission to a non-owning session to unlock a lock. Typically such
 "lock-superuser" capability is intended to facilitate administrational
 clean-up of orphaned open-scoped locks.
 <p>
 Note that it is possible to unlock a node even if it is checked-in (the
 lock-related properties will be changed despite the checked-in status).

 @throws UnsupportedRepositoryOperationException
                                   if this implementation
                                   does not support locking.
 @throws LockException             if this node does not currently hold a lock or
                                   holds a lock for which this Session does not have the correct lock token
 @throws AccessDeniedException     if the current session does not have
                                   sufficent access to unlock this node.
 @throws InvalidItemStateException if this node has pending unsaved
                                   changes.
 @throws RepositoryException       if another error occurs.
 @deprecated As of JCR 2.0, {@link LockManager#unlock(String)} should be
             used instead.]]>
      </doc>
    </method>
    <method name="holdsLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link LockManager#holdsLock(String)} should
             be used instead.">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node holds a lock; otherwise returns
 <code>false</code>. To <i>hold</i> a lock means that this node has
 actually had a lock placed on it specifically, as opposed to just having
 a lock <i>apply</i> to it due to a deep lock held by a node above.

 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.
 @deprecated As of JCR 2.0, {@link LockManager#holdsLock(String)} should
             be used instead.]]>
      </doc>
    </method>
    <method name="isLocked" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node is locked either as a result of a
 lock held by this node or by a deep lock on a node above this node;
 otherwise returns <code>false</code>. This includes the case
 where a repository does not support locking (in which case all
 nodes are "unlocked" by default).

 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="followLifecycleTransition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transition" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="InvalidLifecycleTransitionException" type="javax.jcr.InvalidLifecycleTransitionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Causes the lifecycle state of this node to undergo the specified
 <code>transition</code>.
 <p>
 This method may change the value of the <code>jcr:currentLifecycleState</code>
 property, in most cases it is expected that the implementation will
 change the value to that of the passed <code>transition</code> parameter,
 though this is an implementation-specific issue. If the
 <code>jcr:currentLifecycleState</code> property is changed the change is
 persisted immediately, there is no need to call <code>save</code>.

 @param transition a state transition
 @throws UnsupportedRepositoryOperationException
                             if this implementation
                             does not support lifecycle actions or if this node does not have the
                             <code>mix:lifecycle</code> mixin.
 @throws InvalidLifecycleTransitionException
                             if the lifecycle transition
                             is not successful.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getAllowedLifecycleTransistions" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the list of valid state transitions for this node.

 @return a <code>String</code> array.
 @throws UnsupportedRepositoryOperationException
                             if this implementation
                             does not support lifecycle actions or if this node does not have the
                             <code>mix:lifecycle</code> mixin.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <field name="JCR_CONTENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the JCR name <code>jcr:content</code>. This is the name of
 a child node  declared in {@link NodeType#NT_FILE nt:file} and a property
 declared in {@link javax.jcr.nodetype.NodeType#NT_LINKED_FILE
 nt:linkedFile}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_PROPERTY_DEFINITION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node name <code>jcr:propertyDefinition</code> declared
 in {@link NodeType#NT_FILE nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_CHILD_NODE_DEFINITION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node name <code>jcr:childNodeDefinition</code>
 declared in {@link NodeType#NT_FILE nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_ROOT_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node name <code>jcr:rootVersion</code> declared in
 {@link NodeType#NT_VERSION_HISTORY nt:versionHistory}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_VERSION_LABELS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node name <code>jcr:versionLabels</code> declared in
 {@link NodeType#NT_VERSION_HISTORY nt:versionHistory}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_FROZEN_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node name <code>jcr:frozenNode</code> declared in
 {@link NodeType#NT_VERSION nt:version}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The <code>Node</code> interface represents a node in a workspace.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Node -->
  <!-- start interface javax.jcr.NodeIterator -->
  <interface name="NodeIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Node</code> in the iteration.

 @return the next <code>Node</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>Node</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Node</code>s with
 <code>nextNode</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.NodeIterator -->
  <!-- start class javax.jcr.NoSuchWorkspaceException -->
  <class name="NoSuchWorkspaceException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoSuchWorkspaceException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchWorkspaceException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchWorkspaceException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="NoSuchWorkspaceException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by <code>{@link Repository#login(Credentials,
 String)}</code> when a specific workspace is not found.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.NoSuchWorkspaceException -->
  <!-- start class javax.jcr.PathNotFoundException -->
  <class name="PathNotFoundException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathNotFoundException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="PathNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="PathNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="PathNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when no <code>Item</code> exists at the specified path or
 when the specified path implies intermediary <code>Node</code>s that do not
 exist.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.PathNotFoundException -->
  <!-- start interface javax.jcr.Property -->
  <interface name="Property"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Item"/>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Value"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. If this property's
 property type is not constrained by the node type of its parent node,
 then the property type is changed to that of the supplied
 <code>value</code>. If the property type is constrained, then a
 best-effort conversion is attempted.
 <p>
 This method is a session-write and therefore requires a <code>save</code>
 to dispatch the change.
 <p>
 A <code>ConstraintViolationException</code> will be thrown either
 immediately, on dispatch, or on persist, if the change would violate a
 node type or implementation-specific constraint. Implementations may
 differ on when this validation is performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch, or on persist, if this property belongs to a node that is
 versionable and checked-in or is non-versionable but whose nearest
 versionable ancestor is checked-in. Implementations may differ on when
 this validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch, or on persist, if a lock prevents the setting of the value.
 Implementations may differ on when this validation is performed.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="javax.jcr.Value[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to the <code>values</code> array. If this
 property's property type is not constrained by the node type of its
 parent node, then the property type may be changed. If the property type
 is constrained, then a best-effort conversion is attempted, according to
 an implemention-dependent definition of "best effort". The change will be
 persisted (if valid) on <code>save</code>.
 <p>
 A <code>ConstraintViolationException</code> will be thrown either
 immediately, on dispatch, or on persist, if the change would violate a
 node type or implementation-specific constraint. Implementations may
 differ on when this validation is performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch, or on persist, if this property belongs to a node that is
 read-only due to a checked-in node. Implementations may differ on when
 this validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch, or on persist, if a lock prevents the setting of the value.
 Implementations may differ on when this validation is performed.

 @param values The new values to set the property to.
 @throws ValueFormatException         if the type or format of the specified
                                      values is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as a <code>String</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified
                                      values is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.String[]"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to the <code>values</code> array. Same as
 <code>{@link #setValue(Value[] values)}</code> except that the values are
 specified as a <code>String[]</code>.

 @param values The new values to set the property to.
 @throws ValueFormatException         if the type or format of one or more of the
                                      specified values is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #setValue(Binary)} should be used
             instead.">
      <param name="value" type="java.io.InputStream"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as an <code>InputStream</code>.
 <p>
 The passed stream is closed before this method returns either normally or
 because of an exception.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.
 @deprecated As of JCR 2.0, {@link #setValue(Binary)} should be used
             instead.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Binary"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as a <code>Binary</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as a <code>long</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as a <code>double</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.math.BigDecimal"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as a <code>BigDecimal</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.Calendar"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as a <code>Calendar</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the value of this property to <code>value</code>. Same as
 <code>{@link #setValue(Value value)}</code> except that the value is
 specified as a <code>boolean</code>.

 @param value The new value to set the property to.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Node"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets this <code>REFERENCE</code> or <code>WEAKREFERNCE</code> property to
 refer to the specified node.

 @param value The node to which this property will refer.
 @throws ValueFormatException         if the type or format of the specified value
                                      is incompatible with the type of this property the specified node is not
                                      referenceable.
 @throws VersionException             if this property belongs to a node that is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the setting of the value and
                                      this implementation performs this validation immediately.
 @throws ConstraintViolationException if the change would violate a
                                      node-type or other constraint and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="getValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the value of this  property as a <code>Value</code> object.
 <p>
 The object returned is a copy of the stored value and is immutable.

 @return the <code>Value</code>.
 @throws ValueFormatException if the property is multi-valued.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getValues" return="javax.jcr.Value[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of all the values of this property. Used to access
 multi-value properties. The array returned is a copy of the stored
 values, so changes to it are not reflected in internal storage.

 @return a <code>Value</code> array.
 @throws ValueFormatException if the property is single-valued.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>String</code> representation of the value of this
 property. A shortcut for <code>Property.getValue().getString()</code>.

 @return A string representation of the value of this property.
 @throws ValueFormatException if conversion to a <code>String</code> is
                              not possible or if the property is multi-valued.
 @throws RepositoryException  if another error occurs.
 @see Value]]>
      </doc>
    </method>
    <method name="getStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #getBinary()} should be used instead.">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>InputStream</code> representation of the value of this
 property. A shortcut for <code>Property.getValue().getStream()</code>.
 <p>
 It is the responsibility of the caller to close the returned
 InputStream.

 @return A stream representation of the value of this property.
 @throws ValueFormatException if the property is multi-valued.
 @throws RepositoryException  if another error occurs
 @see Value
 @deprecated As of JCR 2.0, {@link #getBinary()} should be used instead.]]>
      </doc>
    </method>
    <method name="getBinary" return="javax.jcr.Binary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Binary</code> representation of the value of this
 property. A shortcut for <code>Property.getValue().getBinary()</code>.

 @return A <code>Binary</code> representation of the value of this
         property.
 @throws ValueFormatException if the property is multi-valued.
 @throws RepositoryException  if another error occurs.
 @see Value
 @see Binary
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>long</code> representation of the value of this property.
 A shortcut for <code>Property.getValue().getLong()</code>.

 @return A <code>long</code> representation of the value of this
         property.
 @throws ValueFormatException if conversion to a <code>long</code> is not
                              possible or if the property is multi-valued.
 @throws RepositoryException  if another error occurs.
 @see Value]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>double</code> representation of the value of this
 property. A shortcut for <code>Property.getValue().getDouble()</code>.

 @return A <code>double</code> representation of the value of this
         property.
 @throws ValueFormatException if conversion to a <code>double</code> is
                              not possible or if the property is multi-valued.
 @throws RepositoryException  if another error occurs.
 @see Value]]>
      </doc>
    </method>
    <method name="getDecimal" return="java.math.BigDecimal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>BigDecimal</code> representation of the value of this
 property. A shortcut for <code>Property.getValue().getDecimal()</code>.

 @return A <code>BigDecimal</code> representation of the value of this
         property.
 @throws ValueFormatException if conversion to a <code>BigDecimal</code>
                              is not possible or if the property is multi-valued.
 @throws RepositoryException  if another error occurs
 @see Value
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDate" return="java.util.Calendar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Calendar</code> representation of the value of this
 property. A shortcut for <code>Property.getValue().getDate()</code>.

 @return A <code>Calendar</code> representation of the value of this
         property.
 @throws ValueFormatException if conversion to a string is not possible or
                              if the property is multi-valued.
 @throws RepositoryException  if another error occurs.
 @see Value]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>boolean</code> representation of the value of this
 property. A shortcut for <code>Property.getValue().getBoolean()</code>.

 @return A <code>boolean</code> representation of the value of this
         property.
 @throws ValueFormatException if conversion to a <code>boolean</code> is
                              not possible or if the property is multi-valued.
 @throws RepositoryException  if another error occurs.
 @see Value]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this property is of type <code>REFERENCE</code>,
 <code>WEAKREFERENCE</code> or <code>PATH</code> (or convertible to one of
 these types) this method returns the <code>Node</code> to which this
 property refers.
 <p>
 If this property is of type <code>PATH</code> and it contains a relative
 path, it is interpreted relative to the parent node of this property. For
 example "<code>.</code>" refers to the parent node itself,
 "<code>..</code>" to the parent of the parent node and "<code>foo</code>"
 to a sibling node of this property.

 @return the referenced Node
 @throws ValueFormatException  if this property cannot be converted to a
                               referring type (<code>REFERENCE</code>, <code>WEAKREFERENCE</code> or
                               <code>PATH</code>), if the property is multi-valued or if this property
                               is a referring type but is currently part of the frozen state of a
                               version in version storage.
 @throws ItemNotFoundException If this property is of type
                               <code>PATH</code> or <code>WEAKREFERENCE</code> and no target node
                               accessible by the current <code>Session</code> exists in this workspace.
                               Note that this applies even if the property is a <code>PATHS</code> and a
                               <i>property</i> exists at the specified location. To dereference to a
                               target property (as opposed to a target node), the method
                               <code>Property.getProperty</code> is used.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this property is of type <code>PATH</code> (or convertible to this
 type) this method returns the <code>Property</code> to which <i>this</i>
 property refers.
 <p>
 If this property contains a relative path, it is interpreted relative to
 the parent node of this property. Therefore, when resolving such a
 relative path, the segment "<code>.</code>" refers to
 the parent node itself, "<code>..</code>" to the parent of the parent
 node and "<code>foo</code>" to a sibling property of this property or
 this property itself.
 <p>
 For example, if this property is located at
 <code>/a/b/c</code> and it has a value of "<code>../d</code>" then this
 method will return the property at <code>/a/d</code> if such exists.
 <p>
 If this property is multi-valued, this method throws a
 <code>ValueFormatException</code>.
 <p>
 If this property cannot be converted to a <code>PATH</code> then a
 <code>ValueFormatException</code> is thrown.
 <p>
 If this property is currently part of the frozen state of a version in
 version storage, this method will throw a <code>ValueFormatException</code>.

 @return the referenced property
 @throws ValueFormatException  if this property cannot be converted to a
                               <code>PATH</code>, if the property is multi-valued or if this property is
                               a referring type but is currently part of the frozen state of a version
                               in version storage.
 @throws ItemNotFoundException If no property accessible by the current
                               <code>Session</code> exists in this workspace at the specified path. Note
                               that this applies even if a <i>node</i> exists at the specified location.
                               To dereference to a target node, the method <code>Property.getNode</code>
                               is used.
 @throws RepositoryException   if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the length of the value of this property.
 <p>
 For a <code>BINARY</code> property, <code>getLength</code> returns the
 number of bytes. For other property types, <code>getLength</code> returns
 the same value that would be returned by calling {@link
 java.lang.String#length()} on the value when it has been converted to a
 <code>STRING</code> according to standard JCR property type conversion.
 <p>
 Returns -1 if the implementation cannot determine the length.

 @return an <code>long</code>.
 @throws ValueFormatException if this property is multi-valued.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getLengths" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array holding the lengths of the values of this (multi-value)
 property in bytes where each is individually calculated as described in
 {@link #getLength()}.
 <p>
 Returns a <code>-1</code> in the appropriate position if the
 implementation cannot determine the length of a value.

 @return an array of lengths
 @throws ValueFormatException if this property is single-valued.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getDefinition" return="javax.jcr.nodetype.PropertyDefinition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the property definition that applies to this property. In some
 cases there may appear to be more than one definition that could apply to
 this node. However, it is assumed that upon creation or change of this
 property, a single particular definition is chosen by the implementation.
 It is <i>that</i> definition that this method returns. How this governing
 definition is selected upon property creation or change from among others
 which may have been applicable is an implementation issue and is not
 covered by this specification.

 @return a <code>PropertyDefinition</code> object.
 @throws RepositoryException if an error occurs.
 @see javax.jcr.nodetype.NodeType#getPropertyDefinitions]]>
      </doc>
    </method>
    <method name="getType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the type of this <code>Property</code>. One of: <ul>
 <li><code>PropertyType.STRING</code></li> <li><code>PropertyType.BINARY</code></li>
 <li><code>PropertyType.DATE</code></li> <li><code>PropertyType.DOUBLE</code></li>
 <li><code>PropertyType.LONG</code></li> <li><code>PropertyType.BOOLEAN</code></li>
 <li><code>PropertyType.NAME</code></li> <li><code>PropertyType.PATH</code></li>
 <li><code>PropertyType.REFERENCE</code></li> <li><code>PropertyType.WEAKREFERENCE</code></li>
 <li><code>PropertyType.URI</code></li> </ul> The type returned is that
 which was set at property creation. Note that for some property
 <code>p</code>, the type returned by <code>p.getType()</code> will differ
 from the type returned by <code>p.getDefinition.getRequiredType()</code>
 only in the case where the latter returns <code>UNDEFINED</code>. The
 type of a property instance is never <code>UNDEFINED</code> (it must
 always have some actual type).

 @return an int
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="isMultiple" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this property is multi-valued and
 <code>false</code> if this property is single-valued.

 @return <code>true</code> if this property is multi-valued;
         <code>false</code> otherwise.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <field name="JCR_PRIMARY_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:primaryType</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_BASE
 nt:base}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_MIXIN_TYPES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:mixinTypes</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_BASE
 nt:base}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_CONTENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:content</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_LINKED_FILE
 nt:linkedFile}. Note, <code>jcr:content</code> is also the name of a
 child node declared in {@link javax.jcr.nodetype.NodeType#NT_FILE
 nt:file}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_DATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:data</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_RESOURCE
 nt:resource}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_PROTOCOL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:protocol</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_ADDRESS
 nt:address}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_HOST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:host</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_ADDRESS
 nt:address}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:port</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_ADDRESS
 nt:address}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_REPOSITORY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:repository</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_ADDRESS
 nt:address}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_WORKSPACE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:workspace</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_ADDRESS
 nt:address}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:path</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_ADDRESS
 nt:address}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:id</code> (in expanded form),
 declared in node type {@link javax.jcr.nodetype.NodeType#NT_ADDRESS
 nt:address}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_UUID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:uuid</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_REFERENCEABLE
 mix:referenceable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_TITLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:title</code> (in expanded
 form), declared in node types {@link javax.jcr.nodetype.NodeType#MIX_TITLE
 mix:title} and {@link javax.jcr.nodetype.NodeType#NT_ACTIVITY
 nt:activity}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:description</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_TITLE
 mix:title}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_CREATED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:created</code> (in expanded
 form), declared in node types {@link javax.jcr.nodetype.NodeType#MIX_CREATED
 mix:created} and {@link javax.jcr.nodetype.NodeType#NT_VERSION
 nt:version}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_CREATED_BY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:createdBy</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_CREATED
 mix:created}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_LAST_MODIFIED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:lastModified</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_LAST_MODIFIED
 mix:lastModified}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_LAST_MODIFIED_BY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:lastModifiedBy</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_LAST_MODIFIED
 mix:lastModified}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_LANGUAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:language</code> (in expanded
 form), declared in node types {@link javax.jcr.nodetype.NodeType#MIX_LANGUAGE
 mix:language} and {@link javax.jcr.nodetype.NodeType#NT_QUERY nt:query}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_MIMETYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:mimeType</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_MIMETYPE
 mix:mimeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_ENCODING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:encoding</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_MIMETYPE
 mix:mimeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_NODE_TYPE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:nodeTypeName</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_NODE_TYPE
 nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_SUPERTYPES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:supertypes</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_NODE_TYPE
 nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_IS_ABSTRACT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:isAbstract</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_NODE_TYPE
 nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_IS_MIXIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:isMixin</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_NODE_TYPE
 nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_HAS_ORDERABLE_CHILD_NODES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:hasOrderableChildNodes</code>
 (in expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_NODE_TYPE
 nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_PRIMARY_ITEM_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:primaryItemName</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_NODE_TYPE
 nt:nodeType}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:name</code> (in expanded
 form), declared in node types {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition} and {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_AUTOCREATED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:autoCreated</code> (in
 expanded form), declared in node types {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition} and {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_MANDATORY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:mandatory</code> (in expanded
 form), declared in node types {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition} and {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_PROTECTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:protected</code> (in expanded
 form), declared in node types {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition} and {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_ON_PARENT_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:onParentVersion</code> (in
 expanded form), declared in node types {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition} and {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_REQUIRED_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:requiredType</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_VALUE_CONSTRAINTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:valueConstraints</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_DEFAULT_VALUES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:defaultValues</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_MULTIPLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:multiple</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_PROPERTY_DEFINITION
 nt:propertyDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_REQUIRED_PRIMARY_TYPES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:requiredPrimaryTypes</code>
 (in expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_DEFAULT_PRIMARY_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:defaultPrimaryType</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_SAME_NAME_SIBLINGS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:sameNameSiblings</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_CHILD_NODE_DEFINITION
 nt:childNodeDefinition}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_LOCK_OWNER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:lockOwner</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_LOCKABLE
 mix:lockable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_LOCK_IS_DEEP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:lockIsDeep</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_LOCKABLE
 mix:lockable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_LIFECYCLE_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:lifecyclePolicy</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_LIFECYCLE
 mix:lifecycle}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_CURRENT_LIFECYCLE_STATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:currentLifecycleState</code>
 (in expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_LIFECYCLE
 mix:lifecycle}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_IS_CHECKED_OUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:isCheckedOut</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_SIMPLE_VERSIONABLE
 mix:simpleVersionable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_FROZEN_PRIMARY_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:frozenPrimaryType</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_FROZEN_NODE
 nt:frozenNode}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_FROZEN_MIXIN_TYPES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:frozenMixinTypes</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_FROZEN_NODE
 nt:frozenNode}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_FROZEN_UUID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:frozenUuid</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_FROZEN_NODE
 nt:frozenNode}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_VERSION_HISTORY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:versionHistory</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_VERSIONABLE
 mix:versionable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_BASE_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:baseVersion</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_VERSIONABLE
 mix:versionable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_PREDECESSORS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:predecessors</code> (in
 expanded form), declared in node types {@link javax.jcr.nodetype.NodeType#MIX_VERSIONABLE
 mix:versionable} and {@link javax.jcr.nodetype.NodeType#NT_VERSION
 nt:version}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_MERGE_FAILED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:mergeFailed</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_VERSIONABLE
 mix:versionable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_ACTIVITY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:activity</code> (in expanded
 form), declared in node types {@link javax.jcr.nodetype.NodeType#MIX_VERSIONABLE
 mix:versionable} and {@link javax.jcr.nodetype.NodeType#NT_VERSION
 nt:version}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_CONFIGURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:configuration</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#MIX_VERSIONABLE
 mix:versionable}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_VERSIONABLE_UUID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:versionableUuid</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_VERSION
 nt:version}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_COPIED_FROM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:copiedFrom</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_VERSION
 nt:version}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_SUCCESSORS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:successors</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_VERSION
 nt:versione}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_CHILD_VERSION_HISTORY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:childVersionHistory</code> (in
 expanded form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_VERSIONED_CHILD
 nt:versionedChild}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_ROOT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:root</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_CONFIGURATION
 nt:configuration}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_STATEMENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the property name <code>jcr:statement</code> (in expanded
 form), declared in node type {@link javax.jcr.nodetype.NodeType#NT_QUERY
 nt:query}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A <code>Property</code> object represents the smallest granularity of content
 storage. It has a single parent node and no children. A property consists of
 a name and a value, or in the case of multi-value properties, a set of values
 all of the same type. See <code>{@link Value}</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Property -->
  <!-- start interface javax.jcr.PropertyIterator -->
  <interface name="PropertyIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Property</code> in the iteration.

 @return the next <code>Property</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>Property</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Property</code>s with
 <code>nextProperty</code> as well as a <code>skip</code> method.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.PropertyIterator -->
  <!-- start class javax.jcr.PropertyType -->
  <class name="PropertyType" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nameFromValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="int"/>
      <doc>
      <![CDATA[Returns the name of the specified <code>type</code>, as used in
 serialization.

 @param type the property type
 @return the name of the specified <code>type</code>
 @throws IllegalArgumentException if <code>type</code> is not a valid
                                  property type.]]>
      </doc>
    </method>
    <method name="valueFromName" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the numeric constant value of the type with the specified name.

 @param name the name of the property type.
 @return the numeric constant value.
 @throws IllegalArgumentException if <code>name</code> is not a valid
                                  property type name.]]>
      </doc>
    </method>
    <field name="STRING" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <code>STRING</code> property type is used to store strings. It has
 the same characteristics as the Java <code>String</code> class.]]>
      </doc>
    </field>
    <field name="BINARY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<code>BINARY</code> properties are used to store binary data.]]>
      </doc>
    </field>
    <field name="LONG" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <code>LONG</code> property type is used to store integers. It has the
 same characteristics as the Java primitive type <code>long</code>.]]>
      </doc>
    </field>
    <field name="DOUBLE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <code>DOUBLE</code> property type is used to store floating point
 numbers. It has the same characteristics as the Java primitive type
 <code>double</code>.]]>
      </doc>
    </field>
    <field name="DATE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <code>DATE</code> property type is used to store time and date
 information.]]>
      </doc>
    </field>
    <field name="BOOLEAN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <code>BOOLEAN</code> property type is used to store boolean values.
 It has the same characteristics as the Java primitive type
 <code>boolean</code>.]]>
      </doc>
    </field>
    <field name="NAME" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A <code>NAME</code> is a pairing of a namespace and a local name. When
 read, the namespace is mapped to the current prefix.]]>
      </doc>
    </field>
    <field name="PATH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A <code>PATH</code> property is an ordered list of path elements. A path
 element is a <code>NAME</code> with an optional index. When read, the
 <code>NAME</code>s within the path are mapped to their current prefix. A
 path may be absolute or relative.]]>
      </doc>
    </field>
    <field name="REFERENCE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A <code>REFERENCE</code> property stores the identifier of a
 referenceable node (one having type <code>mix:referenceable</code>),
 which must exist within the same workspace or session as the
 <code>REFERENCE</code> property. A <code>REFERENCE</code> property
 enforces this referential integrity by preventing the removal of its
 target node.]]>
      </doc>
    </field>
    <field name="WEAKREFERENCE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A <code>WEAKREFERENCE</code> property stores the identifier of a
 referenceable node (one having type <code>mix:referenceable</code>). A
 <code>WEAKREFERENCE</code> property does not enforce referential
 integrity.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="URI" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A <code>URI</code> property is identical to <code>STRING</code> property
 except that it only accepts values that conform to the syntax of a
 URI-reference as defined in RFC 3986.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="DECIMAL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <code>DECIMAL</code> property type is used to store precise decimal
 numbers. It has the same characteristics as the Java class
 <code>java.math.BigDecimal</code>.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="UNDEFINED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant can be used within a property definition (see <i>4.7.5
 Property Definitions</i>) to specify that the property in question may be
 of any type. However, it cannot be the actual type of any property
 instance. For example, it will never be returned by {@link
 Property#getType} and it cannot be assigned as the type when creating a
 new property.]]>
      </doc>
    </field>
    <field name="TYPENAME_STRING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_BINARY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_LONG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_DOUBLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_DECIMAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="TYPENAME_DATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_BOOLEAN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_REFERENCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.]]>
      </doc>
    </field>
    <field name="TYPENAME_WEAKREFERENCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="TYPENAME_URI" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String constant for type name as used in serialization.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="TYPENAME_UNDEFINED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The property types supported by the JCR standard.
 <p>
 This interface defines following property types: <ul> <li><code>STRING</code>
 <li><code>BINARY</code> <li><code>LONG</code> <li><code>DOUBLE</code>
 <li><code>DECIMAL</code> <li><code>DATE</code> <li><code>BOOLEAN</code>
 <li><code>NAME</code> <li><code>PATH</code> <li><code>REFERENCE</code>
 <li><code>WEAKREFERENCE</code> <li><code>URI</code> </ul>.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.PropertyType -->
  <!-- start interface javax.jcr.RangeIterator -->
  <interface name="RangeIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="skipNum" type="long"/>
      <doc>
      <![CDATA[Skip a number of elements in the iterator.

 @param skipNum the non-negative number of elements to skip
 @throws java.util.NoSuchElementException
          if skipped past the last element
          in the iterator.]]>
      </doc>
    </method>
    <method name="getSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of of items available through this iterator. For
 example, for some node <code>N</code>, <code>N.getNodes().getSize()</code>
 returns the number of child nodes of <code>N</code> visible through the
 current <code>Session</code>. In some implementations precise information
 about the number of elements may not be available. In such cases this
 method must return -1. API clients will then be able to use
 <code>RangeIterator.getNumberRemaining</code> to get an estimate on the
 number of elements.

 @return a long]]>
      </doc>
    </method>
    <method name="getPosition" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current position within the iterator. The number returned is
 the 0-based index of the next element in the iterator, i.e. the one that
 will be returned on the subsequent <code>next</code> call.
 <p>
 Note that this method does not check if there is a next element, i.e. an
 empty iterator will always return 0.

 @return a long]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Extends <code>Iterator</code> with the <code>skip</code>,
 <code>getSize</code> and <code>getPosition</code> methods. The base interface
 of all type-specific iterators in the <code>javax.jcr</code> and its sub
 packages.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.RangeIterator -->
  <!-- start class javax.jcr.ReferentialIntegrityException -->
  <class name="ReferentialIntegrityException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReferentialIntegrityException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ReferentialIntegrityException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ReferentialIntegrityException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ReferentialIntegrityException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown on referential integrity violation.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ReferentialIntegrityException -->
  <!-- start interface javax.jcr.Repository -->
  <interface name="Repository"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDescriptorKeys" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string array holding all descriptor keys available for this
 implementation, both the standard descriptors defined by the string
 constants in this interface and any implementation-specific descriptors.
 Used in conjunction with {@link #getDescriptorValue(String key)} and
 {@link #getDescriptorValues(String key)} to query information about this
 repository implementation.

 @return a string array holding all descriptor keys.]]>
      </doc>
    </method>
    <method name="isStandardDescriptor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if <code>key</code> is a standard descriptor
 defined by the string constants in this interface and <code>false</code>
 if it is either a valid implementation-specific key or not a valid key.

 @param key a descriptor key.
 @return whether <code>key</code> is a standard descriptor.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isSingleValueDescriptor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if <code>key</code> is a valid single-value
 descriptor; otherwise returns <code>false</code>.

 @param key a descriptor key.
 @return whether the specified desdfriptor is multi-valued.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDescriptorValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[The value of a single-value descriptor is found by passing the key for
 that descriptor to this method. If <code>key</code> is the key of a
 multi-value descriptor or not a valid key this method returns
 <code>null</code>.

 @param key a descriptor key.
 @return The value of the indicated descriptor
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDescriptorValues" return="javax.jcr.Value[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[The value array of a multi-value descriptor is found by passing the key
 for that descriptor to this method. If <code>key</code> is the key of a
 single-value descriptor then this method returns that value as an array
 of size one. If <code>key</code> is not a valid key this method returns
 <code>null</code>.

 @param key a descriptor key.
 @return the value array for the indicated descriptor
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDescriptor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[<p> A convenience method. The call  <p> <code>String s =
 repository.getDescriptor(key);</code>  <p> is equivalent to
 <p>
 <code>Value v = repository.getDescriptorValue(key);<br/> String s = (v ==
 null) ? null : v.getString();</code>

 @param key a descriptor key.
 @return a descriptor value in string form.]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="credentials" type="javax.jcr.Credentials"/>
      <param name="workspaceName" type="java.lang.String"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Authenticates the user using the supplied <code>credentials</code>. If
 <code>workspaceName</code> is recognized as the name of an existing
 workspace in the repository and authorization to access that workspace is
 granted, then a new <code>Session</code> object is returned. The format
 of the string <code>workspaceName</code> depends upon the
 implementation.
 <p>
 If <code>credentials</code> is <code>null</code>, it is assumed that
 authentication is handled by a mechanism external to the repository
 itself (for example, through the JAAS framework) and that the repository
 implementation exists within a context (for example, an application
 server) that allows it to handle authorization of the request for access
 to the specified workspace.
 <p>
 If <code>workspaceName</code> is <code>null</code>, a default workspace
 is automatically selected by the repository implementation. This may, for
 example, be the "home workspace" of the user whose credentials were
 passed, though this is entirely up to the configuration and
 implementation of the repository. Alternatively, it may be a "null
 workspace" that serves only to provide the method {@link
 Workspace#getAccessibleWorkspaceNames}, allowing the client to select
 from among available "real" workspaces.

 @param credentials   The credentials of the user
 @param workspaceName the name of a workspace.
 @return a valid session for the user to access the repository.
 @throws LoginException           if authentication or authorization for the
                                  specified workspace fails.
 @throws NoSuchWorkspaceException if the specified
                                  <code>workspaceName</code> is not recognized.
 @throws RepositoryException      if another error occurs.]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="credentials" type="javax.jcr.Credentials"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>login(credentials, null)</code>.

 @param credentials The credentials of the user
 @return a valid session for the user to access the repository.
 @throws LoginException      if authentication or authorization fails.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="workspaceName" type="java.lang.String"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>login(null, workspaceName)</code>.

 @param workspaceName the name of a workspace.
 @return a valid session for the user to access the repository.
 @throws LoginException           if authentication or authorization for the
                                  specified workspace fails.
 @throws NoSuchWorkspaceException if the specified
                                  <code>workspaceName</code> is not recognized.
 @throws RepositoryException      if another error occurs.]]>
      </doc>
    </method>
    <method name="login" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>login(null, null)</code>.

 @return a valid session for the user to access the repository.
 @throws LoginException      if authentication or authorization fails.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <field name="SPEC_VERSION_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the version of the specification that this
 repository implements. For JCR 2.0 the value of this descriptor is the
 <code>String</code> "2.0".]]>
      </doc>
    </field>
    <field name="SPEC_NAME_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the name of the specification that this repository
 implements. For JCR 2.0 the value of this descriptor is the
 <code>String</code> "Content Repository for Java Technology API".]]>
      </doc>
    </field>
    <field name="REP_VENDOR_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the name of the repository vendor. The descriptor
 returned for this key is a <code>String</code>.]]>
      </doc>
    </field>
    <field name="REP_VENDOR_URL_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the URL of the repository vendor. The descriptor
 returned for this key is a <code>String</code>.]]>
      </doc>
    </field>
    <field name="REP_NAME_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the name of this repository implementation. The
 descriptor returned for this key is a <code>String</code>.]]>
      </doc>
    </field>
    <field name="REP_VERSION_DESC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The descriptor key for the version of this repository implementation. The
 descriptor returned for this key is a <code>String</code>.]]>
      </doc>
    </field>
    <field name="WRITE_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if repository content can be updated through the JCR API (as
 opposed to having read-only access).

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="IDENTIFIER_STABILITY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>String</code> descriptor. Returns one of the following
 <code>javax.jcr.Repository</code> constants indicating the stability of
 identifiers: <dl>
 <p>
 <dt>IDENTIFIER_STABILITY_METHOD_DURATION</dt> <dd>Identifiers may change
 between method calls.</dd>
 <p>
 <dt>IDENTIFIER_STABILITY_SAVE_DURATION</dt> <dd>Identifiers are
 guaranteed stable within a single save/refresh cycle.</dd>
 <p>
 <dt>IDENTIFIER_STABILITY_SESSION_DURATION</dt> <dd>Identifiers are
 guaranteed stable within a single session.</dd>
 <p>
 <dt>IDENTIFIER_STABILITY_INDEFINITE_DURATION</dt> <dd>Identifiers are
 guaranteed to be stable forever.</dd>
 <p>
 </dl>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="IDENTIFIER_STABILITY_METHOD_DURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of four possible values for the descriptor <code>IDENTIFIER_STABILITY</code>.
 Indicates that identifiers may change between method calls.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="IDENTIFIER_STABILITY_SAVE_DURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of four possible values for the descriptor <code>IDENTIFIER_STABILITY</code>.
 Indicates that identifiers are guaranteed stable within a single
 save/refresh cycle.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="IDENTIFIER_STABILITY_SESSION_DURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of four possible values for the descriptor <code>IDENTIFIER_STABILITY</code>.
 Indicates that identifiers are guaranteed stable within a single
 session.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="IDENTIFIER_STABILITY_INDEFINITE_DURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of four possible values for the descriptor <code>IDENTIFIER_STABILITY</code>.
 Indicates that identifiers are guaranteed to be stable forever.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_XML_EXPORT_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if XML export is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_XML_IMPORT_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if XML import is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_UNFILED_CONTENT_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if unfiled content is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_VERSIONING_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if full versioning is supported.]]>
      </doc>
    </field>
    <field name="OPTION_SIMPLE_VERSIONING_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPTION_ACTIVITIES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if activities are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_BASELINES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if configurations and baselines are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_ACCESS_CONTROL_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if access control is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_LOCKING_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if locking is supported.]]>
      </doc>
    </field>
    <field name="OPTION_OBSERVATION_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if asynchronous observation is supported.]]>
      </doc>
    </field>
    <field name="OPTION_JOURNALED_OBSERVATION_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if journaled observation is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_RETENTION_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if retention and hold are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_LIFECYCLE_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if lifecycles are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_TRANSACTIONS_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if transactions are supported.]]>
      </doc>
    </field>
    <field name="OPTION_WORKSPACE_MANAGEMENT_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if workspace management is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_UPDATE_PRIMARY_NODE_TYPE_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if the primary node type of an existing node can be updated.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_UPDATE_MIXIN_NODE_TYPES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if the mixin node types of an existing node can be added and
 removed.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_SHAREABLE_NODES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if the creation of shareable nodes is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_NODE_TYPE_MANAGEMENT_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if node type management is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="OPTION_NODE_AND_PROPERTY_WITH_SAME_NAME_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if node and property with same name is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_INHERITANCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to <code>String</code> descriptor. Returns one of the following
 <code>javax.jcr.Repository</code> constants indicating the level of
 support for node type inheritance: <dl> <dt>NODE_TYPE_MANAGEMENT_INHERITANCE_MINIMAL</dt>
 <dd> Registration of primary node types is limited to those which have
 only nt:base as supertype. Registration of mixin node types is limited to
 those without any supertypes. </dd> <dt>NODE_TYPE_MANAGEMENT_INHERITANCE_SINGLE</dt>
 <dd> Registration of primary node types is limited to those with exactly
 one supertype. Registration of mixin node types is limited to those with
 at most one supertype. </dd> <dt>NODE_TYPE_MANAGEMENT_INHERITANCE_MULTIPLE</dt>
 <dd> Primary node types can be registered with one or more supertypes.
 Mixin node types can be registered with zero or more supertypes. </dd>
 </dl>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_INHERITANCE_MINIMAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of three possible values for the descriptor <code>NODE_TYPE_MANAGEMENT_INHERITANCE</code>.
 Indicates that registration of primary node types is limited to those
 which have only nt:base as supertype. Registration of mixin node types is
 limited to those without any supertypes.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_INHERITANCE_SINGLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of three possible values for the descriptor <code>NODE_TYPE_MANAGEMENT_INHERITANCE</code>.
 Indicates that registration of primary node types is limited to those
 with exactly one supertype. Registration of mixin node types is limited
 to those with at most one supertype.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_INHERITANCE_MULTIPLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of three possible values for the descriptor <code>NODE_TYPE_MANAGEMENT_INHERITANCE</code>.
 Indicates that primary node types can be registered with one or more
 supertypes. Mixin node types can be registered with zero or more
 supertypes.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_OVERRIDES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if override of inherited property or child node definitions is
 supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_PRIMARY_ITEM_NAME_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if primary items are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_ORDERABLE_CHILD_NODES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if preservation of child node ordering is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_RESIDUAL_DEFINITIONS_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if residual property and child node definitions are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_AUTOCREATED_DEFINITIONS_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if autocreated properties and child nodes are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_SAME_NAME_SIBLINGS_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if same-name sibling child nodes are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_PROPERTY_TYPES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>long[]</code> descriptor. Returns an array holding the
 <code>javax.jcr.PropertyType</code> constants for the property types
 (including <code>UNDEFINED</code>, if supported) that a registered node
 type can specify, or a zero-length array if registered node types cannot
 specify property definitions.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_MULTIVALUED_PROPERTIES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if multivalue properties are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_MULTIPLE_BINARY_PROPERTIES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if registration of a node types with more than one
 <code>BINARY</code> property is permitted.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_VALUE_CONSTRAINTS_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns true if and only
 value-constraints are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NODE_TYPE_MANAGEMENT_UPDATE_IN_USE_SUPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns true if and only the
 update of node types is supported for node types currently in use as the
 type of an existing node in the repository.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="QUERY_LANGUAGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>String[]</code> descriptor. Returns an array holding the
 constants representing the supported query languages, or a zero-length if
 query is not supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="QUERY_STORED_QUERIES_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if stored queries are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="QUERY_FULL_TEXT_SEARCH_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if full-text search is supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="QUERY_JOINS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to <code>String</code> descriptor. Returns one of the following
 <code>javax.jcr.Repository</code> constants indicating the level of
 support for joins in queries: <dl> <dt>QUERY_JOINS_NONE</dt> <dd>Joins
 are not supported. Queries are limited to a single selector.</dd>
 <dt>QUERY_JOINS_INNER</dt> <dd> Inner joins are supported.</dd>
 <dt>QUERY_JOINS_INNER_OUTER</dt> <dd>Inner and outer joins are
 supported.</dd> </dl>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="QUERY_JOINS_NONE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of three possible values for the descriptor <code>QUERY_JOINS
 </code>. Indicates that joins are not supported. Queries are limited to a
 single selector.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="QUERY_JOINS_INNER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of three possible values for the descriptor <code>QUERY_JOINS
 </code>. Indicates that inner joins are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="QUERY_JOINS_INNER_OUTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One of three possible values for the descriptor <code>QUERY_JOINS
 </code>. Indicates that inner and outer joins are supported.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="LEVEL_1_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="As of JCR 2.0.">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if <ul> <li><code>OPTION_XML_EXPORT_SUPPORTED = true</code>
 and</li> <li><code>QUERY_LANGUAGES</code> is of non-zero length.</li>
 </ul> These semantics are identical to those in JCR 1.0. This constant is
 deprecated.

 @deprecated As of JCR 2.0.]]>
      </doc>
    </field>
    <field name="LEVEL_2_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="As of JCR 2.0.">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if <ul> <li><code>LEVEL_1_SUPPORTED = true</code>,</li>
 <li><code>WRITE_SUPPORTED = true</code> and</li> <li><code>OPTION_XML_IMPORT_SUPPORTED
 = true</code>.</li> </ul> These semantics are identical to those in JCR
 1.0. This constant is deprecated.

 @deprecated As of JCR 2.0.]]>
      </doc>
    </field>
    <field name="OPTION_QUERY_SQL_SUPPORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="As of JCR 2.0.">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns <code>true</code> if
 and only if the (deprecated) JCR 1.0 XPath query language is supported.
 This constant is deprecated.

 @deprecated As of JCR 2.0.]]>
      </doc>
    </field>
    <field name="QUERY_XPATH_POS_INDEX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="As of JCR 2.0.">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns false unless the
 (deprecated) JCR 1.0 XPath query language is supported. If JCR 1.0 XPath
 is supported then this descriptor has the same semantics as in JCR 1.0.
 This constant is deprecated.

 @deprecated As of JCR 2.0.]]>
      </doc>
    </field>
    <field name="QUERY_XPATH_DOC_ORDER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="As of JCR 2.0.">
      <doc>
      <![CDATA[Key to a <code>boolean</code> descriptor. Returns false unless the
 (deprecated) JCR 1.0 XPath query language is supported. If JCR 1.0 XPath
 is supported then this descriptor has the same semantics as in JCR 1.0.
 This constant is deprecated.

 @deprecated As of JCR 2.0.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The entry point into the content repository. The <code>Repository</code>
 object is usually acquired through the {@link RepositoryFactory}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Repository -->
  <!-- start class javax.jcr.RepositoryException -->
  <class name="RepositoryException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RepositoryException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="RepositoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="RepositoryException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="RepositoryException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Main exception thrown by classes in this package. May contain an error
 message and/or another nested exception.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.RepositoryException -->
  <!-- start interface javax.jcr.RepositoryFactory -->
  <interface name="RepositoryFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRepository" return="javax.jcr.Repository"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.util.Map"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Attempts to establish a connection to a repository using the given
 <code>parameters</code>. <p> Parameters are passed in a <code>Map</code>
 of <code>String</code> key/value pairs. The keys are not specified by JCR
 and are implementation specific. However, vendors should use keys that
 are namespace qualified in the Java package style to distinguish their
 key names. For example an address parameter might be
 <code>com.vendor.address</code>.  <p> The implementation must return
 <code>null</code> if it does not understand the given parameters. The
 implementation may also return <code>null</code> if a default repository
 instance is requested (indicated by <code>null</code>
 <code>parameters</code>) and this factory is not able to identify a
 default repository.  <p> An implementation of this method must be
 thread-safe.

 @param parameters map of string key/value pairs as repository arguments
                   or <code>null</code> if none are provided and a client wishes to connect
                   to a default repository.
 @return a repository instance or <code>null</code> if this implementation
         does not understand the passed <code>parameters</code>.
 @throws RepositoryException if if no suitable repository is found or
                             another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<code>RepositoryFactory</code> is a factory for <code>Repository</code>
 objects.
 <p>
 An implementation of this interface must have a zero-argument public
 constructor. Repository factories may be installed in an instance of the Java
 platform as extensions, that is, jar files placed into any of the usual
 extension directories. Factories may also be made available by adding them to
 the applet or application class path or by some other platform-specific
 means.
 <p>
 A repository factory implementation should support the Java Standard Edition
 Service Provider mechanism, that is, an implementation should include the
 file <code>META-INF/services/javax.jcr.RepositoryFactory</code>. This file
 contains the fully qualified name of the class that implements
 <code>RepositoryFactory</code>.
 <p>
 <b>Examples how to obtain repository instances</b>
 <p>
 Explicitly specifying the repository factory implementation: <code>
 <pre>
   Map parameters = new HashMap();
   parameters.put("com.vendor.address", "vendor://localhost:9999/repo");
   RepositoryFactory factory = (RepositoryFactory) Class.forName("com.vendor.RepositoryFactoryImpl");
   Repository repo = factory.getRepository(parameters);
 </pre>
 </code>
 <p>
 Using ServiceLoader from Java SE 6: <code>
 <pre>
   Map parameters = new HashMap();
   parameters.put("com.vendor.address", "vendor://localhost:9999/repo");
   Repository repo = null;
   for (RepositoryFactory factory : ServiceLoader.load(RepositoryFactory.class))
 {
     repo = factory.getRepository(parameters);
     if (repo != null) {
       // factory accepted parameters
       break;
     }
   }
 </pre>
 </code>
 <b>Note:</b> on Java SE prior to version 6, one may use the class
 <code>javax.imageio.spi.ServiceRegistry</code> to look up the available
 <code>RepositoryFactory</code> implementations.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.RepositoryFactory -->
  <!-- start interface javax.jcr.Session -->
  <interface name="Session"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRepository" return="javax.jcr.Repository"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>Repository</code> object through which this session was
 acquired.

 @return a <code>{@link Repository}</code> object.]]>
      </doc>
    </method>
    <method name="getUserID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the user ID associated with this <code>Session</code>. How the user
 ID is set is up to the implementation, it may be a string passed in as
 part of the credentials or it may be a string acquired in some other way.
 This method is free to return an "anonymous user ID" or
 <code>null</code>.

 @return the user ID associated with this <code>Session</code>.]]>
      </doc>
    </method>
    <method name="getAttributeNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the attributes set in this session as a result of
 the <code>Credentials</code> that were used to acquire it. Not all
 <code>Credentials</code> implementations will contain attributes (though,
 for example, <code>SimpleCredentials</code> does allow for them). This
 method returns an empty array if the <code>Credentials</code> instance
 did not provide attributes.

 @return A string array containing the names of all attributes passed in
         the credentials used to acquire this session.]]>
      </doc>
    </method>
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the value of the named attribute as an <code>Object</code>, or
 <code>null</code> if no attribute of the given name exists. See {@link
 Session#getAttributeNames}.

 @param name the name of an attribute passed in the credentials used to
             acquire this session.
 @return the value of the attribute or <code>null</code> if no attribute
         of the given name exists.]]>
      </doc>
    </method>
    <method name="getWorkspace" return="javax.jcr.Workspace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>Workspace</code> attached to this
 <code>Session</code>.

 @return a <code>{@link Workspace}</code> object.]]>
      </doc>
    </method>
    <method name="getRootNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the root node of the workspace, "/". This node is the main access
 point to the content of the workspace.

 @return The root node of the workspace: a <code>{@link Node}</code>
         object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="impersonate" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="credentials" type="javax.jcr.Credentials"/>
      <exception name="LoginException" type="javax.jcr.LoginException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a new session in accordance with the specified (new) Credentials.
 Allows the current user to "impersonate" another using incomplete or
 relaxed credentials requirements (perhaps including a user name but no
 password, for example), assuming that this <code>Session</code> gives
 them that permission.
 <p>
 The new <code>Session</code> is tied to a new <code>Workspace</code>
 instance. In other words, <code>Workspace</code> instances are not
 re-used. However, the <code>Workspace</code> instance returned represents
 the same actual persistent workspace entity in the repository as is
 represented by the <code>Workspace</code> object tied to this
 <code>Session</code>.

 @param credentials A <code>Credentials</code> object
 @return a <code>Session</code> object
 @throws LoginException      if the current session does not have sufficient
                             access to perform the operation.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getNodeByUUID" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #getNodeByIdentifier(String)} should be
             used instead.">
      <param name="uuid" type="java.lang.String"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node specified by the given UUID. Only applies to nodes that
 expose a UUID, in other words, those of mixin node type
 <code>mix:referenceable</code>

 @param uuid A universally unique identifier.
 @return A <code>Node</code>.
 @throws ItemNotFoundException if the specified UUID is not found.
 @throws RepositoryException   if another error occurs.
 @deprecated As of JCR 2.0, {@link #getNodeByIdentifier(String)} should be
             used instead.]]>
      </doc>
    </method>
    <method name="getNodeByIdentifier" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node specified by the given identifier. Applies to both
 referenceable and non-referenceable nodes.

 @param id An identifier.
 @return A <code>Node</code>.
 @throws ItemNotFoundException if no node with the specified identifier
                               exists or if this <code>Session<code> does not have read access to the
                               node with the specified identifier.
 @throws RepositoryException   if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getItem" return="javax.jcr.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node at the specified absolute path in the workspace. If no
 such node exists, then it returns the property at the specified path.
 <p>
 This method should only be used if the application does not know whether
 the item at the indicated path is property or node. In cases where the
 application has this information, either {@link #getNode} or {@link
 #getProperty} should be used, as appropriate. In many repository
 implementations the node and property-specific methods are likely to be
 more efficient than <code>getItem</code>.

 @param absPath An absolute path.
 @return the specified <code>Item</code>.
 @throws PathNotFoundException if no accessible item is found at the
                               specified path.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node at the specified absolute path in the workspace.

 @param absPath An absolute path.
 @return the specified <code>Node</code>.
 @throws PathNotFoundException If no accessible node is found at the
                               specifed path.
 @throws RepositoryException   If another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getProperty" return="javax.jcr.Property"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the property at the specified absolute path in the workspace.

 @param absPath An absolute path.
 @return the specified <code>Property</code>.
 @throws PathNotFoundException If no accessible property is found at the
                               specified path.
 @throws RepositoryException   if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="itemExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if an item exists at <code>absPath</code> and
 this <code>Session</code> has read access to it; otherwise returns
 <code>false</code>.

 @param absPath An absolute path.
 @return a <code>boolean</code>
 @throws RepositoryException if <code>absPath</code> is not a well-formed
                             absolute path.]]>
      </doc>
    </method>
    <method name="nodeExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if a node exists at <code>absPath</code> and
 this <code>Session</code> has read access to it; otherwise returns
 <code>false</code>.

 @param absPath An absolute path.
 @return a <code>boolean</code>
 @throws RepositoryException if <code>absPath</code> is not a well-formed
                             absolute path.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="propertyExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if a property exists at <code>absPath</code>
 and this <code>Session</code> has read access to it; otherwise returns
 <code>false</code>.

 @param absPath An absolute path.
 @return a <code>boolean</code>
 @throws RepositoryException if <code>absPath</code> is not a well-formed
                             absolute path.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Moves the node at <code>srcAbsPath</code> (and its entire subgraph) to
 the new location at <code>destAbsPath</code>.
 <p>
 This is a session-write method and therefor requires a <code>save</code>
 to dispatch the change.
 <p>
 The identifiers of referenceable nodes <i>must not</i> be changed by a
 <code>move</code>. The identifiers of non-referenceable nodes <i>may</i>
 change.
 <p>
 A <code>ConstraintViolationException</code> is thrown either immediately,
 on dispatch or on persist, if performing this operation would violate a
 node type or implementation-specific constraint. Implementations may
 differ on when this validation is performed.
 <p>
 As well, a <code>ConstraintViolationException</code> will be thrown on
 persist if an attempt is made to separately <code>save</code> either the
 source or destination node.
 <p>
 Note that this behavior differs from that of {@link Workspace#move},
 which is a workspace-write method and therefore immediately dispatches
 changes.
 <p>
 The <code>destAbsPath</code> provided must not have an index on its final
 element. If ordering is supported by the node type of the parent node of
 the new location, then the newly moved node is appended to the end of the
 child node list.
 <p>
 This method cannot be used to move an individual property by itself. It
 moves an entire node and its subgraph.
 <p>
 If no node exists at <code>srcAbsPath</code> or no node exists one level
 above <code>destAbsPath</code> (in other words, there is no node that
 will serve as the parent of the moved item) then a
 <code>PathNotFoundException</code> is thrown either immediately, on
 dispatch or on persist. Implementations may differ on when this
 validation is performed.
 <p>
 An <code>ItemExistsException</code> is thrown either immediately, on
 dispatch or on persist, if a node already exists at
 <code>destAbsPath</code> and same-name siblings are not allowed.
 Implementations may differ on when this validation is performed.
 <p>
 Note that if a property already exists at <code>destAbsPath</code>, the
 operation succeeds, since a node may have a child node and property with
 the same name.
 <p>
 A <code>VersionException</code> is thrown either immediately, on dispatch
 or on persist, if the parent node of <code>destAbsPath</code> or the
 parent node of <code>srcAbsPath] is read-only due to a checked-in node.
 Implementations may differ on when this validation is performed.
 <p>
 A <code>LockException</code> is thrown either immediately, on dispatch or
 on persist, if a lock prevents the <code>move</code>. Implementations may
 differ on when this validation is performed.

 @param srcAbsPath  the root of the subgraph to be moved.
 @param destAbsPath the location to which the subgraph is to be moved.
 @throws ItemExistsException          if a node already exists at
                                      <code>destAbsPath</code> and same-name siblings are not allowed.
 @throws PathNotFoundException        if either <code>srcAbsPath</code> or
                                      <code>destAbsPath</code> cannot be found and this implementation performs
                                      this validation immediately.
 @throws VersionException             if the parent node of <code>destAbsPath</code>
                                      or the parent node of <code>srcAbsPath</code> is versionable and
                                      checked-in, or or is non-versionable and its nearest versionable ancestor
                                      is checked-in and this implementation performs this validation
                                      immediately.
 @throws ConstraintViolationException if a node-type or other constraint
                                      violation is detected immediately and this implementation performs this
                                      validation immediately.
 @throws LockException                if the move operation would violate a lock and this
                                      implementation performs this validation immediately.
 @throws RepositoryException          if the last element of
                                      <code>destAbsPath</code> has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="removeItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified item and its subgraph.
 <p>
 This is a session-write method and therefore requires a <code>save</code>
 in order to dispatch the change.
 <p>
 If a node with same-name siblings is removed, this decrements by one the
 indices of all the siblings with indices greater than that of the removed
 node. In other words, a removal compacts the array of same-name siblings
 and causes the minimal re-numbering required to maintain the original
 order but leave no gaps in the numbering.
 <p>
 A <code>ReferentialIntegrityException</code> will be thrown on dispatch
 if the specified item or an item in its subgraph is currently the target
 of a <code>REFERENCE</code> property located in this workspace but
 outside the specified item's subgraph and the current
 <code>Session</code> has read access to that <code>REFERENCE</code>
 property.
 <p>
 A <code>ConstraintViolationException</code> will be thrown either
 immediately, on dispatch or on persist, if removing the specified item
 would violate a node type or implementation-specific constraint.
 Implementations may differ on when this validation is performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch or on persist, if the parent node of the specified item is
 read-only due to a checked-in node. Implementations may differ on when
 this validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch or on persist, if a lock prevents the removal of the specified
 item. Implementations may differ on when this validation is performed.
 <p>
 A <code>PathNotFoundException</code> will be thrown either immediately,
 on dispatch or on persist, if no accessible item is found at at
 <code>absPath</code>.
 <p>
 A <code>AccessDeniedException</code> will be thrown either immediately,
 on dispatch or on persist, if the specified item or an item in its
 subgraph is currently the target of a <code>REFERENCE</code> property
 located in this workspace but outside the specified item's subgraph and
 the current <code>Session</code> <i>does not</i> have read access to that
 <code>REFERENCE</code> property.

 @param absPath the absolute path of the item to be removed.

 @throws VersionException             if the parent node of the item at absPath is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the removal of the specified
                                      item and this implementation performs this validation immediately.
 @throws ConstraintViolationException if removing the specified item would
                                      violate a node type or implementation-specific constraint and this
                                      implementation performs this validation immediately.
 @throws PathNotFoundException        if no accessible item is found at <code>absPath</code> and this
                                      implementation performs this validation immediately.
 @throws AccessDeniedException        if the specified item or an item in its
                                      subgraph is currently the target of a <code>REFERENCE</code> property
                                      located in this workspace but outside the specified item's subgraph and
                                      the current <code>Session</code> <i>does not</i> have read access to that
                                      <code>REFERENCE</code> property and this implementation performs this
                                      validation immediately.
 @throws RepositoryException          if another error occurs.
 @see Item#remove()
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ReferentialIntegrityException" type="javax.jcr.ReferentialIntegrityException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Validates all pending changes currently recorded in this
 <code>Session</code>. If validation of <i>all</i> pending changes
 succeeds, then this change information is cleared from the
 <code>Session</code>.
 <p>
 If the <code>save</code> occurs outside a transaction, the changes are
 <i>dispatched</i> and <i>persisted</i>. Upon being persisted the changes
 become potentially visible to other <code>Sessions</code> bound to the
 same persitent workspace.
 <p>
 If the <code>save</code> occurs within a transaction, the changes are
 <i>dispatched</i> but are not <i>persisted</i> until the transaction is
 committed.
 <p>
 If validation fails, then no pending changes are dispatched and they
 remain recorded on the <code>Session</code>. There is no best-effort or
 partial <code>save</code>.

 @throws AccessDeniedException         if any of the changes to be persisted would
                                       violate the access privileges of the this <code>Session</code>. Also
                                       thrown if  any of the changes to be persisted would cause the removal of
                                       a node that is currently referenced by a <code>REFERENCE</code> property
                                       that this Session <i>does not</i> have read access to.
 @throws ItemExistsException           if any of the changes to be persisted would
                                       be prevented by the presence of an already existing item in the
                                       workspace.
 @throws ConstraintViolationException  if any of the changes to be
                                       persisted would violate a node type or restriction. Additionally, a
                                       repository may use this exception to enforce implementation- or
                                       configuration-dependent restrictions.
 @throws InvalidItemStateException     if any of the changes to be persisted
                                       conflicts with a change already persisted through another session and the
                                       implementation is such that this conflict can only be detected at
                                       <code>save</code>-time and therefore was not detected earlier, at
                                       change-time.
 @throws ReferentialIntegrityException if any of the changes to be
                                       persisted would cause the removal of a node that is currently referenced
                                       by a <code>REFERENCE</code> property that this <code>Session</code> has
                                       read access to.
 @throws VersionException              if the <code>save</code> would make a result in
                                       a change to persistent storage that would violate the read-only status of
                                       a checked-in node.
 @throws LockException                 if the <code>save</code> would result in a change
                                       to persistent storage that would violate a lock.
 @throws NoSuchNodeTypeException       if the <code>save</code> would result in
                                       the addition of a node with an unrecognized node type.
 @throws RepositoryException           if another error occurs.]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keepChanges" type="boolean"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If <code>keepChanges</code> is <code>false</code>, this method discards
 all pending changes currently recorded in this <code>Session</code> and
 returns all items to reflect the current saved state. Outside a
 transaction this state is simply the current state of persistent storage.
 Within a transaction, this state will reflect persistent storage as
 modified by changes that have been saved but not yet committed.
 <p>
 If <code>keepChanges</code> is true then pending change are not discarded
 but items that do not have changes pending have their state refreshed to
 reflect the current saved state, thus revealing changes made by other
 sessions.

 @param keepChanges a boolean
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="hasPendingChanges" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this session holds pending (that is,
 unsaved) changes; otherwise returns <code>false</code>.

 @return a boolean
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getValueFactory" return="javax.jcr.ValueFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns a <code>ValueFactory</code> that is used to create
 <code>Value</code> objects for use when setting repository properties.

 @return a <code>ValueFactory</code>
 @throws UnsupportedRepositoryOperationException
                             if writing to the
                             repository is not supported.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="hasPermission" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="actions" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Session</code> has permission to
 perform the specified actions at the specified <code>absPath</code> and
 <code>false</code> otherwise.
 <p>
 The <code>actions</code> parameter is a comma separated list of action
 strings. The following action strings are defined: <ul> <li> {@link
 #ACTION_ADD_NODE <code>add_node</code>}: If <code>hasPermission(path,
 "add_node")</code> returns <code>true</code>, then this
 <code>Session</code> has permission to add a node at <code>path</code>.
 </li> <li> {@link #ACTION_SET_PROPERTY <code>set_property</code>}: If
 <code>hasPermission(path, "set_property")</code> returns
 <code>true</code>, then this <code>Session</code> has permission to set
 (add or change) a property at <code>path</code>. </li> <li> {@link
 #ACTION_REMOVE <code>remove</code>}: If <code>hasPermission(path,
 "remove")</code> returns <code>true</code>, then this
 <code>Session</code> has permission to remove an item at
 <code>path</code>. </li> <li> {@link #ACTION_READ <code>read</code>}: If
 <code>hasPermission(path, "read")</code> returns <code>true</code>, then
 this <code>Session</code> has permission to retrieve (and read the value
 of, in the case of a property) an item at <code>path</code>. </li> </ul>
 When more than one action is specified in the <code>actions</code>
 parameter, this method will only return <code>true</code> if this
 <code>Session</code> has permission to perform <i>all</i> of the listed
 actions at the specified path.
 <p>
 The information returned through this method will only reflect the access
 control status (both JCR defined and implementation-specific) and not
 other restrictions that may exist, such as node type constraints. For
 example, even though <code>hasPermission</code> may indicate that a
 particular <code>Session</code> may add a property at
 <code>/A/B/C</code>, the node type of the node at <code>/A/B</code> may
 prevent the addition of a property called <code>C</code>.

 @param absPath an absolute path.
 @param actions a comma separated list of action strings.
 @return <code>true</code> if this <code>Session</code> has permission to
         perform the specified actions at the specified
         <code>absPath</code>.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="checkPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="actions" type="java.lang.String"/>
      <exception name="AccessControlException" type="java.security.AccessControlException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Determines whether this <code>Session</code> has permission to perform
 the specified actions at the specified <code>absPath</code>. This method
 quietly returns if the access request is permitted, or throws a suitable
 <code>java.security.AccessControlException</code> otherwise.
 <p>
 The <code>actions</code> parameter is a comma separated list of action
 strings. The following action strings are defined: <ul> <li> {@link
 #ACTION_ADD_NODE <code>add_node</code>}: If <code>checkPermission(path,
 "add_node")</code> returns quietly, then this <code>Session</code> has
 permission to add a node at <code>path</code>, otherwise permission is
 denied. </li> <li> {@link #ACTION_SET_PROPERTY <code>set_property</code>}:
 If <code>checkPermission(path, "set_property")</code> returns quietly,
 then this <code>Session</code> has permission to set (add or change) a
 property at <code>path</code>, otherwise permission is denied. </li> <li>
 {@link #ACTION_REMOVE <code>remove</code>}: If <code>checkPermission(path,
 "remove")</code> returns quietly, then this <code>Session</code> has
 permission to remove an item at <code>path</code>, otherwise permission
 is denied. </li> <li> {@link #ACTION_READ <code>read</code>}: If
 <code>checkPermission(path, "read")</code> returns quietly, then this
 <code>Session</code> has permission to retrieve (and read the value of,
 in the case of a property) an item at <code>path</code>, otherwise
 permission is denied. </li> </ul> When more than one action is specified
 in the <code>actions</code> parameter, this method will only return
 quietly if this <code>Session</code> has permission to perform <i>all</i>
 of the listed actions at the specified path.
 <p>
 The information returned through this method will only reflect access
 control status (both JCR defined and implementation-specific) and not
 other restrictions that may exist, such as node type constraints. For
 example, even though <code>checkPermission</code> may indicate that a
 particular <code>Session</code> may add a property at
 <code>/A/B/C</code>, the node type of the node at <code>/A/B</code> may
 prevent the addition of a property called <code>C</code>.

 @param absPath an absolute path.
 @param actions a comma separated list of action strings.
 @throws java.security.AccessControlException
                             If permission is denied.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="hasCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodName" type="java.lang.String"/>
      <param name="target" type="java.lang.Object"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Checks whether an operation can be performed given as much context as can
 be determined by the repository, including: <ul> <li> Permissions granted
 to the current user, including access control privileges. </li> <li>
 Current state of the target object (reflecting locks, checkin/checkout
 status, retention and hold status etc.). </li> <li> Repository
 capabilities. </li> <li> Node type-enforced restrictions. </li> <li>
 Repository configuration-specific restrictions. </li> </ul> The
 implementation of this method is best effort: returning
 <code>false</code> guarantees that the operation cannot be performed, but
 returning <code>true</code> does not guarantee the opposite. The
 repository implementation should use this to give priority to performance
 over completeness. An exception should be thrown only for important
 failures such as loss of connectivity to the back-end.
 <p>
 The implementation of this method is best effort: returning false
 guarantees that the operation cannot be performed, but returning true
 does not guarantee the opposite.
 <p>
 The <code>methodName</code> parameter identifies the method in question
 by its name as defined in the Javadoc.
 <p>
 The <code>target</code> parameter identifies the object on which the
 specified method is called.
 <p>
 The <code>arguments</code> parameter contains an array of type
 <code>Object</code> object consisting of the arguments to be passed
 to the method in question. In cases where a parameter is a Java
 primitive type it must be converted to its corresponding Java object form.
 <p>
 For example, given a <code>Session</code> <code>S</code> and
 <code>Node</code> <code>N</code> then
 <p>
 <code>boolean b = S.hasCapability("addNode", N, new Object[]{"foo"});</code>
 <p>
 will result in <code>b == false</code> if a child node called <code>foo</code> cannot be added to
 the node <code>N</code> within the session <code>S</code>.

 @param methodName the nakme of the method.
 @param target     the target object of the operation.
 @param arguments  the arguments of the operation.
 @return <code>false</code> if the operation cannot be performed,
         <code>true</code> if the operation can be performed or if the
         repository cannot determine whether the operation can be
         performed.
 @throws RepositoryException if an error occurs
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getImportContentHandler" return="org.xml.sax.ContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>org.xml.sax.ContentHandler</code> which is used to push
 SAX events to the repository. If the incoming XML (in the form of SAX
 events) does not appear to be a JCR <i>system view</i> XML document then
 it is interpreted as a JCR <i>document view</i> XML document.
 <p>
 The incoming XML is deserialized into a subgraph of items immediately
 below the node at <code>parentAbsPath</code>.
 <p>
 This method simply returns the <code>ContentHandler</code> without
 altering the state of the session; the actual deserialization to the
 session transient space is done through the methods of the
 <code>ContentHandler</code>. Invalid XML data will cause the
 <code>ContentHandler</code> to throw a <code>SAXException</code>.
 <p>
 As SAX events are fed into the <code>ContentHandler</code>, the tree of
 new items is built in the transient storage of the session. In order to
 dispatch the new content, <code>save</code> must be called. See {@link
 Workspace#getImportContentHandler} for a workspace-write version of this
 method.
 <p>
 The flag <code>uuidBehavior</code> governs how the identifiers of
 incoming nodes are handled: <ul> <li> {@link ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}:
 Incoming identifiers nodes are added in the same way that new node is
 added with <code>Node.addNode</code>. That is, they are either assigned
 newly created identifiers upon addition or upon <code>save</code>
 (depending on the implementation). In either case, identifier collisions
 will not occur. </li> <li> {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}:
 If an incoming node has the same identifier as a node already existing in
 the workspace then the already existing node (and its subgraph) is
 removed from wherever it may be in the workspace before the incoming node
 is added. Note that this can result in nodes "disappearing" from
 locations in the workspace that are remote from the location to which the
 incoming subgraph is being written. Both the removal and the new addition
 will be persisted on <code>save</code>. </li> <li> {@link
 ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}: If an
 incoming node has the same identifier as a node already existing in the
 workspace, then the already-existing node is replaced by the incoming
 node in the same position as the existing node. Note that this may result
 in the incoming subgraph being disaggregated and "spread around" to
 different locations in the workspace. In the most extreme case this
 behavior may result in no node at all being added as child of
 <code>parentAbsPath</code>. This will occur if the topmost element of the
 incoming XML has the same identifier as an existing node elsewhere in the
 workspace. The change will be persisted on <code>save</code>. </li> <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If an incoming
 node has the same identifier as a node already existing in the workspace
 then a <code>SAXException</code> is thrown by the
 <code>ContentHandler</code> during deserialization. </li> </ul> Unlike
 <code>Workspace.getImportContentHandler</code>, this method does not
 necessarily enforce all node type constraints during deserialization.
 Those that would be immediately enforced in a session-write method
 (<code>Node.addNode</code>, <code>Node.setProperty</code> etc.) of this
 implementation cause the returned <code>ContentHandler</code> to throw an
 immediate <code>SAXException</code> during deserialization. All other
 constraints are checked on save, just as they are in normal write
 operations. However, which node type constraints are enforced depends
 upon whether node type information in the imported data is respected, and
 this is an implementation-specific issue.
 <p>
 A <code>SAXException</code> will also be thrown by the returned
 <code>ContentHandler</code> during deserialization if
 <code>uuidBehavior</code> is set to <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code>
 and an incoming node has the same identifier as the node at
 <code>parentAbsPath</code> or one of its ancestors.
 <p>
 A <code>PathNotFoundException</code> is thrown either immediately, on
 dispatch or on persist, if no node exists at <code>parentAbsPath</code>.
 Implementations may differ on when this validation is performed
 <p>
 A <code>ConstraintViolationException</code> is thrown either immediately,
 on dispatch or on persist, if the new subgraph cannot be added to the
 node at <code>parentAbsPath</code> due to node-type or other
 implementation-specific constraints, and this can be determined before
 the first SAX event is sent. Implementations may differ on when this
 validation is performed.
 <p>
 A <code>VersionException</code> is thrown either immediately, on dispatch
 or on persist, if the node at <code>parentAbsPath</code> is read-only due
 to a check-in. Implementations may differ on when this validation is
 performed.
 <p>
 A <code>LockException</code> is thrown either immediately, on dispatch or
 on persist, if a lock prevents the addition of the subgraph.
 Implementations may differ on when this validation is performed.

 @param parentAbsPath the absolute path of a node under which (as child)
                      the imported subgraph will be built.
 @param uuidBehavior  a four-value flag that governs how incoming
                      identifiers are handled.
 @return an org.xml.sax.ContentHandler whose methods may be called to feed
         SAX events into the deserializer.
 @throws PathNotFoundException        if no node exists at
                                      <code>parentAbsPath</code> and this implementation performs this
                                      validation immediately.
 @throws ConstraintViolationException if the new subgraph cannot be added
                                      to the node at <code>parentAbsPath</code> due to node-type or other
                                      implementation-specific constraints, and this implementation performs
                                      this validation immediately.
 @throws VersionException             if the node at <code>parentAbsPath</code> is
                                      read-only due to a checked-in node and this implementation performs this
                                      validation immediately.
 @throws LockException                if a lock prevents the addition of the subgraph and
                                      this implementation performs this validation immediately.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="importXML"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="in" type="java.io.InputStream"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidSerializedDataException" type="javax.jcr.InvalidSerializedDataException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Deserializes an XML document and adds the resulting item subgraph as a
 child of the node at <code>parentAbsPath</code>.
 <p>
 If the incoming XML stream does not appear to be a JCR <i>system view</i>
 XML document then it is interpreted as a <i>document view</i> XML
 document.
 <p>
 The passed <code>InputStream</code> is closed before this method returns
 either normally or because of an exception.
 <p>
 The tree of new items is built in the transient storage of the
 <code>Session</code>. In order to persist the new content,
 <code>save</code> must be called. The advantage of this
 through-the-session method is that (depending on what constraint checks
 the implementation leaves until <code>save</code>) structures that
 violate node type constraints can be imported, fixed and then saved. The
 disadvantage is that a large import will result in a large cache of
 pending nodes in the session. See {@link Workspace#importXML} for a
 version of this method that does not go through the
 <code>Session</code>.
 <p>
 The flag <code>uuidBehavior</code> governs how the identifiers of
 incoming nodes are handled. There are four options: <ul> <li> {@link
 ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}: Incoming nodes are added in
 the same way that new node is added with <code>Node.addNode</code>. That
 is, they are either assigned newly created identifiers upon addition or
 upon <code>save</code> (depending on the implementation, see <i>4.9.1.1
 When Identifiers are Assigned</i> in the specification). In either case,
 identifier collisions will not occur. </li> <li> {@link
 ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}: If an incoming
 node has the same identifier as a node already existing in the workspace
 then the already existing node (and its subgraph) is removed from
 wherever it may be in the workspace before the incoming node is added.
 Note that this can result in nodes "disappearing" from locations in the
 workspace that are remote from the location to which the incoming
 subgraph is being written. Both the removal and the new addition will be
 dispatched on <code>save</code>. </li> <li> {@link
 ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}: If an
 incoming node has the same identifier as a node already existing in the
 workspace, then the already-existing node is replaced by the incoming
 node in the same position as the existing node. Note that this may result
 in the incoming subgraph being disaggregated and "spread around" to
 different locations in the workspace. In the most extreme case this
 behavior may result in no node at all being added as child of
 <code>parentAbsPath</code>. This will occur if the topmost element of the
 incoming XML has the same identifier as an existing node elsewhere in the
 workspace. The change will be dispatched on <code>save</code>. </li> <li>
 {@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If an incoming
 node has the same identifier as a node already existing in the workspace
 then an <code>ItemExistsException</code> is thrown. </li> </ul> Unlike
 {@link Workspace#importXML}, this method does not necessarily enforce all
 node type constraints during deserialization. Those that would be
 immediately enforced in a normal write method (<code>Node.addNode</code>,
 <code>Node.setProperty</code> etc.) of this implementation cause an
 immediate <code>ConstraintViolationException</code> during
 deserialization. All other constraints are checked on <code>save</code>,
 just as they are in normal write operations. However, which node type
 constraints are enforced depends upon whether node type information in
 the imported data is respected, and this is an implementation-specific
 issue.
 <p>
 A <code>ConstraintViolationException</code> will also be thrown
 immediately if <code>uuidBehavior</code> is set to
 <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code> and an incoming node
 has the same identifier as the node at <code>parentAbsPath</code> or one
 of its ancestors.
 <p>
 A <code>PathNotFoundException</code> is thrown either immediately, on
 dispatch or on persist, if no node exists at <code>parentAbsPath</code>.
 Implementations may differ on when this validation is performed
 <p>
 A <code>ConstraintViolationException</code> is thrown either immediately,
 on dispatch or on persist, if the new subgraph cannot be added to the
 node at <code>parentAbsPath</code> due to node-type or other
 implementation-specific constraints. Implementations may differ on when
 this validation is performed.
 <p>
 A <code>VersionException</code> is thrown either immediately, on dispatch
 or on persist, if the node at <code>parentAbsPath</code> is read-only due
 to a check-in. Implementations may differ on when this validation is
 performed.
 <p>
 A <code>LockException</code> is thrown either immediately, on dispatch or
 on persist, if a lock prevents the addition of the subgraph.
 Implementations may differ on when this validation is performed.

 @param parentAbsPath the absolute path of the node below which the
                      deserialized subgraph is added.
 @param in            The <code>Inputstream</code> from which the XML to be
                      deserialized is read.
 @param uuidBehavior  a four-value flag that governs how incoming
                      identifiers are handled.
 @throws java.io.IOException            if an error during an I/O operation occurs.
 @throws PathNotFoundException          if no node exists at
                                        <code>parentAbsPath</code> and this implementation performs this
                                        validation immediately.
 @throws ItemExistsException            if deserialization would overwrite an
                                        existing item and this implementation performs this validation
                                        immediately.
 @throws ConstraintViolationException   if a node type or other
                                        implementation-specific constraint is violated that would be checked on a
                                        session-write method or if <code>uuidBehavior</code> is set to
                                        <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code> and an incoming node
                                        has the same UUID as the node at <code>parentAbsPath</code> or one of its
                                        ancestors.
 @throws VersionException               if the node at <code>parentAbsPath</code> is
                                        read-only due to a checked-in node and this implementation performs this
                                        validation immediately.
 @throws InvalidSerializedDataException if incoming stream is not a valid
                                        XML document.
 @throws LockException                  if a lock prevents the addition of the subgraph and
                                        this implementation performs this validation immediately.
 @throws RepositoryException            if another error occurs.]]>
      </doc>
    </method>
    <method name="exportSystemView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="contentHandler" type="org.xml.sax.ContentHandler"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="SAXException" type="org.xml.sax.SAXException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subgraph) at <code>absPath</code> into a series of SAX events
 by calling the methods of the supplied <code>org.xml.sax.ContentHandler</code>.
 The resulting XML is in the system view form. Note that
 <code>absPath</code> must be the path of a node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of
 <code>PropertyType.BINARY</code> will be serialized as if they are empty.
 That is, the existence of the property will be serialized, but its
 content will not appear in the serialized output (the
 <code>&lt;sv:value&gt;</code> element will have no content). Note that in
 the case of multi-value <code>BINARY</code> properties, the number of
 values in the property will be reflected in the serialized output, though
 they will all be empty. If <code>skipBinary</code> is false then the
 actual value(s) of each <code>BINARY</code> property is recorded using
 Base64 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the
 entire subgraph rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's point
 of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to node
 type constraints) and all namespace mappings in the namespace registry,
 as modified by the current session-mappings, are reflected in the
 output.
 <p>
 The output XML will be encoded in UTF-8.

 @param absPath        The path of the root of the subgraph to be serialized.
                       This must be the path to a node, not a property
 @param contentHandler The  <code>org.xml.sax.ContentHandler</code> to
                       which the SAX events representing the XML serialization of the subgraph
                       will be output.
 @param skipBinary     A <code>boolean</code> governing whether binary
                       properties are to be serialized.
 @param noRecurse      A <code>boolean</code> governing whether the subgraph at
                       absPath is to be recursed.
 @throws PathNotFoundException    if no node exists at <code>absPath</code>.
 @throws org.xml.sax.SAXException if an error occurs while feeding events
                                  to the <code>org.xml.sax.ContentHandler</code>.
 @throws RepositoryException      if another error occurs.]]>
      </doc>
    </method>
    <method name="exportSystemView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subgraph) at <code>absPath</code> as an XML stream and outputs
 it to the supplied <code>OutputStream</code>. The resulting XML is in the
 system view form. Note that <code>absPath</code> must be the path of a
 node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of
 <code>PropertyType.BINARY</code> will be serialized as if they are empty.
 That is, the existence of the property will be serialized, but its
 content will not appear in the serialized output (the
 <code>&lt;sv:value&gt;</code> element will have no content). Note that in
 the case of multi-value <code>BINARY</code> properties, the number of
 values in the property will be reflected in the serialized output, though
 they will all be empty. If <code>skipBinary</code> is false then the
 actual value(s) of each <code>BINARY</code> property is recorded using
 Base64 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the
 entire subgraph rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's point
 of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to node
 type constraints) and all namespace mappings in the namespace registry,
 as modified by the current session-mappings, are reflected in the
 output.
 <p>
 The output XML will be encoded in UTF-8.
 <p>
 It is the responsibility of the caller to close the passed
 <code>OutputStream</code>.

 @param absPath    The path of the root of the subgraph to be serialized.
                   This must be the path to a node, not a property
 @param out        The <code>OutputStream</code> to which the XML serialization
                   of the subgraph will be output.
 @param skipBinary A <code>boolean</code> governing whether binary
                   properties are to be serialized.
 @param noRecurse  A <code>boolean</code> governing whether the subgraph at
                   absPath is to be recursed.
 @throws PathNotFoundException if no node exists at <code>absPath</code>.
 @throws IOException           if an error during an I/O operation occurs.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="exportDocumentView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="contentHandler" type="org.xml.sax.ContentHandler"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="SAXException" type="org.xml.sax.SAXException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subgraph) at <code>absPath</code> into a series of SAX events
 by calling the methods of the supplied <code>org.xml.sax.ContentHandler</code>.
 The resulting XML is in the document view form. Note that
 <code>absPath</code> must be the path of a node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of
 <code>PropertyType.BINARY</code> will be serialized as if they are empty.
 That is, the existence of the property will be serialized, but its
 content will not appear in the serialized output (the value of the
 attribute will be empty). If <code>skipBinary</code> is false then the
 actual value(s) of each <code>BINARY</code> property is recorded using
 Base64 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the
 entire subgraph rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's point
 of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to node
 type constraints) and all namespace mappings in the namespace registry,
 as modified by the current session-mappings, are reflected in the
 output.
 <p>
 The output XML will be encoded in UTF-8.

 @param absPath        The path of the root of the subgraph to be serialized.
                       This must be the path to a node, not a property
 @param contentHandler The  <code>org.xml.sax.ContentHandler</code> to
                       which the SAX events representing the XML serialization of the subgraph
                       will be output.
 @param skipBinary     A <code>boolean</code> governing whether binary
                       properties are to be serialized.
 @param noRecurse      A <code>boolean</code> governing whether the subgraph at
                       absPath is to be recursed.
 @throws PathNotFoundException    if no node exists at <code>absPath</code>.
 @throws org.xml.sax.SAXException if an error occurs while feeding events
                                  to the <code>org.xml.sax.ContentHandler</code>.
 @throws RepositoryException      if another error occurs.]]>
      </doc>
    </method>
    <method name="exportDocumentView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="skipBinary" type="boolean"/>
      <param name="noRecurse" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Serializes the node (and if <code>noRecurse</code> is <code>false</code>,
 the whole subgraph) at <code>absPath</code> as an XML stream and outputs
 it to the supplied <code>OutputStream</code>. The resulting XML is in the
 document view form. Note that <code>absPath</code> must be the path of a
 node, not a property.
 <p>
 If <code>skipBinary</code> is true then any properties of
 <code>PropertyType.BINARY</code> will be serialized as if they are empty.
 That is, the existence of the property will be serialized, but its
 content will not appear in the serialized output (the value of the
 attribute will be empty). If <code>skipBinary</code> is false then the
 actual value(s) of each <code>BINARY</code> property is recorded using
 Base64 encoding.
 <p>
 If <code>noRecurse</code> is true then only the node at
 <code>absPath</code> and its properties, but not its child nodes, are
 serialized. If <code>noRecurse</code> is <code>false</code> then the
 entire subgraph rooted at <code>absPath</code> is serialized.
 <p>
 If the user lacks read access to some subsection of the specified tree,
 that section simply does not get serialized, since, from the user's point
 of view, it is not there.
 <p>
 The serialized output will reflect the state of the current workspace as
 modified by the state of this <code>Session</code>. This means that
 pending changes (regardless of whether they are valid according to node
 type constraints) and all namespace mappings in the namespace registry,
 as modified by the current session-mappings, are reflected in the
 output.
 <p>
 The output XML will be encoded in UTF-8.
 <p>
 It is the responsibility of the caller to close the passed
 <code>OutputStream</code>.

 @param absPath    The path of the root of the subgraph to be serialized.
                   This must be the path to a node, not a property
 @param out        The <code>OutputStream</code> to which the XML serialization
                   of the subgraph will be output.
 @param skipBinary A <code>boolean</code> governing whether binary
                   properties are to be serialized.
 @param noRecurse  A <code>boolean</code> governing whether the subgraph at
                   absPath is to be recursed.
 @throws PathNotFoundException if no node exists at <code>absPath</code>.
 @throws IOException           if an error during an I/O operation occurs.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="setNamespacePrefix"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Within the scope of this <code>Session</code>, this method maps
 <code>uri</code> to <code>prefix</code>. The remapping only affects
 operations done through this <code>Session</code>. To clear all
 remappings, the client must acquire a new <code>Session</code>.
 <p>
 All local mappings already present in the <code>Session</code> that
 include either the specified <code>prefix</code> or the specified
 <code>uri</code> are removed and the new mapping is added.

 @param prefix a string
 @param uri    a string
 @throws NamespaceException  if an attempt is made to map a namespace URI
                             to a prefix beginning with the characters "<code>xml</code>" (in any
                             combination of case) or if an attempt is made to map either the empty
                             prefix or the empty namespace (i.e., if either <code>prefix</code> or
                             <code>uri</code> are the empty string).
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getNamespacePrefixes" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all prefixes currently mapped to URIs in this
 <code>Session</code>.

 @return a string array
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getNamespaceURI" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the URI to which the given <code>prefix</code> is mapped as
 currently set in this <code>Session</code>.

 @param prefix a string
 @return a string
 @throws NamespaceException  if the specified <code>prefix</code> is
                             unknown.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="getNamespacePrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="NamespaceException" type="javax.jcr.NamespaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the prefix to which the given <code>uri</code> is mapped as
 currently set in this <code>Session</code>.

 @param uri a string
 @return a string
 @throws NamespaceException  if the specified <code>uri</code> is unknown.
 @throws RepositoryException if another error occurs]]>
      </doc>
    </method>
    <method name="logout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Releases all resources associated with this <code>Session</code>. This
 method should be called when a <code>Session</code> is no longer needed.]]>
      </doc>
    </method>
    <method name="isLive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Session</code> object is usable
 by the client. Otherwise, returns <code>false</code>. A usable
 <code>Session</code> is one that is neither logged-out, timed-out nor in
 any other way disconnected from the repository.

 @return <code>true</code> if this <code>Session</code> is usable,
         <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="addLockToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link LockManager#addLockToken(String)}
             should be used instead.">
      <param name="lt" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the specified lock token to this <code>Session</code>. Holding a
 lock token makes this <code>Session</code> the owner of the lock
 specified by that particular lock token.

 @param lt a lock token (a string).
 @deprecated As of JCR 2.0, {@link LockManager#addLockToken(String)}
             should be used instead.]]>
      </doc>
    </method>
    <method name="getLockTokens" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link LockManager#getLockTokens()} should be
             used instead.">
      <doc>
      <![CDATA[Returns an array containing all lock tokens currently held by this
 <code>Session</code>. Note that any such tokens will represent
 open-scoped locks, since session-scoped locks do not have tokens.

 @return an array of lock tokens (strings)
 @deprecated As of JCR 2.0, {@link LockManager#getLockTokens()} should be
             used instead.]]>
      </doc>
    </method>
    <method name="removeLockToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link LockManager#removeLockToken(String)}
             should be used instead.">
      <param name="lt" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes the specified lock token from this <code>Session</code>.

 @param lt a lock token (a string)
 @deprecated As of JCR 2.0, {@link LockManager#removeLockToken(String)}
             should be used instead.]]>
      </doc>
    </method>
    <method name="getAccessControlManager" return="javax.jcr.security.AccessControlManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the access control manager for this <code>Session</code>.

 @return the access control manager for this <code>Session</code>
 @throws UnsupportedRepositoryOperationException
                             if access control is not
                             supported.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getRetentionManager" return="javax.jcr.retention.RetentionManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the retention and hold manager for this <code>Session</code>.

 @return the retention manager for this <code>Session</code>.
 @throws UnsupportedRepositoryOperationException
                             if retention and hold are
                             not supported.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <field name="ACTION_READ" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing the <code>read</code> action string, used to
 determine if this <code>Session</code> has permission to retrieve an item
 (and read the value, in the case of a property).

 @see #hasPermission(String, String)
 @see #checkPermission(String, String)
 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="ACTION_ADD_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing the <code>add_node</code> action string, used to
 determine if this <code>Session</code> has permission to add a new node.

 @see #hasPermission(String, String)
 @see #checkPermission(String, String)
 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="ACTION_SET_PROPERTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing the <code>set_property</code> action string, used
 to determine if this <code>Session</code> has permission to set (add or
 modify) a property.

 @see #hasPermission(String, String)
 @see #checkPermission(String, String)
 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="ACTION_REMOVE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing the <code>remove</code> action string, used to
 determine if this <code>Session</code> has permission to remove an item.

 @see #hasPermission(String, String)
 @see #checkPermission(String, String)
 @since JCR 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The <code>Session</code> object provides read and (in level 2) write access
 to the content of a particular workspace in the repository.
 <p>
 The <code>Session</code> object is returned by {@link
 Repository#login(Credentials, String) Repository.login()}. It encapsulates
 both the authorization settings of a particular user (as specified by the
 passed <code>Credentials</code>) and a binding to the workspace specified by
 the <code>workspaceName</code> passed on <code>login</code>.
 <p>
 Each <code>Session</code> object is associated one-to-one with a
 <code>Workspace</code> object. The <code>Workspace</code> object represents a
 "view" of an actual repository workspace entity as seen through the
 authorization settings of its associated <code>Session</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Session -->
  <!-- start class javax.jcr.SimpleCredentials -->
  <class name="SimpleCredentials" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Credentials"/>
    <constructor name="SimpleCredentials" type="java.lang.String, char[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The constructor creates a new <code>SimpleCredentials</code> object,
 given a user ID and password.
 <p>
 Note that the given password is cloned before it is stored in the new
 <code>SimpleCredentials</code> object. This should avoid the risk of
 having unnecessary references to password data lying around in memory.

 @param userID   the user ID
 @param password the user's password]]>
      </doc>
    </constructor>
    <method name="getPassword" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user password.
 <p>
 Note that this method returns a reference to the password. It is the
 caller's responsibility to zero out the password information after it is
 no longer needed.

 @return the password]]>
      </doc>
    </method>
    <method name="getUserID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user ID.

 @return the user ID.]]>
      </doc>
    </method>
    <method name="setAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Stores an attribute in this credentials instance.

 @param name  a <code>String</code> specifying the name of the attribute
 @param value the <code>Object</code> to be stored]]>
      </doc>
    </method>
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the value of the named attribute as an <code>Object</code>, or
 <code>null</code> if no attribute of the given name exists.

 @param name a <code>String</code> specifying the name of the attribute
 @return an <code>Object</code> containing the value of the attribute, or
         <code>null</code> if the attribute does not exist]]>
      </doc>
    </method>
    <method name="removeAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes an attribute from this credentials instance.

 @param name a <code>String</code> specifying the name of the attribute to
             remove]]>
      </doc>
    </method>
    <method name="getAttributeNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the attributes available to this credentials
 instance. This method returns an empty array if the credentials instance
 has no attributes available to it.

 @return a string array containing the names of the stored attributes]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<code>SimpleCredentials</code> implements the <code>Credentials</code>
 interface and represents simple user ID/password credentials.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.SimpleCredentials -->
  <!-- start class javax.jcr.UnsupportedRepositoryOperationException -->
  <class name="UnsupportedRepositoryOperationException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnsupportedRepositoryOperationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="UnsupportedRepositoryOperationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="UnsupportedRepositoryOperationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause.]]>
      </doc>
    </constructor>
    <constructor name="UnsupportedRepositoryOperationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown by methods that are not supported by a particular implementation.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.UnsupportedRepositoryOperationException -->
  <!-- start interface javax.jcr.Value -->
  <interface name="Value"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>String</code> representation of this value.

 @return A <code>String</code> representation of the value of this
         property.
 @throws ValueFormatException  if conversion to a <code>String</code> is
                               not possible.
 @throws IllegalStateException if <code>getStream</code> has previously
                               been called on this <code>Value</code> instance. In this case a new
                               <code>Value</code> instance must be acquired in order to successfully
                               call this method.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #getBinary()} should be used instead.">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>InputStream</code> representation of this value. Uses
 the standard conversion to binary (see JCR specification).
 <p>
 It is the responsibility of the caller to close the returned
 <code>InputStream</code>.

 @return An <code>InputStream</code> representation of this value.
 @throws RepositoryException if an error occurs.
 @deprecated As of JCR 2.0, {@link #getBinary()} should be used instead.]]>
      </doc>
    </method>
    <method name="getBinary" return="javax.jcr.Binary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Binary</code> representation of this value. The {@link
 Binary} object in turn provides methods to access the binary data itself.
 Uses the standard conversion to binary (see JCR specification).

 @return A <code>Binary</code> representation of this value.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>long</code> representation of this value.

 @return A <code>long</code> representation of this value.
 @throws ValueFormatException if conversion to an <code>long</code> is not
                              possible.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>double</code> representation of this value.

 @return A <code>double</code> representation of this value.
 @throws ValueFormatException if conversion to a <code>double</code> is
                              not possible.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getDecimal" return="java.math.BigDecimal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>BigDecimal</code> representation of this value.

 @return A <code>BigDecimal</code> representation of this value.
 @throws ValueFormatException if conversion to a <code>BigDecimal</code>
                              is not possible.
 @throws RepositoryException  if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDate" return="java.util.Calendar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Calendar</code> representation of this value.
 <p>
 The object returned is a copy of the stored value, so changes to it are
 not reflected in internal storage.

 @return A <code>Calendar</code> representation of this value.
 @throws ValueFormatException if conversion to a <code>Calendar</code> is
                              not possible.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Boolean</code> representation of this value.

 @return A <code>Boolean</code> representation of this value.
 @throws ValueFormatException if conversion to a <code>Boolean</code> is
                              not possible.
 @throws RepositoryException  if another error occurs.]]>
      </doc>
    </method>
    <method name="getType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>type</code> of this <code>Value</code>. One of: <ul>
 <li><code>PropertyType.STRING</code></li> <li><code>PropertyType.DATE</code></li>
 <li><code>PropertyType.BINARY</code></li> <li><code>PropertyType.DOUBLE</code></li>
 <li><code>PropertyType.DECIMAL</code></li>
 <li><code>PropertyType.LONG</code></li> <li><code>PropertyType.BOOLEAN</code></li>
 <li><code>PropertyType.NAME</code></li> <li><code>PropertyType.PATH</code></li>
 <li><code>PropertyType.REFERENCE</code></li> <li><code>PropertyType.WEAKREFERENCE</code></li>
 <li><code>PropertyType.URI</code></li></ul> See <code>{@link
 PropertyType}</code>.
 <p>
 The type returned is that which was set at property creation.

 @return an int]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A generic holder for the value of a property. A <code>Value</code> object can
 be used without knowing the actual property type (<code>STRING</code>,
 <code>DOUBLE</code>, <code>BINARY</code> etc.).
 <p>
 The <code>Binary</code> interface and its related methods in
 <code>Property</code>, <code>Value</code> and <code>ValueFactory</code>
 replace the deprecated <code>Value.getStream</code> and
 <code>Property.getStream</code> methods from JCR 1.0. However, though
 <code>getStream</code> has been deprecated, for reasons of backward
 compatibility its behavior must still conform to the following rules: <ul>
 <li> A <code>Value</code> object can be read using type-specific
 <code>get</code> methods. These methods are divided into two groups: <ul>
 <li> The non-stream <code>get</code> methods <code>getString()</code>,
 <code>getBinary()</code>, <code>getDate()</code>, <code>getDecimal()</code>,
 <code>getLong()</code>, <code>getDouble()</code> and
 <code>getBoolean()</code>. </li> <li> <code>getStream()</code>. </li> </ul>
 </li> <li> Once a <code>Value</code> object has been read once using
 <code>getStream()</code>, all subsequent calls to <code>getStream()</code>
 will return the same <code>Stream</code> object. This may mean, for example,
 that the stream returned is fully or partially consumed. In order to get a
 fresh stream the <code>Value</code> object must be reacquired via {@link
 Property#getValue()} or {@link Property#getValues()}. </li> <li> Once a
 <code>Value</code> object has been read once using <code>getStream()</code>,
 any subsequent call to any of the non-stream <code>get</code> methods will
 throw an <code>IllegalStateException</code>. In order to successfully invoke
 a non-stream <code>get</code> method, the <code>Value</code> must be
 reacquired via {@link Property#getValue()} or {@link Property#getValues()}.
 </li> <li> Once a <code>Value</code> object has been read once using a
 non-stream get method, any subsequent call to <code>getStream()</code> will
 throw an <code>IllegalStateException</code>. In order to successfully invoke
 <code>getStream()</code>, the <code>Value</code> must be reacquired via
 {@link Property#getValue()} or {@link Property#getValues()}. </ul>
 <p>
 Two <code>Value</code> instances, <code>v1</code> and <code>v2</code>, are
 considered equal if and only if: <ul> <li><code>v1.getType() ==
 v2.getType()</code>, and,</li> <li><code>v1.getString().equals(v2.getString())</code></li>
 </ul> Actually comparing two <code>Value</code> instances by converting them
 to string form may not be practical in some cases (for example, if the values
 are very large binaries). Consequently, the above is intended as a normative
 definition of <code>Value</code> equality but not as a procedural test of
 equality. It is assumed that implementations will have efficient means of
 determining equality that conform with the above definition.
 <p>
 An implementation is only required to support equality comparisons on
 <code>Value</code> instances that were acquired from the same
 <code>Session</code> and whose contents have not been read. The equality
 comparison must not change the state of the <code>Value</code> instances even
 though the <code>getString()</code> method in the above definition implies a
 state change.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Value -->
  <!-- start interface javax.jcr.ValueFactory -->
  <interface name="ValueFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#STRING} with
 the specified <code>value</code>.

 @param value a <code>String</code>
 @return a <code>Value</code> of {@link PropertyType#STRING}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="type" type="int"/>
      <exception name="ValueFormatException" type="javax.jcr.ValueFormatException"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of the {@link PropertyType} specified
 by <code>type</code> with the specified <code>value</code>.

 @param value a <code>String</code>
 @param type  one of the constants defined in {@link PropertyType}.
 @return a <code>Value</code> of {@link PropertyType} <code>type</code>.
 @throws ValueFormatException if the specified <code>value</code> cannot
                              be converted to the specified <code>type</code>.]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#LONG} with the
 specified <code>value</code>.

 @param value a <code>long</code>
 @return a <code>Value</code> of {@link PropertyType#LONG}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#DOUBLE} with
 the specified <code>value</code>.

 @param value a <code>double</code>
 @return a <code>Value</code> of {@link PropertyType#DOUBLE}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.math.BigDecimal"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#DECIMAL} with
 the specified <code>value</code>.

 @param value a <code>double</code>
 @return a <code>Value</code> of {@link PropertyType#DECIMAL}
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#BOOLEAN} with
 the specified <code>value</code>.

 @param value a <code>boolean</code>
 @return a <code>Value</code> of {@link PropertyType#BOOLEAN}]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.Calendar"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#DATE} with the
 specified <code>value</code>.

 @param value a <code>Calendar</code>
 @return a <code>Value</code> of {@link PropertyType#DATE}
 @throws IllegalArgumentException if the specified <code>value</code>
                                  cannot be expressed in the ISO 8601-based format defined in the JCR 2.0
                                  specification and the implementation does not support dates incompatible
                                  with that format.]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #createValue(Binary)} should be used
             instead.">
      <param name="value" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of <code>PropertyType.BINARY</code>
 with a value consisting of the content of the specified
 <code>InputStream</code>.
 <p>
 The passed <code>InputStream</code> is closed before this method returns
 either normally or because of an exception.

 @param value an <code>InputStream</code>
 @return a <code>Value</code> of {@link PropertyType#BINARY}
 @deprecated As of JCR 2.0, {@link #createValue(Binary)} should be used
             instead.]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Binary"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of <code>PropertyType.BINARY</code>
 with a value consisting of the content of the specified
 <code>Binary</code>.

 @param value a <code>Binary</code>
 @return a <code>Value</code> of {@link PropertyType#BINARY}
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Node"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#REFERENCE}
 that holds the identifier of the specified <code>Node</code>. This
 <code>Value</code> object can then be used to set a property that will be
 a reference to that <code>Node</code>.

 @param value a <code>Node</code>
 @return a <code>Value</code> of {@link PropertyType#REFERENCE}
 @throws RepositoryException if the specified <code>Node</code> is not
                             referenceable, the current <code>Session</code> is no longer active, or
                             another error occurs.]]>
      </doc>
    </method>
    <method name="createValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="javax.jcr.Node"/>
      <param name="weak" type="boolean"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Value</code> object of {@link PropertyType#REFERENCE} (if
 <code>weak</code> is <code>false</code>) or {@link
 PropertyType#REFERENCE} (if <code>weak</code> is <code>true</code>) that
 holds the identifier of the specified <code>Node</code>. This
 <code>Value</code> object can then be used to set a property that will be
 a reference to that <code>Node</code>.

 @param value a <code>Node</code>
 @param weak  a <code>boolean</code>. If true then a {@link
              PropertyType#WEAKREFERENCE} is created, otherwise a {@link
              PropertyType#REFERENCE} is created.
 @return a <code>Value</code> of {@link PropertyType#REFERENCE} or {@link
         PropertyType#REFERENCE}
 @throws RepositoryException if the specified <code>Node</code> is not
                             referenceable, the current <code>Session</code> is no longer active, or
                             another error occurs.]]>
      </doc>
    </method>
    <method name="createBinary" return="javax.jcr.Binary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.InputStream"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>Binary</code> object with a value consisting of the
 content of the specified <code>InputStream</code>.
 <p>
 The passed <code>InputStream</code> is closed before this method returns
 either normally or because of an exception.

 @param stream an <code>InputStream</code>
 @return a <code>Binary</code>
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>ValueFactory</code> object provides methods for the creation Value
 objects that can then be used to set properties.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.ValueFactory -->
  <!-- start class javax.jcr.ValueFormatException -->
  <class name="ValueFormatException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ValueFormatException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ValueFormatException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ValueFormatException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ValueFormatException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when an attempt is made to assign a value to a property that
 has an invalid format, given the type of the property. Also thrown if an
 attempt is made to read the value of a property using a type-specific read
 method of a type into which it is not convertible.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.ValueFormatException -->
  <!-- start interface javax.jcr.Workspace -->
  <interface name="Workspace"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSession" return="javax.jcr.Session"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <code>Session</code> object through which this
 <code>Workspace</code> object was acquired.

 @return a <code>{@link Session}</code> object.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the actual persistent workspace represented by this
 <code>Workspace</code> object. This the name used in
 <code>Repository.login</code>.

 @return the name of this workspace.]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method copies the subgraph rooted at, and including, the node at
 <code>srcAbsPath</code> to the new location at <code>destAbsPath</code>.
 <p>
 This is a workspace-write operation and therefore dispatches changes
 immediately and does not require a <code>save</code>.
 <p>
 When a node <code>N</code> is copied to a path location where no node
 currently exists, a new node <code>N'</code> is created at that location.
 The subgraph rooted at and including <code>N'</code> (call it <code>S'</code>)
 is created and is identical to the subgraph rooted at and including <code>N</code>
 (call it <code>S</code>) with the following exceptions:
 <ul>
 <li>Every node in <code>S'</code> is given a new and distinct identifier.</li>
 <li>The repository <i>may</i> automatically drop any mixin node type <code>T</code>
 present on any node <code>M</code> in <code>S</code>. Dropping a mixin node type
 in this context means that while <code>M</code> remains unchanged, its copy
 <code>M'</code> will lack the mixin <code>T</code> and any child nodes and properties
 defined by <code>T</code> that are present on <code>M</code>. For example, a node
 <code>M</code> that is <code>mix:versionable</code> may be copied such that the
 resulting node <code>M'</code> will be a copy of <code>N</code> except that
 <code>M'</code> will not be <code>mix:versionable</code> and will not have any of the
 properties defined by <code>mix:versionable</code>. In order for a mixin node type to
 be dropped it must be listed by name in the <code>jcr:mixinTypes</code> property of
 <code>M</code>. The resulting <code>jcr:mixinTypes</code> property of <code>M'</code>
 will reflect any change.</li>
 <li>If a node <code>M</code> in <code>S</code> is referenceable and its
 <code>mix:referenceable</code> mixin is not dropped on copy, then the resulting
 <code>jcr:uuid</code> property of <code>M'</code> will reflect the new identifier
 assigned to <code>M'<code>.</li>
 <li>Each <code>REFERENCE</code> or <code>WEAKEREFERENCE</code> property <code>R</code>
 in <code>S</code> is copied to its new location <code>R'</code> in <code>S'</code>.
 If <code>R</code> references a node <code>M</code> within <code>S</code> then the value
 of <code>R'</code> will be the identifier of <code>M'</code>, the new copy of
 <code>M</code>, thus preserving the reference within the subgraph.</li>
 </ul>
 When a node <code>N</code> is copied to a location where a node <code>N'</code> already
 exists, the repository may either immediately throw an <code>ItemExistsException</code>
 or attempt to update the node <code>N'</code> by selectively replacing part of its subgraph
 with a copy of the relevant part of the subgraph of <code>N</code>. If the node types of
 <code>N</code> and <code>N'</code> are compatible, the implementation supports update-on-copy
 for these node types and no other errors occur, then the copy will succeed. Otherwise an
 <code>ItemExistsException</code> is thrown.
 <p>
 Which node types can be updated on copy and the details of any such updates are
 implementation-dependent. For example, some implementations may support update-on-copy
 for <code>mix:versionable</code> nodes. In such a case the versioning-related properties
 of the target node would remain unchanged (<code>jcr:uuid</code>,
 <code>jcr:versionHistory</code>, etc.) while the substantive content part of the subgraph
 would be replaced with that of the source node.
 <p>
 The <code>destAbsPath</code> provided must not have an index on its final
 element. If it does then a <code>RepositoryException</code> is thrown.
 Strictly speaking, the <code>destAbsPath</code> parameter is actually an
 <i>absolute path</i> to the parent node of the new location, appended
 with the new <i>name</i> desired for the copied node. It does not specify
 a position within the child node ordering. If ordering is supported by
 the node type of the parent node of the new location, then the new copy
 of the node is appended to the end of the child node list.
 <p>
 This method cannot be used to copy an individual property by itself. It
 copies an entire node and its subgraph.

 @param srcAbsPath  the path of the node to be copied.
 @param destAbsPath the location to which the node at
                    <code>srcAbsPath</code> is to be copied.
 @throws ConstraintViolationException if the operation would violate a
                                      node-type or other implementation-specific constraint.
 @throws VersionException             if the parent node of <code>destAbsPath</code>
                                      is read-only due to a checked-in node.
 @throws AccessDeniedException        if the current session does not have
                                      sufficent access to complete the operation.
 @throws PathNotFoundException        if the node at <code>srcAbsPath</code> or
                                      the parent of <code>destAbsPath</code> does not exist.
 @throws ItemExistsException          if a node already exists at
                                      <code>destAbsPath</code> and either same-name siblings are not allowed or
                                      update on copy is not supported for the nodes involved.
 @throws LockException                if a lock prevents the copy.
 @throws RepositoryException          if the last element of
                                      <code>destAbsPath</code> has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method copies the subgraph at <code>srcAbsPath</code> in
 <code>srcWorkspace</code> to <code>destAbsPath</code> in
 <code>this</code> workspace.
 <p>
 When a node <code>N</code> is copied to a path location where no node
 currently exists, a new node <code>N'</code> is created at that location.
 The subgraph rooted at and including <code>N'</code> (call it <code>S'</code>)
 is created and is identical to the subgraph rooted at and including <code>N</code>
 (call it <code>S</code>) with the following exceptions:
 <ul>
 <li>Every referenceable node in <code>S'</code> is given a new and distinct identifier
 while every non-referenceable node in <code>S'</code> <i>may</i> be given a new and
 distinct identifier.</li>
 <li>The repository <i>may</i> automatically drop any mixin node type <code>T</code>
 present on any node <code>M</code> in <code>S</code>. Dropping a mixin node type
 in this context means that while <code>M</code> remains unchanged, its copy
 <code>M'</code> will lack the mixin <code>T</code> and any child nodes and properties
 defined by <code>T</code> that are present on <code>M</code>. For example, a node
 <code>M</code> that is <code>mix:versionable</code> may be copied such that the
 resulting node <code>M'</code> will be a copy of <code>N</code> except that
 <code>M'</code> will not be <code>mix:versionable</code> and will not have any of the
 properties defined by <code>mix:versionable</code>. In order for a mixin node type to
 be dropped it must be listed by name in the <code>jcr:mixinTypes</code> property of
 <code>M</code>. The resulting <code>jcr:mixinTypes</code> property of <code>M'</code>
 will reflect any change.</li>
 <li>If a node <code>M</code> in <code>S</code> is referenceable and its
 <code>mix:referenceable</code> mixin is not dropped on copy, then the resulting
 <code>jcr:uuid</code> property of <code>M'</code> will reflect the new identifier
 assigned to <code>M'<code>.</li>
 <li>Each <code>REFERENCE</code> or <code>WEAKEREFERENCE</code> property <code>R</code>
 in <code>S</code> is copied to its new location <code>R'</code> in <code>S'</code>.
 If <code>R</code> references a node <code>M</code> within <code>S</code> then the value
 of <code>R'</code> will be the identifier of <code>M'</code>, the new copy of
 <code>M</code>, thus preserving the reference within the subgraph.</li>
 </ul>
 When a node <code>N</code> is copied to a location where a node <code>N'</code> already
 exists, the repository may either immediately throw an <code>ItemExistsException</code>
 or attempt to update the node <code>N'</code> by selectively replacing part of its subgraph
 with a copy of the relevant part of the subgraph of <code>N</code>. If the node types of
 <code>N</code> and <code>N'</code> are compatible, the implementation supports update-on-copy
 for these node types and no other errors occur, then the copy will succeed. Otherwise an
 <code>ItemExistsException</code> is thrown.
 <p>
 Which node types can be updated on copy and the details of any such updates are
 implementation-dependent. For example, some implementations may support update-on-copy
 for <code>mix:versionable</code> nodes. In such a case the versioning-related properties
 of the target node would remain unchanged (<code>jcr:uuid</code>,
 <code>jcr:versionHistory</code>, etc.) while the substantive content part of the subgraph
 would be replaced with that of the source node.
 <p>
 The <code>destAbsPath</code> provided must not have an index on its final
 element. If it does then a <code>RepositoryException</code> is thrown.
 Strictly speaking, the <code>destAbsPath</code> parameter is actually an
 <i>absolute path</i> to the parent node of the new location, appended
 with the new <i>name</i> desired for the copied node. It does not specify
 a position within the child node ordering. If ordering is supported by
 the node type of the parent node of the new location, then the new copy
 of the node is appended to the end of the child node list.
 <p>
 This method cannot be used to copy just an individual property by itself.
 It copies an entire node and its subgraph (including, of course, any
 properties contained therein).

 @param srcWorkspace the name of the workspace from which the copy is to
                     be made.
 @param srcAbsPath   the path of the node to be copied.
 @param destAbsPath  the location to which the node at
                     <code>srcAbsPath</code> is to be copied in <code>this</code> workspace.
 @throws NoSuchWorkspaceException     if <code>srcWorkspace</code> does not
                                      exist or if the current <code>Session</code> does not have permission to
                                      access it.
 @throws ConstraintViolationException if the operation would violate a
                                      node-type or other implementation-specific constraint
 @throws VersionException             if the parent node of <code>destAbsPath</code>
                                      is read-only due to a checked-in node.
 @throws AccessDeniedException        if the current session does have access to
                                      <code>srcWorkspace</code> but otherwise does not have sufficient access
                                      to complete the operation.
 @throws PathNotFoundException        if the node at <code>srcAbsPath</code> in
                                      <code>srcWorkspace</code> or the parent of <code>destAbsPath</code> in
                                      this workspace does not exist.
 @throws ItemExistsException          if a node already exists at
                                      <code>destAbsPath</code> and either same-name siblings are not allowed or
                                      update on copy is not supported for the nodes involved.
 @throws LockException                if a lock prevents the copy.
 @throws RepositoryException          if the last element of
                                      <code>destAbsPath</code> has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="clone"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Clones the subgraph at the node <code>srcAbsPath</code> in
 <code>srcWorkspace</code> to the new location at <code>destAbsPath</code>
 in <code>this</code> workspace.
 <p>
 Unlike the signature of <code>copy</code> that copies between workspaces,
 this method <i>does not</i> assign new identifiers to the newly cloned
 nodes but preserves the identifiers of their respective source nodes.
 This applies to both referenceable and non-referenceable nodes.
 <p>
 In some implementations there may be cases where preservation of a
 non-referenceable identifier is not possible, due to how
 non-referenceable identifiers are constructed in that implementation. In
 such a case this method will throw a <code>RepositoryException</code>.
 <p>
 If <code>removeExisting</code> is true and an existing node in this
 workspace (the destination workspace) has the same identifier as a node
 being cloned from <code>srcWorkspace</code>, then the incoming node takes
 precedence, and the existing node (and its subgraph) is removed. If
 <code>removeExisting</code> is false then an identifier collision causes
 this method to throw a <code>ItemExistsException</code> and no changes
 are made.
 <p>
 If successful, the change is persisted immediately, there is no need to
 call <code>save</code>.
 <p>
 The <code>destAbsPath</code> provided must not have an index on its final
 element. If it does then a <code>RepositoryException</code> is thrown. If
 ordering is supported by the node type of the parent node of the new
 location, then the new clone of the node is appended to the end of the
 child node list.
 <p>
 This method cannot be used to clone just an individual property; it
 clones an node and its subgraph.

 @param srcWorkspace   The name of the workspace from which the node is to
                       be copied.
 @param srcAbsPath     the path of the node to be copied in
                       <code>srcWorkspace</code>.
 @param destAbsPath    the location to which the node at
                       <code>srcAbsPath</code> is to be copied in <code>this</code> workspace.
 @param removeExisting if <code>false</code> then this method throws an
                       <code>ItemExistsException</code> on identifier conflict with an incoming
                       node. If <code>true</code> then a identifier conflict is resolved by
                       removing the existing node from its location in this workspace and
                       cloning (copying in) the one from <code>srcWorkspace</code>.
 @throws NoSuchWorkspaceException     if <code>destWorkspace</code> does not
                                      exist.
 @throws ConstraintViolationException if the operation would violate a
                                      node-type or other implementation-specific constraint.
 @throws VersionException             if the parent node of <code>destAbsPath</code>
                                      is read-only due to a checked-in node. This exception will also be thrown
                                      if <code>removeExisting</code> is <code>true</code>, and an identifier
                                      conflict occurs that would require the moving and/or altering of a node
                                      that is checked-in.
 @throws AccessDeniedException        if the current session does not have
                                      sufficient access to complete the operation.
 @throws PathNotFoundException        if the node at <code>srcAbsPath</code> in
                                      <code>srcWorkspace</code> or the parent of <code>destAbsPath</code> in
                                      this workspace does not exist.
 @throws ItemExistsException          if a node already exists at
                                      <code>destAbsPath</code> and same-name siblings are not allowed or if
                                      <code>removeExisting</code> is <code>false</code> and an identifier
                                      conflict occurs.
 @throws LockException                if a lock prevents the clone.
 @throws RepositoryException          if the last element of
                                      <code>destAbsPath</code> has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcAbsPath" type="java.lang.String"/>
      <param name="destAbsPath" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Moves the node at <code>srcAbsPath</code> (and its entire subgraph) to
 the new location at <code>destAbsPath</code>.
 <p>
 If successful, the change is persisted immediately, there is no need to
 call <code>save</code>. Note that this is in contrast to {@link
 Session#move} which operates within the transient space and hence
 requires a <code>save</code>.
 <p>
 The identifiers of referenceable nodes must not be changed by a
 <code>move</code>. The identifiers of non-referenceable nodes <i>may</i>
 change.
 <p>
 The <code>destAbsPath</code> provided must not have an index on its final
 element. If it does then a <code>RepositoryException</code> is thrown.
 Strictly speaking, the <code>destAbsPath</code> parameter is actually an
 <i>absolute path</i> to the parent node of the new location, appended
 with the new <i>name</i> desired for the moved node. It does not specify
 a position within the child node ordering. If ordering is supported by
 the node type of the parent node of the new location, then the newly
 moved node is appended to the end of the child node list.
 <p>
 This method cannot be used to move just an individual property by itself.
 It moves an entire node and its subgraph (including, of course, any
 properties contained therein).
 <p>
 The identifiers of referenceable nodes must not be changed by a
 <code>move</code>. The identifiers of non-referenceable nodes may
 change.
 <p>
 A <code>ConstraintViolationException</code> is thrown if the operation
 would violate a node-type or other implementation-specific constraint.
 <p>
 A <code>VersionException</code> is thrown if the parent node of
 <code>destAbsPath</code> or the parent node of <code>srcAbsPath</code> is
 versionable and checked-in, or is non-versionable but its nearest
 versionable ancestor is checked-in.
 <p>
 An <code>AccessDeniedException</code> is thrown if the current session
 (i.e. the session that was used to acquire this <code>Workspace</code>
 object) does not have sufficient access rights to complete the
 operation.
 <p>
 A <code>PathNotFoundException</code> is thrown if the node at
 <code>srcAbsPath</code> or the parent of <code>destAbsPath</code> does
 not exist.
 <p>
 An <code>ItemExistException</code> is thrown if a node already exists at
 <code>destAbsPath</code> and same-name siblings are not allowed.
 <p>
 Note that if a property already exists at <code>destAbsPath</code>, the
 operation succeeds, since a node may have a child node and property with
 the same name
 <p>
 A <code>LockException</code> if a lock prevents the move.

 @param srcAbsPath  the path of the node to be moved.
 @param destAbsPath the location to which the node at
                    <code>srcAbsPath</code> is to be moved.
 @throws ConstraintViolationException if the operation would violate a
                                      node-type or other implementation-specific constraint
 @throws VersionException             if the parent node of <code>destAbsPath</code>
                                      is read-only due to a checked-in node.
 @throws AccessDeniedException        if the current session does not have
                                      sufficient access to complete the operation.
 @throws PathNotFoundException        if the node at <code>srcAbsPath</code> or
                                      the parent of <code>destAbsPath</code> does not exist.
 @throws ItemExistsException          if a node already exists at
                                      <code>destAbsPath</code> and same-name siblings are not allowed.
 @throws LockException                if a lock prevents the move.
 @throws RepositoryException          if the last element of
                                      <code>destAbsPath</code> has an index or if another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.">
      <param name="versions" type="javax.jcr.version.Version[]"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores a set of versions at once. Used in cases where a "chicken and
 egg" problem of mutually referring <code>REFERENCE</code> properties
 would prevent the restore in any serial order.
 <p>
 If the restore succeeds the changes made to <code>this</code> node are
 persisted immediately, there is no need to call <code>save</code>.
 <p>
 The following restrictions apply to the set of versions specified:
 <p>
 If <code>S</code> is the set of versions being restored simultaneously,
 <ul> <li> For every version <code>V</code> in <code>S</code> that
 corresponds to a <i>missing</i> node, there must also be a parent of V in
 S. </li> <li> <code>S</code> must contain at least one version that
 corresponds to an existing node in the workspace. </li> <li> No
 <code>V</code> in <code>S</code> can be a root version
 (<code>jcr:rootVersion</code>). </li> </ul> If any of these restrictions
 does not hold, the restore will fail because the system will be unable to
 determine the path locations to which one or more versions are to be
 restored. In this case a <code>VersionException</code> is thrown.
 <p>
 The versionable nodes in this workspace that correspond to the versions
 being restored define a set of (one or more) subgraphs. An identifier
 collision occurs when this workspace contains a node <i>outside these
 subgraphs</i> that has the same identifier as one of the nodes that would
 be introduced by the <code>restore</code> operation <i>into one of these
 subgraphs</i>. The result in such a case is governed by the
 <code>removeExisting</code> flag. If <code>removeExisting</code> is
 <code>true</code> then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed. If <code>removeExisting</code>
 is <code>false</code> then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.

 @param versions       The set of versions to be restored
 @param removeExisting governs what happens on identifier collision.
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs with a node being
                                   restored.
 @throws UnsupportedRepositoryOperationException
                                   if one or more of the
                                   nodes to be restored is not versionable.
 @throws VersionException          if the set of versions to be restored is such
                                   that the original path location of one or more of the versions cannot be
                                   determined or if the <code>restore</code> would change the state of a
                                   existing versionable node that is currently checked-in or if a root
                                   version (<code>jcr:rootVersion</code>) is among those being restored.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> has
                                   pending unsaved changes.
 @throws RepositoryException       if another error occurs.
 @deprecated As of JCR 2.0, {@link javax.jcr.version.VersionManager#restore}
             should be used instead.]]>
      </doc>
    </method>
    <method name="getLockManager" return="javax.jcr.lock.LockManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>LockManager</code> object, through which locking
 methods are accessed.

 @return the <code>LockManager</code> object.
 @throws UnsupportedRepositoryOperationException
                             if the implementation
                             does not support locking.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getQueryManager" return="javax.jcr.query.QueryManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>QueryManager</code> object, through search methods are
 accessed.

 @return the <code>QueryManager</code> object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getNamespaceRegistry" return="javax.jcr.NamespaceRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>NamespaceRegistry</code> object, which is used to
 access the mapping between prefixes and namespaces. In level 2
 repositories the <code>NamespaceRegistry</code> can also be used to
 change the namespace mappings.

 @return the <code>NamespaceRegistry</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getNodeTypeManager" return="javax.jcr.nodetype.NodeTypeManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>NodeTypeManager</code> through which node type
 information can be queried. There is one node type registry per
 repository, therefore the <code>NodeTypeManager</code> is not
 workspace-specific; it provides introspection methods for the global,
 repository-wide set of available node types. In repositories that support
 it, the <code>NodeTypeManager</code> can also be used to register new
 node types.

 @return a <code>NodeTypeManager</code> object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getObservationManager" return="javax.jcr.observation.ObservationManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>ObservationManager</code> object.

 @return an <code>ObservationManager</code> object.
 @throws UnsupportedRepositoryOperationException
                             if the implementation
                             does not support observation.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getVersionManager" return="javax.jcr.version.VersionManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>VersionManager</code> object.

 @return an <code>VersionManager</code> object.
 @throws UnsupportedRepositoryOperationException
                             if the implementation
                             does not support versioning.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getAccessibleWorkspaceNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a string array containing the names of all workspaces in this
 repository that are accessible to this user, given the
 <code>Credentials</code> that were used to get the <code>Session</code>
 to which this <code>Workspace</code> is tied.
 <p>
 In order to access one of the listed workspaces, the user performs
 another {@link Repository#login}, specifying the name of the desired
 workspace, and receives a new <code>Session</code> object.

 @return string array of names of accessible workspaces.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getImportContentHandler" return="org.xml.sax.ContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an <code>org.xml.sax.ContentHandler</code> which can be used to
 push SAX events into the repository. If the incoming XML stream (in the
 form of SAX events) does not appear to be a JCR system view XML document
 then it is interpreted as a document view XML document.
 <p>
 The incoming XML is deserialized into a subgraph of items immediately
 below the node at <code>parentAbsPath</code>.
 <p>
 This method simply returns the <code>ContentHandler</code> without
 altering the state of the repository; the actual deserialization is done
 through the methods of the <code>ContentHandler</code>. Invalid XML data
 will cause the <code>ContentHandler</code> to throw a
 <code>SAXException</code>.
 <p>
 As SAX events are fed into the <code>ContentHandler</code>, changes are
 made directly at the workspace level, without going through the
 <code>Session</code>. As a result, there is not need to call
 <code>save</code>. The advantage of this direct-to-workspace method is
 that a large import will not result in a large cache of pending nodes in
 the <code>Session</code>. The disadvantage is that structures that
 violate node type constraints cannot be imported, fixed and then saved.
 Instead, a constraint violation will cause the <code>ContentHandler</code>
 to throw a <code>SAXException</code>. See <code>Session.getImportContentHandler</code>
 for a version of this method that <i>does</i> go through the
 <code>Session</code>.
 <p>
 The flag <code>uuidBehavior</code> governs how the identifiers of
 incoming (deserialized) nodes are handled. There are four options: <ul>
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}: Incoming nodes are
 assigned newly created identifiers upon addition to the workspace. As a
 result identifier collisions never occur. <li>{@link
 ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}: If an incoming
 node has the same identifier as a node already existing in the workspace,
 then the already existing node (and its subgraph) is removed from
 wherever it may be in the workspace before the incoming node is added.
 Note that this can result in nodes "disappearing" from locations in the
 workspace that are remote from the location to which the incoming
 subgraph is being written. <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}:
 If an incoming node has the same identifier as a node already existing in
 the workspace then the already existing node is replaced by the incoming
 node in the same position as the existing node. Note that this may result
 in the incoming subgraph being disaggregated and "spread around" to
 different locations in the workspace. In the most extreme case this
 behavior may result in no node at all being added as child of
 <code>parentAbsPath</code>. This will occur if the topmost element of the
 incoming XML has the same identifier as an existing node elsewhere in the
 workspace. <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If
 an incoming node has the same identifier as a node already existing in
 the workspace then a <code>SAXException</code> is thrown by the returned
 <code>ContentHandler</code> during deserialization. </ul> A
 <code>SAXException</code> will be thrown by the returned
 <code>ContentHandler</code> during deserialization if the top-most
 element of the incoming XML would deserialize to a node with the same
 name as an existing child of <code>parentAbsPath</code> and that child
 does not allow same-name siblings.
 <p>
 A <code>SAXException</code> will also be thrown by the returned
 <code>ContentHandler</code> during deserialization if
 <code>uuidBehavior</code> is set to <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code>
 and an incoming node has the same identifier as the node at
 <code>parentAbsPath</code> or one of its ancestors.

 @param parentAbsPath the absolute path of a node under which (as child)
                      the imported subgraph will be built.
 @param uuidBehavior  a four-value flag that governs how incoming
                      identifiers are handled.
 @return an org.xml.sax.ContentHandler whose methods may be called to feed
         SAX events into the deserializer.
 @throws PathNotFoundException        if no node exists at
                                      <code>parentAbsPath</code>.
 @throws ConstraintViolationException if the new subgraph cannot be added
                                      to the node at <code>parentAbsPath</code> due to node-type or other
                                      implementation-specific constraints, and this can be determined before
                                      the first SAX event is sent. Unlike {@link Session#getImportContentHandler},
                                      this method also enforces node type constraints by throwing
                                      <code>SAXException</code>s during deserialization. However, which node
                                      type constraints are enforced depends upon whether node type information
                                      in the imported data is respected, and this is an implementation-specific
                                      issue.
 @throws VersionException             if the node at <code>parentAbsPath</code> is
                                      read-only due to a checked-in node.
 @throws LockException                if a lock prevents the addition of the subgraph.
 @throws AccessDeniedException        if the session associated with this
                                      <code>Workspace</code> object does not have sufficient access to perform
                                      the import.
 @throws RepositoryException          if another error occurs.]]>
      </doc>
    </method>
    <method name="importXML"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentAbsPath" type="java.lang.String"/>
      <param name="in" type="java.io.InputStream"/>
      <param name="uuidBehavior" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="InvalidSerializedDataException" type="javax.jcr.InvalidSerializedDataException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Deserializes an XML document and adds the resulting item subgraph as a
 child of the node at <code>parentAbsPath</code>.
 <p>
 If the incoming XML stream does not appear to be a JCR system view XML
 document then it is interpreted as a <b>document view</b> XML document.
 <p>
 The passed <code>InputStream</code> is closed before this method returns
 either normally or because of an exception.
 <p>
 Changes are made directly at the workspace level, without going through
 the <code>Session</code>. As a result, there is not need to call
 <code>save</code>. The advantage of this direct-to-workspace method is
 that a large import will not result in a large cache of pending nodes in
 the <code>Session</code>. The disadvantage is that invalid data cannot be
 imported, fixed and then saved. Instead, invalid data will cause this
 method to throw an <code>InvalidSerializedDataException</code>. See
 <code>Session.importXML</code> for a version of this method that
 <i>does</i> go through the <code>Session</code>.
 <p>
 The flag <code>uuidBehavior</code> governs how the identifiers of
 incoming (deserialized) nodes are handled. There are four options: <ul>
 <li>{@link ImportUUIDBehavior#IMPORT_UUID_CREATE_NEW}: Incoming nodes are
 assigned newly created identifiers upon addition to the workspace. As a
 result identifier collisions never occur. <li>{@link
 ImportUUIDBehavior#IMPORT_UUID_COLLISION_REMOVE_EXISTING}: If an incoming
 node has the same identifier as a node already existing in the workspace
 then the already existing node (and its subgraph) is removed from
 wherever it may be in the workspace before the incoming node is added.
 Note that this can result in nodes "disappearing" from locations in the
 workspace that are remote from the location to which the incoming
 subgraph is being written. If an incoming node has the same identifier as
 the existing root node of this workspace then <li>{@link
 ImportUUIDBehavior#IMPORT_UUID_COLLISION_REPLACE_EXISTING}: If an
 incoming node has the same identifier as a node already existing in the
 workspace then the already existing node is replaced by the incoming node
 in the same position as the existing node. Note that this may result in
 the incoming subgraph being disaggregated and "spread around" to
 different locations in the workspace. In the most extreme edge case this
 behavior may result in no node at all being added as child of
 <code>parentAbsPath</code>. This will occur if the topmost element of the
 incoming XML has the same identifier as an existing node elsewhere in the
 workspace. <li>{@link ImportUUIDBehavior#IMPORT_UUID_COLLISION_THROW}: If
 an incoming node has the same identifier as a node already existing in
 the workspace then an <code>ItemExistsException</code> is thrown. </ul>
 An <code>ItemExistsException</code> will be thrown if the top-most
 element of the incoming XML would deserialize to a node with the same
 name as an existing child of <code>parentAbsPath</code> and that child
 does not allow same-name siblings.

 @param parentAbsPath the absolute path of the node below which the
                      deserialized subgraph is added.
 @param in            The <code>Inputstream</code> from which the XML to be
                      deserialized is read.
 @param uuidBehavior  a four-value flag that governs how incoming
                      identifiers are handled.
 @throws java.io.IOException            if an error during an I/O operation occurs.
 @throws PathNotFoundException          if no node exists at
                                        <code>parentAbsPath</code>.
 @throws ConstraintViolationException   if node-type or other
                                        implementation-specific constraints prevent the addition of the subgraph
                                        or if <code>uuidBehavior</code> is set to <code>IMPORT_UUID_COLLISION_REMOVE_EXISTING</code>
                                        and an incoming node has the same identifier as the node at
                                        <code>parentAbsPath</code> or one of its ancestors.
 @throws VersionException               if the node at <code>parentAbsPath</code> is
                                        read-only due to a checked-in node..
 @throws InvalidSerializedDataException if incoming stream is not a valid
                                        XML document.
 @throws ItemExistsException            if the top-most element of the incoming XML
                                        would deserialize to a node with the same name as an existing child of
                                        <code>parentAbsPath</code> and that child does not allow same-name
                                        siblings, or if a <code>uuidBehavior</code> is set to
                                        <code>IMPORT_UUID_COLLISION_THROW</code> and an identifier collision
                                        occurs.
 @throws LockException                  if a lock prevents the addition of the subgraph.
 @throws AccessDeniedException          if the session associated with this
                                        <code>Workspace</code> object does not have sufficient access to perform
                                        the import.
 @throws RepositoryException            if another error occurs.]]>
      </doc>
    </method>
    <method name="createWorkspace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new <code>Workspace</code> with the specified
 <code>name</code>. The new workspace is empty, meaning it contains only
 root node.
 <p>
 The new workspace can be accessed through a <code>login</code> specifying
 its name.

 @param name A <code>String</code>, the name of the new workspace.
 @throws AccessDeniedException if the session through which this
                               <code>Workspace</code> object was acquired does not have permission to
                               create the new workspace.
 @throws UnsupportedRepositoryOperationException
                               if the repository does
                               not support the creation of workspaces.
 @throws RepositoryException   if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="createWorkspace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="srcWorkspace" type="java.lang.String"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new <code>Workspace</code> with the specified <code>name</code>
 initialized with a <code>clone</code> of the content of the workspace
 <code>srcWorkspace</code>. Semantically, this method is equivalent to
 creating a new workspace and manually cloning <code>srcWorkspace</code>
 to it; however, this method may assist some implementations in optimizing
 subsequent <code>Node.update</code> and <code>Node.merge</code> calls
 between the new workspace and its source.
 <p>
 The new workspace can be accessed through a <code>login</code> specifying
 its name.

 @param name         A <code>String</code>, the name of the new workspace.
 @param srcWorkspace The name of the workspace from which the new
                     workspace is to be cloned.
 @throws AccessDeniedException    if the session through which this
                                  <code>Workspace</code> object was acquired does not have sufficient
                                  access to create the new workspace.
 @throws UnsupportedRepositoryOperationException
                                  if the repository does
                                  not support the creation of workspaces.
 @throws NoSuchWorkspaceException is <code>srcWorkspace</code> does not
                                  exist.
 @throws RepositoryException      if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="deleteWorkspace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Deletes the workspace with the specified <code>name</code> from the
 repository, deleting all content within it.

 @param name A <code>String</code>, the name of the workspace to be
             deleted.
 @throws AccessDeniedException    if the session through which this
                                  <code>Workspace</code> object was acquired does not have sufficent access
                                  to remove the workspace.
 @throws UnsupportedRepositoryOperationException
                                  if the repository does
                                  not support the removal of workspaces.
 @throws NoSuchWorkspaceException is <code>srcWorkspace</code> does not
                                  exist.
 @throws RepositoryException      if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <field name="NAME_WORKSPACE_ROOT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the workspace root node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PATH_WORKSPACE_ROOT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the absolute path of the workspace root node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_SYSTEM_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the system node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PATH_SYSTEM_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the absolute path of the system node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_NODE_TYPES_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the node type definition storage node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PATH_NODE_TYPES_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the absolute path of the node type definition storage
 node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_VERSION_STORAGE_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the version storage node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PATH_VERSION_STORAGE_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the absolute path of the version storage node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_ACTIVITIES_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the activities node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PATH_ACTIVITIES_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the absolute path of the activities node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_CONFIGURATIONS_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the configurations node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PATH_CONFIGURATIONS_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the absolute path of the configurations node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_UNFILED_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the unfiled storage node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PATH_UNFILED_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the absolute path of the unfiled storage node.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_JCR_XMLTEXT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the <code>jcr:xmltext</code> node produced on
 {@link #importXML}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NAME_JCR_XMLCHARACTERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the name of the <code>jcr:xmlcharacters</code> property
 produced on {@link #importXML}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="RELPATH_JCR_XMLCHARACTERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the relative path from the node representing the imported
 XML element of the <code>jcr:xmlcharacters</code> property produced on
 {@link #importXML}.

 @since JCR 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A <code>Workspace</code> object represents a view onto a persitent workspace
 within a repository. This view is defined by the authorization settings of
 the <code>Session</code> object associated with the <code>Workspace</code>
 object. Each <code>Workspace</code> object is associated one-to-one with a
 <code>Session</code> object. The <code>Workspace</code> object can be
 acquired by calling <code>{@link Session#getWorkspace()}</code> on the
 associated <code>Session</code> object.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.Workspace -->
  <doc>
  <![CDATA[Provides interfaces and classes for the Content Repository for Java Technology.]]>
  </doc>
</package>
<package name="javax.jcr.lock">
  <!-- start interface javax.jcr.lock.Lock -->
  <interface name="Lock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getLockOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of the <code>jcr:lockOwner</code> property. This is
 either the client supplied owner information (see {@link
 LockManager#lock(String, boolean, boolean, long, String)}), an
 implementation-dependent string identifying the user who either created
 the lock or who is bound to the session holding the lock, or
 <code>null</code> if none of these are available. The lock owner's
 identity is only provided for informational purposes. It does not govern
 who can perform an unlock or make changes to the locked nodes; that
 depends entirely upon who the token holder is.

 @return a user ID.]]>
      </doc>
    </method>
    <method name="isDeep" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is a deep lock; <code>false</code>
 otherwise.

 @return a boolean]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lock holding node. Note that <code>N.getLock().getNode()</code>
 (where <code>N</code> is a locked node) will only return <code>N</code>
 if <code>N</code> is the lock holder. If <code>N</code> is in the
 subgraph of the lock holder, <code>H</code>, then this call will return
 <code>H</code>.

 @return an <code>Node</code>.]]>
      </doc>
    </method>
    <method name="getLockToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[May return the lock token for this lock. If this lock is open-scoped and
 the current session either holds the lock token for this lock, or the
 repository chooses to expose the lock token to the current session, then
 this method will return that lock token. Otherwise this method will
 return <code>null</code>.

 @return a <code>String</code>.]]>
      </doc>
    </method>
    <method name="getSecondsRemaining" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the number of seconds remaining until this locks times out. If
 the lock has already timed out, a negative value is returned. If the
 number of seconds remaining is infinite or unknown,
 <code>Long.MAX_VALUE</code> is returned.

 @return the number of seconds remaining until this lock times out.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isLive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns true if this <code>Lock</code> object represents a lock that is
 currently in effect. If this lock has been unlocked either explicitly or
 due to an implementation-specific limitation (like a timeout) then it
 returns <code>false</code>. Note that this method is intended for those
 cases where one is holding a <code>Lock</code> Java object and wants to
 find out whether the lock (the JCR-level entity that is attached to the
 lockable node) that this object originally represented still exists. For
 example, a timeout or explicit <code>unlock</code> will remove a lock
 from a node but the <code>Lock</code> Java object corresponding to that
 lock may still exist, and in that case its <code>isLive</code> method
 will return <code>false</code>.

 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="isSessionScoped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is a session-scoped lock and the scope
 is bound to the current session. Returns <code>false</code> otherwise.

 @return a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="isLockOwningSession" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if the current session is the owner of this
 lock, either because it is session-scoped and bound to this session or
 open-scoped and this session currently holds the token for this lock.
 Returns <code>false</code> otherwise.

 @return a <code>boolean</code>.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this lock's time-to-live is governed by a timer, this method resets
 that timer so that the lock does not timeout and expire. If this lock's
 time-to-live is not governed by a timer, then this method has no effect.

 @throws LockException       if this <code>Session</code> does not hold the
                             correct lock token for this lock.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a lock placed on an item.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.lock.Lock -->
  <!-- start class javax.jcr.lock.LockException -->
  <class name="LockException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LockException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class.]]>
      </doc>
    </constructor>
    <constructor name="LockException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message.]]>
      </doc>
    </constructor>
    <constructor name="LockException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause the root failure cause.]]>
      </doc>
    </constructor>
    <constructor name="LockException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message.
 @param rootCause the root failure cause.]]>
      </doc>
    </constructor>
    <constructor name="LockException" type="java.lang.String, java.lang.Throwable, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message, root cause and failure node path.

 @param message         the detail message.
 @param rootCause       the root failure cause.
 @param failureNodePath the absolute path of the node that caused the
                        error or <code>null</code> if the implementation chooses not to, or
                        cannot, return a path.
                        <p>
                        If a path is passed it must be an absolute path in normalized, standard
                        form, that is, each path segment must be a JCR name in qualified form,
                        the path must have no trailing slash, no self or parent segments and no
                        [1] indexes.]]>
      </doc>
    </constructor>
    <method name="getFailureNodePath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the absolute path of the node that caused the error or
 <code>null</code> if the implementation chooses not to, or cannot, return
 a path.

 @return path of the node that caused the error]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exception thrown by when a lock-related error occurs.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.lock.LockException -->
  <!-- start interface javax.jcr.lock.LockManager -->
  <interface name="LockManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addLockToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockToken" type="java.lang.String"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds the specified lock token to the current <code>Session</code>.
 Holding a lock token makes the current <code>Session</code> the owner of
 the lock specified by that particular lock token.

 @param lockToken a lock token (a string).
 @throws LockException       if the specified lock token is already held by
                             another <code>Session</code> and the implementation does not support
                             simultaneous ownership of open-scoped locks.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getLock" return="javax.jcr.lock.Lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>Lock</code> object that applies to the node at the
 specified <code>absPath</code>. This may be either a lock on that node
 itself or a deep lock on a node above that node.
 <p>

 @param absPath absolute path of node for which to obtain the lock
 @return The applicable <code>Lock</code> object.
 @throws LockException         if no lock applies to this node.
 @throws AccessDeniedException if the current session does not have
                               sufficent access to get the lock.
 @throws PathNotFoundException if no node is found at
                               <code>absPath</code>
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getLockTokens" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array containing all lock tokens currently held by the current
 <code>Session</code>. Note that any such tokens will represent
 open-scoped locks, since session-scoped locks do not have tokens.

 @return an array of lock tokens (strings)
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="holdsLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if the node at <code>absPath</code> holds a
 lock; otherwise returns <code>false</code>. To <i>hold</i> a lock means
 that this node has actually had a lock placed on it specifically, as
 opposed to just having a lock <i>apply</i> to it due to a deep lock held
 by a node above.

 @param absPath absolute path of node
 @return a <code>boolean</code>.
 @throws PathNotFoundException if no node is found at
                               <code>absPath</code>
 @throws RepositoryException   if an error occurs.]]>
      </doc>
    </method>
    <method name="lock" return="javax.jcr.lock.Lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="isDeep" type="boolean"/>
      <param name="isSessionScoped" type="boolean"/>
      <param name="timeoutHint" type="long"/>
      <param name="ownerInfo" type="java.lang.String"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[<p> Places a lock on the node at <code>absPath</code>. If successful,
 the node is said to <i>hold</i> the lock.  <p> If <code>isDeep</code> is
 <code>true</code> then the lock applies to the specified node and all its
 descendant nodes; if <code>false</code>, the lock applies only to the
 specified node. On a successful lock, the <code>jcr:lockIsDeep</code>
 property of the locked node is set to this value.  <p> If
 <code>isSessionScoped</code> is <code>true</code> then this lock will
 expire upon the expiration of the current session (either through an
 automatic or explicit <code>Session.logout</code>); if false, this lock
 does not expire until it is explicitly unlocked, it times out, or it is
 automatically unlocked due to a implementation-specific limitation. <p>
 The timeout parameter specifies the number of seconds until the lock
 times out (if it is not refreshed with <code>Lock.refresh</code> in the
 meantime). An implementation may use this information as a hint or ignore
 it altogether. Clients can discover the actual timeout by inspecting the
 returned <code>Lock</code> object.  <p> The <code>ownerInfo</code>
 parameter can be used to pass a string holding owner information relevant
 to the client. An implementation may either use or ignore this parameter.
 If it uses the parameter it must set the <code>jcr:lockOwner</code>
 property of the locked node to this value and return this value on
 <code>Lock.getLockOwner</code>. If it ignores this parameter the
 <code>jcr:lockOwner</code> property (and the value returned by
 <code>Lock.getLockOwner</code>) is set to either the value returned by
 <code>Session.getUserID</code> of the owning session or an
 implementation-specific string identifying the owner.  <p> The method
 returns a <code>Lock</code> object representing the new lock. If the lock
 is open-scoped the returned lock will include a lock token. The lock
 token is also automatically added to the set of lock tokens held by the
 current session.  <p> The addition or change of the properties
 <code>jcr:lockIsDeep</code> and <code>jcr:lockOwner</code> are persisted
 immediately; there is no need to call <code>save</code>.  <p> It is
 possible to lock a node even if it is checked-in.

 @param absPath         absolute path of node to be locked
 @param isDeep          if <code>true</code> this lock will apply to this node and
                        all its descendants; if <code>false</code>, it applies only to this
                        node.
 @param isSessionScoped if <code>true</code>, this lock expires with the
                        current session; if <code>false</code> it expires when explicitly or
                        automatically unlocked for some other reason.
 @param timeoutHint     desired lock timeout in seconds (servers are free to
                        ignore this value); specify {@link Long#MAX_VALUE} for no timeout.
 @param ownerInfo       a string containing owner information supplied by the
                        client; servers are free to ignore this value.
 @return A <code>Lock</code> object containing a lock token.
 @throws LockException             if this node is not <code>mix:lockable</code> or
                                   this node is already locked or <code>isDeep</code> is <code>true</code>
                                   and a descendant node of this node already holds a lock.
 @throws AccessDeniedException     if this session does not have sufficent
                                   access to lock this node.
 @throws InvalidItemStateException if this node has pending unsaved
                                   changes.
 @throws PathNotFoundException     if no node is found at
                                   <code>absPath</code>
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <method name="isLocked" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if the node at <code>absPath</code> is locked
 either as a result of a lock held by that node or by a deep lock on a
 node above that node; otherwise returns <code>false</code>.

 @param absPath absolute path of node
 @return a <code>boolean</code>.
 @throws PathNotFoundException if no node is found at
                               <code>absPath</code>
 @throws RepositoryException   if an error occurs.]]>
      </doc>
    </method>
    <method name="removeLockToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockToken" type="java.lang.String"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified lock token from this <code>Session</code>.

 @param lockToken a lock token (a string)
 @throws LockException       if the current <code>Session</code> does not hold
                             the specified lock token.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the lock on the node at <code>absPath</code>. Also removes the
 properties <code>jcr:lockOwner</code> and <code>jcr:lockIsDeep</code>
 from that node. As well, the corresponding lock token is removed from the
 set of lock tokens held by the current <code>Session</code>.
 <p>
 If the node does not currently hold a lock or holds a lock for which this
 <code>Session</code> is not the owner and is not a "lock-superuser", then
 a <code>LockException</code> is thrown. Note that the system may give
 permission to a non-owning session to unlock a lock. Typically, such
 "lock-superuser" capability is intended to facilitate administrational
 clean-up of orphaned open-scoped locks.
 <p>
 Note that it is possible to unlock a node even if it is checked-in (the
 lock-related properties will be changed despite the checked-in status).
 <p>
 If the current session does not have sufficient privileges to remove the
 lock, an <code>AccessDeniedException</code> is thrown.

 @param absPath absolute path of node to be unlocked
 @throws LockException             if this node does not currently hold a lock or
                                   holds a lock for which this Session does not have the correct lock
                                   token.
 @throws AccessDeniedException     if the current session does not have
                                   permission to unlock this node.
 @throws InvalidItemStateException if this node has pending unsaved
                                   changes.
 @throws PathNotFoundException     if no node is found at
                                   <code>absPath</code>
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface encapsulates methods for the management of locks.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.lock.LockManager -->
  <doc>
  <![CDATA[Provides interfaces and classes for content repository locking functionality.]]>
  </doc>
</package>
<package name="javax.jcr.nodetype">
  <!-- start class javax.jcr.nodetype.ConstraintViolationException -->
  <class name="ConstraintViolationException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConstraintViolationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ConstraintViolationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ConstraintViolationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ConstraintViolationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when an action would violate a constraint on repository
 structure. For example, when an attempt is made to persistently add an item
 to a node that would violate that node's node type.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.nodetype.ConstraintViolationException -->
  <!-- start class javax.jcr.nodetype.InvalidNodeTypeDefinitionException -->
  <class name="InvalidNodeTypeDefinitionException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidNodeTypeDefinitionException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidNodeTypeDefinitionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidNodeTypeDefinitionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidNodeTypeDefinitionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when an attempt is made to register an invalid node type
 definition template.

 @since JCR 2.0]]>
    </doc>
  </class>
  <!-- end class javax.jcr.nodetype.InvalidNodeTypeDefinitionException -->
  <!-- start interface javax.jcr.nodetype.ItemDefinition -->
  <interface name="ItemDefinition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDeclaringNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the node type that contains the declaration of <i>this</i>
 <code>ItemDefinition</code>.
 <p>
 In implementations that support node type registration an
 <code>ItemDefinition</code> object may be acquired (in the form of a
 <code>NodeDefinitionTemplate</code> or <code>PropertyDefinitionTemplate</code>)
 that is not attached to a live <code>NodeType</code>. In such cases this
 method returns <code>null</code>.

 @return a <code>NodeType</code> object.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the child item. If <code>"*"</code>, this
 <code>ItemDefinition</code> defines a residual set of child items. That
 is, it defines the characteristics of all those child items with names
 apart from the names explicitly used in other child item definitions.
 <p>
 In implementations that support node type registration, if this
 <code>ItemDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code> or <code>NodeDefinitionTemplate</code>,
 then this method will return <code>null</code>.

 @return a <code>String</code> denoting the name or <code>"*"</code>.]]>
      </doc>
    </method>
    <method name="isAutoCreated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether the item is to be automatically created when its parent
 node is created. If <code>true</code>, then this <code>ItemDefinition</code>
 will necessarily not be a residual set definition but will specify an
 actual item name (in other words getName() will not return "*").
 <p>
 An autocreated non-protected item must be created immediately when its
 parent node is created in the transient session space. Creation of
 autocreated non-protected items is never delayed until
 <code>save</code>.
 <p>
 <p>
 An autocreated protected item should be created immediately when its
 parent node is created in the transient session space. Creation of
 autocreated protected items should not be delayed until
 <code>save</code>, though doing so does not violate JCR compliance.
 <p>
 In implementations that support node type registration, if this
 <code>ItemDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code> or <code>NodeDefinitionTemplate</code>,
 then this method will return <code>false</code>.

 @return a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="isMandatory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether the item is mandatory. A mandatory item is one that, if
 its parent node exists, must also exist.
 <p>
 This means that a mandatory single-value property must have a value
 (since there is no such thing a <code>null</code> value). In the case of
 multi-value properties this means that the property must exist, though it
 can have zero or more values.
 <p>
 An attempt to save a node that has a mandatory child item without first
 creating that child item  will throw a <code>ConstraintViolationException</code>
 on <code>save</code>.
 <p>
 In implementations that support node type registration, if this
 <code>ItemDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code> or <code>NodeDefinitionTemplate</code>,
 then this method will return <code>false</code>.
 <p>
 An item definition cannot be both residual and mandatory.

 @return a <code>boolean</code>]]>
      </doc>
    </method>
    <method name="getOnParentVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the <code>OnParentVersion </code> status of the child item. This
 governs what occurs (in implementations that support versioning) when the
 parent node of this item is checked-in. One of: <ul>
 <li><code>OnParentVersionAction.COPY</code></li> <li><code>OnParentVersionAction.VERSION</code></li>
 <li><code>OnParentVersionAction.IGNORE</code></li>
 <li><code>OnParentVersionAction.INITIALIZE</code></li>
 <li><code>OnParentVersionAction.COMPUTE</code></li>
 <li><code>OnParentVersionAction.ABORT</code></li> </ul>
 <p>
 In implementations that support node type registration, if this
 <code>ItemDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code> or <code>NodeDefinitionTemplate</code>,
 then this method will return <code>OnParentVersionAction.COPY</code>.

 @return a <code>int</code> constant member of {@link
         javax.jcr.version.OnParentVersionAction}.]]>
      </doc>
    </method>
    <method name="isProtected" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether the child item is protected. In level 2 implementations,
 a protected item is one that cannot be removed (except by removing its
 parent) or modified through the the standard write methods of this API
 (that is, <code>Item.remove</code>, <code>Node.addNode</code>,
 <code>Node.setProperty</code> and <code>Property.setValue</code>).
 <p>
 A protected node may be removed or modified (in a level 2
 implementation), however, through some mechanism not defined by this
 specification or as a side-effect of operations other than the standard
 write methods of the API.
 <p>
 In implementations that support node type registration, if this
 <code>ItemDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code> or <code>NodeDefinitionTemplate</code>,
 then this method will return <code>false</code>.

 @return a <code>boolean</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Superclass of {@link NodeDefinition} and {@link PropertyDefinition}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.ItemDefinition -->
  <!-- start interface javax.jcr.nodetype.NodeDefinition -->
  <interface name="NodeDefinition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.ItemDefinition"/>
    <method name="getRequiredPrimaryTypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum set of primary node types that the child node must have.
 Returns an array to support those implementations with multiple
 inheritance. This method never returns an empty array. If this node
 definition places no requirements on the primary node type, then this
 method will return an array containing only the <code>NodeType</code>
 object representing <code>nt:base</code>, which is the base of all
 primary node types and therefore constitutes the least restrictive node
 type requirement. Note that any particular node instance still has only
 one assigned primary node type, but in multiple-inheritance-supporting
 implementations the <code>RequiredPrimaryTypes</code> attribute can be
 used to restrict that assigned node type to be a subtype of <i>all</i> of
 a specified set of node types.
 <p>
 In implementations that support node type registration an
 <code>NodeDefinition</code> object may be acquired (in the form of a
 <code>NodeDefinitionTemplate</code>) that is not attached to a live
 <code>NodeType</code>. In such cases this method returns
 <code>null</code>.

 @return an array of <code>NodeType</code> objects.]]>
      </doc>
    </method>
    <method name="getRequiredPrimaryTypeNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the required primary node types.
 <p>
 If this <code>NodeDefinition</code> is acquired from a live
 <code>NodeType</code> this list will reflect the node types returned by
 <code>getRequiredPrimaryTypes</code>, above.
 <p>
 If this <code>NodeDefinition</code> is actually a
 <code>NodeDefinitionTemplate</code> that is not part of a registered node
 type, then this method will return the required primary types as set in
 that template. If that template is a newly-created empty one, then this
 method will return </code>null<code>.

 @return a String array
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDefaultPrimaryType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default primary node type that will be assigned to the child
 node if it is created without an explicitly specified primary node type.
 This node type must be a subtype of (or the same type as) the node types
 returned by <code>getRequiredPrimaryTypes</code>.
 <p>
 If <code>null</code> is returned this indicates that no default primary
 type is specified and that therefore an attempt to create this node
 without specifying a node type will throw a <code>ConstraintViolationException</code>.
 <p>
 In implementations that support node type registration an
 <code>NodeDefinition</code> object may be acquired (in the form of a
 <code>NodeDefinitionTemplate</code>) that is not attached to a live
 <code>NodeType</code>. In such cases this method returns
 <code>null</code>.

 @return a <code>NodeType</code>.]]>
      </doc>
    </method>
    <method name="getDefaultPrimaryTypeName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the default primary node type.
 <p>
 If this <code>NodeDefinition</code> is acquired from a live
 <code>NodeType</code> this list will reflect the NodeType returned by
 getDefaultPrimaryType, above.
 <p>
 If this <code>NodeDefinition</code> is actually a
 <code>NodeDefinitionTemplate</code> that is not part of a registered node
 type, then this method will return the required primary types as set in
 that template. If that template is a newly-created empty one, then this
 method will return <code>null</code>.

 @return a String
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="allowsSameNameSiblings" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether this child node can have same-name siblings. In other
 words, whether the parent node can have more than one child node of this
 name.
 <p>
 If this <code>NodeDefinition</code> is actually a
 <code>NodeDefinitionTemplate</code> that is not part of a registered node
 type, then this method will return the same name siblings status as set
 in that template. If that template is a newly-created empty one, then
 this method will return <code>false</code>.

 @return a boolean.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A node definition. Used in node type definitions.

 @see NodeType#getChildNodeDefinitions
 @see javax.jcr.Node#getDefinition]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeDefinition -->
  <!-- start interface javax.jcr.nodetype.NodeDefinitionTemplate -->
  <interface name="NodeDefinitionTemplate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.NodeDefinition"/>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <doc>
      <![CDATA[Sets the name of the node. This must be a JCR name in either
 qualified or expanded form.

 @param name a JCR name.
 @throws ConstraintViolationException if <code>name</code> is not a
 syntactically valid JCR name in either qualified or expanded form.]]>
      </doc>
    </method>
    <method name="setAutoCreated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="autoCreated" type="boolean"/>
      <doc>
      <![CDATA[Sets the auto-create status of the node.

 @param autoCreated a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setMandatory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mandatory" type="boolean"/>
      <doc>
      <![CDATA[Sets the mandatory status of the node.

 @param mandatory a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setOnParentVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="opv" type="int"/>
      <doc>
      <![CDATA[Sets the on-parent-version status of the node.

 @param opv an <code>int</code> constant member of
            <code>OnParentVersionAction</code>.]]>
      </doc>
    </method>
    <method name="setProtected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protectedStatus" type="boolean"/>
      <doc>
      <![CDATA[Sets the protected status of the node.

 @param protectedStatus a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setRequiredPrimaryTypeNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <doc>
      <![CDATA[Sets the names of the required primary types of this node.
 These must be a JCR names in either qualified or expanded form.

 @param names an array of JCR names.
 @throws ConstraintViolationException if <code>names</code> includes a
 name that is not a syntactically valid JCR name in either qualified or expanded form.]]>
      </doc>
    </method>
    <method name="setDefaultPrimaryTypeName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <doc>
      <![CDATA[Sets the name of the default primary type of this node.
 This must be a JCR name in either qualified or expanded form.

 @param name a JCR name.
 @throws ConstraintViolationException if <code>name</code> is not a
 syntactically valid JCR name in either qualified or expanded form.]]>
      </doc>
    </method>
    <method name="setSameNameSiblings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allowSameNameSiblings" type="boolean"/>
      <doc>
      <![CDATA[Sets the same-name sibling status of this node.

 @param allowSameNameSiblings a <code>boolean</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>NodeDefinitionTemplate</code> interface extends
 <code>NodeDefinition</code> with the addition of write methods, enabling the
 characteristics of a child node definition to be set, after which the
 <code>NodeDefinitionTemplate</code> is added to a <code>NodeTypeTemplate</code>.
 <p>
 See the corresponding <code>get</code> methods for each attribute in
 <code>NodeDefinition</code> for the default values assumed when a new empty
 <code>NodeDefinitionTemplate</code> is created (as opposed to one extracted
 from an existing <code>NodeType</code>).

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeDefinitionTemplate -->
  <!-- start interface javax.jcr.nodetype.NodeType -->
  <interface name="NodeType"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.NodeTypeDefinition"/>
    <method name="getSupertypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all supertypes of this node type in the node type inheritance
 hierarchy. For primary types apart from <code>nt:base</code>, this list
 will always include at least <code>nt:base</code>. For mixin types, there
 is no required supertype.

 @return an array of <code>NodeType</code> objects.
 @see #getDeclaredSupertypes]]>
      </doc>
    </method>
    <method name="getDeclaredSupertypes" return="javax.jcr.nodetype.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <i>direct</i> supertypes of this node type in the node type
 inheritance hierarchy, that is, those actually declared in this node
 type. In single-inheritance systems, this will always be an array of size
 0 or 1. In systems that support multiple inheritance of node types this
 array may be of size greater than 1.

 @return an array of <code>NodeType</code> objects.
 @see #getSupertypes]]>
      </doc>
    </method>
    <method name="getSubtypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all subtypes of this node type in the node type inheritance
 hierarchy.

 @return a <code>NodeTypeIterator</code>.
 @see #getDeclaredSubtypes
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDeclaredSubtypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <i>direct</i> subtypes of this node type in the node type
 inheritance hierarchy, that is, those which actually declared this node
 type in their list of supertypes.

 @return an <code>NodeTypeIterator</code>.
 @see #getSubtypes
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isNodeType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if the name of <i>this</i> node type or any of
 its direct or indirect supertypes is equal to <code>nodeTypeName</code>,
 otherwise returns <code>false</code>.

 @param nodeTypeName the name of a node type.
 @return a boolean]]>
      </doc>
    </method>
    <method name="getPropertyDefinitions" return="javax.jcr.nodetype.PropertyDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the property definitions of this node type.
 This includes both those property definitions actually declared in this
 node type and those inherited from the supertypes of this type.

 @return an array containing the property definitions.
 @see #getDeclaredPropertyDefinitions()]]>
      </doc>
    </method>
    <method name="getChildNodeDefinitions" return="javax.jcr.nodetype.NodeDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the child node definitions of this node type.
 This includes both those child node definitions actually declared in this
 node type and those inherited from the supertypes of this node type.

 @return an array containing the child node definitions.
 @see #getDeclaredChildNodeDefinitions()]]>
      </doc>
    </method>
    <method name="canSetProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Value"/>
      <doc>
      <![CDATA[Returns <code>true</code> if setting <code>propertyName</code> to
 <code>value</code> is allowed by this node type. Otherwise returns
 <code>false</code>.

 @param propertyName The name of the property
 @param value        A <code>Value</code> object.
 @return a boolean]]>
      </doc>
    </method>
    <method name="canSetProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <param name="values" type="javax.jcr.Value[]"/>
      <doc>
      <![CDATA[Returns <code>true</code> if setting <code>propertyName</code> to
 <code>values</code> is allowed by this node type. Otherwise returns
 <code>false</code>.

 @param propertyName The name of the property
 @param values       A <code>Value</code> array.
 @return a boolean]]>
      </doc>
    </method>
    <method name="canAddChildNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="childNodeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node type allows the addition of a
 child node called <code>childNodeName</code> without specific node type
 information (that is, given the definition of this parent node type, the
 child node name is sufficient to determine the intended child node type).
 Returns <code>false</code> otherwise.

 @param childNodeName The name of the child node.
 @return a boolean]]>
      </doc>
    </method>
    <method name="canAddChildNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="childNodeName" type="java.lang.String"/>
      <param name="nodeTypeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this node type allows the addition of a
 child node called <code>childNodeName</code> of node type
 <code>nodeTypeName</code>. Returns <code>false</code> otherwise.

 @param childNodeName The name of the child node.
 @param nodeTypeName  The name of the node type of the child node.
 @return a boolean]]>
      </doc>
    </method>
    <method name="canRemoveItem" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, clients should use {@link #canRemoveNode(String)}
             and {@link #canRemoveProperty(String)} instead.">
      <param name="itemName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if removing the child item called
 <code>itemName</code> is allowed by this node type. Returns
 <code>false</code> otherwise.

 @param itemName The name of the child item
 @return a boolean
 @deprecated As of JCR 2.0, clients should use {@link #canRemoveNode(String)}
             and {@link #canRemoveProperty(String)} instead.]]>
      </doc>
    </method>
    <method name="canRemoveNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if removing the child node called
 <code>nodeName</code> is allowed by this node type. Returns
 <code>false</code> otherwise.

 @param nodeName The name of the child node
 @return a boolean
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="canRemoveProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns <code>true</code> if removing the property called
 <code>propertyName</code> is allowed by this node type. Returns
 <code>false</code> otherwise.

 @param propertyName The name of the property
 @return a boolean
 @since JCR 2.0]]>
      </doc>
    </method>
    <field name="NT_BASE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:base</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>nt:base</code> are: <ul> <li>{@link javax.jcr.Property#JCR_PRIMARY_TYPE}</li>
 <li>{@link javax.jcr.Property#JCR_MIXIN_TYPES}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_HIERARCHY_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:hierarchyNode</code> (in
 expanded form).

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_FOLDER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:folder</code> (in expanded
 form).

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:file</code> (in expanded
 form). A constant for the name of the child node declared by
 <code>nt:file</code> is: <ul> <li>{@link javax.jcr.Node#JCR_CONTENT}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_LINKED_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:linkedFile</code> (in expanded
 form). A constant for the name of the property declared by
 <code>nt:linkedFile</code> is: <ul> <li>{@link javax.jcr.Property#JCR_CONTENT}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_RESOURCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:resource</code> (in expanded
 form). A constant for the name of the property declared by
 <code>nt:resource</code> is: <ul> <li>{@link javax.jcr.Property#JCR_DATA}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_UNSTRUCTURED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:unstructured</code> (in
 expanded form).

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_ADDRESS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:address</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>nt:base</code> are: <ul> <li>{@link javax.jcr.Property#JCR_PROTOCOL}</li>
 <li>{@link javax.jcr.Property#JCR_HOST}</li> <li>{@link
 javax.jcr.Property#JCR_PORT}</li> <li>{@link javax.jcr.Property#JCR_REPOSITORY}</li>
 <li>{@link javax.jcr.Property#JCR_WORKSPACE}</li> <li>{@link
 javax.jcr.Property#JCR_PATH}</li> <li>{@link javax.jcr.Property#JCR_ID}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_REFERENCEABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:referenceable</code> (in
 expanded form). A constant for the name of the property declared by
 <code>mix:referenceable</code> is: <ul> <li>{@link
 javax.jcr.Property#JCR_UUID}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_TITLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:title</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>mix:title</code> are: <ul> <li>{@link javax.jcr.Property#JCR_TITLE}</li>
 <li>{@link javax.jcr.Property#JCR_DESCRIPTION}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_CREATED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:created</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>mix:created</code> are: <ul> <li>{@link javax.jcr.Property#JCR_CREATED}</li>
 <li>{@link javax.jcr.Property#JCR_CREATED_BY}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_LAST_MODIFIED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:lastModified</code> (in
 expanded form). Constants for the names of the properties declared by
 <code>mix:lastModified</code> are: <ul> <li>{@link
 javax.jcr.Property#JCR_LAST_MODIFIED}</li> <li>{@link
 javax.jcr.Property#JCR_LAST_MODIFIED_BY}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_LANGUAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:language</code> (in expanded
 form). A constant for the name of the property declared by
 <code>mix:language</code> is: <ul> <li>{@link javax.jcr.Property#JCR_LANGUAGE}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_MIMETYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:mimeType</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>mix:mimeType</code> are: <ul> <li>{@link javax.jcr.Property#JCR_MIMETYPE}</li>
 <li>{@link javax.jcr.Property#JCR_ENCODING}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_NODE_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:nodeType</code> (in expanded
 form). Constants for the names of the child items declared by
 <code>nt:nodeType</code> are: <ul> <li>{@link javax.jcr.Property#JCR_NODE_TYPE_NAME}</li>
 <li>{@link javax.jcr.Property#JCR_SUPERTYPES}</li> <li>{@link
 javax.jcr.Property#JCR_IS_ABSTRACT}</li> <li>{@link
 javax.jcr.Property#JCR_IS_MIXIN}</li> <li>{@link javax.jcr.Property#JCR_HAS_ORDERABLE_CHILD_NODES}</li>
 <li>{@link javax.jcr.Property#JCR_PRIMARY_ITEM_NAME}</li> <li>{@link
 javax.jcr.Node#JCR_PROPERTY_DEFINITION}</li> <li>{@link
 javax.jcr.Node#JCR_CHILD_NODE_DEFINITION}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_PROPERTY_DEFINITION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:propertyDefinition</code> (in
 expanded form). Constants for the names of the properties declared by
 <code>nt:propertyDefinition</code> are: <ul> <li>{@link
 javax.jcr.Property#JCR_NAME}</li> <li>{@link javax.jcr.Property#JCR_AUTOCREATED}</li>
 <li>{@link javax.jcr.Property#JCR_MANDATORY}</li> <li>{@link
 javax.jcr.Property#JCR_PROTECTED}</li> <li>{@link
 javax.jcr.Property#JCR_ON_PARENT_VERSION}</li> <li>{@link
 javax.jcr.Property#JCR_REQUIRED_TYPE}</li> <li>{@link
 javax.jcr.Property#JCR_VALUE_CONSTRAINTS}</li> <li>{@link
 javax.jcr.Property#JCR_DEFAULT_VALUES}</li> <li>{@link
 javax.jcr.Property#JCR_MULTIPLE}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_CHILD_NODE_DEFINITION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:childNodeDefinition</code> (in
 expanded form). Constants for the names of the properties declared by
 <code>nt:childNodeDefinition</code> are: <ul> <li>{@link
 javax.jcr.Property#JCR_NAME}</li> <li>{@link javax.jcr.Property#JCR_AUTOCREATED}</li>
 <li>{@link javax.jcr.Property#JCR_MANDATORY}</li> <li>{@link
 javax.jcr.Property#JCR_PROTECTED}</li> <li>{@link
 javax.jcr.Property#JCR_ON_PARENT_VERSION}</li> <li>{@link
 javax.jcr.Property#JCR_REQUIRED_PRIMARY_TYPES}</li> <li>{@link
 javax.jcr.Property#JCR_DEFAULT_PRIMARY_TYPE}</li> <li>{@link
 javax.jcr.Property#JCR_SAME_NAME_SIBLINGS}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_SHAREABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:shareable</code> (in expanded
 form).

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_LOCKABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:lockable</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>mix:lockable</code> are: <ul> <li>{@link javax.jcr.Property#JCR_LOCK_OWNER}</li>
 <li>{@link javax.jcr.Property#JCR_LOCK_IS_DEEP}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_LIFECYCLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:lifecycle</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>mix:lifecycle</code> are: <ul> <li>{@link javax.jcr.Property#JCR_LIFECYCLE_POLICY}</li>
 <li>{@link javax.jcr.Property#JCR_CURRENT_LIFECYCLE_STATE}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_SIMPLE_VERSIONABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:simpleVersionable</code> (in
 expanded form). A constant for the name of the property declared by
 <code>mix:simpleVersionable</code> is: <ul> <li>{@link
 javax.jcr.Property#JCR_IS_CHECKED_OUT}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="MIX_VERSIONABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>mix:versionable</code> (in
 expanded form). Constants for the names of the properties declared by
 <code>mix:versionable</code> are: <ul> <li>{@link
 javax.jcr.Property#JCR_VERSION_HISTORY}</li> <li>{@link
 javax.jcr.Property#JCR_BASE_VERSION}</li> <li>{@link
 javax.jcr.Property#JCR_PREDECESSORS}</li> <li>{@link
 javax.jcr.Property#JCR_MERGE_FAILED}</li> <li>{@link
 javax.jcr.Property#JCR_ACTIVITY}</li> <li>{@link javax.jcr.Property#JCR_CONFIGURATION}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_VERSION_HISTORY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:versionHistory</code> (in
 expanded form). Constants for the names of the child items declared by
 <code>nt:versionHistory</code> are: <ul> <li>{@link
 javax.jcr.Property#JCR_VERSIONABLE_UUID}</li> <li>{@link
 javax.jcr.Property#JCR_COPIED_FROM}</li> <li>{@link
 javax.jcr.Node#JCR_ROOT_VERSION}</li> <li>{@link javax.jcr.Node#JCR_VERSION_LABELS}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:version</code> (in expanded
 form). Constants for the names of the child items declared by
 <code>nt:version</code> are: <ul> <li>{@link javax.jcr.Property#JCR_CREATED}</li>
 <li>{@link javax.jcr.Property#JCR_PREDECESSORS}</li> <li>{@link
 javax.jcr.Property#JCR_SUCCESSORS}</li> <li>{@link
 javax.jcr.Property#JCR_ACTIVITY}</li> <li>{@link javax.jcr.Node#JCR_FROZEN_NODE}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_FROZEN_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:frozenNode</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>nt:frozenNode</code> are: <ul> <li>{@link javax.jcr.Property#JCR_FROZEN_PRIMARY_TYPE}</li>
 <li>{@link javax.jcr.Property#JCR_FROZEN_MIXIN_TYPES}</li> <li>{@link
 javax.jcr.Property#JCR_FROZEN_UUID}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_VERSIONED_CHILD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:versionedChild</code> (in
 expanded form). A constant for the name of the property declared by
 <code>nt:versionedChild</code> is: <ul> <li>{@link
 javax.jcr.Property#JCR_CHILD_VERSION_HISTORY}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_ACTIVITY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:activity</code> (in expanded
 form). A constant for the name of the property declared by
 <code>nt:activity</code> is: <ul> <li>{@link javax.jcr.Property#JCR_TITLE}</li>
 </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_CONFIGURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:configuration</code> (in
 expanded form). A constant for the name of the property declared by
 <code>nt:configuration</code> are: <ul> <li>{@link
 javax.jcr.Property#JCR_ROOT}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="NT_QUERY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant for the node type name <code>nt:query</code> (in expanded
 form). Constants for the names of the properties declared by
 <code>nt:query</code> are: <ul> <li>{@link javax.jcr.Property#JCR_STATEMENT}</li>
 <li>{@link javax.jcr.Property#JCR_LANGUAGE}</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A <code>NodeType</code> object represents a "live" node type that is
 registered in the repository.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeType -->
  <!-- start interface javax.jcr.nodetype.NodeTypeDefinition -->
  <interface name="NodeTypeDefinition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the node type.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 <code>null</code>.

 @return a <code>String</code>
 @since JCR 2.0 moved here from JCR 1.0 <code>NodeType</code>.]]>
      </doc>
    </method>
    <method name="getDeclaredSupertypeNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the supertypes actually declared in this node type.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return an empty array.

 @return an array of <code>String</code>s
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isAbstract" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is an abstract node type; returns
 <code>false</code> otherwise.
 <p>
 An abstract node type is one that cannot be assigned as the primary or
 mixin type of a node but can be used in the definitions of other node
 types as a superclass.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 <code>false</code>.

 @return a <code>boolean</code>
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isMixin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this is a mixin type; returns
 <code>false</code> if it is primary.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 <code>false</code>.

 @return a <code>boolean</code>
 @since JCR 2.0 moved here from JCR 1.0 <code>NodeType</code>.]]>
      </doc>
    </method>
    <method name="hasOrderableChildNodes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if nodes of this type must support orderable
 child nodes; returns <code>false</code> otherwise. If a node type returns
 <code>true</code> on a call to this method, then all nodes of that node
 type <i>must</i> support the method <code>Node.orderBefore</code>. If a
 node type returns <code>false</code> on a call to this method, then nodes
 of that node type <i>may</i> support <code>Node.orderBefore</code>. Only
 the primary node type of a node controls that node's status in this
 regard. This setting on a mixin node type will not have any effect on the
 node.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 <code>false</code>.

 @return a <code>boolean</code>
 @since JCR 2.0 moved here from JCR 1.0 <code>NodeType</code>.]]>
      </doc>
    </method>
    <method name="isQueryable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if the node type is queryable, meaning that the
 available-query-operators, full-text-searchable and query-orderable
 attributes of its property definitions take effect. See {@link
 javax.jcr.nodetype.PropertyDefinition#getAvailableQueryOperators()},
 {@link javax.jcr.nodetype.PropertyDefinition#isFullTextSearchable()} and
 {@link javax.jcr.nodetype.PropertyDefinition#isQueryOrderable()}.
 <p>
 If a node type is declared non-queryable then these attributes of its
 property definitions have no effect.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 an implementation-determined defalt value.

 @return a <code>boolean</code>
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getPrimaryItemName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the primary item (one of the child items of the nodes
 of this node type). If this node has no primary item, then this method
 returns <code>null</code>. This indicator is used by the method
 <code>Node.getPrimaryItem()</code>.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 <code>null</code>.

 @return a <code>String</code>
 @since JCR 2.0 moved here from JCR 1.0 <code>NodeType</code>.]]>
      </doc>
    </method>
    <method name="getDeclaredPropertyDefinitions" return="javax.jcr.nodetype.PropertyDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the property definitions actually declared in
 this node type.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 <code>null</code>.

 @return an array of <code>PropertyDefinition</code>s
 @since JCR 2.0 moved here from JCR 1.0 <code>NodeType</code>.]]>
      </doc>
    </method>
    <method name="getDeclaredChildNodeDefinitions" return="javax.jcr.nodetype.NodeDefinition[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing the child node definitions actually declared
 in this node type.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return
 <code>null</code>.

 @return an array of <code>NodeDefinition</code>s
 @since JCR 2.0 moved here from JCR 1.0 <code>NodeType</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>NodeTypeDefinition</code> interface provides methods for
 discovering the static definition of a node type. These are accessible both
 before and after the node type is registered. Its subclass
 <code>NodeType</code> adds methods that are relevant only when the node type
 is "live"; that is, after it has been registered. Note that the separate
 <code>NodeDefinition</code> interface only plays a significant role in
 implementations that support node type registration. In those cases it serves
 as the superclass of both <code>NodeType</code> and <code>NodeTypeTemplate</code>.
 In implementations that do not support node type registration, only objects
 implementing the subinterface <code>NodeType</code> will be encountered.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeTypeDefinition -->
  <!-- start class javax.jcr.nodetype.NodeTypeExistsException -->
  <class name="NodeTypeExistsException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NodeTypeExistsException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="NodeTypeExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="NodeTypeExistsException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="NodeTypeExistsException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when an attempt is made to register a node type that already
 exists, and <code>allowUpdate</code> has not been set to <code>true</code>.

 @since JCR 2.0]]>
    </doc>
  </class>
  <!-- end class javax.jcr.nodetype.NodeTypeExistsException -->
  <!-- start interface javax.jcr.nodetype.NodeTypeIterator -->
  <interface name="NodeTypeIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>NodeType</code> in the iteration.

 @return the next <code>NodeType</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>NodeType</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator for <code>NodeType</code> objects.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeTypeIterator -->
  <!-- start interface javax.jcr.nodetype.NodeTypeManager -->
  <interface name="NodeTypeManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the named node type.

 @param nodeTypeName the name of an existing node type.
 @return A <code>NodeType</code> object.
 @throws NoSuchNodeTypeException if no node type by the given name
                                 exists.
 @throws RepositoryException     if another error occurs.]]>
      </doc>
    </method>
    <method name="hasNodeType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if a node type with the specified name is
 registered. Returns <code>false</code> otherwise.

 @param name a <code>String</code>.
 @return a <code>boolean</code>
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getAllNodeTypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all available node types (primary and mixin).

 @return An <code>NodeTypeIterator</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getPrimaryNodeTypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all available primary node types.

 @return An <code>NodeTypeIterator</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getMixinNodeTypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all available mixin node types. If none are
 available, an empty iterator is returned.

 @return An <code>NodeTypeIterator</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="createNodeTypeTemplate" return="javax.jcr.nodetype.NodeTypeTemplate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an empty <code>NodeTypeTemplate</code> which can then be used to
 define a node type and passed to <code>NodeTypeManager.registerNodeType</code>.

 @return A <code>NodeTypeTemplate</code>.
 @throws UnsupportedRepositoryOperationException
                             if this implementation
                             does not support node type registration.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="createNodeTypeTemplate" return="javax.jcr.nodetype.NodeTypeTemplate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ntd" type="javax.jcr.nodetype.NodeTypeDefinition"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns a <code>NodeTypeTemplate</code> holding the specified node type
 definition. This template can then be altered and passed to
 <code>NodeTypeManager.registerNodeType</code>.

 @param ntd a <code>NodeTypeDefinition</code>.
 @return A <code>NodeTypeTemplate</code>.
 @throws UnsupportedRepositoryOperationException
                             if this implementation
                             does not support node type registration.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="createNodeDefinitionTemplate" return="javax.jcr.nodetype.NodeDefinitionTemplate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an empty <code>NodeDefinitionTemplate</code> which can then be
 used to create a child node definition and attached to a
 <code>NodeTypeTemplate</code>.

 @return A <code>NodeDefinitionTemplate</code>.
 @throws UnsupportedRepositoryOperationException
                             if this implementation
                             does not support node type registration.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="createPropertyDefinitionTemplate" return="javax.jcr.nodetype.PropertyDefinitionTemplate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an empty <code>PropertyDefinitionTemplate</code> which can then
 be used to create a property definition and attached to a
 <code>NodeTypeTemplate</code>.

 @return A <code>PropertyDefinitionTemplate</code>.
 @throws UnsupportedRepositoryOperationException
                             if this implementation
                             does not support node type registration.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="registerNodeType" return="javax.jcr.nodetype.NodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ntd" type="javax.jcr.nodetype.NodeTypeDefinition"/>
      <param name="allowUpdate" type="boolean"/>
      <exception name="InvalidNodeTypeDefinitionException" type="javax.jcr.nodetype.InvalidNodeTypeDefinitionException"/>
      <exception name="NodeTypeExistsException" type="javax.jcr.nodetype.NodeTypeExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Registers a new node type or updates an existing node type using the
 specified definition and returns the resulting <code>NodeType</code>
 object.
 <p>
 Typically, the object passed to this method will be a
 <code>NodeTypeTemplate</code> (a subclass of <code>NodeTypeDefinition</code>)
 acquired from <code>NodeTypeManager.createNodeTypeTemplate</code> and
 then filled-in with definition information.

 @param ntd         an <code>NodeTypeDefinition</code>.
 @param allowUpdate a boolean
 @return the registered node type
 @throws InvalidNodeTypeDefinitionException
                                 if the
                                 <code>NodeTypeDefinition</code> is invalid.
 @throws NodeTypeExistsException if <code>allowUpdate</code> is
                                 <code>false</code> and the <code>NodeTypeDefinition</code> specifies a
                                 node type name that is already registered.
 @throws UnsupportedRepositoryOperationException
                                 if this implementation
                                 does not support node type registration.
 @throws RepositoryException     if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="registerNodeTypes" return="javax.jcr.nodetype.NodeTypeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ntds" type="javax.jcr.nodetype.NodeTypeDefinition[]"/>
      <param name="allowUpdate" type="boolean"/>
      <exception name="InvalidNodeTypeDefinitionException" type="javax.jcr.nodetype.InvalidNodeTypeDefinitionException"/>
      <exception name="NodeTypeExistsException" type="javax.jcr.nodetype.NodeTypeExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Registers or updates the specified array of <code>NodeTypeDefinition</code>
 objects. This method is used to register or update a set of node types
 with mutual dependencies. Returns an iterator over the resulting
 <code>NodeType</code> objects.
 <p>
 The effect of the method is "all or nothing"; if an error occurs, no node
 types are registered or updated.

 @param ntds        a collection of <code>NodeTypeDefinition</code>s
 @param allowUpdate a boolean
 @return the registered node types.
 @throws InvalidNodeTypeDefinitionException
                                 if a <code>NodeTypeDefinition</code>
                                 within the <code>Collection</code> is invalid or if the
                                 <code>Collection</code> contains an object of a type other than
                                 <code>NodeTypeDefinition</code>.
 @throws NodeTypeExistsException if <code>allowUpdate</code> is
                                 <code>false</code> and a <code>NodeTypeDefinition</code> within the
                                 <code>Collection</code> specifies a node type name that is already
                                 registered.
 @throws UnsupportedRepositoryOperationException
                                 if this implementation
                                 does not support node type registration.
 @throws RepositoryException     if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="unregisterNodeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Unregisters the specified node type.

 @param name a <code>String</code>.
 @throws UnsupportedRepositoryOperationException
                                 if this implementation
                                 does not support node type registration.
 @throws NoSuchNodeTypeException if no registered node type exists with
                                 the specified name.
 @throws RepositoryException     if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="unregisterNodeTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="NoSuchNodeTypeException" type="javax.jcr.nodetype.NoSuchNodeTypeException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Unregisters the specified set of node types. Used to unregister a set of
 node types with mutual dependencies.

 @param names a <code>String</code> array
 @throws UnsupportedRepositoryOperationException
                                 if this implementation
                                 does not support node type registration.
 @throws NoSuchNodeTypeException if one of the names listed is not a
                                 registered node type.
 @throws RepositoryException     if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows for the retrieval and (in implementations that support it) the
 registration of node types. Accessed via {@link Workspace#getNodeTypeManager}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeTypeManager -->
  <!-- start interface javax.jcr.nodetype.NodeTypeTemplate -->
  <interface name="NodeTypeTemplate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.NodeTypeDefinition"/>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <doc>
      <![CDATA[Sets the name of the node type. This must be a JCR name in either
 qualified or expanded form.

 @param name a JCR name.
 @throws ConstraintViolationException if <code>name</code> is not a
 syntactically valid JCR name in either qualified or expanded form.]]>
      </doc>
    </method>
    <method name="setDeclaredSuperTypeNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <doc>
      <![CDATA[Sets the names of the supertypes of the node type.
 These must be a JCR names in either
 qualified or expanded form.

 @param names an array of JCR names.
 @throws ConstraintViolationException if <code>names</code> includes a
 name that is not a syntactically valid JCR name in either qualified or expanded form.]]>
      </doc>
    </method>
    <method name="setAbstract"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="abstractStatus" type="boolean"/>
      <doc>
      <![CDATA[Sets the abstract flag of the node type.

 @param abstractStatus a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setMixin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mixin" type="boolean"/>
      <doc>
      <![CDATA[Sets the mixin flag of the node type.

 @param mixin a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setOrderableChildNodes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="orderable" type="boolean"/>
      <doc>
      <![CDATA[Sets the orderable child nodes flag of the node type.

 @param orderable a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setPrimaryItemName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <doc>
      <![CDATA[Sets the name of the primary item. This must be a JCR name in either
 qualified or expanded form.

 @param name a JCR name.
 @throws ConstraintViolationException if <code>name</code> is not a
 syntactically valid JCR name in either qualified or expanded form.]]>
      </doc>
    </method>
    <method name="setQueryable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queryable" type="boolean"/>
      <doc>
      <![CDATA[Sets the queryable status of the node type.

 @param queryable a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="getPropertyDefinitionTemplates" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a mutable <code>List</code> of <code>PropertyDefinitionTemplate</code>
 objects. To define a new <code>NodeTypeTemplate</code> or change an
 existing one, <code>PropertyDefinitionTemplate</code> objects can be
 added to or removed from this <code>List</code>.

 @return a mutable <code>List</code> of <code>PropertyDefinitionTemplate</code>
         objects.]]>
      </doc>
    </method>
    <method name="getNodeDefinitionTemplates" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a mutable <code>List</code> of <code>NodeDefinitionTemplate</code>
 objects. To define a new <code>NodeTypeTemplate</code> or change an
 existing one, <code>NodeDefinitionTemplate</code> objects can be added to
 or removed from this <code>List</code>.

 @return a mutable <code>List</code> of <code>NodeDefinitionTemplate</code>
         objects.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>NodeTypeTemplate</code> interface is used to define node types which
 are then registered through the <code>NodeTypeManager.registerNodeType</code> method.
 <p>
 <code>NodeTypeTemplate</code>, like <code>NodeType</code>, is a subclass of
 <code>NodeTypeDefinition</code> so it shares with <code>NodeType</code> those
 methods that are relevant to a static definition. In addition,
 <code>NodeTypeTemplate</code> provides methods for setting the attributes of
 the definition.
 <p>
 See the corresponding <code>get</code> methods for each attribute in
 <code>NodeTypeDefinition</code> for the default values assumed when a new
 empty <code>NodeTypeTemplate</code> is created (as opposed to one extracted
 from an existing <code>NodeType</code>).

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.NodeTypeTemplate -->
  <!-- start class javax.jcr.nodetype.NoSuchNodeTypeException -->
  <class name="NoSuchNodeTypeException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoSuchNodeTypeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchNodeTypeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="NoSuchNodeTypeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="NoSuchNodeTypeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by node type-related methods.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.nodetype.NoSuchNodeTypeException -->
  <!-- start interface javax.jcr.nodetype.PropertyDefinition -->
  <interface name="PropertyDefinition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.ItemDefinition"/>
    <method name="getRequiredType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the required type of the property. One of: <ul>
 <li><code>PropertyType.STRING</code></li> <li><code>PropertyType.DATE</code></li>
 <li><code>PropertyType.BINARY</code></li> <li><code>PropertyType.DOUBLE</code></li>
 <li><code>PropertyType.DECIMAL</code></li> <li><code>PropertyType.LONG</code></li>
 <li><code>PropertyType.BOOLEAN</code></li> <li><code>PropertyType.NAME</code></li>
 <li><code>PropertyType.PATH</code></li> <li><code>PropertyType.URI</code></li>
 <li><code>PropertyType.REFERENCE</code></li> <li><code>PropertyType.WEAKREFERENCE</code></li>
 <li><code>PropertyType.UNDEFINED</code></li> </ul>
 <code>PropertyType.UNDEFINED</code> is returned if this property may be
 of any type.
 <p>
 In implementations that support node type registration, if this
 <code>PropertyDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code>, then this method will return
 <code>PropertyType.STRING</code>.

 @return an <code>int</code> constant member of <code>PropertyType</code>.]]>
      </doc>
    </method>
    <method name="getValueConstraints" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the array of constraint strings. Each string in the array specifies
 a constraint on the value of the property. The constraints are OR-ed
 together, meaning that in order to be valid, the value must meet at least
 one of the constraints. For example, a constraint array of
 <code>["constraint1", "constraint2", "constraint3"]</code> has the
 interpretation: "the value of this property must meet at least one of
 <code>constraint1</code>, <code>constraint2 </code>or
 <code>constraint3</code>".
 <p>
 Reporting of value constraints is optional. An implementation may return
 <code>null</code>, indicating that value constraint information is
 unavailable (though a constraint may still exist).
 <p>
 Returning an empty array, on the other hand, indicates that value
 constraint information is available and that no constraints are placed on
 this value.
 <p>
 In the case of multi-value properties, the constraint string array
 returned applies to all the values of the property.
 <p>
 The constraint strings themselves having differing formats and
 interpretations depending on the type of the property in question. The
 following describes the value constraint syntax for each property type:
 <ul> <li> <code>STRING</code> and <code>URI</code>: The constraint string
 is a regular expression pattern. For example the regular expression
 "<code>.*</code>" means "any string, including the empty string". Whereas
 a simple literal string (without any RE-specific meta-characters) like
 "<code>banana</code>" matches only the string "<code>banana</code>".
 </li> <li> <code>PATH</code>: The constraint string is a <i>JCR path</i>
 with an optional "<code>*</code>" character after the last
 "<code>/</code>" character. For example, possible constraint strings for
 a property of type <code>PATH</code> include: <ol> <li>
 "<code>/myapp:products/myapp:televisions</code>" </li> <li>
 "<code>/myapp:products/myapp:televisions/</code>" </li> <li>
 "<code>/myapp:products/*</code>" </li> <li> "<code>myapp:products/myapp:televisions</code>"
 </li> <li> "<code>../myapp:televisions</code>" </li> <li>
 "<code>../myapp:televisions/*</code>" </li> </ol> The following
 principles apply: <ul> <li> The "*" means "matches descendants" not
 "matches any subsequent path". For example, <code>/a/*</code> does not
 match <code>/a/../c</code>. The constraint must match the normalized
 path. </li> <li> Relative path constraint only match relative path values
 and absolute path constraints only match absolute path values. </li> <li>
 A trailing "<code>/</code>" has no effect (hence, <code>1</code> and
 <code>2</code>, above, are equivalent). </li> <li> The trailing
 "<code>*</code>" character means that the value of the <code>PATH</code>
 property is restricted to the indicated subgraph (in other words any
 additional relative path can replace the "<code>*</code>"). For example,
 3, above would allow <code>/myapp:products/myapp:radios</code>,
 <code>/myapp:products/myapp:microwaves/X900</code>, and so forth. </li>
 <li> A constraint without a "<code>*</code>" means that the
 <code>PATH</code> property is restricted to that precise path. For
 example, <code>1</code>, above, would allow only the value
 <code>/myapp:products/myapp:televisions</code>. </li> <li> The constraint
 can indicate either a relative path or an absolute path depending on
 whether it includes a leading "<code>/</code>" character. <code>1</code>
 and <code>4</code>, above for example, are distinct. </li> <li> The
 string returned must reflect the namespace mapping in the current
 <code>Session</code> (i.e., the current state of the namespace registry
 overlaid with any session-specific mappings). Constraint strings for
 <code>PATH</code> properties should be stored in fully-qualified form
 (using the actual URI instead of the prefix) and then be converted to
 prefix form according to the current mapping upon the
 <code>PropertyDefinition.getValueConstraints</code> call. </li> </ul>
 </li> <li> <code>NAME</code>: The constraint string is a <i>JCR name</i>
 in prefix form. For example "<code>myapp:products</code>". No wildcards
 or other pattern matching are supported. As with <code>PATH</code>
 properties, the string returned must reflect the namespace mapping in the
 current <code>Session</code>. Constraint strings for <code>NAME</code>
 properties should be stored in fully-qualified form (using the actual URI
 instead of the prefix) and then be converted to prefix form according to
 the current mapping. </li> <li> <code>REFERENCE</code> and
 <code>WEAKREFERENCE</code>: The constraint string is a <i>JCR name</i> in
 prefix form. This name is interpreted as a node type name and the
 <code>REFERENCE</code> or <code>WEAKREFERENCE</code> property is
 restricted to referring only to nodes that have at least the indicated
 node type. For example, a constraint of "<code>mytype:document</code>"
 would indicate that the property in question can only refer to nodes that
 have at least the node type <code>mytype:document</code> (assuming this
 was the only constraint returned in the array, recall that the array of
 constraints are to be ORed together). No wildcards or other pattern
 matching are supported. As with <code>PATH</code> properties, the string
 returned must reflect the namespace mapping in the current
 <code>Session</code>. Constraint strings for <code>REFERENCE</code> and
 <code>WEAKREFERENCE</code> properties should be stored by the
 implementation in fully-qualified form (using the actual URI instead of
 the prefix) and then be converted to prefix form according to the current
 mapping. </li> <li> <code>BOOLEAN</code>: A constraint string can be
 either "true" or "false". In most cases <code>getValueConstraints</code>
 will return an empty array since placing a constraint on a
 <code>BOOLEAN</code> value does not usually make sense. </li> </ul> The
 remaining types all have value constraints in the form of inclusive or
 exclusive ranges: i.e., "<code>[min, max]</code>", "<code>(min,
 max)</code>", "<code>(min, max]</code>" or "<code>[min, max)</code>".
 Where "<code>[</code>" and "<code>]</code>" indicate "inclusive", while
 "<code>(</code>" and "<code>)</code>" indicate "exclusive". A missing
 <code>min</code> or <code>max</code> value indicates no bound in that
 direction. For example [,5] means no minimum but a maximum of 5
 (inclusive) while [,] means simply that any value will suffice, The
 meaning of the <code>min</code> and <code>max</code> values themselves
 differ between types as follows: <ul> <li> <code>BINARY</code>:
 <code>min</code> and <code>max</code> specify the allowed size range of
 the binary value in bytes. </li> <li> <code>DATE</code>: <code>min</code>
 and <code>max</code> are dates specifying the allowed date range. The
 date strings must be in the ISO8601-compliant format:
 <code>YYYY-MM-DDThh:mm:ss.sssTZD</code>. </li> <li> <code>LONG</code>,
 <code>DOUBLE</code>: min and max are numbers. </li> </ul> In
 implementations that support node type registration, when specifying that
 a <code>DATE</code>, <code>LONG </code>or <code>DOUBLE </code> is
 constrained to be equal to some disjunctive set of constants, a string
 consisting of just the constant itself, "c" may be used as a shorthand
 for the standard constraint notation of "[c, c]", where c is the
 constant. For example, to indicate that particular LONG property is
 constrained to be one of the values 2, 4, or 8, the constraint string
 array {"2", "4", "8"} can be used instead of the standard notation,
 {"[2,2]", "[4,4]", "[8,8]"}. However, even if this shorthand is used on
 registration, the value returned by <code>PropertyDefinition.getValueConstraints()</code>
 will always use the standard notation.
 <p>
 Because constraints are returned as an array of disjunctive constraints,
 in many cases the elements of the array can serve directly as a "choice
 list". This may, for example, be used by an application to display
 options to the end user indicating the set of permitted values.
 <p>
 In implementations that support node type registration, if this
 <code>PropertyDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code>, then this method will return
 <code>null</code>.

 @return a <code>String</code> array.]]>
      </doc>
    </method>
    <method name="getDefaultValues" return="javax.jcr.Value[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default value(s) of the property. These are the values that the
 property defined by this PropertyDefinition will be assigned if it is
 automatically created (that is, if {@link #isAutoCreated()} returns
 <code>true</code>).
 <p>
 This method returns an array of <code>Value</code> objects. If the
 property is multi-valued, then this array represents the full set of
 values that the property will be assigned upon being auto-created. Note
 that this could be the empty array. If the property is single-valued,
 then the array returned will be of size 1.
 <p>
 If <code>null</code> is returned, then the property has no fixed default
 value. This does not exclude the possibility that the property still
 assumes some value automatically, but that value may be parametrized (for
 example, "the current date") and hence not expressible as a single fixed
 value. In particular, this <i>must</i> be the case if
 <code>isAutoCreated</code> returns <code>true</code> and this method
 returns <code>null</code>.
 <p>
 Note that to indicate a <code>null</code> value for this attribute in a
 node type definition that is stored in content, the
 <code>jcr:defaultValues</code> property is simply removed (since
 <code>null</code> values for properties are not allowed.
 <p>
 In implementations that support node type registration, if this
 <code>PropertyDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code>, then this method will return
 <code>null</code>.

 @return an array of <code>Value</code> objects.]]>
      </doc>
    </method>
    <method name="isMultiple" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports whether this property can have multiple values. Note that the
 <code>isMultiple</code> flag is special in that a given node type may
 have two property definitions that are identical in every respect except
 for the their <code>isMultiple</code> status. For example, a node type
 can specify two string properties both called <code>X</code>, one of
 which is multi-valued and the other not. An example of such a node type
 is <code>nt:unstructured</code>.
 <p>
 In implementations that support node type registration, if this
 <code>PropertyDefinition</code> object is actually a newly-created empty
 <code>PropertyDefinitionTemplate</code>, then this method will return
 <code>false</code>.

 @return a <code>boolean</code>]]>
      </doc>
    </method>
    <method name="getAvailableQueryOperators" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of query comparison operators supported by this
 property.
 <p>
 This attribute only takes effect if the node type holding the property
 definition has a queryable setting of <code>true</code>.
 <p>
 JCR defines the following comparison operators: <ul> <li>{@link
 javax.jcr.query.qom.QueryObjectModelConstants#JCR_OPERATOR_EQUAL_TO},</li>
 <li>{@link javax.jcr.query.qom.QueryObjectModelConstants#JCR_OPERATOR_NOT_EQUAL_TO},</li>
 <li>{@link javax.jcr.query.qom.QueryObjectModelConstants#JCR_OPERATOR_LESS_THAN},</li>
 <li>{@link javax.jcr.query.qom.QueryObjectModelConstants#JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO},</li>
 <li>{@link javax.jcr.query.qom.QueryObjectModelConstants#JCR_OPERATOR_GREATER_THAN},</li>
 <li>{@link javax.jcr.query.qom.QueryObjectModelConstants#JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO},
 or</li> <li>{@link javax.jcr.query.qom.QueryObjectModelConstants#JCR_OPERATOR_LIKE}</li>
 </ul> An implementation may define additional comparison operators.
 <p>
 Note that the set of operators that can appear in this attribute may be
 limited by implementation-specific constraints that differ across
 property types. For example, some implementations may permit property
 definitions to provide <code>JCR_OPERATOR_EQUAL_TO</code> and
 <code>JCR_OPERATOR_NOT_EQUAL_TO</code> as available operators for
 <code>BINARY</code> properties while others may not.
 <p>
 However, in all cases where a JCR-defined operator <i>is</i> potentially
 available for a given property type, its behavior must conform to the
 comparison semantics defined in the specification document (see 3.6.5
 <i>Comparison of Values</i>).
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return an impementation-
 determined default set of operator constants.

 @return a <code>String</code> array.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isFullTextSearchable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this property is full-text searchable,
 meaning that its value is accessible through the full-text search
 function within a query.
 <p>
 This attribute only takes effect if the node type holding the property
 definition has a queryable setting of <code>true</code>.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return an impementation-
 determined default value.

 @return a <code>boolean</code>
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isQueryOrderable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if this property is query-orderable, meaning
 that query results may be ordered by this property using the order-by
 clause of a query.
 <p>
 This attribute only takes effect if the node type holding the property
 definition has a queryable setting of <code>true</code>.
 <p>
 In implementations that support node type registration, if this
 <code>NodeTypeDefinition</code> object is actually a newly-created empty
 <code>NodeTypeTemplate</code>, then this method will return an impementation-
 determined default value.

 @return a <code>boolean</code>
 @since JCR 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A property definition. Used in node type definitions.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.PropertyDefinition -->
  <!-- start interface javax.jcr.nodetype.PropertyDefinitionTemplate -->
  <interface name="PropertyDefinitionTemplate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.nodetype.PropertyDefinition"/>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <doc>
      <![CDATA[Sets the name of the property. This must be a JCR name in either
 qualified or expanded form.

 @param name a JCR name.
 @throws ConstraintViolationException if <code>name</code> is not a
 syntactically valid JCR name in either qualified or expanded form.]]>
      </doc>
    </method>
    <method name="setAutoCreated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="autoCreated" type="boolean"/>
      <doc>
      <![CDATA[Sets the auto-create status of the property.

 @param autoCreated a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setMandatory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mandatory" type="boolean"/>
      <doc>
      <![CDATA[Sets the mandatory status of the property.

 @param mandatory a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setOnParentVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="opv" type="int"/>
      <doc>
      <![CDATA[Sets the on-parent-version status of the property.

 @param opv an <code>int</code> constant member of
            <code>OnParentVersionAction</code>.]]>
      </doc>
    </method>
    <method name="setProtected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protectedStatus" type="boolean"/>
      <doc>
      <![CDATA[Sets the protected status of the property.

 @param protectedStatus a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setRequiredType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="int"/>
      <doc>
      <![CDATA[Sets the required type of the property.

 @param type an <code>int</code> constant member of
             <code>PropertyType</code>.]]>
      </doc>
    </method>
    <method name="setValueConstraints"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constraints" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Sets the value constraints of the property.

 @param constraints a <code>String</code> array.]]>
      </doc>
    </method>
    <method name="setDefaultValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultValues" type="javax.jcr.Value[]"/>
      <doc>
      <![CDATA[Sets the default value (or values, in the case of a multi-value property)
 of the property.

 @param defaultValues a <code>Value</code> array.]]>
      </doc>
    </method>
    <method name="setMultiple"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiple" type="boolean"/>
      <doc>
      <![CDATA[Sets the multi-value status of the property.

 @param multiple a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setAvailableQueryOperators"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operators" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Sets the queryable status of the property.

 @param operators an array of String constants. See {@link
                  PropertyDefinition#getAvailableQueryOperators()} .]]>
      </doc>
    </method>
    <method name="setFullTextSearchable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fullTextSearchable" type="boolean"/>
      <doc>
      <![CDATA[Sets the full-text-searchable status of the property.

 @param fullTextSearchable a <code>boolean</code>.]]>
      </doc>
    </method>
    <method name="setQueryOrderable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queryOrderable" type="boolean"/>
      <doc>
      <![CDATA[Sets the query-orderable status of the property.

 @param queryOrderable a <code>boolean</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>PropertyDefinitionTemplate</code> interface extends
 <code>PropertyDefinition</code> with the addition of write methods, enabling
 the characteristics of a child property definition to be set, after which the
 <code>PropertyDefinitionTemplate</code> is added to a
 <code>NodeTypeTemplate</code>.
 <p>
 See the corresponding <code>get</code> methods for each attribute in
 <code>PropertyDefinition</code> for the default values assumed when a new
 empty <code>PropertyDefinitionTemplate</code> is created (as opposed to one
 extracted from an existing <code>NodeType</code>).

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.nodetype.PropertyDefinitionTemplate -->
  <doc>
  <![CDATA[This package provides interfaces and classes for content repository node type functionality.
<br>
<br>
The following node types are defined by the JCR 2.0 specification.
Consult the specification document for details on their use.
<ul class='toc'>
<li><a class='nt_link' href='#mix:created'>mix:created</a></li>
<li><a class='nt_link' href='#mix:etag'>mix:etag</a></li>
<li><a class='nt_link' href='#mix:language'>mix:language</a></li>
<li><a class='nt_link' href='#mix:lastModified'>mix:lastModified</a></li>
<li><a class='nt_link' href='#mix:lifecycle'>mix:lifecycle</a></li>
<li><a class='nt_link' href='#mix:lockable'>mix:lockable</a></li>
<li><a class='nt_link' href='#mix:mimeType'>mix:mimeType</a></li>
<li><a class='nt_link' href='#mix:referenceable'>mix:referenceable</a></li>
<li><a class='nt_link' href='#mix:shareable'>mix:shareable</a></li>
<li><a class='nt_link' href='#mix:simpleVersionable'>mix:simpleVersionable</a></li>
<li><a class='nt_link' href='#mix:title'>mix:title</a></li>
<li><a class='nt_link' href='#mix:versionable'>mix:versionable</a></li>
<li><a class='nt_link' href='#nt:activity'>nt:activity</a></li>
<li><a class='nt_link' href='#nt:address'>nt:address</a></li>
<li><a class='nt_link' href='#nt:base'>nt:base</a></li>
<li><a class='nt_link' href='#nt:childNodeDefinition'>nt:childNodeDefinition</a></li>
<li><a class='nt_link' href='#nt:configuration'>nt:configuration</a></li>
<li><a class='nt_link' href='#nt:file'>nt:file</a></li>
<li><a class='nt_link' href='#nt:folder'>nt:folder</a></li>
<li><a class='nt_link' href='#nt:frozenNode'>nt:frozenNode</a></li>
<li><a class='nt_link' href='#nt:hierarchyNode'>nt:hierarchyNode</a></li>
<li><a class='nt_link' href='#nt:linkedFile'>nt:linkedFile</a></li>
<li><a class='nt_link' href='#nt:nodeType'>nt:nodeType</a></li>
<li><a class='nt_link' href='#nt:propertyDefinition'>nt:propertyDefinition</a></li>
<li><a class='nt_link' href='#nt:query'>nt:query</a></li>
<li><a class='nt_link' href='#nt:resource'>nt:resource</a></li>
<li><a class='nt_link' href='#nt:unstructured'>nt:unstructured</a></li>
<li><a class='nt_link' href='#nt:version'>nt:version</a></li>
<li><a class='nt_link' href='#nt:versionHistory'>nt:versionHistory</a></li>
<li><a class='nt_link' href='#nt:versionLabels'>nt:versionLabels</a></li>
<li><a class='nt_link' href='#nt:versionedChild'>nt:versionedChild</a></li>
</ul>
The node types are defined in CND notation, see the specification for information on this notation<br><br>
<div class='cnd'>
<span class='namespace'>&lt;'mix'='http://www.jcp.org/jcr/mix/1.0'&gt;</span><br>
<span class='namespace'>&lt;'jcr'='http://www.jcp.org/jcr/1.0'&gt;</span><br>
<span class='namespace'>&lt;'nt'='http://www.jcp.org/jcr/nt/1.0'&gt;</span><br>
<span class='namespace'>&lt;'rep'='internal'&gt;</span><br>
<br>
<a name='mix:created'></a>[<span class='nt_name'>mix:created</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:created</span> (<span class='prop_type'>DATE</span>)<span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:createdBy</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> PROTECTED</span><br>
<br>
<a name='mix:etag'></a>[<span class='nt_name'>mix:etag</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:etag</span> (<span class='prop_type'>STRING</span>) = '<span class='prop_value'></span>'<span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span><br>
<br>
<a name='mix:language'></a>[<span class='nt_name'>mix:language</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:language</span> (<span class='prop_type'>STRING</span>)<br>
<br>
<a name='mix:lastModified'></a>[<span class='nt_name'>mix:lastModified</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:lastModified</span> (<span class='prop_type'>DATE</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:lastModifiedBy</span> (<span class='prop_type'>STRING</span>)<br>
<br>
<a name='mix:lifecycle'></a>[<span class='nt_name'>mix:lifecycle</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:lifecyclePolicy</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>INITIALIZE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:currentLifecycleState</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>INITIALIZE</span><br>
<br>
<a name='mix:lockable'></a>[<span class='nt_name'>mix:lockable</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:lockOwner</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>IGNORE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:lockIsDeep</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>IGNORE</span><br>
<br>
<a name='mix:mimeType'></a>[<span class='nt_name'>mix:mimeType</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:mimeType</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:encoding</span> (<span class='prop_type'>STRING</span>)<br>
<br>
<a name='mix:referenceable'></a>[<span class='nt_name'>mix:referenceable</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:uuid</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>INITIALIZE</span><br>
<br>
<a name='mix:shareable'></a>[<span class='nt_name'>mix:shareable</span>] &gt; <a class='nt_link' href='#mix:referenceable'>mix:referenceable</a><br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
<br>
<a name='mix:simpleVersionable'></a>[<span class='nt_name'>mix:simpleVersionable</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:isCheckedOut</span> (<span class='prop_type'>BOOLEAN</span>) = '<span class='prop_value'>true</span>'<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>IGNORE</span><br>
<br>
<a name='mix:title'></a>[<span class='nt_name'>mix:title</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:title</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:description</span> (<span class='prop_type'>STRING</span>)<br>
<br>
<a name='mix:versionable'></a>[<span class='nt_name'>mix:versionable</span>] &gt; <a class='nt_link' href='#mix:referenceable'>mix:referenceable</a>, <a class='nt_link' href='#mix:simpleVersionable'>mix:simpleVersionable</a><br>
&nbsp;&nbsp;<span class='nt_option'>MIXIN</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:versionHistory</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span> <span class='opv'>IGNORE</span> &lt; '<span class='prop_constraint'>nt:versionHistory</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:baseVersion</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span> <span class='opv'>IGNORE</span> &lt; '<span class='prop_constraint'>nt:version</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:predecessors</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span> <span class='prop_option'> MULTIPLE</span> <span class='opv'>IGNORE</span> &lt; '<span class='prop_constraint'>nt:version</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:mergeFailed</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span> <span class='opv'>ABORT</span> &lt; '<span class='prop_constraint'>nt:version</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:activity</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>IGNORE</span> &lt; '<span class='prop_constraint'>nt:activity</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:configuration</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>IGNORE</span> &lt; '<span class='prop_constraint'>nt:configuration</span>'<br>
<br>
<a name='nt:activity'></a>[<span class='nt_name'>nt:activity</span>] &gt; <a class='nt_link' href='#mix:referenceable'>mix:referenceable</a><br>
&nbsp;&nbsp;- <span class='name'>jcr:activityTitle</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span><br>
<br>
<a name='nt:address'></a>[<span class='nt_name'>nt:address</span>]<br>
&nbsp;&nbsp;- <span class='name'>jcr:protocol</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:host</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:port</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:repository</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:workspace</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:path</span> (<span class='prop_type'>PATH</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:id</span> (<span class='prop_type'>WEAKREFERENCE</span>)<br>
<br>
<a name='nt:base'></a>[<span class='nt_name'>nt:base</span>]<br>
&nbsp;&nbsp;- <span class='name'>jcr:primaryType</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>COMPUTE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:mixinTypes</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span> <span class='opv'>COMPUTE</span><br>
<br>
<a name='nt:childNodeDefinition'></a>[<span class='nt_name'>nt:childNodeDefinition</span>]<br>
&nbsp;&nbsp;- <span class='name'>jcr:name</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:autoCreated</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:mandatory</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:onParentVersion</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span> &lt; '<span class='prop_constraint'>COPY</span>', '<span class='prop_constraint'>VERSION</span>', '<span class='prop_constraint'>INITIALIZE</span>', '<span class='prop_constraint'>COMPUTE</span>', '<span class='prop_constraint'>IGNORE</span>', '<span class='prop_constraint'>ABORT</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:protected</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:requiredPrimaryTypes</span> (<span class='prop_type'>NAME</span>) = '<span class='prop_value'>nt:base</span>'<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:defaultPrimaryType</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:sameNameSiblings</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
<br>
<a name='nt:configuration'></a>[<span class='nt_name'>nt:configuration</span>] &gt; <a class='nt_link' href='#mix:versionable'>mix:versionable</a><br>
&nbsp;&nbsp;- <span class='name'>jcr:root</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span><br>
<br>
<a name='nt:file'></a>[<span class='nt_name'>nt:file</span>] &gt; <a class='nt_link' href='#nt:hierarchyNode'>nt:hierarchyNode</a><br>
&nbsp;&nbsp;<span class='nt_option'>PRIMARYITEM</span> <span class='nt_option'>JCR:CONTENT</span><br>
&nbsp;&nbsp;+ <span class='name'>jcr:content</span> (<a class='nt_link' href='#nt:base'>nt:base</a>)<span class='node_option'> MANDATORY</span><br>
<br>
<a name='nt:folder'></a>[<span class='nt_name'>nt:folder</span>] &gt; <a class='nt_link' href='#nt:hierarchyNode'>nt:hierarchyNode</a><br>
&nbsp;&nbsp;+ * (<a class='nt_link' href='#nt:hierarchyNode'>nt:hierarchyNode</a>) <span class='opv'>VERSION</span><br>
<br>
<a name='nt:frozenNode'></a>[<span class='nt_name'>nt:frozenNode</span>] &gt; <a class='nt_link' href='#mix:referenceable'>mix:referenceable</a><br>
&nbsp;&nbsp;<span class='nt_option'>ORDERABLE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:frozenPrimaryType</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:frozenMixinTypes</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:frozenUuid</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;- * (<span class='prop_type'>UNDEFINED</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;- * (<span class='prop_type'>UNDEFINED</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;+ * (<a class='nt_link' href='#nt:base'>nt:base</a>)<span class='node_option'> PROTECTED</span><span class='node_option'> SNS</span> <span class='opv'>ABORT</span><br>
<br>
<a name='nt:hierarchyNode'></a>[<span class='nt_name'>nt:hierarchyNode</span>] &gt; <a class='nt_link' href='#mix:created'>mix:created</a><br>
<br>
<a name='nt:linkedFile'></a>[<span class='nt_name'>nt:linkedFile</span>] &gt; <a class='nt_link' href='#nt:hierarchyNode'>nt:hierarchyNode</a><br>
&nbsp;&nbsp;<span class='nt_option'>PRIMARYITEM</span> <span class='nt_option'>JCR:CONTENT</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:content</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> MANDATORY</span><br>
<br>
<a name='nt:nodeType'></a>[<span class='nt_name'>nt:nodeType</span>]<br>
&nbsp;&nbsp;- <span class='name'>jcr:nodeTypeName</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:supertypes</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:isAbstract</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:isQueryable</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:isMixin</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:hasOrderableChildNodes</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:primaryItemName</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;+ <span class='name'>jcr:propertyDefinition</span> (<a class='nt_link' href='#nt:propertyDefinition'>nt:propertyDefinition</a>) = <a class='nt_link' href='#nt:propertyDefinition'>nt:propertyDefinition</a><span class='node_option'> PROTECTED</span><span class='node_option'> SNS</span><br>
&nbsp;&nbsp;+ <span class='name'>jcr:childNodeDefinition</span> (<a class='nt_link' href='#nt:childNodeDefinition'>nt:childNodeDefinition</a>) = <a class='nt_link' href='#nt:childNodeDefinition'>nt:childNodeDefinition</a><span class='node_option'> PROTECTED</span><span class='node_option'> SNS</span><br>
<br>
<a name='nt:propertyDefinition'></a>[<span class='nt_name'>nt:propertyDefinition</span>]<br>
&nbsp;&nbsp;- <span class='name'>jcr:name</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:autoCreated</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:mandatory</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:onParentVersion</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span> &lt; '<span class='prop_constraint'>COPY</span>', '<span class='prop_constraint'>VERSION</span>', '<span class='prop_constraint'>INITIALIZE</span>', '<span class='prop_constraint'>COMPUTE</span>', '<span class='prop_constraint'>IGNORE</span>', '<span class='prop_constraint'>ABORT</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:protected</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:requiredType</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span> &lt; '<span class='prop_constraint'>STRING</span>', '<span class='prop_constraint'>URI</span>', '<span class='prop_constraint'>BINARY</span>', '<span class='prop_constraint'>LONG</span>', '<span class='prop_constraint'>DOUBLE</span>', '<span class='prop_constraint'>DECIMAL</span>', '<span class='prop_constraint'>BOOLEAN</span>', '<span class='prop_constraint'>DATE</span>', '<span class='prop_constraint'>NAME</span>', '<span class='prop_constraint'>PATH</span>', '<span class='prop_constraint'>REFERENCE</span>', '<span class='prop_constraint'>WEAKREFERENCE</span>', '<span class='prop_constraint'>UNDEFINED</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:valueConstraints</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:defaultValues</span> (<span class='prop_type'>UNDEFINED</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:multiple</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:availableQueryOperators</span> (<span class='prop_type'>NAME</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:isFullTextSearchable</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:isQueryOrderable</span> (<span class='prop_type'>BOOLEAN</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> PROTECTED</span><br>
<br>
<a name='nt:query'></a>[<span class='nt_name'>nt:query</span>]<br>
&nbsp;&nbsp;- <span class='name'>jcr:statement</span> (<span class='prop_type'>STRING</span>)<br>
&nbsp;&nbsp;- <span class='name'>jcr:language</span> (<span class='prop_type'>STRING</span>)<br>
<br>
<a name='nt:resource'></a>[<span class='nt_name'>nt:resource</span>] &gt; <a class='nt_link' href='#mix:lastModified'>mix:lastModified</a>, <a class='nt_link' href='#mix:mimeType'>mix:mimeType</a><br>
&nbsp;&nbsp;<span class='nt_option'>PRIMARYITEM</span> <span class='nt_option'>JCR:DATA</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:data</span> (<span class='prop_type'>BINARY</span>)<span class='prop_option'> MANDATORY</span><br>
<br>
<a name='nt:unstructured'></a>[<span class='nt_name'>nt:unstructured</span>]<br>
&nbsp;&nbsp;<span class='nt_option'>ORDERABLE</span><br>
&nbsp;&nbsp;- * (<span class='prop_type'>UNDEFINED</span>)<span class='prop_option'> MULTIPLE</span><br>
&nbsp;&nbsp;- * (<span class='prop_type'>UNDEFINED</span>)<br>
&nbsp;&nbsp;+ * (<a class='nt_link' href='#nt:base'>nt:base</a>) = <a class='nt_link' href='#nt:unstructured'>nt:unstructured</a><span class='node_option'> SNS</span> <span class='opv'>VERSION</span><br>
<br>
<a name='nt:version'></a>[<span class='nt_name'>nt:version</span>] &gt; <a class='nt_link' href='#mix:referenceable'>mix:referenceable</a><br>
&nbsp;&nbsp;- <span class='name'>jcr:created</span> (<span class='prop_type'>DATE</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:predecessors</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span> <span class='opv'>ABORT</span> &lt; '<span class='prop_constraint'>nt:version</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:successors</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span><span class='prop_option'> MULTIPLE</span> <span class='opv'>ABORT</span> &lt; '<span class='prop_constraint'>nt:version</span>'<br>
&nbsp;&nbsp;- <span class='name'>jcr:activity</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span> &lt; '<span class='prop_constraint'>nt:activity</span>'<br>
&nbsp;&nbsp;+ <span class='name'>jcr:frozenNode</span> (<a class='nt_link' href='#nt:frozenNode'>nt:frozenNode</a>)<span class='node_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
<br>
<a name='nt:versionHistory'></a>[<span class='nt_name'>nt:versionHistory</span>] &gt; <a class='nt_link' href='#mix:referenceable'>mix:referenceable</a><br>
&nbsp;&nbsp;- <span class='name'>jcr:versionableUuid</span> (<span class='prop_type'>STRING</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;- <span class='name'>jcr:copiedFrom</span> (<span class='prop_type'>WEAKREFERENCE</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span> &lt; '<span class='prop_constraint'>nt:version</span>'<br>
&nbsp;&nbsp;+ <span class='name'>jcr:rootVersion</span> (<a class='nt_link' href='#nt:version'>nt:version</a>) = <a class='nt_link' href='#nt:version'>nt:version</a><span class='node_option'> MANDATORY</span><span class='node_option'> AUTOCREATED</span><span class='node_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;+ <span class='name'>jcr:versionLabels</span> (<a class='nt_link' href='#nt:versionLabels'>nt:versionLabels</a>) = <a class='nt_link' href='#nt:versionLabels'>nt:versionLabels</a><span class='node_option'> MANDATORY</span><span class='node_option'> AUTOCREATED</span><span class='node_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
&nbsp;&nbsp;+ * (<a class='nt_link' href='#nt:version'>nt:version</a>) = <a class='nt_link' href='#nt:version'>nt:version</a><span class='node_option'> PROTECTED</span> <span class='opv'>ABORT</span><br>
<br>
<a name='nt:versionLabels'></a>[<span class='nt_name'>nt:versionLabels</span>]<br>
&nbsp;&nbsp;- * (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span> &lt; '<span class='prop_constraint'>nt:version</span>'<br>
<br>
<a name='nt:versionedChild'></a>[<span class='nt_name'>nt:versionedChild</span>]<br>
&nbsp;&nbsp;- <span class='name'>jcr:childVersionHistory</span> (<span class='prop_type'>REFERENCE</span>)<span class='prop_option'> MANDATORY</span><span class='prop_option'> AUTOCREATED</span><span class='prop_option'> PROTECTED</span> <span class='opv'>ABORT</span> &lt; '<span class='prop_constraint'>nt:versionHistory</span>'<br>
<br>
</div>]]>
  </doc>
</package>
<package name="javax.jcr.observation">
  <!-- start interface javax.jcr.observation.Event -->
  <interface name="Event"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of this event: a constant defined by this interface. One
 of: <ul> <li><code>NODE_ADDED</code></li> <li><code>NODE_REMOVED</code></li>
 <li><code>PROPERTY_ADDED</code></li> <li><code>PROPERTY_REMOVED</code></li>
 <li><code>PROPERTY_CHANGED</code></li> <li><code>NODE_MOVED</code></li>
 <li><code>PERSIST</code></li> </ul>

 @return the type of this event.]]>
      </doc>
    </method>
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the absolute path associated with this event or <code>null</code>
 if this event has no associated identifier. The meaning of the associated
 path depends upon the type of the event. See event type constants above.

 @return the absolute path associated with this event or
         <coe>null</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getUserID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user ID connected with this event. This is the string
 returned by {@link javax.jcr.Session#getUserID} of the session that
 caused the event.

 @return the user ID.]]>
      </doc>
    </method>
    <method name="getIdentifier" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the identifier associated with this event or <code>null</code> if
 this event has no associated identifier. The meaning of the associated
 identifier depends upon the type of the event. See event type constants
 above.

 @return the identifier associated with this event or <code>null</code>.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getInfo" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the information map associated with this event. The meaning of
 the map depends upon the type of the event. See event type constants
 above.

 @return A <code>Map</code> containing parameter information for instances
         of a <code>NODE_MOVED</code> event.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getUserData" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the user data set through {@link ObservationManager#setUserData}
 on the <code>ObservationManager</code> bound to the <code>Session</code>
 that caused the event.

 @return The user data string.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getDate" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the date when the change was persisted that caused this event.
 The date is represented as a millisecond value that is an offset from the
 Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). The granularity of
 the returned value is implementation dependent.

 @return the date when the change was persisted that caused this event.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <field name="NODE_ADDED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generated on persist when a node is added. <ul> <li>{@link #getPath}
 returns the absolute path of the node that was added.</li> <li>{@link
 #getIdentifier} returns the identifier of the node that was added.</li>
 <li>{@link #getInfo} returns an empty <code>Map</code> object.</li>
 </ul>]]>
      </doc>
    </field>
    <field name="NODE_REMOVED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generated on persist when a node is removed. <ul> <li>{@link #getPath}
 returns the absolute path of the node that was removed.</li> <li>{@link
 #getIdentifier} returns the identifier of the node that was removed.</li>
 <li>{@link #getInfo} returns an empty <code>Map</code> object.</li>
 </ul>]]>
      </doc>
    </field>
    <field name="PROPERTY_ADDED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generated on persist when a property is added. <ul> <li>{@link #getPath}
 returns the absolute path of the property that was added.</li> <li>{@link
 #getIdentifier} returns the identifier of the parent node of the property
 that was added. <li>{@link #getInfo} returns an empty <code>Map</code>
 object.</li> </ul>]]>
      </doc>
    </field>
    <field name="PROPERTY_REMOVED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generated on persist when a property is removed. <ul> <li>{@link
 #getPath} returns the absolute path of the property that was
 removed.</li> <li>{@link #getIdentifier} returns the identifier of the
 parent node of the property that was removed. <li>{@link #getInfo}
 returns an empty <code>Map</code> object.</li> </ul>]]>
      </doc>
    </field>
    <field name="PROPERTY_CHANGED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generated on persist when a property is changed. <ul> <li>{@link
 #getPath} returns the absolute path of the property that was
 changed.</li> <li>{@link #getIdentifier} returns the identifier of the
 parent node of the property that was changed. <li>{@link #getInfo}
 returns an empty <code>Map</code> object.</li> </ul>]]>
      </doc>
    </field>
    <field name="NODE_MOVED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generated on persist when a node is moved. <ul> <li>{@link #getPath}
 returns the absolute path of the destination of the move.</li> <li>{@link
 #getIdentifier} returns the identifier of the moved node. <li> {@link
 #getInfo} If the method that caused this event was a {@link
 javax.jcr.Session#move Session.move} or {@link javax.jcr.Workspace#move
 Workspace.move} then the returned {@link java.util.Map Map} has keys
 <code>srcAbsPath</code> and <code>destAbsPath</code> with values
 corresponding to the parameters passed to the <code>move</code> method.
 <p>
 If the method that caused this event was a {@link
 javax.jcr.Node#orderBefore Node.orderBefore} then the returned
 <code>Map</code> has keys <code>srcChildRelPath</code> and
 <code>destChildRelPath</code> with values corresponding to the parameters
 passed to the <code>orderBefore</code> method. </li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="PERSIST" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If event bundling is supported, this event is used to indicate a bundle
 boundary within the event journal. <ul> <li>{@link #getPath} returns
 <code>null</code>.</li> <li>{@link #getIdentifier} returns
 <code>null</code>.</li> <li>{@link #getInfo} returns an empty
 <code>Map</code> object.</li> </ul>

 @since JCR 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An event fired by the observation mechanism.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.Event -->
  <!-- start interface javax.jcr.observation.EventIterator -->
  <interface name="EventIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextEvent" return="javax.jcr.observation.Event"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Event</code> in the iteration.

 @return the next <code>Event</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>Event</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Event</code>s with
 <code>nextEvent</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.EventIterator -->
  <!-- start interface javax.jcr.observation.EventJournal -->
  <interface name="EventJournal"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.observation.EventIterator"/>
    <method name="skipTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="long"/>
      <doc>
      <![CDATA[Skip all elements of the iterator earlier than <code>date</code>.
 <p>
 If an attempt is made to skip past the last element of the iterator, no
 exception is thrown but the subsequent {@link #nextEvent()} will fail.

 @param date a long value that represents an offset in milliseconds from
             the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An <code>EventJournal</code> is an extension of <code>EventIterator</code>
 that provides the additional method {@link #skipTo(long)}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.EventJournal -->
  <!-- start interface javax.jcr.observation.EventListener -->
  <interface name="EventListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onEvent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="events" type="javax.jcr.observation.EventIterator"/>
      <doc>
      <![CDATA[This method is called when a bundle of events is dispatched.

 @param events The event set received.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An event listener.
 <p>
 An <code>EventListener</code> can be registered via the <code>{@link
 javax.jcr.observation.ObservationManager}</code> object. Event listeners are
 notified asynchronously, and see events after they occur and the transaction
 is committed. An event listener only sees events for which the session that
 registered it has sufficient access rights.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.EventListener -->
  <!-- start interface javax.jcr.observation.EventListenerIterator -->
  <interface name="EventListenerIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextEventListener" return="javax.jcr.observation.EventListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>EventListener</code> in the iteration.

 @return the next <code>EventListener</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>EventListener</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>EventListener</code>s with
 <code>nextEventListener</code> as well as a <code>skip</code> method
 inherited from <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.EventListenerIterator -->
  <!-- start interface javax.jcr.observation.ObservationManager -->
  <interface name="ObservationManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addEventListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="javax.jcr.observation.EventListener"/>
      <param name="eventTypes" type="int"/>
      <param name="absPath" type="java.lang.String"/>
      <param name="isDeep" type="boolean"/>
      <param name="uuid" type="java.lang.String[]"/>
      <param name="nodeTypeName" type="java.lang.String[]"/>
      <param name="noLocal" type="boolean"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds an event listener that listens for the specified
 <code>eventTypes</code> (a combination of one or more event types encoded
 as a bit mask value).
 <p>
 The set of events will be further filtered by the access rights of the
 current <code>Session</code> as well as the restrictions specified by the
 parameters of this method. These restrictions are stated in terms of
 characteristics of the <i>associated parent node</i> of the event.
 <p>
 The associated parent node of an event is the parent node of the item at
 (or formerly at) the path returned by {@link Event#getPath}. The
 following restrictions are available: <ul> <li> <code>absPath</code>,
 <code>isDeep</code>: Only events whose associated parent node is at
 <code>absPath</code> (or within its subgraph, if <code>isDeep</code> is
 <code>true</code>) will be received. It is permissible to register a
 listener for a path where no node currently exists. </li> <li>
 <code>uuid</code>: Only events whose associated parent node has one of
 the identifiers in this list will be received. If his parameter is
 <code>null</code> then no identifier-related restriction is placed on
 events received. Note that specifying an empty array instead of
 <code>null</code> would result in no nodes being listened to. The term
 "UUID" is used for compatibility with JCR 1.0. </li> <li>
 <code>nodeTypeName</code>: Only events whose associated parent node has
 one of the node types (or a subtype of one of the node types) in this
 list will be received. If his parameter is <code>null</code> then no node
 type-related restriction is placed on events received. Note that
 specifying an empty array instead of <code>null</code> would result in no
 nodes types being listened to. </li> </ul> The restrictions are "ANDed"
 together. In other words, for a particular node to be "listened to" it
 must meet all the restrictions.
 <p>
 Additionally, if <code>noLocal</code> is <code>true</code>, then events
 generated by the session through which the listener was registered are
 ignored. Otherwise, they are not ignored.
 <p>
 The filters of an already-registered <code>EventListener</code> can be
 changed at runtime by re-registering the same <code>EventListener</code>
 object (i.e. the same actual Java object) with a new set of filter
 arguments. The implementation must ensure that no events are lost during
 the changeover.
 <p>
 In addition to the filters placed on a listener above, the scope of
 observation support, in terms of which subgraphs are observable, may also
 be subject to implementation-specific restrictions. For example, in some
 repositories observation of changes in the <code>jcr:system</code>
 subgraph may not be supported

 @param listener     an {@link EventListener} object.
 @param eventTypes   A combination of one or more event type constants
                     encoded as a bitmask.
 @param absPath      an absolute path.
 @param isDeep       a <code>boolean</code>.
 @param uuid         array of identifiers.
 @param nodeTypeName array of node type names.
 @param noLocal      a <code>boolean</code>.
 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <method name="removeEventListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="javax.jcr.observation.EventListener"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Deregisters an event listener.
 <p>
 A listener may be deregistered while it is being executed. The
 deregistration method will block until the listener has completed
 executing. An exception to this rule is a listener which deregisters
 itself from within the <code>onEvent</code> method. In this case, the
 deregistration method returns immediately, but deregistration will
 effectively be delayed until the listener completes.

 @param listener The listener to deregister.
 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <method name="getRegisteredEventListeners" return="javax.jcr.observation.EventListenerIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all event listeners that have been registered through this
 session. If no listeners have been registered, an empty iterator is
 returned.

 @return an <code>EventListenerIterator</code>.
 @throws RepositoryException If an error occurs]]>
      </doc>
    </method>
    <method name="setUserData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="userData" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the user data information that will be returned by {@link
 Event#getUserData}.

 @param userData the user data
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getEventJournal" return="javax.jcr.observation.EventJournal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves the event journal for this workspace. If journaled observation
 is not supported for this workspace, <code>null</code> is returned.
 Events recorded in the <code>EventJournal</code> instance will be
 filtered according to the current session's access rights as well as any
 additional restrictions specified through implemention-specific
 configuration.

 @return an <code>EventJournal</code> or <code>null</code>.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getEventJournal" return="javax.jcr.observation.EventJournal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eventTypes" type="int"/>
      <param name="absPath" type="java.lang.String"/>
      <param name="isDeep" type="boolean"/>
      <param name="uuid" type="java.lang.String[]"/>
      <param name="nodeTypeName" type="java.lang.String[]"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves the event journal for this workspace.
 <p>
 If journaled observation
 is not supported for this workspace, <code>null</code> is returned.
 <p>
 Events returned in the <code>EventJournal</code> instance will be
 filtered according to the parameters of this method,
 the current session's access restrictions as well as any
 additional restrictions specified through implemention-specific
 configuration.
 <p>
 The parameters of this method filter the event set in the same way as
 they do in {@link #addEventListener}.

 @param eventTypes   A combination of one or more event type constants encoded as a bitmask.
 @param absPath      an absolute path.
 @param isDeep       a <code>boolean</code>.
 @param uuid         array of identifiers.
 @param nodeTypeName array of node type names.

 @return an <code>EventJournal</code> or <code>null</code>.
 @throws RepositoryException If an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The ObservationManager object.
 <p>
 Acquired via <code>{@link javax.jcr.Workspace#getObservationManager()}</code>.
 Allows for the registration and deregistration of event listeners.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.observation.ObservationManager -->
  <doc>
  <![CDATA[Provides interfaces and classes for content repository event observation
functionality.]]>
  </doc>
</package>
<package name="javax.jcr.query">
  <!-- start class javax.jcr.query.InvalidQueryException -->
  <class name="InvalidQueryException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidQueryException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="InvalidQueryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="InvalidQueryException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="InvalidQueryException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown by methods of <code>Query</code>.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.query.InvalidQueryException -->
  <!-- start interface javax.jcr.query.Query -->
  <interface name="Query"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="execute" return="javax.jcr.query.QueryResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Executes this query and returns a <code>{@link QueryResult}</code>
 object.
 <p>
 If this <code>Query</code> contains a variable (see {@link
 javax.jcr.query.qom.BindVariableValue BindVariableValue}) which has not
 been bound to a value (see {@link Query#bindValue}) then this method
 throws an <code>InvalidQueryException</code>.

 @return a <code>QueryResult</code> object
 @throws InvalidQueryException if the query contains an unbound variable.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="setLimit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="long"/>
      <doc>
      <![CDATA[Sets the maximum size of the result set to <code>limit</code>.

 @param limit a <code>long</code>
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="setOffset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <doc>
      <![CDATA[Sets the start offset of the result set to <code>offset</code>.

 @param offset a <code>long</code>
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getStatement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the statement defined for this query.
 <p>
 If the language of this query is JCR-SQL2 or another string-based
 language, this method will return the statement that was used to create
 this query.
 <p>
 If the language of this query is JCR-JQOM, this method will return the
 JCR-SQL2 equivalent of the JCR-JQOM object tree. This is the standard
 serialization of JCR-JQOM and is also the string stored in the
 <code>jcr:statement</code> property if the query is persisted. See {@link
 #storeAsNode(String)}.

 @return the query statement.]]>
      </doc>
    </method>
    <method name="getLanguage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the language set for this query. This will be one of the query
 language constants returned by {@link QueryManager#getSupportedQueryLanguages}.

 @return the query language.]]>
      </doc>
    </method>
    <method name="getStoredQueryPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[If this is a <code>Query</code> object that has been stored using {@link
 Query#storeAsNode} (regardless of whether it has been <code>save</code>d
 yet) or retrieved using {@link QueryManager#getQuery}), then this method
 returns the path of the <code>nt:query</code> node that stores the
 query.

 @return path of the node representing this query.
 @throws ItemNotFoundException if this query is not a stored query.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="storeAsNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a node of type <code>nt:query</code> holding this query at
 <code>absPath</code> and returns that node.
 <p>
 This is  a session-write method and therefore requires a
 <code>Session.save()</code> to dispatch the change.
 <p>
 The <code>absPath</code> provided must not have an index on its final
 element. If ordering is supported by the node type of the parent node
 then the new node is appended to the end of the child node list.
 <p>
 An <code>ItemExistsException</code> will be thrown either immediately, on
 dispatch or on persists, if an item at the specified path already exists
 and same-name siblings are not allowed. Implementations may differ on
 when this validation is performed.
 <p>
 A <code>PathNotFoundException</code> will be thrown either immediately,
 on dispatch or on persists, if the specified path implies intermediary
 nodes that do not exist. Implementations may differ on when this
 validation is performed.
 <p>
 A <code>ConstraintViolationException</code>will be thrown either
 immediately, on dispatch or on persists, if adding the node would violate
 a node type or implementation-specific constraint or if an attempt is
 made to add a node as the child of a property. Implementations may differ
 on when this validation is performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch or on persists, if the node to which the new child is being
 added is read-only due to a checked-in node. Implementations may differ
 on when this validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch or on persists, if a lock prevents the addition of the node.
 Implementations may differ on when this validation is performed.

 @param absPath absolute path the query should be stored at
 @return the newly created node.
 @throws ItemExistsException          if an item at the specified path already
                                      exists, same-name siblings are not allowed and this implementation
                                      performs this validation immediately.
 @throws PathNotFoundException        if the specified path implies intermediary
                                      <code>Node</code>s that do not exist or the last element of
                                      <code>relPath</code> has an index, and this implementation performs this
                                      validation immediately.
 @throws ConstraintViolationException if a node type or
                                      implementation-specific constraint is violated or if an attempt is made
                                      to add a node as the child of a property and this implementation performs
                                      this validation immediately.
 @throws VersionException             if the node to which the new child is being
                                      added is read-only due to a checked-in node and this implementation
                                      performs this validation immediately.
 @throws LockException                if a lock prevents the addition of the node and
                                      this implementation performs this validation immediately.
 @throws UnsupportedRepositoryOperationException
                                      if persistent queries are
                                      not supported.
 @throws RepositoryException          if another error occurs or if the
                                      <code>absPath</code> provided has an index on its final element.]]>
      </doc>
    </method>
    <method name="bindValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="varName" type="java.lang.String"/>
      <param name="value" type="javax.jcr.Value"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Binds the given <code>value</code> to the variable named
 <code>varName</code>.

 @param varName name of variable in query
 @param value   value to bind
 @throws IllegalArgumentException      if <code>varName</code> is not a valid
                                       variable in this query.
 @throws javax.jcr.RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getBindVariableNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the names of the bind variables in this query. If this query does
 not contains any bind variables then an empty array is returned.

 @return the names of the bind variables in this query.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <field name="XPATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="As of JCR 2.0, this language is deprecated.">
      <doc>
      <![CDATA[A string constant representing the XPath query language as defined in JCR
 1.0.

 @deprecated As of JCR 2.0, this language is deprecated.]]>
      </doc>
    </field>
    <field name="SQL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="As of JCR 2.0, this language is deprecated.">
      <doc>
      <![CDATA[A string constant representing the SQL query language as defined in JCR
 1.0.

 @deprecated As of JCR 2.0, this language is deprecated.]]>
      </doc>
    </field>
    <field name="JCR_SQL2" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string constant representing the JCR-SQL2 query language.

 @since JCR 2.0]]>
      </doc>
    </field>
    <field name="JCR_JQOM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string constant representing the JCR-JQOM query language.

 @since JCR 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A <code>Query</code> object.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.Query -->
  <!-- start interface javax.jcr.query.QueryManager -->
  <interface name="QueryManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createQuery" return="javax.jcr.query.Query"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statement" type="java.lang.String"/>
      <param name="language" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a new query by specifying the query <code>statement</code> itself
 and the <code>language</code> in which the query is stated. The
 <code>language</code> must be a string from among those returned by
 QueryManager.getSupportedQueryLanguages().

 @param statement a <code>String</code>
 @param language  a <code>String</code>
 @return a <code>Query</code> object
 @throws InvalidQueryException if the query statement is syntactically
                               invalid or the specified language is not supported.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getQOMFactory" return="javax.jcr.query.qom.QueryObjectModelFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a <code>QueryObjectModelFactory</code> with which a JCR-JQOM
 query can be built programmatically.

 @return a <code>QueryObjectModelFactory</code> object
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getQuery" return="javax.jcr.query.Query"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves an existing persistent query.
 <p>
 Persistent queries are created by first using {@link
 QueryManager#createQuery} to create a <code>Query</code> object and then
 calling <code>Query.save</code> to persist the query to a location in the
 workspace.

 @param node a persisted query (that is, a node of type
             <code>nt:query</code>).
 @return a <code>Query</code> object.
 @throws InvalidQueryException If <code>node</code> is not a valid
                               persisted query (that is, a node of type <code>nt:query</code>).
 @throws RepositoryException   if another error occurs]]>
      </doc>
    </method>
    <method name="getSupportedQueryLanguages" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of strings representing all query languages supported by
 this repository. This set must include at least the strings represented
 by the constants {@link Query#JCR_SQL2} and {@link Query#JCR_JQOM}}. An
 implementation may also support other languages, including the deprecated
 languages of JCR 1.0: {@link Query#XPATH} and {@link Query#SQL}.

 @return A string array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface encapsulates methods for the management of search queries.
 Provides methods for the creation and retrieval of search queries.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.QueryManager -->
  <!-- start interface javax.jcr.query.QueryResult -->
  <interface name="QueryResult"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getColumnNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of all the column names in the table view of this result
 set.

 @return a <code>String</code> array holding the column names.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getRows" return="javax.jcr.query.RowIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over the <code>Row</code>s of the result table. The
 rows are returned according to the ordering specified in the query.

 @return a <code>RowIterator</code>
 @throws RepositoryException if this call is the second time either
                             <code>getRows</code> or </code>getNodes</code> has been called on the
                             same <code>QueryResult</code> object or if another error occurs.]]>
      </doc>
    </method>
    <method name="getNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all nodes that match the query. The nodes are
 returned according to the ordering specified in the query.

 @return a <code>NodeIterator</code>
 @throws RepositoryException if the query contains more than one selector,
                             if this call is the second time either <code>getRows</code> or
                             </code>getNodes</code> has been called on the same
                             <code>QueryResult</code> object or if another error occurs.]]>
      </doc>
    </method>
    <method name="getSelectorNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of all the selector names that were used in the query
 that created this result. If the query did not have a selector name then
 an empty array is returned.

 @return a <code>String</code> array holding the selector names.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>QueryResult</code> object. Returned by {@link
 javax.jcr.query.Query#execute()}.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.QueryResult -->
  <!-- start interface javax.jcr.query.Row -->
  <interface name="Row"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getValues" return="javax.jcr.Value[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an array of all the values in the same order as the column names
 returned by {@link QueryResult#getColumnNames()}.

 @return a <code>Value</code> array.
 @throws RepositoryException if an error occurs]]>
      </doc>
    </method>
    <method name="getValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnName" type="java.lang.String"/>
      <exception name="ItemNotFoundException" type="javax.jcr.ItemNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the value of the indicated column in this <code>Row</code>.

 @param columnName name of query result table column
 @return a <code>Value</code>
 @throws ItemNotFoundException if <code>columnName</code> is not among the
                               column names of the query result table.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>Node</code> corresponding to this <code>Row</code>.

 @return a <code>Node</code>
 @throws RepositoryException if this query has more than one selector (and
                             therefore, this <code>Row</code> corresponds to more than one
                             <code>Node</code>) or if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>Node</code> corresponding to this <code>Row</code> and
 the specified selector. If this <code>Row</code> is from a result
 involving outer joins, it may have no <code>Node</code> corresponding to
 the specified selector. In such a case this method returns
 <code>null</code>.

 @param selectorName a <code>String</code>
 @return a <code>Node</code>
 @throws RepositoryException if <code>selectorName</code> is not the alias
                             of a selector in this query or if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>Row.getNode().getPath()</code>. However, some
 implementations may be able gain efficiency by not resolving the actual
 <code>Node</code>.

 @return a <code>String</code>
 @throws RepositoryException if this query has more than one selector (and
                             therefore, this <code>Row</code> corresponds to more than one
                             <code>Node</code>) or if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Equivalent to <code>Row.getNode(selectorName).getPath()</code>. However,
 some implementations may be able gain efficiency by not resolving the
 actual <code>Node</code>. If this <code>Row</code> is from a result
 involving outer joins, it may have no <code>Node</code> corresponding to
 the specified selector. In such a case this method returns
 <code>null</code>.

 @param selectorName a <code>String</code>
 @return a <code>String</code>
 @throws RepositoryException if <code>selectorName</code> is not the alias
                             of a selector in this query or if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getScore" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the full text search score for this row associated with the
 default selector. This corresponds to the score of a particular node.
 <p>
 If no <code>FullTextSearchScore</code> AQM object is associated with the
 default selector this method will still return a value. However, in that
 case the returned value may not be meaningful or may simply reflect the
 minimum possible relevance level (for example, in some systems this might
 be a score of 0).
 <p>
 Note, in JCR-SQL2 a <code>FullTextSearchScore</code> AQM object is
 represented by a <code>SCORE()</code> function. In JCR-JQOM it is
 represented by a Java object of type <code>javax.jcr.query.qom.FullTextSearchScore</code>.

 @return a <code>double</code>
 @throws RepositoryException if this query has more than one selector (and
                             therefore, this <code>Row</code> corresponds to more than one
                             <code>Node</code>) or if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getScore" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the full text search score for this row associated with the
 specified selector. This corresponds to the score of a particular node.
 <p>
 If no <code>FullTextSearchScore</code> AQM object is associated with the
 selector <code>selectorName</code> this method will still return a value.
 However, in that case the returned value may not be meaningful or may
 simply reflect the minimum possible relevance level (for example, in some
 systems this might be a score of 0).
 <p>
 Note, in JCR-SQL2 a <code>FullTextSearchScore</code> AQM object is
 represented by a <code>SCORE()</code> function. In JCR-JQOM it is
 represented by a Java object of type <code>javax.jcr.query.qom.FullTextSearchScore</code>.
 <p>
 If this <code>Row</code> is from a result involving outer joins, it may
 have no <code>Node</code> corresponding to the specified selector. In
 such a case this method returns an implementation selected value, as it
 would if there were no <code>FullTextSearchScore</code> associated with
 the selector.

 @param selectorName a <code>String</code>
 @return a <code>double</code>
 @throws RepositoryException if <code>selectorName</code> is not the alias
                             of a selector in this query or if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A row in the query result table.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.Row -->
  <!-- start interface javax.jcr.query.RowIterator -->
  <interface name="RowIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextRow" return="javax.jcr.query.Row"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Row</code> in the iteration.

 @return the next <code>Row</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>Row</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Row</code>s with
 <code>nextRow</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.RowIterator -->
  <doc>
  <![CDATA[Provides interfaces and classes for content repository searching functionality.]]>
  </doc>
</package>
<package name="javax.jcr.query.qom">
  <!-- start interface javax.jcr.query.qom.And -->
  <interface name="And"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getConstraint1" return="javax.jcr.query.qom.Constraint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the first constraint.

 @return the constraint; non-null]]>
      </doc>
    </method>
    <method name="getConstraint2" return="javax.jcr.query.qom.Constraint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the second constraint.

 @return the constraint; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Performs a logical conjunction of two other constraints.
 <p>
 To satisfy the <code>And</code> constraint, a node-tuple must satisfy both
 {@link #getConstraint1 constraint1} and {@link #getConstraint2 constraint2}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.And -->
  <!-- start interface javax.jcr.query.qom.BindVariableValue -->
  <interface name="BindVariableValue"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.StaticOperand"/>
    <method name="getBindVariableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the bind variable.

 @return the bind variable name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to the value of a bind variable.
 <p>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.BindVariableValue -->
  <!-- start interface javax.jcr.query.qom.ChildNode -->
  <interface name="ChildNode"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to apply this constraint.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getParentPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the absolute path.

 @return the path; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests whether the {@link #getSelectorName selector} node is a child of a node
 reachable by absolute path {@link #getParentPath path}.
 <p>
 A node-tuple satisfies the constraint only if:
 <pre>  selectorNode.getParent().isSame(session.getNode(path))</pre>
 would return true, where <code>selectorNode</code> is the node for the
 specified selector.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.ChildNode -->
  <!-- start interface javax.jcr.query.qom.ChildNodeJoinCondition -->
  <interface name="ChildNodeJoinCondition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.JoinCondition"/>
    <method name="getChildSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the child selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getParentSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the parent selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests whether the {@link #getChildSelectorName childSelector} node is a child
 of the {@link #getParentSelectorName parentSelector} node.  A node-tuple
 satisfies the constraint only if:
 <pre>  childSelectorNode.getParent().isSame(parentSelectorNode)</pre>
 would return true, where <code>childSelectorNode</code> is the node for
 {@link #getChildSelectorName childSelector} and <code>parentSelectorNode</code>
 is the node for {@link #getParentSelectorName parentSelector}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.ChildNodeJoinCondition -->
  <!-- start interface javax.jcr.query.qom.Column -->
  <interface name="Column"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getPropertyName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the property.

 @return the property name, or null to include a column for each
         single-value non-residual property of the selector's node type]]>
      </doc>
    </method>
    <method name="getColumnName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the column name.
 <p>

 @return the column name; must be null if <code>getPropertyName</code> is
         null and non-null otherwise]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Defines a column to include in the tabular view of query results.
 <p>
 If {@link #getPropertyName property} is not specified, a column is included
 for each single-valued non-residual property of the node type specified by
 the <code>nodeType</code> attribute of {@link #getSelectorName selector}.
 <p>
 If {@link #getPropertyName property} is specified, {@link #getColumnName
 columnName} is required and used to name the column in the tabular results.
 If {@link #getPropertyName property} is not specified, {@link #getColumnName
 columnName} must not be specified, and the included columns will be named
 "{@link #getSelectorName selector}.<i>propertyName</i>".

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Column -->
  <!-- start interface javax.jcr.query.qom.Comparison -->
  <interface name="Comparison"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getOperand1" return="javax.jcr.query.qom.DynamicOperand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the first operand.

 @return the operand; non-null]]>
      </doc>
    </method>
    <method name="getOperator" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the operator.

 @return either <ul> <li>{@link QueryObjectModelConstants#JCR_OPERATOR_EQUAL_TO},</li>
         <li>{@link QueryObjectModelConstants#JCR_OPERATOR_NOT_EQUAL_TO},</li>
         <li>{@link QueryObjectModelConstants#JCR_OPERATOR_LESS_THAN},</li>
         <li>{@link QueryObjectModelConstants#JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO},</li>
         <li>{@link QueryObjectModelConstants#JCR_OPERATOR_GREATER_THAN},</li>
         <li>{@link QueryObjectModelConstants#JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO},
         or</li> <li>{@link QueryObjectModelConstants#JCR_OPERATOR_LIKE}</li>
         </ul>]]>
      </doc>
    </method>
    <method name="getOperand2" return="javax.jcr.query.qom.StaticOperand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the second operand.

 @return the operand; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Filters node-tuples based on the outcome of a binary operation.
 <p>
 For any comparison, {@link #getOperand2 operand2} always evaluates to a
 scalar value.  In contrast, {@link #getOperand1 operand1} may evaluate to an
 array of values (for example, the value of a multi-valued property), in which
 case the comparison is separately performed for each element of the array,
 and the <code>Comparison</code> constraint is satisfied as a whole if the
 comparison against <i>any</i> element of the array is satisfied.
 <p>
 If {@link #getOperand1 operand1} and {@link #getOperand2 operand2} evaluate
 to values of different property types, the value of {@link #getOperand2
 operand2} is converted to the property type of the value of {@link
 #getOperand1 operand1}.  If the type conversion fails, the query is invalid.
 <p>
 If {@link #getOperator operator} is not supported for the property type of
 {@link #getOperand1 operand1}, the query is invalid.
 <p>
 If {@link #getOperand1 operand1} evaluates to null (for example, if the
 operand evaluates the value of a property which does not exist), the
 constraint is not satisfied.
 <p>
 The <code>JCR_OPERATOR_EQUAL_TO</code> operator is satisfied <i>only if</i>
 the value of {@link #getOperand1 operand1} equals the value of {@link
 #getOperand2 operand2}.
 <p>
 The <code>JCR_OPERATOR_NOT_EQUAL_TO</code> operator is satisfied
 <i>unless</i> the value of {@link #getOperand1 operand1} equals the value of
 {@link #getOperand2 operand2}.
 <p>
 The <code>JCR_OPERATOR_LESSS_THAN</code> operator is satisfied <i>only if</i>
 the value of {@link #getOperand1 operand1} is ordered <i>before</i> the value
 of {@link #getOperand2 operand2}.
 <p>
 The <code>JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO</code> operator is satisfied
 <i>unless</i> the value of {@link #getOperand1 operand1} is ordered
 <i>after</i> the value of {@link #getOperand2 operand2}.
 <p>
 The <code>JCR_OPERATOR_GREATER_THAN</code> operator is satisfied <i>only
 if</i> the value of {@link #getOperand1 operand1} is ordered <i>after</i> the
 value of {@link #getOperand2 operand2}.
 <p>
 The <code>JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO</code> operator is satisfied
 <i>unless</i> the value of {@link #getOperand1 operand1} is ordered
 <i>before</i> the value of {@link #getOperand2 operand2}.
 <p>
 The <code>JCR_OPERATOR_LIKE</code> operator is satisfied only if the value of
 {@link #getOperand1 operand1} <i>matches</i> the pattern specified by the
 value of {@link #getOperand2 operand2}, where in the pattern: <ul> <li>the
 character "<code>%</code>" matches zero or more characters, and</li> <li>the
 character "<code>_</code>" (underscore) matches exactly one character,
 and</li> <li>the string "<code>\<i>x</i></code>" matches the character
 "<code><i>x</i></code>", and</li> <li>all other characters match
 themselves.</li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Comparison -->
  <!-- start interface javax.jcr.query.qom.Constraint -->
  <interface name="Constraint"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Filters the set of node-tuples formed by evaluating the query's selectors and
 the joins between them.
 <p>
 To be included in the query results, a node-tuple must satisfy the
 constraint.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Constraint -->
  <!-- start interface javax.jcr.query.qom.DescendantNode -->
  <interface name="DescendantNode"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to apply this constraint.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getAncestorPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the absolute path.

 @return the path; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests whether the {@link #getSelectorName selector} node is a descendant of a
 node reachable by absolute path {@link #getAncestorPath path}.
 <p>
 A node-tuple satisfies the constraint only if:
 <pre>  selectorNode.getAncestor(n).isSame(session.getNode(path)) &&
     selectorNode.getDepth() > n</pre>
 would return true for some non-negative integer <code>n</code>, where {@link
 #getSelectorName selectorNode} is the node for the specified selector.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.DescendantNode -->
  <!-- start interface javax.jcr.query.qom.DescendantNodeJoinCondition -->
  <interface name="DescendantNodeJoinCondition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.JoinCondition"/>
    <method name="getDescendantSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the descendant selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getAncestorSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the ancestor selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests whether the {@link #getDescendantSelectorName descendantSelector} node
 is a descendant of the {@link #getAncestorSelectorName ancestorSelector}
 node.  A node-tuple satisfies the constraint only if:
 <pre>  descendantSelectorNode.getAncestor(n).isSame(ancestorSelectorNode) &&
     descendantSelectorNode.getDepth() > n</pre>
 would return true some some non-negative integer <code>n</code>, where
 <code>descendantSelectorNode</code> is the node for {@link
 #getDescendantSelectorName descendantSelector} and <code>ancestorSelectorNode</code>
 is the node for {@link #getAncestorSelectorName ancestorSelector}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.DescendantNodeJoinCondition -->
  <!-- start interface javax.jcr.query.qom.DynamicOperand -->
  <interface name="DynamicOperand"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Operand"/>
    <doc>
    <![CDATA[An operand whose value can only be determined in evaluating the query.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.DynamicOperand -->
  <!-- start interface javax.jcr.query.qom.EquiJoinCondition -->
  <interface name="EquiJoinCondition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.JoinCondition"/>
    <method name="getSelector1Name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the first selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getProperty1Name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the property name in the first selector.

 @return the property name; non-null]]>
      </doc>
    </method>
    <method name="getSelector2Name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the second selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getProperty2Name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the property name in the second selector.

 @return the property name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests whether the value of a property in a first selector is equal to the
 value of a property in a second selector.
 <p>
 A node-tuple satisfies the constraint only if: <ul> <li>{@link
 #getSelector1Name selector1} has a property named {@link #getProperty1Name
 property1}, and</li> <li>{@link #getSelector2Name selector2} has a property
 named {@link #getProperty2Name property2}, and</li> <li>the value of {@link
 #getProperty1Name property1} equals the value of {@link #getProperty2Name
 property2}</li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.EquiJoinCondition -->
  <!-- start interface javax.jcr.query.qom.FullTextSearch -->
  <interface name="FullTextSearch"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to apply this constraint.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getPropertyName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the property.

 @return the property name if the full-text search scope is a property,
         otherwise null if the full-text search scope is the node (or node
         subgraph, in some implementations).]]>
      </doc>
    </method>
    <method name="getFullTextSearchExpression" return="javax.jcr.query.qom.StaticOperand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the full-text search expression.

 @return the full-text search expression; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Performs a full-text search.
 <p>
 The full-text search expression is evaluated against the set of full-text
 indexed properties within the full-text search scope.  If {@link
 #getPropertyName property} is specified, the full-text search scope is the
 property of that name on the {@link #getSelectorName selector} node in the
 node-tuple; otherwise the full-text search scope is all properties of the
 {@link #getSelectorName selector} node (or, in some implementations, all
 properties in the node subgraph).
 <p>
 Which properties (if any) in a repository are full-text indexed is
 implementation determined.
 <p>
 It is also implementation determined whether {@link #getFullTextSearchExpression
 fullTextSearchExpression} is independently evaluated against each full-text
 indexed property in the full-text search scope, or collectively evaluated
 against the set of such properties using some implementation-determined
 mechanism.
 <p>
 Similarly, for multi-valued properties, it is implementation determined
 whether {@link #getFullTextSearchExpression fullTextSearchExpression} is
 independently evaluated against each element in the array of values, or
 collectively evaluated against the array of values using some
 implementation-determined mechanism.
 <p>
 At minimum, an implementation must support the following {@link
 #getFullTextSearchExpression fullTextSearchExpression} grammar:
 <pre>  fullTextSearchExpression ::= [-]term {whitespace [OR] whitespace
 [-]term}
 <p>
  term ::= word | '"' word {whitespace word} '"'
 <p>
  word ::= (A string containing no whitespace)
 <p>
  whitespace ::= (A string of only whitespace)
 </pre>
 <p>
 A query satisfies a <code>FullTextSearch</code> constraint if the value (or
 values) of the full-text indexed properties within the full-text search scope
 satisfy the specified {@link #getFullTextSearchExpression
 fullTextSearchExpression}, evaluated as follows: <ul> <li>A term not preceded
 with "<code>-</code>" (minus sign) is satisfied only if the value contains
 that term.</li> <li>A term preceded with "<code>-</code>" (minus sign) is
 satisfied only if the value does not contain that term.</li> <li>Terms
 separated by whitespace are implicitly "ANDed".</li> <li>Terms separated by
 "<code>OR</code>" are "ORed".</li> <li>"AND" has higher precedence than "OR".
 <li>Within a term, each double quote (<code>"</code>), "<code>-</code>"
 (minus sign), and "<code>\</code>" (backslash) must be escaped by a preceding
 "<code>\</code>" (backslash).</li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.FullTextSearch -->
  <!-- start interface javax.jcr.query.qom.FullTextSearchScore -->
  <interface name="FullTextSearchScore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.DynamicOperand"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to evaluate this operand.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to a <code>DOUBLE</code> value equal to the full-text search score
 of a node.
 <p>
 Full-text search score ranks a selector's nodes by their relevance to the
 <code>fullTextSearchExpression</code> specified in a {@link FullTextSearch}.
 The values to which <code>FullTextSearchScore</code> evaluates and the
 interpretation of those values are implementation specific.
 <code>FullTextSearchScore</code> may evaluate to a constant value in a
 repository that does not support full-text search scoring or has no full-text
 indexed properties.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.FullTextSearchScore -->
  <!-- start interface javax.jcr.query.qom.Join -->
  <interface name="Join"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Source"/>
    <method name="getLeft" return="javax.jcr.query.qom.Source"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the left node-tuple source.

 @return the left source; non-null]]>
      </doc>
    </method>
    <method name="getRight" return="javax.jcr.query.qom.Source"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the right node-tuple source.

 @return the right source; non-null]]>
      </doc>
    </method>
    <method name="getJoinType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the join type.

 @return either <ul> <li>{@link QueryObjectModelConstants#JCR_JOIN_TYPE_INNER},</li>
         <li>{@link QueryObjectModelConstants#JCR_JOIN_TYPE_LEFT_OUTER},</li>
         <li>{@link QueryObjectModelConstants#JCR_JOIN_TYPE_RIGHT_OUTER}</li>
         </ul>]]>
      </doc>
    </method>
    <method name="getJoinCondition" return="javax.jcr.query.qom.JoinCondition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the join condition.

 @return the join condition; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Performs a join between two node-tuple sources.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Join -->
  <!-- start interface javax.jcr.query.qom.JoinCondition -->
  <interface name="JoinCondition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Filters the set of node-tuples formed from a {@link Join join}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.JoinCondition -->
  <!-- start interface javax.jcr.query.qom.Length -->
  <interface name="Length"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.DynamicOperand"/>
    <method name="getPropertyValue" return="javax.jcr.query.qom.PropertyValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the property value for which to compute the length.

 @return the property value; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to the length (or lengths, if multi-valued) of a property.
 <p>
 The length should be computed as though the <code>getLength</code> method (or
 <code>getLengths</code>, if multi-valued) of <code>javax.jcr.Property</code>
 were called.
 <p>
 If {@link #getPropertyValue propertyValue} evaluates to null, the
 <code>Length</code> operand also evaluates to null.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Length -->
  <!-- start interface javax.jcr.query.qom.Literal -->
  <interface name="Literal"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.StaticOperand"/>
    <method name="getLiteralValue" return="javax.jcr.Value"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the literal.

 @return the value of the literal.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to a literal value.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Literal -->
  <!-- start interface javax.jcr.query.qom.LowerCase -->
  <interface name="LowerCase"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.DynamicOperand"/>
    <method name="getOperand" return="javax.jcr.query.qom.DynamicOperand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the operand whose value is converted to a lower-case string.

 @return the operand; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to the lower-case string value (or values, if multi-valued) of
 {@link #getOperand operand}.
 <p>
 If {@link #getOperand operand} does not evaluate to a string value, its value
 is first converted to a string.  The lower-case string value is computed as
 though the <code>toLowerCase()</code> method of <code>java.lang.String</code>
 were called.
 <p>
 If {@link #getOperand operand} evaluates to null, the <code>LowerCase</code>
 operand also evaluates to null.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.LowerCase -->
  <!-- start interface javax.jcr.query.qom.NodeLocalName -->
  <interface name="NodeLocalName"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.DynamicOperand"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to evaluate this operand.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to a <code>NAME</code> value equal to the local (unprefixed) name
 of a node.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.NodeLocalName -->
  <!-- start interface javax.jcr.query.qom.NodeName -->
  <interface name="NodeName"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.DynamicOperand"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to evaluate this operand.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to a <code>NAME</code> value equal to the namespace-qualified name
 of a node.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.NodeName -->
  <!-- start interface javax.jcr.query.qom.Not -->
  <interface name="Not"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getConstraint" return="javax.jcr.query.qom.Constraint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the constraint negated by this <code>Not</code> constraint.

 @return the constraint; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Performs a logical negation of another constraint.
 <p>
 To satisfy the <code>Not</code> constraint, the node-tuple must <i>not</i>
 satisfy {@link #getConstraint constraint}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Not -->
  <!-- start interface javax.jcr.query.qom.Operand -->
  <interface name="Operand"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[An operand to a binary operation specified by a {@link Comparison}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Operand -->
  <!-- start interface javax.jcr.query.qom.Or -->
  <interface name="Or"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getConstraint1" return="javax.jcr.query.qom.Constraint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the first constraint.

 @return the constraint; non-null]]>
      </doc>
    </method>
    <method name="getConstraint2" return="javax.jcr.query.qom.Constraint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the second constraint.

 @return the constraint; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Performs a logical disjunction of two other constraints.
 <p>
 To satisfy the <code>Or</code> constraint, the node-tuple must either: <ul>
 <li>satisfy {@link #getConstraint1 constraint1} but not {@link
 #getConstraint2 constraint2}, or</li> <li>satisfy {@link #getConstraint2
 constraint2} but not {@link #getConstraint1 constraint1}, or</li> <li>satisfy
 both {@link #getConstraint1 constraint1} and {@link #getConstraint2
 constraint2}.</li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Or -->
  <!-- start interface javax.jcr.query.qom.Ordering -->
  <interface name="Ordering"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getOperand" return="javax.jcr.query.qom.DynamicOperand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The operand by which to order.

 @return the operand; non-null]]>
      </doc>
    </method>
    <method name="getOrder" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the order.

 @return either <ul> <li>{@link QueryObjectModelConstants#JCR_ORDER_ASCENDING}
         or</li> <li>{@link QueryObjectModelConstants#JCR_ORDER_DESCENDING}</li>
         </ul>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Determines the relative order of two node-tuples by evaluating {@link
 #getOperand operand} for each.
 <p>
 For a first node-tuple, <code>nt1</code>, for which {@link #getOperand
 operand} evaluates to <code>v1</code>, and a second node-tuple,
 <code>nt2</code>, for which {@link #getOperand operand} evaluates to
 <code>v2</code>: <ul> <li>If {@link #getOrder order} is
 <code>Ascending</code>, then:<ul> <li>if either <code>v1</code> is null,
 <code>v2</code> is null, or both <code>v1</code> and <code>v2</code> are
 null, the relative order of <code>nt1</code> and <code>nt2</code> is
 implementation determined, otherwise</li> <li>if <code>v1</code> is a
 different property type than <code>v2</code>, the relative order of
 <code>nt1</code> and <code>nt2</code> is implementation determined,
 otherwise</li> <li>if <code>v1</code> is ordered before <code>v2</code>, then
 <code>nt1</code> precedes <code>nt2</code>, otherwise</li> <li>if
 <code>v1</code> is ordered after <code>v2</code>, then <code>nt2</code>
 precedes <code>nt1</code>, otherwise</li> <li>the relative order of
 <code>nt1</code> and <code>nt2</code> is implementation determined and may be
 arbitrary.</li></ul></li> <li>Otherwise, if {@link #getOrder order} is
 <code>Descending</code>, then:<ul> <li>if either <code>v1</code> is null,
 <code>v2</code> is null, or both <code>v1</code> and <code>v2</code> are
 null, the relative order of <code>nt1</code> and <code>nt2</code> is
 implementation determined, otherwise</li> <li>if <code>v1</code> is a
 different property type than <code>v2</code>, the relative order of
 <code>nt1</code> and <code>nt2</code> is implementation determined,
 otherwise</li> <li>if <code>v1</code> is ordered before <code>v2</code>, then
 <code>nt2</code> precedes <code>nt1</code>, otherwise</li> <li>if
 <code>v1</code> is ordered after <code>v2</code>, then <code>nt1</code>
 precedes <code>nt2</code>, otherwise</li> <li>the relative order of
 <code>nt1</code> and <code>nt2</code> is implementation determined and may be
 arbitrary.</li></ul></li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Ordering -->
  <!-- start interface javax.jcr.query.qom.PropertyExistence -->
  <interface name="PropertyExistence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to apply this constraint.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getPropertyName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the property.

 @return the property name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests the existence of a property.
 <p>
 A node-tuple satisfies the constraint if the selector node has a property
 named {@link #getPropertyName property}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.PropertyExistence -->
  <!-- start interface javax.jcr.query.qom.PropertyValue -->
  <interface name="PropertyValue"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.DynamicOperand"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to evaluate this operand.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getPropertyName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the property.

 @return the property name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to the value (or values, if multi-valued) of a property.
 <p>
 If, for a node-tuple, the {@link #getSelectorName selector} node does not
 have a property named {@link #getPropertyName property}, the operand
 evaluates to null.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.PropertyValue -->
  <!-- start interface javax.jcr.query.qom.QueryObjectModel -->
  <interface name="QueryObjectModel"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.Query"/>
    <method name="getSource" return="javax.jcr.query.qom.Source"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the node-tuple source for this query.

 @return the node-tuple source; non-null]]>
      </doc>
    </method>
    <method name="getConstraint" return="javax.jcr.query.qom.Constraint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the constraint for this query.

 @return the constraint, or null if none]]>
      </doc>
    </method>
    <method name="getOrderings" return="javax.jcr.query.qom.Ordering[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the orderings for this query.

 @return an array of zero or more orderings; non-null]]>
      </doc>
    </method>
    <method name="getColumns" return="javax.jcr.query.qom.Column[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the columns for this query.

 @return an array of zero or more columns; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A query in the JCR query object model.
 <p>
 The JCR query object model describes the queries that can be evaluated by a
 JCR repository independent of any particular query language, such as SQL.
 <p>
 A query consists of: <ul> <li>a source.  When the query is evaluated, the
 source evaluates its selectors and the joins between them to produce a
 (possibly empty) set of node-tuples.  This is a set of 1-tuples if the query
 has one selector (and therefore no joins), a set of 2-tuples if the query has
 two selectors (and therefore one join), a set of 3-tuples if the query has
 three selectors (two joins), and so forth.</li> <li>an optional constraint.
 When the query is evaluated, the constraint filters the set of
 node-tuples.</li> <li>a list of zero or more orderings.  The orderings
 specify the order in which the node-tuples appear in the query results.  The
 relative order of two node-tuples is determined by evaluating the specified
 orderings, in list order, until encountering an ordering for which one
 node-tuple precedes the other.  If no orderings are specified, or if for none
 of the specified orderings does one node-tuple precede the other, then the
 relative order of the node-tuples is implementation determined (and may be
 arbitrary).</li> <li>a list of zero or more columns to include in the tabular
 view of the query results.  If no columns are specified, the columns
 available in the tabular view are implementation determined, but minimally
 include, for each selector, a column for each single-valued non-residual
 property of the selector's node type.</li> </ul>
 <p>
 The query object model representation of a query is created by factory
 methods in the {@link QueryObjectModelFactory}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.QueryObjectModel -->
  <!-- start interface javax.jcr.query.qom.QueryObjectModelConstants -->
  <interface name="QueryObjectModelConstants"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="JCR_JOIN_TYPE_INNER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An inner join.]]>
      </doc>
    </field>
    <field name="JCR_JOIN_TYPE_LEFT_OUTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A left-outer join.]]>
      </doc>
    </field>
    <field name="JCR_JOIN_TYPE_RIGHT_OUTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A right-outer join.]]>
      </doc>
    </field>
    <field name="JCR_OPERATOR_EQUAL_TO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "<code>=</code>" comparison operator.]]>
      </doc>
    </field>
    <field name="JCR_OPERATOR_NOT_EQUAL_TO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "<code>!=</code>" comparison operator.]]>
      </doc>
    </field>
    <field name="JCR_OPERATOR_LESS_THAN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "<code>&lt;</code>" comparison operator.]]>
      </doc>
    </field>
    <field name="JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "<code>&lt;=</code>" comparison operator.]]>
      </doc>
    </field>
    <field name="JCR_OPERATOR_GREATER_THAN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "<code>&gt;</code>" comparison operator.]]>
      </doc>
    </field>
    <field name="JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "<code>&gt;=</code>" comparison operator.]]>
      </doc>
    </field>
    <field name="JCR_OPERATOR_LIKE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "<code>like</code>" comparison operator.]]>
      </doc>
    </field>
    <field name="JCR_ORDER_ASCENDING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ascending order.]]>
      </doc>
    </field>
    <field name="JCR_ORDER_DESCENDING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Descending order.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines constants used in the query object model.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.QueryObjectModelConstants -->
  <!-- start interface javax.jcr.query.qom.QueryObjectModelFactory -->
  <interface name="QueryObjectModelFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.QueryObjectModelConstants"/>
    <method name="createQuery" return="javax.jcr.query.qom.QueryObjectModel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="javax.jcr.query.qom.Source"/>
      <param name="constraint" type="javax.jcr.query.qom.Constraint"/>
      <param name="orderings" type="javax.jcr.query.qom.Ordering[]"/>
      <param name="columns" type="javax.jcr.query.qom.Column[]"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates a query with one or more selectors.

 @param source     the node-tuple source; non-null
 @param constraint the constraint, or null if none
 @param orderings  zero or more orderings; null is equivalent to a
                   zero-length array
 @param columns    the columns; null is equivalent to a zero-length array
 @return the query; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test and the
                               parameters given fail that test. See the individual QOM factory methods
                               for the validity criteria of each query element.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="selector" return="javax.jcr.query.qom.Selector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeTypeName" type="java.lang.String"/>
      <param name="selectorName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Selects a subset of the nodes in the repository based on node type.
 <p>
 The query is invalid if <code>nodeTypeName</code> or
 <code>selectorName</code> is not a syntactically valid JCR name.
 <p>
 The query is invalid if <code>selectorName</code>} is identical to the
 name of another selector in the query.
 <p>
 The query is also invalid if <code>nodeType</code> is not a valid JCR
 name or is a valid JCR name but not the name of a node type available in
 the repository.

 @param nodeTypeName the name of the required node type; non-null
 @param selectorName the selector name; non-null
 @return the selector; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="join" return="javax.jcr.query.qom.Join"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="javax.jcr.query.qom.Source"/>
      <param name="right" type="javax.jcr.query.qom.Source"/>
      <param name="joinType" type="java.lang.String"/>
      <param name="joinCondition" type="javax.jcr.query.qom.JoinCondition"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Performs a join between two node-tuple sources.
 <p>
 The query is invalid if <code>left</code> is the same source as
 <code>right</code>.

 @param left          the left node-tuple source; non-null
 @param right         the right node-tuple source; non-null
 @param joinType      either <ul> <li>{@link QueryObjectModelConstants#JCR_JOIN_TYPE_INNER},</li>
                      <li>{@link QueryObjectModelConstants#JCR_JOIN_TYPE_LEFT_OUTER},</li>
                      <li>{@link QueryObjectModelConstants#JCR_JOIN_TYPE_RIGHT_OUTER}</li>
                      </ul>
 @param joinCondition the join condition; non-null
 @return the join; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="equiJoinCondition" return="javax.jcr.query.qom.EquiJoinCondition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selector1Name" type="java.lang.String"/>
      <param name="property1Name" type="java.lang.String"/>
      <param name="selector2Name" type="java.lang.String"/>
      <param name="property2Name" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests whether the value of a property in a first selector is equal to the
 value of a property in a second selector.
 <p>
 <p>
 The query is invalid if: <ul> <li><code>selector1</code> is not the name
 of a selector in the query, or</li> <li><code>selector2</code> is not the
 name of a selector in the query, or</li> <li><code>selector1</code> is
 the same as <code>selector2</code>, or</li> <li><code>property1</code> is
 not a syntactically valid JCR name, or</li> <li><code>property2</code> is
 not a syntactically valid JCR name, or</li> <li>the value of
 <code>property1</code> is not the same property type as the value of
 <code>property2</code>, or</li> <li><code>property1</code> is a
 multi-valued property, or</li> <li><code>property2</code> is a
 multi-valued property, or</li> <li><code>property1</code> is a
 <code>BINARY</code> property, or</li> <li><code>property2</code> is a
 <code>BINARY</code> property.</li> </ul>

 @param selector1Name the name of the first selector; non-null
 @param property1Name the property name in the first selector; non-null
 @param selector2Name the name of the second selector; non-null
 @param property2Name the property name in the second selector; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implementation chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="sameNodeJoinCondition" return="javax.jcr.query.qom.SameNodeJoinCondition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selector1Name" type="java.lang.String"/>
      <param name="selector2Name" type="java.lang.String"/>
      <param name="selector2Path" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests whether a first selector's node is the same as a node identified by
 relative path from a second selector's node.
 <p>
 The query is invalid if: <ul> <li><code>selector1</code> is not the name
 of a selector in the query, or</li> <li><code>selector2</code> is not the
 name of a selector in the query, or</li> <li><code>selector1</code> is
 the same as selector2, or</li> <li><code>selector2Path</code> is not a
 syntactically valid relative path.  Note, however, that if the path is
 syntactically valid but does not identify a node visible to the current
 session, the query is valid but the constraint is not satisfied.</li>
 </ul>

 @param selector1Name the name of the first selector; non-null
 @param selector2Name the name of the second selector; non-null
 @param selector2Path the path relative to the second selector; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="childNodeJoinCondition" return="javax.jcr.query.qom.ChildNodeJoinCondition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="childSelectorName" type="java.lang.String"/>
      <param name="parentSelectorName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests whether a first selector's node is a child of a second selector's
 node.
 <p>
 The query is invalid if: <ul> <li><code>childSelector</code> is not the
 name of a selector in the query, or</li> <li><code>parentSelector</code>
 is not the name of a selector in the query, or</li>
 <li><code>childSelector</code> is the same as <code>parentSelector</code>.
 </ul>

 @param childSelectorName  the name of the child selector; non-null
 @param parentSelectorName the name of the parent selector; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="descendantNodeJoinCondition" return="javax.jcr.query.qom.DescendantNodeJoinCondition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="descendantSelectorName" type="java.lang.String"/>
      <param name="ancestorSelectorName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests whether a first selector's node is a descendant of a second
 selector's node.
 <p>
 The query is invalid if: <ul> <li><code>descendantSelector</code> is not
 the name of a selector in the query, or</li> <li><code>ancestorSelector</code>
 is not the name of a selector in the query, or</li>
 <li><code>descendantSelector</code> is the same as
 <code>ancestorSelector</code>. </ul>

 @param descendantSelectorName the name of the descendant selector;
                               non-null
 @param ancestorSelectorName   the name of the ancestor selector; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="and" return="javax.jcr.query.qom.And"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constraint1" type="javax.jcr.query.qom.Constraint"/>
      <param name="constraint2" type="javax.jcr.query.qom.Constraint"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Performs a logical conjunction of two other constraints.

 @param constraint1 the first constraint; non-null
 @param constraint2 the second constraint; non-null
 @return the <code>And</code> constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="or" return="javax.jcr.query.qom.Or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constraint1" type="javax.jcr.query.qom.Constraint"/>
      <param name="constraint2" type="javax.jcr.query.qom.Constraint"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Performs a logical disjunction of two other constraints.

 @param constraint1 the first constraint; non-null
 @param constraint2 the second constraint; non-null
 @return the <code>Or</code> constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="not" return="javax.jcr.query.qom.Not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constraint" type="javax.jcr.query.qom.Constraint"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Performs a logical negation of another constraint.

 @param constraint the constraint to be negated; non-null
 @return the <code>Not</code> constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="comparison" return="javax.jcr.query.qom.Comparison"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand1" type="javax.jcr.query.qom.DynamicOperand"/>
      <param name="operator" type="java.lang.String"/>
      <param name="operand2" type="javax.jcr.query.qom.StaticOperand"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Filters node-tuples based on the outcome of a binary operation.

 @param operand1 the first operand; non-null
 @param operator the operator; either <ul> <li>{@link
                 QueryObjectModelConstants#JCR_OPERATOR_EQUAL_TO},</li> <li>{@link
                 QueryObjectModelConstants#JCR_OPERATOR_NOT_EQUAL_TO},</li> <li>{@link
                 QueryObjectModelConstants#JCR_OPERATOR_LESS_THAN},</li> <li>{@link
                 QueryObjectModelConstants#JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO},</li>
                 <li>{@link QueryObjectModelConstants#JCR_OPERATOR_GREATER_THAN},</li>
                 <li>{@link QueryObjectModelConstants#JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO},
                 or</li> <li>{@link QueryObjectModelConstants#JCR_OPERATOR_LIKE}</li>
                 </ul>
 @param operand2 the second operand; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="propertyExistence" return="javax.jcr.query.qom.PropertyExistence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <param name="propertyName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests the existence of a property in the specified selector.
 <p>
 The query is invalid if: <ul> <li><code>selector</code> is not the name
 of a selector in the query, or</li> <li><code>property</code> is not a
 syntactically valid JCR name.</li> </ul>

 @param selectorName the selector name; non-null
 @param propertyName the property name; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="fullTextSearch" return="javax.jcr.query.qom.FullTextSearch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <param name="propertyName" type="java.lang.String"/>
      <param name="fullTextSearchExpression" type="javax.jcr.query.qom.StaticOperand"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Performs a full-text search against the specified selector.
 <p>
 The query is invalid if: <ul> <li><code>selector</code> is not the name
 of a selector in the query, or</li> <li><code>property</code> is
 specified but is not a syntactically valid JCR name, or</li>
 <li><code>fullTextSearchExpression</code> does not evaluate to a JCR
 STRING Value (or convertible to STRING) that conforms to the full text
 search grammar.</li> </ul>
 <p>
 If <code>property</code> is specified but, for a node-tuple, the selector
 node does not have a property named <code>property</code>, the query is
 valid but the constraint is not satisfied.</li>

 @param selectorName             the selector name; non-null
 @param propertyName             the property name, or null to search all full-text
                                 indexed properties of the node (or node subgraph, in some
                                 implementations)
 @param fullTextSearchExpression the full-text search expression as a
                                 static operand; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="sameNode" return="javax.jcr.query.qom.SameNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests whether a node in the specified selector is reachable by a
 specified absolute path.
 <p>
 The query is invalid if: <ul> <li><code>selector</code> is not the name
 of a selector in the query, or</li> <li><code>path</code> is not a
 syntactically valid absolute path.  Note, however, that if the path is
 syntactically valid but does not identify a node in the repository (or
 the node is not visible to this session, because of access control
 constraints), the query is valid but the constraint is not
 satisfied.</li> </ul>

 @param selectorName the selector name; non-null
 @param path         an absolute path; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="childNode" return="javax.jcr.query.qom.ChildNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests whether a node in the specified selector is a child of a node
 reachable by a specified absolute path. The query is invalid if: <ul>
 <li><code>selector</code> is not the name of a selector in the query,
 or</li> <li><code>path</code> is not a syntactically valid absolute path.
 Note, however, that if the path is syntactically valid but does not
 identify a node in the repository (or the node is not visible to this
 session, because of access control constraints), the query is valid but
 the constraint is not satisfied.</li> </ul>

 @param selectorName the selector name; non-null
 @param path         an absolute path; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="descendantNode" return="javax.jcr.query.qom.DescendantNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Tests whether a node in the specified selector is a descendant of a node
 reachable by a specified absolute path.
 <p>
 The query is invalid if: <ul> <li><code>selector</code> is not the name
 of a selector in the query, or</li> <li><code>path</code> is not a
 syntactically valid absolute path.  Note, however, that if the path is
 syntactically valid but does not identify a node in the repository (or
 the node is not visible to this session, because of access control
 constraints), the query is valid but the constraint is not
 satisfied.</li> </ul>

 @param selectorName the selector name; non-null
 @param path         an absolute path; non-null
 @return the constraint; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="propertyValue" return="javax.jcr.query.qom.PropertyValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <param name="propertyName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to the value (or values, if multi-valued) of a property in the
 specified selector.
 <p>
 The query is invalid if: <ul> <li><code>selector</code> is not the name
 of a selector in the query, or</li> <li><code>property</code> is not a
 syntactically valid JCR name.</li> </ul>

 @param selectorName the selector name; non-null
 @param propertyName the property name; non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="length" return="javax.jcr.query.qom.Length"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyValue" type="javax.jcr.query.qom.PropertyValue"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to the length (or lengths, if multi-valued) of a property.

 @param propertyValue the property value for which to compute the length;
                      non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="nodeName" return="javax.jcr.query.qom.NodeName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to a <code>NAME</code> value equal to the prefix-qualified name
 of a node in the specified selector.
 <p>
 The query is invalid if <code>selector</code> is not the name of a
 selector in the query.

 @param selectorName the selector name; non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="nodeLocalName" return="javax.jcr.query.qom.NodeLocalName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to a <code>NAME</code> value equal to the local (unprefixed)
 name of a node in the specified selector.
 <p>
 The query is invalid if <code>selector</code> is not the name of a
 selector in the query.

 @param selectorName the selector name; non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="fullTextSearchScore" return="javax.jcr.query.qom.FullTextSearchScore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to a <code>DOUBLE</code> value equal to the full-text search
 score of a node in the specified selector.
 <p>
 The query is invalid if <code>selector</code> is not the name of a
 selector in the query.

 @param selectorName the selector name; non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="lowerCase" return="javax.jcr.query.qom.LowerCase"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="javax.jcr.query.qom.DynamicOperand"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to the lower-case string value (or values, if multi-valued) of
 an operand.

 @param operand the operand whose value is converted to a lower-case
                string; non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="upperCase" return="javax.jcr.query.qom.UpperCase"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="javax.jcr.query.qom.DynamicOperand"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to the upper-case string value (or values, if multi-valued) of
 an operand.

 @param operand the operand whose value is converted to a upper-case
                string; non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="bindVariable" return="javax.jcr.query.qom.BindVariableValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindVariableName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to the value of a bind variable.
 <p>
 The query is invalid if <code>bindVariableName</code> is not a valid JCR
 prefix.

 @param bindVariableName the bind variable name; non-null
 @return the operand; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test.
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="literal" return="javax.jcr.query.qom.Literal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="literalValue" type="javax.jcr.Value"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Evaluates to a literal value.

 @param literalValue the value
 @return the literal; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses
                               to perform that test (and not leave it
                               until later, on {@link #createQuery}),
                               and the parameter given fails that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="ascending" return="javax.jcr.query.qom.Ordering"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="javax.jcr.query.qom.DynamicOperand"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Orders by the value of the specified operand, in ascending order. The
 query is invalid if <code>operand</code> does not evaluate to a scalar
 value.

 @param operand the operand by which to order; non-null
 @return the ordering
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="descending" return="javax.jcr.query.qom.Ordering"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="javax.jcr.query.qom.DynamicOperand"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Orders by the value of the specified operand, in descending order. The
 query is invalid if <code>operand</code> does not evaluate to a scalar
 value.

 @param operand the operand by which to order; non-null
 @return the ordering
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <method name="column" return="javax.jcr.query.qom.Column"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selectorName" type="java.lang.String"/>
      <param name="propertyName" type="java.lang.String"/>
      <param name="columnName" type="java.lang.String"/>
      <exception name="InvalidQueryException" type="javax.jcr.query.InvalidQueryException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Identifies a property in the specified selector to include in the tabular
 view of query results.
 <p>
 The query is invalid if: <ul> <li><code>selectorName</code> is not the name
 of a selector in the query, or</li>
 <li><code>propertyName</code> is specified but does not evaluate to a scalar
 value, or</li> <li><code>propertyName</code> is specified but
 <code>columnName</code> is omitted, or</li> <li><code>propertyName</code> is
 omitted but <code>columnName</code> is specified, or</li> <li>the columns
 in the tabular view are not uniquely named, whether those column names
 are specified by <code>columnName</code> (if <code>propertyName</code> is
 specified) or generated as described above (if <code>propertyName</code> is
 omitted).</li> </ul> If <code>propertyName</code> is specified but, for a
 node-tuple, the selector node does not have a property named
 <code>propertyName</code>, the query is valid and the column has null value.

 @param selectorName the selector name; non-null
 @param propertyName the property name, or null to include a column for
                     each single-value non-residual property of the selector's node type
 @param columnName   the column name; must be null if <code>propertyName</code> is null;
                     must be non-null if <code>propertyName</code> is non-null.
 @return the column; non-null
 @throws InvalidQueryException if a particular validity test is possible
                               on this method, the implemention chooses to perform that test (and not
                               leave it until later, on {@link #createQuery}), and the parameters given
                               fail that test
 @throws RepositoryException   if the operation otherwise fails]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>QueryObjectModelFactory</code> creates instances of the JCR query
 object model.
 <p>
 Refer to {@link QueryObjectModel} for a description of the query object
 model.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.QueryObjectModelFactory -->
  <!-- start interface javax.jcr.query.qom.SameNode -->
  <interface name="SameNode"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Constraint"/>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the selector against which to apply this constraint.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the absolute path.

 @return the path; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests whether the {@link #getSelectorName selector} node is reachable by
 absolute path {@link #getPath path}.
 <p>
 A node-tuple satisfies the constraint only if:
 <pre>  selectorNode.isSame(session.getNode(path))</pre>
 would return true, where <code>selectorNode</code> is the node for the
 specified selector.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.SameNode -->
  <!-- start interface javax.jcr.query.qom.SameNodeJoinCondition -->
  <interface name="SameNodeJoinCondition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.JoinCondition"/>
    <method name="getSelector1Name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the first selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getSelector2Name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the second selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <method name="getSelector2Path" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the path relative to the second selector.

 @return the relative path, or null for none]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tests whether two nodes are "the same" according to the <code>isSame</code>
 method of <code>javax.jcr.Item</code>.
 <p>
 Tests whether the {@link #getSelector1Name selector1} node is the same as a node identified by
 relative path from the {@link #getSelector2Name selector2} node.
 A node-tuple satisfies the constraint only if:
 <pre>  selector1Node.isSame(selector2Node.getNode(selector2Path))</pre>
 would return true, where <code>selector1Node</code> is the node for {@link
 #getSelector1Name selector1} and <code>selector2Node</code> is the node for
 {@link #getSelector2Name selector2}.</li></ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.SameNodeJoinCondition -->
  <!-- start interface javax.jcr.query.qom.Selector -->
  <interface name="Selector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Source"/>
    <method name="getNodeTypeName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the required node type.

 @return the node type name; non-null]]>
      </doc>
    </method>
    <method name="getSelectorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the selector name.
 <p>
 A selector's name can be used elsewhere in the query to identify the
 selector.

 @return the selector name; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Selects a subset of the nodes in the repository based on node type.
 <p>
 A selector selects every node in the repository, subject to access control
 constraints, that satisfies at least one of the following conditions: <ul>
 <li>the node's primary node type is {@link #getNodeTypeName nodeType},
 or</li> <li>the node's primary node type is a subtype of {@link
 #getNodeTypeName nodeType}, or</li> <li>the node has a mixin node type that
 is {@link #getNodeTypeName nodeType}, or</li> <li>the node has a mixin node
 type that is a subtype of {@link #getNodeTypeName nodeType}.</li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Selector -->
  <!-- start interface javax.jcr.query.qom.Source -->
  <interface name="Source"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Evaluates to a set of node-tuples.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.Source -->
  <!-- start interface javax.jcr.query.qom.StaticOperand -->
  <interface name="StaticOperand"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.Operand"/>
    <doc>
    <![CDATA[An operand whose value can be determined from static analysis of the query,
 prior to its evaluation.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.StaticOperand -->
  <!-- start interface javax.jcr.query.qom.UpperCase -->
  <interface name="UpperCase"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.query.qom.DynamicOperand"/>
    <method name="getOperand" return="javax.jcr.query.qom.DynamicOperand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the operand whose value is converted to a upper-case string.

 @return the operand; non-null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Evaluates to the upper-case string value (or values, if multi-valued) of
 {@link #getOperand operand}.
 <p>
 If {@link #getOperand operand} does not evaluate to a string value, its value
 is first converted to a string.  The upper-case string value is computed as
 though the <code>toUpperCase()</code> method of <code>java.lang.String</code>
 were called.
 <p>
 If {@link #getOperand operand} evaluates to null, the <code>UpperCase</code>
 operand also evaluates to null.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.query.qom.UpperCase -->
  <doc>
  <![CDATA[Provides interfaces and classes for content repository Query Object Model.]]>
  </doc>
</package>
<package name="javax.jcr.retention">
  <!-- start interface javax.jcr.retention.Hold -->
  <interface name="Hold"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isDeep" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if this <code>Hold</code> is deep.

 @return <code>true</code> if this <code>Hold</code> is deep.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the name of this <code>Hold</code>. A JCR name.

 @return the name of this <code>Hold</code>. A JCR name.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<code>Hold</code> represents a hold that can be applied to an existing node
 in order to prevent the node from being modified or removed. The format and
 interpretation of the name are not specified. They are
 application-dependent.
 <p>
 If {@link #isDeep()} is <code>true</code>, the hold applies to the node and
 its entire subgraph. Otherwise the hold applies to the node and its
 properties only.

 @see RetentionManager#getHolds(String)
 @see RetentionManager#addHold(String, String, boolean)
 @see RetentionManager#removeHold(String, Hold)
 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.retention.Hold -->
  <!-- start interface javax.jcr.retention.RetentionManager -->
  <interface name="RetentionManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getHolds" return="javax.jcr.retention.Hold[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all hold objects that have been added through this API to the
 existing node at <code>absPath</code>. If no hold has been set before,
 this method returns an empty array.

 @param absPath an absolute path.
 @return All hold objects that have been added to the existing node at
         <code>absPath</code> through this API or an empty array if no
         hold has been set.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficent access to retrieve the node.
 @throws AccessDeniedException if the current session does not have
                               sufficient access to retrieve the holds.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="addHold" return="javax.jcr.retention.Hold"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="isDeep" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Places a hold on the existing node at <code>absPath</code>. If
 <code>isDeep</code> is <code>true</code>) the hold applies to this node
 and its subgraph. The hold does not take effect until a <code>save</code>
 is performed. A node may have more than one hold.
 <p>
 The format and interpretation of the <code>name</code> are not specified.
 They are application-dependent.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch or on persists, if the node at <code>absPath</code> is read-only
 due to a checked-in node. Implementations may differ on when this
 validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch or on persists, if a lock prevents the operation.
 Implementations may differ on when this validation is performed.

 @param absPath an absolute path.
 @param name    an application-dependent string.
 @param isDeep  a boolean indicating if the hold applies to the subgraph.
 @return The <code>Hold</code> applied.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve the node.
 @throws AccessDeniedException if the current session does not have
                               sufficient access to perform the operation.
 @throws LockException         if a lock applies at the node at
                               <code>absPath</code> and this implementation performs this validation
                               immediately.
 @throws VersionException      if the node at <code>absPath</code> is read-only
                               due to a checked-in node. and this implementation performs this
                               validation immediately.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="removeHold"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="hold" type="javax.jcr.retention.Hold"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified <code>hold</code> from the node at
 <code>absPath</code>. The removal does not take effect until a
 <code>save</code> is performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch or on persists, if the node at <code>absPath</code> is read-only
 due to a checked-in node. Implementations may differ on when this
 validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch or on persists, if a lock prevents the operation.
 Implementations may differ on when this validation is performed.

 @param absPath an absolute path.
 @param hold    the hold to be removed.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve the node.
 @throws AccessDeniedException if the current session does not have
                               sufficient access to perform the operation.
 @throws LockException         if a lock applies at the node at
                               <code>absPath</code> and this implementation performs this validation
                               immediately.
 @throws VersionException      if the node at <code>absPath</code> is read-only
                               due to a checked-in node and this implementation performs this validation
                               immediately.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getRetentionPolicy" return="javax.jcr.retention.RetentionPolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the retention policy that has been set using {@link
 #setRetentionPolicy} on the node at <code>absPath</code> or
 <code>null</code> if no policy has been set.

 @param absPath an absolute path to an existing node.
 @return The retention policy that applies to the existing node at
         <code>absPath</code> or <code>null</code> if no policy applies.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficent access to retrieve the node.
 @throws AccessDeniedException if the current session does not have
                               sufficient access to retrieve the policy.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="setRetentionPolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="retentionPolicy" type="javax.jcr.retention.RetentionPolicy"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the retention policy of the node at <code>absPath</code> to that
 defined in the specified policy node. Interpretation and enforcement of
 this policy is an implementation issue. In any case the policy does does
 not take effect until a <code>save</code> is performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch or on persists, if the node at <code>absPath</code> is read-only
 due to a checked-in node. Implementations may differ on when this
 validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch or on persists, if a lock prevents the operation.
 Implementations may differ on when this validation is performed.

 @param absPath         an absolute path to an existing node.
 @param retentionPolicy a retention policy.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve the node.
 @throws AccessDeniedException if the current session does not have
                               sufficient access to perform the operation.
 @throws LockException         if a lock applies at the node at
                               <code>absPath</code> and this implementation performs this validation
                               immediately.
 @throws VersionException      if the node at <code>absPath</code> is read-only
                               due to a checked-in node and this implementation performs this validation
                               immediately.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="removeRetentionPolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Causes the current retention policy on the node at <code>absPath</code>
 to no longer apply. The removal does not take effect until a
 <code>save</code> is performed.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch or on persists, if the node at <code>absPath</code> is read-only
 due to a checked-in node. Implementations may differ on when this
 validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch or on persists, if a lock prevents the operation.
 Implementations may differ on when this validation is performed.

 @param absPath an absolute path to an existing node.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve the node.
 @throws AccessDeniedException if the current session does not have
                               sufficient access to perform the operation.
 @throws LockException         if a lock applies at the node at
                               <code>absPath</code> and this implementation performs this validation
                               immediately.
 @throws VersionException      if the node at <code>absPath</code> is read-only
                               due to a checked-in node and this implementation performs this validation
                               immediately.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>RetentionManager</code> object is accessed via {@link
 javax.jcr.Session#getRetentionManager()}.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.retention.RetentionManager -->
  <!-- start interface javax.jcr.retention.RetentionPolicy -->
  <interface name="RetentionPolicy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the name of the retention policy. A JCR name.

 @return the name of the access control policy. A JCR name.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An <code>RetentionPolicy</code> is an object with a name and an optional
 description.

 @see RetentionManager#getRetentionPolicy(String)
 @see RetentionManager#setRetentionPolicy(String, RetentionPolicy)
 @see RetentionManager#removeRetentionPolicy(String)
 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.retention.RetentionPolicy -->
  <doc>
  <![CDATA[Provides interfaces and classes for content repository retention management
functionality.]]>
  </doc>
</package>
<package name="javax.jcr.security">
  <!-- start interface javax.jcr.security.AccessControlEntry -->
  <interface name="AccessControlEntry"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPrincipal" return="java.security.Principal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the principal associated with this access control entry.

 @return a <code>Principal</code>.]]>
      </doc>
    </method>
    <method name="getPrivileges" return="javax.jcr.security.Privilege[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the privileges associated with this access control entry.

 @return an array of <code>Privilege</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An <code>AccessControlEntry</code> represents the association of one or more
 <code>Privilege</code> objects with a specific <code>Principal</code>.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.security.AccessControlEntry -->
  <!-- start class javax.jcr.security.AccessControlException -->
  <class name="AccessControlException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessControlException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by access control related methods of
 <code>AccessControlManager</code>.

 @since JCR 2.0]]>
    </doc>
  </class>
  <!-- end class javax.jcr.security.AccessControlException -->
  <!-- start interface javax.jcr.security.AccessControlList -->
  <interface name="AccessControlList"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.security.AccessControlPolicy"/>
    <method name="getAccessControlEntries" return="javax.jcr.security.AccessControlEntry[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all access control entries present with this policy.
 <p>
 This method is only guaranteed to return an <code>AccessControlEntry</code>
 if that <code>AccessControlEntry</code> has been assigned <i>through this
 API</i>.

 @return all access control entries present with this policy.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="addAccessControlEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="principal" type="java.security.Principal"/>
      <param name="privileges" type="javax.jcr.security.Privilege[]"/>
      <exception name="AccessControlException" type="javax.jcr.security.AccessControlException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds an access control entry to this policy consisting of the specified
 <code>principal</code> and the specified <code>privileges</code>.
 <p>
 This method returns <code>true</code> if this policy was modified,
 <code>false</code> otherwise.
 <p>
 How the entries are grouped within the list is an implementation detail.
 An implementation may e.g. combine the specified privileges with those
 added by a previous call to <code>addAccessControlEntry</code> for the
 same <code>Principal</code>. However, a call to <code>addAccessControlEntry</code>
 for a given <code>Principal</code> can never remove a
 <code>Privilege</code> added by a previous call.
 <p>
 The modification does not take effect until this policy has been set to a
 node by calling {@link AccessControlManager#setPolicy(String,
 AccessControlPolicy)} and <code>save</code> is performed.

 @param principal  a <code>Principal</code>.
 @param privileges an array of <code>Privilege</code>s.
 @return <code>true</code> if this policy was modify; <code>false</code>
         otherwise.
 @throws AccessControlException if the specified principal or any of the
                                privileges does not exist or if some other access control related
                                exception occurs.
 @throws RepositoryException    if another error occurs.]]>
      </doc>
    </method>
    <method name="removeAccessControlEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ace" type="javax.jcr.security.AccessControlEntry"/>
      <exception name="AccessControlException" type="javax.jcr.security.AccessControlException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified <code>AccessControlEntry</code> from this policy.
 <p>
 Only exactly those entries obtained through <code>getAccessControlEntries</code>
 can be removed. This method does not take effect until this policy has
 been re-set to a node by calling {@link AccessControlManager#setPolicy(String,
 AccessControlPolicy)} and <code>save</code> is performed.

 @param ace the access control entry to be removed.
 @throws AccessControlException if the specified entry is not present on
                                the specified node.
 @throws RepositoryException    if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>AccessControlList</code> is an <code>AccessControlPolicy</code>
 representing a list of {@link AccessControlEntry access control entries}. It
 is mutable before being {@link AccessControlManager#setPolicy(String,
 AccessControlPolicy) set} to the AccessControlManager and consequently
 defines methods to read and mutate the list i.e. to get, add or remove
 individual entries.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.security.AccessControlList -->
  <!-- start interface javax.jcr.security.AccessControlManager -->
  <interface name="AccessControlManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSupportedPrivileges" return="javax.jcr.security.Privilege[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the privileges supported for absolute path <code>absPath</code>,
 which must be an existing node.
 <p>
 This method does not return the privileges held by the session. Instead,
 it returns the privileges that the repository supports.

 @param absPath an absolute path.
 @return an array of <code>Privilege</code>s.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve a node at that
                               location.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="privilegeFromName" return="javax.jcr.security.Privilege"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privilegeName" type="java.lang.String"/>
      <exception name="AccessControlException" type="javax.jcr.security.AccessControlException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the privilege with the specified <code>privilegeName</code>.
 Since the privilege name is a JCR name, it may be passed in either
 qualified or expanded form (see specification for details on JCR names).

 @param privilegeName the name of an existing privilege.
 @return the <code>Privilege</code> with the specified
         <code>privilegeName</code>.
 @throws AccessControlException if no privilege with the specified name
                                exists.
 @throws RepositoryException    if another error occurs.]]>
      </doc>
    </method>
    <method name="hasPrivileges" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="privileges" type="javax.jcr.security.Privilege[]"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns whether the session has the specified privileges for absolute
 path <code>absPath</code>, which must be an existing node.
 <p>
 Testing an aggregate privilege is equivalent to testing each non
 aggregate privilege among the set returned by calling
 <code>Privilege.getAggregatePrivileges()</code> for that privilege.
 <p>
 The results reported by the this method reflect the net <i>effect</i> of
 the currently applied control mechanisms. It does not reflect unsaved
 access control policies or unsaved access control entries. Changes to
 access control status caused by these mechanisms only take effect on
 <code>Session.save()</code> and are only then reflected in the results of
 the privilege test methods.

 @param absPath    an absolute path.
 @param privileges an array of <code>Privilege</code>s.
 @return <code>true</code> if the session has the specified privileges;
         <code>false</code> otherwise.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficent access to retrieve a node at that
                               location.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getPrivileges" return="javax.jcr.security.Privilege[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the privileges the session has for absolute path absPath, which
 must be an existing node.
 <p>
 The returned privileges are those for which {@link #hasPrivileges} would
 return <code>true</code>.
 <p>
 The results reported by the this method reflect the net <i>effect</i> of
 the currently applied control mechanisms. It does not reflect unsaved
 access control policies or unsaved access control entries. Changes to
 access control status caused by these mechanisms only take effect on
 <code>Session.save()</code> and are only then reflected in the results of
 the privilege test methods.

 @param absPath an absolute path.
 @return an array of <code>Privilege</code>s.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve a node at that
                               location.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getPolicies" return="javax.jcr.security.AccessControlPolicy[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>AccessControlPolicy</code> objects that have been set
 to the node at <code>absPath</code> or an empty array if no policy has
 been set. This method reflects the binding state, including transient
 policy modifications.
 <p>
 Use {@link #getEffectivePolicies(String)} in order to determine the
 policy that effectively applies at <code>absPath</code>.

 @param absPath an absolute path.
 @return an array of <code>AccessControlPolicy</code> objects or an empty
         array if no policy has been set.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve a node at that
                               location.
 @throws AccessDeniedException if the session lacks
                               <code>READ_ACCESS_CONTROL</code> privilege for the <code>absPath</code>
                               node.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getEffectivePolicies" return="javax.jcr.security.AccessControlPolicy[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>AccessControlPolicy</code> objects that currently are
 in effect at the node at <code>absPath</code>. This may be policies set
 through this API or some implementation specific (default) policies.

 @param absPath an absolute path.
 @return an array of <code>AccessControlPolicy</code> objects.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve a node at that
                               location.
 @throws AccessDeniedException if the session lacks
                               <code>READ_ACCESS_CONTROL</code> privilege for the <code>absPath</code>
                               node.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="getApplicablePolicies" return="javax.jcr.security.AccessControlPolicyIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the access control policies that are capable of being applied to
 the node at <code>absPath</code>.

 @param absPath an absolute path.
 @return an <code>AccessControlPolicyIterator</code> over the applicable
         access control policies or an empty iterator if no policies are
         applicable.
 @throws PathNotFoundException if no node at <code>absPath</code> exists
                               or the session does not have sufficient access to retrieve a node at that
                               location.
 @throws AccessDeniedException if the session lacks
                               <code>READ_ACCESS_CONTROL</code> privilege for the <code>absPath</code>
                               node.
 @throws RepositoryException   if another error occurs.]]>
      </doc>
    </method>
    <method name="setPolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="policy" type="javax.jcr.security.AccessControlPolicy"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessControlException" type="javax.jcr.security.AccessControlException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Binds the <code>policy</code> to the node at <code>absPath</code>.
 <p>
 The behavior of the call <code>acm.setPolicy(absPath, policy)</code>
 differs depending on how the <code>policy</code> object was originally
 acquired.
 <p>
 If <code>policy</code> was acquired through {@link #getApplicablePolicies
 acm.getApplicablePolicies(absPath)} then that <code>policy</code> object
 is <i>added</i> to the node at <code>absPath</code>.
 <p>
 On the other hand, if <code>policy</code> was acquired through {@link
 #getPolicies acm.getPolicies(absPath)} then that <code>policy</code>
 object (usually after being altered) replaces its former version on the
 node at <code>absPath</code>.
 <p>
 This is session-write method and therefore the access control policy is
 only dispatched on <code>save</code> and will only take effect upon
 persist.
 <p>
 A <code>VersionException</code> will be thrown either immediately, on
 dispatch or on persists, if the node at <code>absPath</code> is read-only
 due to a checked-in node. Implementations may differ on when this
 validation is performed.
 <p>
 A <code>LockException</code> will be thrown either immediately, on
 dispatch or on persists, if a lock prevents the operation.
 Implementations may differ on when this validation is performed.

 @param absPath an absolute path.
 @param policy  the <code>AccessControlPolicy</code> to be applied.
 @throws PathNotFoundException  if no node at <code>absPath</code> exists
                                or the session does not have sufficient access to retrieve a node at that
                                location.
 @throws AccessControlException if the policy is not applicable.
 @throws AccessDeniedException  if the session lacks
                                <code>MODIFY_ACCESS_CONTROL</code> privilege for the <code>absPath</code>
                                node.
 @throws LockException          if a lock applies at the node at
                                <code>absPath</code> and this implementation performs this validation
                                immediately.
 @throws VersionException       if the node at <code>absPath</code> is read-only
                                due to a checked-in node and this implementation performs this validation
                                immediately.
 @throws RepositoryException    if another error occurs.]]>
      </doc>
    </method>
    <method name="removePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="policy" type="javax.jcr.security.AccessControlPolicy"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="AccessControlException" type="javax.jcr.security.AccessControlException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified <code>AccessControlPolicy</code> from the node at
 <code>absPath</code>.
 <p>
 An <code>AccessControlPolicy</code> can only be removed if it was bound
 to the specified node through this API before. The effect of the removal
 only takes place upon <code>Session.save()</code>. Note, that an
 implementation default or any other effective <code>AccessControlPolicy</code>
 that has not been applied to the node before may never be removed using
 this method.
 <p>
 A <code>PathNotFoundException</code> is thrown if no node at
 <code>absPath</code> exists or the session does not have privilege to
 retrieve the node.
 <p>
 An <code>AccessControlException</code> is thrown if the policy to remove
 does not exist at the node at <code>absPath</code>.
 <p>
 An <code>AccessDeniedException</code> is thrown if the session lacks
 <code>MODIFY_ACCESS_CONTROL</code> privilege for the <code>absPath</code>
 node.
 <p>
 An <code>LockException</code> is thrown either immediately, on dispatch
 or on persists, if the node at <code>absPath</code> is locked.
 Implementations may differ on when this validation is performed.
 <p>
 An <code>VersionException</code> is thrown either immediately, on
 dispatch or on persists, if the node at <code>absPath</code> is read-only
 due to a checked-in node.Implementations may differ on when this
 validation is performed.
 <p>
 A <code>RepositoryException</code> is thrown if another error occurs.

 @param absPath an absolute path.
 @param policy  the policy to be removed.
 @throws PathNotFoundException  if no node at <code>absPath</code> exists
                                or the session does not have sufficient access to retrieve a node at that
                                location.
 @throws AccessControlException if no policy exists.
 @throws AccessDeniedException  if the session lacks
                                <code>MODIFY_ACCESS_CONTROL</code> privilege for the <code>absPath</code>
                                node.
 @throws LockException          if a lock applies at the node at
                                <code>absPath</code> and this implementation performs this validation
                                immediately instead of waiting until <code>save</code>.
 @throws VersionException       if the node at <code>absPath</code> is
                                versionable and checked-in or is non-versionable but its nearest
                                versionable ancestor is checked-in and this implementation performs this
                                validation immediately instead of waiting until <code>save</code>.
 @throws RepositoryException    if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>AccessControlManager</code> object is accessed via {@link
 javax.jcr.Session#getAccessControlManager()}. It provides methods for: <ul>
 <li>Access control discovery</li> <li>Assigning access control policies</li>
 </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.security.AccessControlManager -->
  <!-- start interface javax.jcr.security.AccessControlPolicy -->
  <interface name="AccessControlPolicy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[The <code>AccessControlPolicy</code> is a marker interface for all kind of
 access control policies. This API defines two subinterfaces: <ul> <li>{@link
 NamedAccessControlPolicy},</li> <li>{@link AccessControlList}.</li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.security.AccessControlPolicy -->
  <!-- start interface javax.jcr.security.AccessControlPolicyIterator -->
  <interface name="AccessControlPolicyIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextAccessControlPolicy" return="javax.jcr.security.AccessControlPolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>AccessControlPolicy</code> in the iteration.

 @return the next <code>AccessControlPolicy</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>AccessControlPolicy</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>AccessControlPolicy</code>s
 with <code>nextAccessControlPolicy</code> as well as a <code>skip</code>
 method inherited from <code>RangeIterator</code>.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.security.AccessControlPolicyIterator -->
  <!-- start interface javax.jcr.security.NamedAccessControlPolicy -->
  <interface name="NamedAccessControlPolicy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.security.AccessControlPolicy"/>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the name of the access control policy, which is JCR name and
 should be unique among the choices applicable to any particular node.

 @return the name of the access control policy. A JCR name.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An <code>NamedAccessControlPolicy</code> is an opaque access control policy
 that is described by a JCR name and optionally a description.
 <code>NamedAccessControlPolicy</code> are immutable and can therefore be
 directly applied to a node without additional configuration step.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.security.NamedAccessControlPolicy -->
  <!-- start interface javax.jcr.security.Privilege -->
  <interface name="Privilege"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this privilege.
 <p>
 Since the privilege name is a JCR name, it must be returned
 in qualified form, according to the prevailing namespace-to-prefix
 mapping in the current <code>Session</code> (see the specification
 for details on JCR names).

 @return the name of this privilege.]]>
      </doc>
    </method>
    <method name="isAbstract" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this privilege is an abstract privilege.

 @return <code>true</code> if this privilege is an abstract privilege;
         <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="isAggregate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this privilege is an aggregate privilege.

 @return <code>true</code> if this privilege is an aggregate privilege;
         <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="getDeclaredAggregatePrivileges" return="javax.jcr.security.Privilege[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this privilege is an aggregate privilege, returns the privileges
 directly contained by the aggregate privilege. Otherwise returns an empty
 array.

 @return an array of <code>Privilege</code>s]]>
      </doc>
    </method>
    <method name="getAggregatePrivileges" return="javax.jcr.security.Privilege[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this privilege is an aggregate privilege, returns the privileges it
 contains, the privileges contained by any aggregate privileges among
 those, and so on (the transitive closure of privileges contained by this
 privilege). Otherwise returns an empty array.

 @return an array of <code>Privilege</code>s]]>
      </doc>
    </method>
    <field name="JCR_READ" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:read</code> (in expanded form), the
 privilege to retrieve a node and get its properties and their values.]]>
      </doc>
    </field>
    <field name="JCR_MODIFY_PROPERTIES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:modifyProperties</code> (in expanded
 form), the privilege to create, modify and remove the properties of a
 node.]]>
      </doc>
    </field>
    <field name="JCR_ADD_CHILD_NODES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:addChildNodes</code> (in expanded
 form), the privilege to create child nodes of a node.]]>
      </doc>
    </field>
    <field name="JCR_REMOVE_NODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:removeNode</code> (in expanded form),
 the privilege to remove a node.
 <p>
 In order to actually remove a node requires <code>jcr:removeNode</code>
 on that node and <code>jcr:removeChildNodes</code> on the parent node.
 <p>
 The distinction is provided in order to reflect implementations that
 internally model "remove" as a "delete" instead of a "unlink". A
 repository that uses the "delete" model can have <code>jcr:removeChildNodes</code>
 in every access control policy, so that removal is effectively controlled
 by <code>jcr:removeNode</code>.]]>
      </doc>
    </field>
    <field name="JCR_REMOVE_CHILD_NODES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:removeChildNodes</code> (in expanded
 form), the privilege to remove child nodes of a node. In order to
 actually remove a node requires <code>jcr:removeNode</code> on that node
 and <code>jcr:removeChildNodes</code> on the parent node.
 <p>
 The distinction is provided in order to reflect implementations that
 internally model "remove" as a "unlink" instead of a "delete". A
 repository that uses the "unlink" model can have <code>jcr:removeNode</code>
 in every access control policy, so that removal is effectively controlled
 by <code>jcr:removeChildNodes</code>.]]>
      </doc>
    </field>
    <field name="JCR_WRITE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:write</code> (in expanded form), an
 aggregate privilege that contains: <ul> <li><code>jcr:modifyProperties</code></li>
 <li><code>jcr:addChildNodes</code></li> <li><code>jcr:removeNode</code></li>
 <li><code>jcr:removeChildNodes</code></li> </ul>]]>
      </doc>
    </field>
    <field name="JCR_READ_ACCESS_CONTROL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:readAccessControl</code> (in expanded
 form), the privilege to get the access control policy of a node.]]>
      </doc>
    </field>
    <field name="JCR_MODIFY_ACCESS_CONTROL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:modifyAccessControl</code> (in expanded
 form), the privilege to modify the access control policies of a node.]]>
      </doc>
    </field>
    <field name="JCR_LOCK_MANAGEMENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:lockManagement</code> (in expanded
 form), the privilege to lock and unlock a node.]]>
      </doc>
    </field>
    <field name="JCR_VERSION_MANAGEMENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:versionManagement</code> (in expanded
 form), the privilege to perform versioning operations on a node.]]>
      </doc>
    </field>
    <field name="JCR_NODE_TYPE_MANAGEMENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:nodeTypeManagement</code> (in expanded
 form), the privilege to add and remove mixin node types and change the
 primary node type of a node.]]>
      </doc>
    </field>
    <field name="JCR_RETENTION_MANAGEMENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:retentionManagement</code> (in expanded
 form), the privilege to perform retention management operations on a
 node.]]>
      </doc>
    </field>
    <field name="JCR_LIFECYCLE_MANAGEMENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:lifecycleManagement</code> (in expanded
 form), the privilege to perform lifecycle operations on a node.]]>
      </doc>
    </field>
    <field name="JCR_ALL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A constant representing <code>jcr:all</code> (in expanded form), an
 aggregate privilege that contains all predefined privileges. <ul>
 <li><code>jcr:read</code></li> <li><code>jcr:write</code></li>
 <li><code>jcr:readAccessControl</code></li> <li><code>jcr:modifyAccessControl</code></li>
 <li><code>jcr:lockManagement</code></li> <li><code>jcr:versionManagement</code></li>
 <li><code>jcr:nodeTypeManagement</code></li> <li><code>jcr:retentionManagement</code></li>
 <li><code>jcr:lifecycleManagement</code></li> </ul> It should, in
 addition, include all implementation-defined privileges.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A privilege represents the capability of performing a particular set of
 operations on items in the JCR repository. Each privilege is identified by a
 JCR name. JCR defines a set of standard privileges in the <code>jcr</code>
 namespace. Implementations may add additional privileges in namespaces other
 than <code>jcr</code>.
 <p>
 A privilege may be an aggregate privilege. Aggregate privileges are sets of
 other privileges. Granting, denying, or testing an aggregate privilege is
 equivalent to individually granting, denying, or testing each privilege it
 contains. The privileges contained by an aggregate privilege may themselves
 be aggregate privileges if the resulting privilege graph is acyclic.
 <p>
 A privilege may be an abstract privilege. Abstract privileges cannot
 themselves be granted or denied, but can be composed into aggregate
 privileges which are granted or denied.
 <p>
 A privilege can be both aggregate and abstract.

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.security.Privilege -->
  <doc>
  <![CDATA[Provides interfaces and classes for content repository access control management
functionality.]]>
  </doc>
</package>
<package name="javax.jcr.util">
  <!-- start class javax.jcr.util.TraversingItemVisitor -->
  <class name="TraversingItemVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.ItemVisitor"/>
    <constructor name="TraversingItemVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class.
 <p>
 The tree of <code>Item</code>s will be traversed in a depth-first manner
 (default behavior).]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class.

 @param breadthFirst if <code>breadthFirst</code> is true then traversal
                     is done in a breadth-first manner; otherwise it is done in a depth-first
                     manner (which is the default behavior).]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor" type="boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class.

 @param breadthFirst if <code>breadthFirst</code> is true then traversal
                     is done in a breadth-first manner; otherwise it is done in a depth-first
                     manner (which is the default behavior).
 @param maxLevel     the 0-based level up to which the hierarchy should be
                     traversed (if it's -1, the hierarchy will be traversed until there are no
                     more children of the current item).]]>
      </doc>
    </constructor>
    <method name="entering"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behavior performed before a
 <code>Property</code> is visited.

 @param property the <code>Property</code> that is accepting this
                 visitor.
 @param level    hierarchy level of this property (the root node starts at
                 level 0).
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="entering"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behavior performed before a
 <code>Node</code> is visited.

 @param node  the <code>Node</code> that is accepting this visitor.
 @param level hierarchy level of this node (the root node starts at level
              0).
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behavior performed after a
 <code>Property</code> is visited.

 @param property the <code>Property</code> that is accepting this
                 visitor.
 @param level    hierarchy level of this property (the root node starts at
                 level 0).
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Implement this method to add behavior performed after a <code>Node</code>
 is visited.

 @param node  the <code>Node</code> that is accepting this visitor.
 @param level hierarchy level of this node (the root node starts at level
              0).
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Called when the <code>Visitor</code> is passed to a
 <code>Property</code>.
 <p>
 It calls <code>TraversingItemVisitor.entering(Property, int)</code>
 followed by <code>TraversingItemVisitor.leaving(Property, int)</code>.
 Implement these abstract methods to specify behavior on 'arrival at' and
 'after leaving' the <code>Property</code>.
 <p>
 If this method throws, the visiting process is aborted.

 @param property the <code>Property</code> that is accepting this
                 visitor.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Called when the <code>Visitor</code> is passed to a <code>Node</code>.
 <p>
 It calls <code>TraversingItemVisitor.entering(Node, int)</code> followed
 by <code>TraversingItemVisitor.leaving(Node, int)</code>. Implement these
 abstract methods to specify behavior on 'arrival at' and 'after leaving'
 the <code>Node</code>.
 <p>
 If this method throws, the visiting process is aborted.

 @param node the <code>Node</code> that is accepting this visitor.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <field name="breadthFirst" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates if traversal should be done in a breadth-first manner rather
 than depth-first (which is the default).]]>
      </doc>
    </field>
    <field name="maxLevel" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The 0-based level up to which the hierarchy should be traversed (if it's
 -1, the hierarchy will be traversed until there are no more children of
 the current item).]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An implementation of <code>ItemVisitor</code>.
 <p>
 <code>TraversingItemVisitor</code> is an abstract utility class which allows
 to easily traverse an <code>Item</code> hierarchy.
 <p>
 <p><code>TraversingItemVisitor</code> makes use of the Visitor Pattern as
 described in the book 'Design Patterns' by the Gang Of Four (Gamma et al.).
 <p>
 <p>Tree traversal is done observing the left-to-right order of child
 <code>Item</code>s if such an order is supported and exists.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.util.TraversingItemVisitor -->
  <!-- start class javax.jcr.util.TraversingItemVisitor.Default -->
  <class name="TraversingItemVisitor.Default" extends="javax.jcr.util.TraversingItemVisitor"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TraversingItemVisitor.Default"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see TraversingItemVisitor#TraversingItemVisitor()]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor.Default" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param breadthFirst a boolean
 @see TraversingItemVisitor#TraversingItemVisitor()]]>
      </doc>
    </constructor>
    <constructor name="TraversingItemVisitor.Default" type="boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param breadthFirst a boolean
 @param maxLevel     an int
 @see TraversingItemVisitor#TraversingItemVisitor(boolean, int)]]>
      </doc>
    </constructor>
    <method name="entering"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#entering(Node, int)]]>
      </doc>
    </method>
    <method name="entering"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#entering(Property, int)]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="javax.jcr.Node"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#leaving(Node, int)]]>
      </doc>
    </method>
    <method name="leaving"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="javax.jcr.Property"/>
      <param name="level" type="int"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[@see TraversingItemVisitor#leaving(Property, int)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Convenience class providing default implementations of the abstract
 methods of <code>TraversingItemVisitor</code>.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.util.TraversingItemVisitor.Default -->
  <doc>
  <![CDATA[Provides utility classes for the content repository API.]]>
  </doc>
</package>
<package name="javax.jcr.version">
  <!-- start class javax.jcr.version.ActivityViolationException -->
  <class name="ActivityViolationException" extends="javax.jcr.version.VersionException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ActivityViolationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="ActivityViolationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="ActivityViolationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="ActivityViolationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception will be thrown by <code>Node.checkout</code> and
 <code>Node.checkpoint</code> if an activity A is present on the current
 session and any of the following conditions is met: <ul> <li>There already is
 a node in another workspace that has a checked-out node for the version
 history of N whose jcr:activity references A.</li> <li>There is a version in
 the version history of N that is not a predecessor of N but whose
 jcr:activity references A</li>. </ul>

 @since JCR 2.0]]>
    </doc>
  </class>
  <!-- end class javax.jcr.version.ActivityViolationException -->
  <!-- start class javax.jcr.version.LabelExistsVersionException -->
  <class name="LabelExistsVersionException" extends="javax.jcr.version.VersionException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LabelExistsVersionException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="LabelExistsVersionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="LabelExistsVersionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="LabelExistsVersionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by <code>VersionHistory.addVersionLabel</code> if
 <code>moveLabel</code> is set to <code>false</code> and an attempt is made to
 add a label that already exists in the <code>VersionHistory</code>.

 @since JCR 2.0]]>
    </doc>
  </class>
  <!-- end class javax.jcr.version.LabelExistsVersionException -->
  <!-- start class javax.jcr.version.OnParentVersionAction -->
  <class name="OnParentVersionAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nameFromValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="int"/>
      <doc>
      <![CDATA[Returns the name of the specified <code>action</code>, as used in
 serialization.

 @param action the on-version action
 @return the name of the specified <code>action</code>
 @throws IllegalArgumentException if <code>action</code> is not a valid
                                  on-version action.]]>
      </doc>
    </method>
    <method name="valueFromName" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the numeric constant value of the on-version action with the
 specified name.

 @param name the name of the on-version action
 @return the numeric constant value
 @throws IllegalArgumentException if <code>name</code> is not a valid
                                  on-version action name.]]>
      </doc>
    </method>
    <field name="COPY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The action constants.]]>
      </doc>
    </field>
    <field name="VERSION" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INITIALIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COMPUTE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IGNORE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ABORT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_COPY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The names of the defined on-version actions, as used in serialization.]]>
      </doc>
    </field>
    <field name="ACTIONNAME_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_INITIALIZE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_COMPUTE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_IGNORE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTIONNAME_ABORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The possible actions specified by the <code>onParentVersion</code> attribute
 in a property definition within a node type definition.
 <p>
 This interface defines the following actions: <UL> <LI><code>COPY</code>
 <LI><code>VERSION</code> <LI><code>INITIALIZE</code> <LI><code>COMPUTE</code>
 <LI><code>IGNORE</code> <LI><code>ABORT</code> </UL>
 <p>
 Every item (node or property) in the repository has a status indicator that
 governs what happens to that item when its parent node is versioned. This
 status is defined by the <code>onParentVersion</code> attribute in the
 <code>PropertyDefinition</code> or <code>NodeDefinition</code> that applies
 to the item in question.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.version.OnParentVersionAction -->
  <!-- start interface javax.jcr.version.Version -->
  <interface name="Version"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Node"/>
    <method name="getContainingHistory" return="javax.jcr.version.VersionHistory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>VersionHistory</code> that contains this
 <code>Version</code>.

 @return the <code>VersionHistory</code> that contains this
         <code>Version</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getCreated" return="java.util.Calendar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the date this version was created. This corresponds to the value
 of the <code>jcr:created</code> property in the <code>nt:version</code>
 node that represents this version.

 @return a <code>Calendar</code> object
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getLinearSuccessor" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Assuming that this <code>Version</code> object was acquired through a
 <code>Workspace</code> <code>W</code> and is within the
 <code>VersionHistory</code> <code>H</code>, this method returns the
 successor of this version along the same line of descent as is returned
 by <code>H.getAllLinearVersions()</code> where <code>H</code> was also
 acquired through <code>W</code>.
 <p>
 Note that under simple versioning the behavior of this method is
 equivalent to getting the unique successor (if any) of this version.

 @return a <code>Version</code> or <code>null</code> if no linear
         successor exists.
 @throws RepositoryException if an error occurs.
 @see VersionHistory#getAllLinearVersions]]>
      </doc>
    </method>
    <method name="getSuccessors" return="javax.jcr.version.Version[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the successor versions of this version. This corresponds to
 returning all the <code>nt:version</code> nodes referenced by the
 <code>jcr:successors</code> multi-value property in the
 <code>nt:version</code> node that represents this version.
 <p>
 In a simple versioning repository this method

 @return a <code>Version</code> array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getLinearPredecessor" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Assuming that this <code>Version</code> object was acquired through a
 <code>Workspace</code> <code>W</code> and is within the
 <code>VersionHistory</code> <code>H</code>, this method returns the
 predecessor of this version along the same line of descent as is returned
 by <code>H.getAllLinearVersions()</code> where <code>H</code> was also
 acquired through <code>W</code>.
 <p>
 Note that under simple versioning the behavior of this method is
 equivalent to getting the unique predecessor (if any) of this version.

 @return a <code>Version</code> or <code>null</code> if no linear
         predecessor exists.
 @throws RepositoryException if an error occurs.
 @see VersionHistory#getAllLinearVersions]]>
      </doc>
    </method>
    <method name="getPredecessors" return="javax.jcr.version.Version[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[In both simple and full versioning repositories, this method returns the
 predecessor versions of this version. This corresponds to returning all
 the <code>nt:version</code> nodes whose <code>jcr:successors</code>
 property includes a reference to the <code>nt:version</code> node that
 represents this version.

 @return a <code>Version</code> array.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getFrozenNode" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the frozen node of this version.

 @return a <code>Node</code> object
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>Version</code> object wraps an <code>nt:version</code> node. It
 provides convenient access to version information.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.version.Version -->
  <!-- start class javax.jcr.version.VersionException -->
  <class name="VersionException" extends="javax.jcr.RepositoryException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with <code>null</code> as its
 detail message.]]>
      </doc>
    </constructor>
    <constructor name="VersionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail
 message.

 @param message the detail message. The detail message is saved for later
                retrieval by the {@link #getMessage()} method.]]>
      </doc>
    </constructor>
    <constructor name="VersionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified detail message
 and root cause.

 @param message   the detail message. The detail message is saved for later
                  retrieval by the {@link #getMessage()} method.
 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <constructor name="VersionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class with the specified root cause.

 @param rootCause root failure cause]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown by Version.addSuccessor if an invalid version graph
 operation is attempted.]]>
    </doc>
  </class>
  <!-- end class javax.jcr.version.VersionException -->
  <!-- start interface javax.jcr.version.VersionHistory -->
  <interface name="VersionHistory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.Node"/>
    <method name="getVersionableUUID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of JCR 2.0, {@link #getVersionableIdentifier} should be
             used instead.">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the identifier of the versionable node for which this is the
 version history.

 @return the identifier of the versionable node for which this is the
         version history.
 @throws RepositoryException if an error occurs.
 @deprecated As of JCR 2.0, {@link #getVersionableIdentifier} should be
             used instead.]]>
      </doc>
    </method>
    <method name="getVersionableIdentifier" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the identifier of the versionable node for which this is the
 version history.

 @return the identifier of the versionable node for which this is the
         version history.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getRootVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the root version of this version history.

 @return a <code>Version</code> object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getAllLinearVersions" return="javax.jcr.version.VersionIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns an iterator over all the versions in the <i>line of
 descent</i> from the root version to that base version within this
 history <i>that is bound to the workspace through which this
 <code>VersionHistory</code> was accessed</i>.
 <p>
 Within a version history <code>H</code>, <code>B</code> is the base
 version bound to workspace <code>W</code> if and only if there exists a
 versionable node <code>N</code> in <code>W</code> whose version history
 is <code>H</code> and <code>B</code> is the base version of
 <code>N</code>.
 <p>
 The <i>line of descent</i> from version <code>V1</code> to
 <code>V2</code>, where <code>V2</code> is a successor of <code>V1</code>,
 is the ordered list of versions starting with <code>V1</code> and
 proceeding through each direct successor to <code>V2</code>.
 <p>
 The versions are returned in order of creation date, from oldest to
 newest.
 <p>
 Note that in a simple versioning repository the behavior of this method
 is equivalent to returning all versions in the version history in order
 from oldest to newest.

 @return a <code>VersionIterator</code> object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getAllVersions" return="javax.jcr.version.VersionIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all the versions within this version history. If
 the version graph of this history is linear then the versions are
 returned in order of creation date, from oldest to newest. Otherwise the
 order of the returned versions is implementation-dependent.

 @return a <code>VersionIterator</code> object.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getAllLinearFrozenNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method returns all the frozen nodes of all the versions in this
 version history in the same order as {@link #getAllLinearVersions}.

 @return a <code>NodeIterator</code> object.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getAllFrozenNodes" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns an iterator over all the frozen nodes of all the versions of this
 version history. Under simple versioning the order of the returned nodes
 will be the order of their creation. Under full versioning the order is
 implementation-dependent.

 @return a <code>NodeIterator</code> object.
 @throws RepositoryException if an error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves a particular version from this version history by version
 name.

 @param versionName a version name
 @return a <code>Version</code> object.
 @throws VersionException    if the specified version is not in this version
                             history.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getVersionByLabel" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Retrieves a particular version from this version history by version
 label.

 @param label a version label
 @return a <code>Version</code> object.
 @throws VersionException    if the specified <code>label</code> is not in
                             this version history.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="addVersionLabel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <param name="label" type="java.lang.String"/>
      <param name="moveLabel" type="boolean"/>
      <exception name="LabelExistsVersionException" type="javax.jcr.version.LabelExistsVersionException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Adds the specified label to the specified version.
 <p>
 The label must be a JCR name in either qualified or expanded form and
 therefore must conform to the syntax restriction that apply to such
 names. In particular a colon (":") should not be used unless it is
 intended as a prefix delimiter in a qualified name.
 <p>
 Adding a version label to a version corresponds to adding a reference
 property with a name specified by the <code>label</code> parameter to the
 <code>jcr:versionLabels</code> sub node of the <code>nt:versionHistory</code>
 node. The reference property points to the <code>nt:version</code> node
 that represents the specified version.
 <p>
 This is a workspace-write method and therefore the change is made
 immediately.
 <p>
 Within a particular version history, a given label may appear a maximum
 of once. If the specified label is already assigned to a version in this
 history and <code>moveLabel</code> is <code>true</code> then the label is
 removed from its current location and added to the version with the
 specified <code>versionName</code>. If <code>moveLabel</code> is
 <code>false</code>, then an attempt to add a label that already exists
 will fail.

 @param versionName the name of the version to which the label is to be
                    added.
 @param label       the label to be added, A JCR name in either expanded or
                    qualified form.
 @param moveLabel   if <code>true</code>, then if <code>label</code> is
                    already assigned to a version in this version history, it is moved to the
                    new version specified; if <code>false</code>, then attempting to assign
                    an already used label will throw a <code>LabelExistsVersionException</code>.
 @throws LabelExistsVersionException if <code>moveLabel</code> is
                                     <code>false</code>, and an attempt is made to add a label that already
                                     exists in this version history.
 @throws VersionException            if the specified version does not exist in this
                                     version history or if the specified version is the root version
                                     (<code>jcr:rootVersion</code>).
 @throws RepositoryException         if another error occurs.]]>
      </doc>
    </method>
    <method name="removeVersionLabel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the specified label from among the labels of this version
 history. The label must be a JCR name in either qualified or expanded
 form. This corresponds to removing a property from the
 <code>jcr:versionLabels</code> child node of the <code>nt:versionHistory</code>
 node that represents this version history.
 <p>
 This is workspace-write method and therefore the change is made
 immediately.

 @param label a version label. A JCR name in either expanded or qualified
              form.
 @throws VersionException    if the name label does not exist in this version
                             history.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="hasVersionLabel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if any version in the history has the given
 <code>label</code>. The label must be a JCR name in either qualified or
 expanded form.

 @param label a version label. A JCR name in either expanded or qualified
              form.
 @return a <code>boolean</code>.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="hasVersionLabel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="label" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns true if the given version has the given <code>label</code>. The
 label must be a JCR name in either qualified or expanded form.

 @param version a Version object
 @param label   a version label. A JCR name in either expanded or qualified
                form.
 @return a <code>boolean</code>.
 @throws VersionException    if the specified <code>version</code> is not of
                             this version history.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="getVersionLabels" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all version labels of the history or an empty array if there are
 none.

 @return a <code>String</code> array containing all the labels of the
         version history.
 @throws RepositoryException if an error occurs.]]>
      </doc>
    </method>
    <method name="getVersionLabels" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns all version labels of the given <code>version</code> - empty
 array if none. Throws a <code>VersionException</code> if the specified
 <code>version</code> is not in this version history.

 @param version a Version object
 @return a <code>String</code> array containing all the labels of the
         given version
 @throws VersionException    if the specified <code>version</code> is not in
                             this version history.
 @throws RepositoryException if another error occurs.]]>
      </doc>
    </method>
    <method name="removeVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="ReferentialIntegrityException" type="javax.jcr.ReferentialIntegrityException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Removes the named version from this version history and automatically
 repairs the version graph. If the version to be removed is
 <code>V</code>, <code>V</code>'s predecessor set is <code>P</code> and
 <code>V</code>'s successor set is <code>S</code>, then the version graph
 is repaired s follows: <ul> <li>For each member of <code>P</code>, remove
 the reference to <code>V</code> from its successor list and add
 references to each member of <code>S</code>. <li>For each member of
 <code>S</code>, remove the reference to <code>V</code> from its
 predecessor list and add references to each member of <code>P</code>.
 </ul> Note that this change is made immediately; there is no need to call
 <code>save</code>. In fact, since the the version storage is read-only
 with respect to normal repository methods, <code>save</code> does not
 even function in this context.

 @param versionName the name of a version in this version history.
 @throws ReferentialIntegrityException if the specified version is
                                       currently the target of a <code>REFERENCE</code> property elsewhere in
                                       the repository (not necessarily in this workspace) and the current
                                       <code>Session</code> has read access to that <code>REFERENCE</code>
                                       property.
 @throws AccessDeniedException         if the current Session does not have
                                       permission to remove the specified version or if the specified version is
                                       currently the target of a <code>REFERENCE</code> property elsewhere in
                                       the repository (not just in this workspace) and the current
                                       <code>Session</code> does not have read access to that
                                       <code>REFERENCE</code> property.
 @throws UnsupportedRepositoryOperationException
                                       if this operation is not
                                       supported by the implementation.
 @throws VersionException              if the named version is not in this version
                                       history.
 @throws RepositoryException           if another error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A <code>VersionHistory</code> object wraps an <code>nt:versionHistory</code>
 node. It provides convenient access to version history information.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.version.VersionHistory -->
  <!-- start interface javax.jcr.version.VersionIterator -->
  <interface name="VersionIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.jcr.RangeIterator"/>
    <method name="nextVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next <code>Version</code> in the iteration.

 @return the next <code>Version</code> in the iteration.
 @throws java.util.NoSuchElementException
          if iteration has no more
          <code>Version</code>s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows easy iteration through a list of <code>Version</code>s objects with
 <code>nextVersion</code> as well as a <code>skip</code> method inherited from
 <code>RangeIterator</code>.]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.version.VersionIterator -->
  <!-- start interface javax.jcr.version.VersionManager -->
  <interface name="VersionManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="checkin" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Creates for the versionable node at <code>absPath</code> a new version
 with a system generated version name and returns that version (which will
 be the new base version of this node). Sets the <code>jcr:checkedOut</code>
 property to false thus putting the node into the <i>checked-in</i> state.
 This means that the node and its <i>connected non-versionable
 subgraph</i> become read-only. A node's connected non-versionable
 subgraph is the set of non-versionable descendant nodes reachable from
 that node through child links without encountering any versionable nodes.
 In other words, the read-only status flows down from the checked-in node
 along every child link until either a versionable node is encountered or
 an item with no children is encountered. In a system that supports only
 simple versioning the connected non-versionable subgraph will be
 equivalent to the whole subgraph, since simple-versionable nodes cannot
 have simple-versionable descendants.
 <p>
 Read-only status means that an item cannot be altered by the client using
 standard API methods (<code>addNode</code>, <code>setProperty</code>,
 etc.). The only exceptions to this rule are the {@link #restore} (all
 signatures), {@link #restoreByLabel}, {@link #restore}, {@link #merge}
 and {@link Node#update} operations; these do not respect read-only status
 due to check-in. Note that <code>remove</code> of a read-only node is
 possible, as long as its parent is not read-only (since removal is an
 alteration of the parent node).
 <p>
 If the node is already checked-in, this method has no effect but returns
 the current base version of the node at <code>absPath</code>.
 <p>
 If a repository supports configurations and baselines and the node at
 <code>absPath</code> is a configuration proxy node in configuration storage
 then checkin of that node has the additional side effect of storing in the
 created version, the state of the configuration that this proxy node represents.
 In particular, the current bs version of each versionable node within the
 configuration is recorded in some implementation-specific way within the
 version created by the checkin. For checkin to succeed on a configuration
 proxy node, every versionable node within the configuration in question must
 have been checked-in at least once (i.e., each must have a current base version
 which is not the root version of its version history).
 <p>
 If <code>checkin</code> succeeds, the change to the
 <code>jcr:isCheckedOut</code> property is dispatched immediately;
 there is no need to call <code>save</code>.

 @param absPath an absolute path.
 @return the created version.
 @throws VersionException          if <code>jcr:predecessors</code> does not
                                   contain at least one value or if a child item of the node at
                                   <code>absPath</code> has an <code>OnParentVersion</code> status of
                                   <code>ABORT</code>. This includes the case where an unresolved merge
                                   failure exists on the node, as indicated by the presence of a
                                   <code>jcr:mergeFailed</code> property.
 @throws UnsupportedRepositoryOperationException
                                   If the node at
                                   <code>absPath</code> node is not versionable.
 @throws InvalidItemStateException If unsaved changes exist on the node at
                                   <code>absPath</code> or the node at <code>absPath</code> is
                                   a configuration proxy node and the configuration it represents
                                   includes a versionabe node that has never been checked-in.
 @throws LockException             if a lock prevents the operation.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="checkout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Sets the versionable node at <code>absPath</code> to checked-out status
 by setting its <code>jcr:isCheckedOut</code> property to
 <code>true</code>. Under full versioning it also sets the
 <code>jcr:predecessors</code> property to be a reference to the current
 base version (the same value as held in <code>jcr:baseVersion</code>).
 <p> This method puts the node into the <i>checked-out</i> state, making
 it and its connected non-versionable subgraph no longer read-only (see
 {@link #checkin(String)} for an explanation of the term "connected
 non-versionable subgraph". Under simple versioning this will simply be
 the whole subgraph). <p> If successful, these changes are dispatched
 immediately; there is no need to call <code>save</code>. <p> If the node
 at <code>absPath</code> is already checked-out, this method has no
 effect.

 @param absPath an absolute path.
 @throws UnsupportedRepositoryOperationException
                             If the node at
                             <code>absPath</code> is not versionable.
 @throws LockException       if a lock prevents the checkout.
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="checkpoint" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Performs a <code>checkin()</code> followed by a <code>checkout()</code>
 on the versionable node at <code>absPath</code>.
 <p>
 If the node is already checked-in, this method is equivalent to
 <code>checkout()</code>.

 @param absPath an absolute path.
 @return the created version.
 @throws VersionException          if a child item of the node at
                                   <code>absPath</code> has an <code>OnParentVersion</code> of
                                   <code>ABORT</code>. This includes the case where an unresolved merge
                                   failure exists on the node, as indicated by the presence of the
                                   <code>jcr:mergeFailed</code>.
 @throws UnsupportedRepositoryOperationException
                                   if the node at
                                   <code>absPath</code> is not versionable.
 @throws InvalidItemStateException if there are unsaved changes pending on
                                   the node at <code>absPath</code>.
 @throws LockException             if a lock prevents the operation.
 @throws RepositoryException       if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="isCheckedOut" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns <code>true</code> if the node at <code>absPath</code> is either
 <ul> <li>versionable (full or simple) and currently checked-out,</li>
 <li>non-versionable and its nearest versionable ancestor is checked-out
 or</li> <li>non-versionable and it has no versionable ancestor.</li>
 </ul>
 <p>
 Returns <code>false</code> if the node at <code>absPath</code> is either
 <ul> <li>versionable (full or simple) and currently checked-in or</li>
 <li>non-versionable and its nearest versionable ancestor is
 checked-in.</li> </ul>

 @param absPath an absolute path.
 @return a boolean
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="getVersionHistory" return="javax.jcr.version.VersionHistory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the <code>VersionHistory</code> object of the node at
 <code>absPath</code>. This object provides access to the
 <code>nt:versionHistory</code> node holding the node's versions.

 @param absPath an absolute path.
 @return a <code>VersionHistory</code> object
 @throws UnsupportedRepositoryOperationException
                             if the node at
                             <code>absPath</code> is not versionable.
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="getBaseVersion" return="javax.jcr.version.Version"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the current base version of the versionable node at
 <code>absPath</code>.

 @param absPath an absolute path.
 @return a <code>Version</code> object.
 @throws UnsupportedRepositoryOperationException
                             if the node at
                             <code>absPath</code> is not versionable.
 @throws RepositoryException If another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versions" type="javax.jcr.version.Version[]"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores a set of versions at once. Used in cases where a "chicken and
 egg" problem of mutually referring <code>REFERENCE</code> properties
 would prevent the restore in any serial order.
 <p>
 If the restore succeeds the changes made are
 dispatched immediately; there is no need to call <code>save</code>.
 <p>
 The following restrictions apply to the set of versions specified:
 <p>
 If <code>S</code> is the set of versions being restored simultaneously,
 <ul> <li> For every version <code>V</code> in <code>S</code> that
 corresponds to a <i>missing</i> node, there must also be a parent of V in
 S.</li> <li><code>S</code> must contain at least one version that
 corresponds to an existing node in the workspace.</li> <li> No
 <code>V</code> in <code>S</code> can be a root version
 (<code>jcr:rootVersion</code>).</li> </ul>
 <p>
 If any of these restrictions does not hold, the restore will fail because
 the system will be unable to determine the path locations to which one or
 more versions are to be restored. In this case a <code>VersionException</code>
 is thrown.
 <p>
 The versionable nodes in the current workspace that correspond to the
 versions being restored define a set of (one or more) subgraphs. An
 identifier collision occurs when the current workspace contains a node
 <i>outside these subgraphs</i> that has the same identifier as one of the
 nodes that would be introduced by the <code>restore</code> operation
 <i>into one of these subgraphs</i>. The result in such a case is governed
 by the <code>removeExisting</code> flag. If <code>removeExisting</code>
 is <code>true</code> then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed. If <code>removeExisting</code>
 is <code>false</code> then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.

 @param versions       The set of versions to be restored.
 @param removeExisting governs what happens on identifier collision.
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs with a node being
                                   restored.
 @throws UnsupportedRepositoryOperationException
                                   if one or more of the
                                   nodes to be restored is not versionable.
 @throws VersionException          if the set of versions to be restored is such
                                   that the original path location of one or more of the versions cannot be
                                   determined or if the <code>restore</code> would change the state of a
                                   existing versionable node that is currently checked-in or if a root
                                   version (<code>jcr:rootVersion</code>) is among those being restored.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> has
                                   pending unsaved changes.
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="versionName" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the node at <code>absPath</code> to the state defined by the
 version with the specified <code>versionName</code>.
 <p>
 If the node at <code>absPath</code> is not versionable, an
 <code>UnsupportedRepositoryOperationException</code> is thrown.
 <p>
 If successful, the change is dispatched immediately; there is no need
 to call <code>save</code>. This method will work regardless of whether
 the node at <code>absPath</code> is checked-in or not.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at this node</i> with the same identifier as a node that would be
 introduced by the <code>restore</code> operation <i>into the subgraph at
 this node</i>. The result in such a case is governed by the
 <code>removeExisting</code> flag. If <code>removeExisting</code> is
 <code>true</code>, then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed (if possible; otherwise a
 <code>RepositoryException</code> is thrown). If <code>removeExisting</code>
 is <code>false</code>, then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.

 @param absPath        an absolute path.
 @param versionName    a <code>Version</code> object
 @param removeExisting a boolean flag that governs what happens in case of
                       an identifier collision.
 @throws UnsupportedRepositoryOperationException
                                   if the node at
                                   <code>absPath</code> is not versionable.
 @throws VersionException          if the specified <code>version</code> is not
                                   part of this node's version history or if an attempt is made to restore
                                   the root version (<code>jcr:rootVersion</code>) or if no node exists
                                   at <code>absPath</code>.
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not
                                   necessarily the <code>Node</code> at <code>absPath</code>) has pending
                                   unsaved changes.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the node in the current workspace that is the versionable node of the
 specified <code>version</code> to the state reflected in that version.
 <p>
 If successful, the change is dispatched immediately; there is no need to call <code>save</code>.
 This method ignores checked-in status.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at this node</i> with the same identifier as a node that would be
 introduced by the <code>restore</code> operation <i>into the subgraph at
 this node</i>. The result in such a case is governed by the
 <code>removeExisting</code> flag. If <code>removeExisting</code> is
 <code>true</code>, then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed (if possible; otherwise a
 <code>RepositoryException</code> is thrown). If <code>removeExisting</code>
 is <code>false</code>, then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.

 @param version        a <code>Version</code> object
 @param removeExisting a boolean flag that governs what happens in case of
                       an identifier collision.
 @throws UnsupportedRepositoryOperationException
                                   if versioning is not
                                   supported.
 @throws VersionException          if the specified <code>version</code> does not
                                   have a corresponding node in the workspace <code>this</code>
                                   VersionManager has been created for or if an attempt is made to restore
                                   the root version (<code>jcr:rootVersion</code>).
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs.
 @throws InvalidItemStateException if this <code>Session</code> (not
                                   necessarily the <code>Node</code> at <code>absPath</code>) has pending
                                   unsaved changes.
 @throws LockException             if a lock prevents the restore.
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <method name="restore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="version" type="javax.jcr.version.Version"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="PathNotFoundException" type="javax.jcr.PathNotFoundException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ConstraintViolationException" type="javax.jcr.nodetype.ConstraintViolationException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the specified version to <code>absPath</code>.
 <p>
 There must be no existing node at <code>absPath</code>. If one exists,
 a <code>VersionException</code> is thrown.
 <p>
 There must be a parent node to the location at
 <code>absPath</code>, otherwise a <code>PathNotFoundException</code>
 is thrown.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at <code>absPath</code></i> with the same identifier as a node
 that would be introduced by the <code>restore</code> operation <i>into
 the subgraph at <code>absPath</code></i>. The result in such a case is
 governed by the <code>removeExisting</code> flag. If
 <code>removeExisting</code> is <code>true</code>, then the incoming node
 takes precedence, and the existing node (and its subgraph) is removed (if
 possible; otherwise a <code>RepositoryException</code> is thrown). If
 <code>removeExisting</code> is <code>false</code>, then a
 <code>ItemExistsException</code> is thrown and no changes are made. Note
 that this applies not only to cases where the restored node itself
 conflicts with an existing node but also to cases where a conflict occurs
 with any node that would be introduced into the workspace by the restore
 operation. In particular, conflicts involving subnodes of the restored
 node that have <code>OnParentVersion</code> settings of <code>COPY</code>
 or <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.
 <p>
 If the would-be parent of the location <code>absPath</code> is actually a
 property, or if a node type restriction would be violated, then a
 <code>ConstraintViolationException</code> is thrown.
 <p>
 If the <code>restore</code> succeeds, the changes made to this node are
 dispatched immediately; there is no need to call <code>save</code>.

 @param absPath        an absolute the path to which the version is to be
                       restored.
 @param version        a version object
 @param removeExisting covers what happens on identifier collision.
 @throws PathNotFoundException        if the parent of <code>absPath</code> does
                                      not exist.
 @throws ItemExistsException          if removeExisting is false and an identifier
                                      collision occurs
 @throws ConstraintViolationException If the would-be parent of the
                                      location <code>absPath</code> is actually a property, or if a node type
                                      restriction would be violated
 @throws VersionException             if the parent node of <code>absPath</code> is
                                      read-only due to a checked-in node or if a node exists at
                                      <code>absPath<code> or if an attempt is made to restore
                                      the root version.
 @throws UnsupportedRepositoryOperationException
                                      if versioning is not
                                      supported.
 @throws LockException                if a lock prevents the restore.
 @throws InvalidItemStateException    if this <code>Session</code> (not
                                      necessarily the <code>Node</code> at <code>absPath</code>) has pending
                                      unsaved changes.
 @throws RepositoryException          if another error occurs]]>
      </doc>
    </method>
    <method name="restoreByLabel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="versionLabel" type="java.lang.String"/>
      <param name="removeExisting" type="boolean"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="ItemExistsException" type="javax.jcr.ItemExistsException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Restores the version of the node at <code>absPath</code> with the
 specified version label. If successful, the change is dispatched
 immediately; there is no need to call <code>save</code>.
 <p>
 This method will work regardless of whether the node at
 <code>absPath</code> is checked-in or not.
 <p>
 An identifier collision occurs when a node exists <i>outside the subgraph
 rooted at this node</i> with the same identifier as a node that would be
 introduced by the <code>restoreByLabel</code> operation <i>into the
 subgraph at this node</i>. The result in such a case is governed by the
 <code>removeExisting</code> flag. If <code>removeExisting</code> is
 <code>true</code>, then the incoming node takes precedence, and the
 existing node (and its subgraph) is removed (if possible; otherwise a
 <code>RepositoryException</code> is thrown). If <code>removeExisting</code>
 is <code>false</code>, then a <code>ItemExistsException</code> is thrown
 and no changes are made. Note that this applies not only to cases where
 the restored node itself conflicts with an existing node but also to
 cases where a conflict occurs with any node that would be introduced into
 the workspace by the restore operation. In particular, conflicts
 involving subnodes of the restored node that have
 <code>OnParentVersion</code> settings of <code>COPY</code> or
 <code>VERSION</code> are also governed by the <code>removeExisting</code>
 flag.

 @param absPath        an absolute path.
 @param versionLabel   a String
 @param removeExisting a boolean flag that governs what happens in case of
                       an identifier collision.
 @throws UnsupportedRepositoryOperationException
                                   if the node at
                                   <code>absPath</code> is not versionable.
 @throws VersionException          if the specified <code>versionLabel</code> does
                                   not exist in this node's version history or if no node exists
                                   at <code>absPath</code>.
 @throws ItemExistsException       if <code>removeExisting</code> is
                                   <code>false</code> and an identifier collision occurs.
 @throws LockException             if a lock prevents the restore.
 @throws InvalidItemStateException if this <code>Session</code> (not
                                   necessarily the <code>Node</code> at <code>absPath</code>) has pending
                                   unsaved changes.
 @throws RepositoryException       If another error occurs.]]>
      </doc>
    </method>
    <method name="merge" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="bestEffort" type="boolean"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="MergeException" type="javax.jcr.MergeException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method recursively tests each versionable node in the subgraph of
 the node at <code>absPath</code> against its corresponding node in
 <code>srcWorkspace</code> with respect to the relation between their
 respective base versions and either updates the node in question or not,
 depending on the outcome of the test.
 <p>
 When a versionable node V with base version B is encountered whose
 corresponding node V' has a base version B': <ul> <li>If B' is an
 eventual predecessor of B then V is left unchanged.</li> <li>If B' is an
 eventual successor of B then V is updated to the state of V'.</li> <li>If
 B' and B are ob divergent branches of the version history then V
 <i>fails</i> the merge.</li> </ul> If <code>bestEffort</code> is
 <code>true</code> then each failed node is marked and traversal
 continues. If <code>bestEffort</code> is <code>false</code> then the
 first failed node results in a <code>MergeException</code>.
 <p>
 This is a workspace-write method and therefore any changes are dispatched
 immediately; there is no need to call <code>save</code>.
 <p>
 This method returns a <code>NodeIterator</code> over all versionable
 nodes in the subgraph that received a merge result of <i>fail</i>. If
 <code>bestEffort</code> is <code>false</code>, this iterator will be
 empty (since if <code>merge</code> returns successfully, instead of
 throwing an exception, it will be because no failures were encountered).
 If <code>bestEffort</code> is <code>true</code>, this iterator will
 contain all nodes that received a <i>fail</i> during the course of this
 <code>merge</code> operation.
 <p>
 See the JCR specifications for more details on the behavior of this
 method.

 @param absPath      an absolute path.
 @param srcWorkspace the name of the source workspace.
 @param bestEffort   a boolean
 @return iterator over all nodes that received a merge result of "fail" in
         the course of this operation.
 @throws MergeException            if <code>bestEffort</code> is <code>false</code>
                                   and a failed merge result is encountered.
 @throws InvalidItemStateException if this session (not necessarily the
                                   node at <code>absPath</code>) has pending unsaved changes.
 @throws NoSuchWorkspaceException  if the specified
                                   <code>srcWorkspace</code> does not exist.
 @throws AccessDeniedException     if the current session does not have
                                   sufficient rights to perform the operation.
 @throws LockException             if a lock prevents the merge.
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <method name="merge" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="srcWorkspace" type="java.lang.String"/>
      <param name="bestEffort" type="boolean"/>
      <param name="isShallow" type="boolean"/>
      <exception name="NoSuchWorkspaceException" type="javax.jcr.NoSuchWorkspaceException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="MergeException" type="javax.jcr.MergeException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Same as {@link #merge(String absPath, String srcWorkspace, boolean
 bestEffort)} except that an option exists to make the merge
 <i>shallow</i>.
 <p>
 If <code>isShallow</code> is <code>true</code>, this method tests this
 versionable node against its corresponding node in
 <code>srcWorkspace</code> with respect to the relation between their
 respective base versions and either updates the node in question or not,
 depending on the outcome of the test.
 <p>
 If <code>isShallow</code> is <code>false</code>, it recursively tests
 each versionable node in the subgraph as mentioned above. See {@link
 #merge(String absPath, String srcWorkspace, boolean bestEffort)}.
 <p>
 If <code>isShallow</code> is <code>true</code> and this node is not
 versionable, then this method returns and no changes are made.
 <p>
 If successful, the changes are dispatched immediately; there is no need to
 call <code>save</code>.
 <p>
 This method returns a <code>NodeIterator</code> over all versionable
 nodes in the subgraph that received a merge result of <i>fail</i>. If
 <code>bestEffort</code> is <code>false</code>, this iterator will be
 empty (since if <code>merge</code> returns successfully, instead of
 throwing an exception, it will be because no failures were encountered).
 If <code>bestEffort</code> is <code>true</code>, this iterator will
 contain all nodes that received a <i>fail</i> during the course of this
 <code>merge</code> operation.

 @param absPath      an absolute path.
 @param srcWorkspace the name of the source workspace.
 @param bestEffort   a boolean
 @param isShallow    a boolean
 @return iterator over all nodes that received a merge result of "fail" in
         the course of this operation.
 @throws MergeException            if <code>bestEffort</code> is <code>false</code>
                                   and a failed merge result is encountered.
 @throws InvalidItemStateException if this session (not necessarily this
                                   node) has pending unsaved changes.
 @throws NoSuchWorkspaceException  if <code>srcWorkspace</code> does not
                                   exist.
 @throws AccessDeniedException     if the current session does not have
                                   sufficient rights to perform the operation.
 @throws LockException             if a lock prevents the merge.
 @throws RepositoryException       if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="doneMerge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Completes the merge process with respect to the node at
 <code>absPath</code> and the specified <code>version</code>.
 <p>
 When the {@link #merge} method is called on a node, every versionable
 node in that subgraph is compared with its corresponding node in the
 indicated other workspace and a "merge test result" is determined
 indicating one of the following:
 <p>
 <ol> <li> This node will be updated to the state of its correspondee (if
 the base version of the correspondee is more recent in terms of version
 history) </li> <li> This node will be left alone (if this node's base
 version is more recent in terms of version history). </li> <li> This node
 will be marked as having failed the merge test (if this node's base
 version is on a different branch of the version history from the base
 version of its corresponding node in the other workspace, thus preventing
 an automatic determination of which is more recent). </li> </ol>
 <p>
 (See {@link #merge} for more details)
 <p>
 In the last case the merge of the non-versionable subgraph (the
 "content") of this node must be done by the application (for example, by
 providing a merge tool for the user).
 <p>
 Additionally, once the content of the nodes has been merged, their
 version graph branches must also be merged. The JCR versioning system
 provides for this by keeping a record, for each versionable node that
 fails the merge test, of the base version of the corresponding node that
 caused the merge failure. This record is kept in the
 <code>jcr:mergeFailed</code> property of this node. After a
 <code>merge</code>, this property will contain one or more (if multiple
 merges have been performed) <code>REFERENCE</code>s that point to the
 "offending versions".
 <p>
 To complete the merge process, the client calls <code>doneMerge(Version
 v)</code> passing the version object referred to be the
 <code>jcr:mergeFailed</code> property that the client wishes to connect
 to <code>this</code> node in the version graph. This has the effect of
 moving the reference to the indicated version from the
 <code>jcr:mergeFailed</code> property of <code>this</code> node to the
 <code>jcr:predecessors</code>.
 <p>
 If the client chooses not to connect this node to a particular version
 referenced in the <code>jcr:mergeFailed</code> property, he calls {@link
 #cancelMerge(String, Version)}. This has the effect of removing the
 reference to the specified <code>version</code> from
 <code>jcr:mergeFailed</code> <i>without</i> adding it to
 <code>jcr:predecessors</code>.
 <p>
 Once the last reference in <code>jcr:mergeFailed</code> has been either
 moved to <code>jcr:predecessors</code> (with <code>doneMerge</code>) or
 just removed from <code>jcr:mergeFailed</code> (with
 <code>cancelMerge</code>) the <code>jcr:mergeFailed</code> property is
 automatically removed, thus enabling <code>this</code> node to be
 checked-in, creating a new version (note that before the
 <code>jcr:mergeFailed</code> is removed, its <code>OnParentVersion</code>
 setting of <code>ABORT</code> prevents checkin). This new version will
 have a predecessor connection to each version for which
 <code>doneMerge</code> was called, thus joining those branches of the
 version graph.
 <p>
 If successful, these changes are dispatched immediately; there is no need
 to call <code>save</code>.

 @param absPath an absolute path.
 @param version a version referred to by the <code>jcr:mergeFailed</code>
                property of the node at <code>absPath</code>.
 @throws VersionException          if the version specified is not among those
                                   referenced in this node's <code>jcr:mergeFailed</code> or if the node is
                                   currently checked-in.
 @throws InvalidItemStateException if there are unsaved changes pending on
                                   the node at <code>absPath</code>.
 @throws UnsupportedRepositoryOperationException
                                   if the node at
                                   <code>absPath</code> is not versionable.
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <method name="cancelMerge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <param name="version" type="javax.jcr.version.Version"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Cancels the merge process with respect to the node at
 <code>absPath</code> and the specified <code>version</code>.
 <p>
 See {@link #doneMerge} for a full explanation. Also see {@link #merge}
 for more details.
 <p>
 If successful, these changes are dispatched immediately; there is no need
 to call <code>save</code>.

 @param absPath an absolute path.
 @param version a version referred to by the <code>jcr:mergeFailed</code>
                property of the node at <code>absPath</code>.
 @throws VersionException          if the version specified is not among those
                                   referenced in the <code>jcr:mergeFailed</code> property of the node at
                                   <code>absPath</code> or if the node is currently checked-in.
 @throws InvalidItemStateException if there are unsaved changes pending on
                                   the node at <code>absPath</code>.
 @throws UnsupportedRepositoryOperationException
                                   if the node at
                                   <code>absPath</code> is not versionable.
 @throws RepositoryException       if another error occurs.]]>
      </doc>
    </method>
    <method name="createConfiguration" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="absPath" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Calling <code>createConfiguration</code> on the node <i>N</i> at
 <code>absPath</code> creates, in the configuration storage, a new
 <code>nt:configuration</code> node whose root is <i>N</i>. A reference to
 <i>N</i> is recorded in the <code>jcr:root</code> property of the new
 configuration, and a reference to the new configuration is recorded in
 the <code>jcr:configuration</code> property of <i>N</i>.
 <p>
 A new version history is created to store baselines of the new configuration,
 and the <code>jcr:baseVersion</code> of the new configuration references
 the root version of the new version history.
 <p>
 The changes are dispatched immediately; a <code>save</code> is not
 required.

 @param absPath  an absolute path.
 @return a new <code>nt:configuration</code> node
 @throws UnsupportedRepositoryOperationException
                             if <i>N</i> is not
                             versionable.
 @throws RepositoryException if no node exists at <code>absPath</code> or another error occurs .
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="setActivity" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="activity" type="javax.jcr.Node"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method is called by the client to set the current activity on the
 current session by specifying a previously created <code>nt:activity</code>
 node (see {@link #createActivity}). Changing the
 current activity is done by calling <code>setActivity</code> again.
 Cancelling the current activity (so that the session has no current
 activity) is done by calling <code>setActivity(null)</code>. The previously
 set <code>nt:activity</code> node is returned, or <code>null</code> if no activity
 was previously set.

 @param activity an activity node
 @return The previously set <code>nt:activity</code> node is returned,
 or <code>null</code> if no activity was previously set.
 @throws UnsupportedRepositoryOperationException
                             if the repository does
                             not support activities or if <code>activity</code> is not a
                             <code>nt:activity</code> node.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="getActivity" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[Returns the node representing the current activity or <code>null</code>
 if there is no current activity.

 @return An <code>nt:activity</code> node or <code>null</code>.
 @throws UnsupportedRepositoryOperationException
                             if the repository does
                             not support activities.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="createActivity" return="javax.jcr.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method creates a new <code>nt:activity</code> at an
 implementation-determined location in the <code>/jcr:system/jcr:activities</code>
 subgraph.
 <p>
 The repository may, but is not required to, use the <code>title</code> as
 a hint for what to name the new activity node. The new activity
 <code>Node</code> is returned.
 <p>
 The new node addition is dispatched immediately and does not require a
 <code>save</code>.
 <p>

 @param title a String
 @return the new activity <code>Node</code>.
 @throws UnsupportedRepositoryOperationException
                             if the repository does
                             not support activities.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="removeActivity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="activityNode" type="javax.jcr.Node"/>
      <exception name="UnsupportedRepositoryOperationException" type="javax.jcr.UnsupportedRepositoryOperationException"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method removes the given <code>activityNode</code> and all <code>REFERENCE</code> properties
 within all workspaces that refer to the <code>activityNode</code>.
 However, the existence of a <code>REFERENCE</code> to the <code>activityNode</code>
 from within version storage will cause a <code>VersionException</code> to be thrown.
 <p>
 The change is dispatched immediately and does not require a <code>save</code>.

 @param activityNode an activity Node.
 @throws UnsupportedRepositoryOperationException if the repository does not support activities.
 @throws VersionException if a <code>REFERENCE</code> to the <code>activityNode</code> exists in
 version storage.
 @throws RepositoryException if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <method name="merge" return="javax.jcr.NodeIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="activityNode" type="javax.jcr.Node"/>
      <exception name="VersionException" type="javax.jcr.version.VersionException"/>
      <exception name="AccessDeniedException" type="javax.jcr.AccessDeniedException"/>
      <exception name="MergeException" type="javax.jcr.MergeException"/>
      <exception name="LockException" type="javax.jcr.lock.LockException"/>
      <exception name="InvalidItemStateException" type="javax.jcr.InvalidItemStateException"/>
      <exception name="RepositoryException" type="javax.jcr.RepositoryException"/>
      <doc>
      <![CDATA[This method merges the changes that were made under the specified
 activity into the current workspace.
 <p>
 An activity <i>A</i> will be associated with a set of versions through
 the <code>jcr:activity</code> reference of each version node in the set.
 We call each such associated version a <i>member of A</i>.
 <p>
 For each version history <i>H</i> that contains one or more members of
 <i>A</i>, one such member will be the latest member of <i>A</i> in
 <i>H</i>. The latest member of <i>A</i> in <i>H</i> is the version in
 <i>H</i> that is a member of <i>A</i> and that has no successor versions
 (to any degree) that are also members of <i>A</i>.
 <p>
 The set of versions that are the latest members of <i>A</i> in their
 respective version histories is called the change set of <i>A</i>. It
 fully describes the changes made under the activity <i>A</i>.
 <p>
 This method performs a shallow merge into the current workspace of each
 version in the change set of the activity specified by
 <code>activityNode</code>. If there is no corresponding node in this
 workspace for a given member of the change set, that member is ignored.
 <p>
 This method returns a <code>NodeIterator</code> over all versionable
 nodes in the subgraph that received a merge result of <i>fail</i>.
 <p>
 The changes are dispatched immediately and do not require a <code>save</code>.

 @param activityNode an <code>nt:activity</code> node
 @return a <code>NodeIterator</code>
 @throws AccessDeniedException     if the current session does not have
                                   sufficient rights to perform the operation.
 @throws VersionException          if the specified node is not an
                                   <code>nt:activity</code> node.
 @throws MergeException            in the same cases as in a regular shallow merge
                                   (see {@link #merge(String, String, boolean, boolean)}.
 @throws LockException             if a lock prevents the merge.
 @throws InvalidItemStateException if this <code>Session</code> has
                                   pending unsaved changes.
 @throws RepositoryException       if another error occurs.
 @since JCR 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>VersionManager</code> object is accessed via {@link
 javax.jcr.Workspace#getVersionManager()}. It provides methods for: <ul>
 <li>Version graph functionality (version history, base version, successors
 predecessors)</li> <li>Basic version operations (checkin, checkout,
 checkpoint)</li> <li>Restore feature</li> <li>Label feature</li> <li>Merge
 feature</li> <li>Configuration feature</li> <li>Activity feature</li> </ul>

 @since JCR 2.0]]>
    </doc>
  </interface>
  <!-- end interface javax.jcr.version.VersionManager -->
  <doc>
  <![CDATA[Provides interfaces and classes for content repository versioning functionality.]]>
  </doc>
</package>

</api>
