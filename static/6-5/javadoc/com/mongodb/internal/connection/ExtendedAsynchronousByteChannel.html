<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_272) on Fri Nov 24 07:38:15 UTC 2023 -->
<title>ExtendedAsynchronousByteChannel (The Adobe AEM Quickstart and Web Application.)</title>
<meta name="date" content="2023-11-24">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="ExtendedAsynchronousByteChannel (The Adobe AEM Quickstart and Web Application.)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/mongodb/internal/connection/ElementExtendingBsonWriter.html" title="class in com.mongodb.internal.connection"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/mongodb/internal/connection/FieldTrackingBsonWriter.html" title="class in com.mongodb.internal.connection"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/mongodb/internal/connection/ExtendedAsynchronousByteChannel.html" target="_top">Frames</a></li>
<li><a href="ExtendedAsynchronousByteChannel.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.mongodb.internal.connection</div>
<h2 title="Interface ExtendedAsynchronousByteChannel" class="title">Interface ExtendedAsynchronousByteChannel</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd>java.nio.channels.AsynchronousByteChannel, java.nio.channels.AsynchronousChannel, java.lang.AutoCloseable, java.nio.channels.Channel, java.io.Closeable</dd>
</dl>
<hr>
<br>
<pre>public interface <span class="typeNameLabel">ExtendedAsynchronousByteChannel</span>
extends java.nio.channels.AsynchronousByteChannel</pre>
<div class="block">This interface extends <code>AsynchronousByteChannel</code> adding optional timeouts and scattering and gathering methods.
 These additions are analogous to the ones made by <code>AsynchronousSocketChannel</code>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/mongodb/internal/connection/ExtendedAsynchronousByteChannel.html#read-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">read</a></span>(java.nio.ByteBuffer[]&nbsp;dsts,
    int&nbsp;offset,
    int&nbsp;length,
    long&nbsp;timeout,
    java.util.concurrent.TimeUnit&nbsp;unit,
    A&nbsp;attach,
    java.nio.channels.CompletionHandler&lt;java.lang.Long,? super A&gt;&nbsp;handler)</code>
<div class="block">Reads a sequence of bytes from this channel into a subsequence of the
 given buffers.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/mongodb/internal/connection/ExtendedAsynchronousByteChannel.html#read-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">read</a></span>(java.nio.ByteBuffer&nbsp;dst,
    long&nbsp;timeout,
    java.util.concurrent.TimeUnit&nbsp;unit,
    A&nbsp;attach,
    java.nio.channels.CompletionHandler&lt;java.lang.Integer,? super A&gt;&nbsp;handler)</code>
<div class="block">Reads a sequence of bytes from this channel into the given buffer.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/mongodb/internal/connection/ExtendedAsynchronousByteChannel.html#write-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">write</a></span>(java.nio.ByteBuffer[]&nbsp;srcs,
     int&nbsp;offset,
     int&nbsp;length,
     long&nbsp;timeout,
     java.util.concurrent.TimeUnit&nbsp;unit,
     A&nbsp;attach,
     java.nio.channels.CompletionHandler&lt;java.lang.Long,? super A&gt;&nbsp;handler)</code>
<div class="block">Writes a sequence of bytes to this channel from a subsequence of the given
 buffers.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/mongodb/internal/connection/ExtendedAsynchronousByteChannel.html#write-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">write</a></span>(java.nio.ByteBuffer&nbsp;src,
     long&nbsp;timeout,
     java.util.concurrent.TimeUnit&nbsp;unit,
     A&nbsp;attach,
     java.nio.channels.CompletionHandler&lt;java.lang.Integer,? super A&gt;&nbsp;handler)</code>
<div class="block">Writes a sequence of bytes to this channel from the given buffer.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.nio.channels.AsynchronousByteChannel">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.nio.channels.AsynchronousByteChannel</h3>
<code>read, read, write, write</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.nio.channels.AsynchronousChannel">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.nio.channels.AsynchronousChannel</h3>
<code>close</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.nio.channels.Channel">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.nio.channels.Channel</h3>
<code>isOpen</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="read-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-java.lang.Object-java.nio.channels.CompletionHandler-">
<!--   -->
</a><a name="read-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>read</h4>
<pre>&lt;A&gt;&nbsp;void&nbsp;read(java.nio.ByteBuffer&nbsp;dst,
              long&nbsp;timeout,
              java.util.concurrent.TimeUnit&nbsp;unit,
              A&nbsp;attach,
              java.nio.channels.CompletionHandler&lt;java.lang.Integer,? super A&gt;&nbsp;handler)</pre>
<div class="block">Reads a sequence of bytes from this channel into the given buffer.

 <p> This method initiates an asynchronous read operation to read a
 sequence of bytes from this channel into the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the read
 operation completes (or fails). The result passed to the completion
 handler is the number of bytes read or <code>-1</code> if no bytes could be
 read because the channel has reached end-of-stream.

 <p> If a timeout is specified and the timeout elapses before the operation
 completes then the operation completes with the exception <code>InterruptedByTimeoutException</code>. Where a timeout occurs, and the
 implementation cannot guarantee that bytes have not been read, or will not
 be read from the channel into the given buffer, then further attempts to
 read from the channel will cause an unspecific runtime exception to be
 thrown.

 <p> Otherwise this method works in the same manner as the <code>AsynchronousByteChannel.read(ByteBuffer, Object, CompletionHandler)</code>
 method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dst</code> - The buffer into which bytes are to be transferred</dd>
<dd><code>timeout</code> - The maximum time for the I/O operation to complete</dd>
<dd><code>unit</code> - The time unit of the <code>timeout</code> argument</dd>
<dd><code>attach</code> - The object to attach to the I/O operation; can be <code>null</code></dd>
<dd><code>handler</code> - The handler for consuming the result</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If the buffer is read-only</dd>
<dd><code>java.nio.channels.ReadPendingException</code> - If a read operation is already in progress on this channel</dd>
<dd><code>java.nio.channels.ShutdownChannelGroupException</code> - If the channel group has terminated</dd>
</dl>
</li>
</ul>
<a name="read-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-java.lang.Object-java.nio.channels.CompletionHandler-">
<!--   -->
</a><a name="read-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>read</h4>
<pre>&lt;A&gt;&nbsp;void&nbsp;read(java.nio.ByteBuffer[]&nbsp;dsts,
              int&nbsp;offset,
              int&nbsp;length,
              long&nbsp;timeout,
              java.util.concurrent.TimeUnit&nbsp;unit,
              A&nbsp;attach,
              java.nio.channels.CompletionHandler&lt;java.lang.Long,? super A&gt;&nbsp;handler)</pre>
<div class="block">Reads a sequence of bytes from this channel into a subsequence of the
 given buffers. This operation, sometimes called a <em>scattering read</em>,
 is often useful when implementing network protocols that group data into
 segments consisting of one or more fixed-length headers followed by a
 variable-length body. The <code>handler</code> parameter is a completion
 handler that is invoked when the read operation completes (or fails). The
 result passed to the completion handler is the number of bytes read or
 <code>-1</code> if no bytes could be read because the channel has reached
 end-of-stream.

 <p> This method initiates a read of up to <i>r</i> bytes from this channel,
 where <i>r</i> is the total number of bytes remaining in the specified
 subsequence of the given buffer array, that is,

 <blockquote><pre>
 dsts[offset].remaining()
     + dsts[offset+1].remaining()
     + ... + dsts[offset+length-1].remaining()</pre></blockquote>
 <p>
 at the moment that the read is attempted.

 <p> Suppose that a byte sequence of length <i>n</i> is read, where
 <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
 Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence
 are transferred into buffer <tt>dsts[offset]</tt>, up to the next
 <tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer
 <tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence
 is transferred into the given buffers.  As many bytes as possible are
 transferred into each buffer, hence the final position of each updated
 buffer, except the last updated buffer, is guaranteed to be equal to
 that buffer's limit. The underlying operating system may impose a limit
 on the number of buffers that may be used in an I/O operation. Where the
 number of buffers (with bytes remaining), exceeds this limit, then the
 I/O operation is performed with the maximum number of buffers allowed by
 the operating system.

 <p> If a timeout is specified and the timeout elapses before the operation
 completes then it completes with the exception <code>InterruptedByTimeoutException</code>. Where a timeout occurs, and the
 implementation cannot guarantee that bytes have not been read, or will not
 be read from the channel into the given buffers, then further attempts to
 read from the channel will cause an unspecific runtime exception to be
 thrown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dsts</code> - The buffers into which bytes are to be transferred</dd>
<dd><code>offset</code> - The offset within the buffer array of the first buffer into which
                bytes are to be transferred; must be non-negative and no larger than
                <code>dsts.length</code></dd>
<dd><code>length</code> - The maximum number of buffers to be accessed; must be non-negative
                and no larger than <code>dsts.length - offset</code></dd>
<dd><code>timeout</code> - The maximum time for the I/O operation to complete</dd>
<dd><code>unit</code> - The time unit of the <code>timeout</code> argument</dd>
<dd><code>attach</code> - The object to attach to the I/O operation; can be <code>null</code></dd>
<dd><code>handler</code> - The handler for consuming the result</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - If the pre-conditions for the <code>offset</code>  and <code>length</code>
                                       parameter aren't met</dd>
<dd><code>java.lang.IllegalArgumentException</code> - If the buffer is read-only</dd>
<dd><code>java.nio.channels.ReadPendingException</code> - If a read operation is already in progress on this channel</dd>
<dd><code>java.nio.channels.ShutdownChannelGroupException</code> - If the channel group has terminated</dd>
</dl>
</li>
</ul>
<a name="write-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-java.lang.Object-java.nio.channels.CompletionHandler-">
<!--   -->
</a><a name="write-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>write</h4>
<pre>&lt;A&gt;&nbsp;void&nbsp;write(java.nio.ByteBuffer&nbsp;src,
               long&nbsp;timeout,
               java.util.concurrent.TimeUnit&nbsp;unit,
               A&nbsp;attach,
               java.nio.channels.CompletionHandler&lt;java.lang.Integer,? super A&gt;&nbsp;handler)</pre>
<div class="block">Writes a sequence of bytes to this channel from the given buffer.

 <p> This method initiates an asynchronous write operation to write a
 sequence of bytes to this channel from the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the write
 operation completes (or fails). The result passed to the completion
 handler is the number of bytes written.

 <p> If a timeout is specified and the timeout elapses before the operation
 completes then it completes with the exception <code>InterruptedByTimeoutException</code>. Where a timeout occurs, and the
 implementation cannot guarantee that bytes have not been written, or will
 not be written to the channel from the given buffer, then further attempts
 to write to the channel will cause an unspecific runtime exception to be
 thrown.

 <p> Otherwise this method works in the same manner as the <code>AsynchronousByteChannel.write(ByteBuffer, Object, CompletionHandler)</code>
 method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - The buffer from which bytes are to be retrieved</dd>
<dd><code>timeout</code> - The maximum time for the I/O operation to complete</dd>
<dd><code>unit</code> - The time unit of the <code>timeout</code> argument</dd>
<dd><code>attach</code> - The object to attach to the I/O operation; can be <code>null</code></dd>
<dd><code>handler</code> - The handler for consuming the result</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.nio.channels.WritePendingException</code> - If a write operation is already in progress on this channel</dd>
<dd><code>java.nio.channels.ShutdownChannelGroupException</code> - If the channel group has terminated</dd>
</dl>
</li>
</ul>
<a name="write-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-java.lang.Object-java.nio.channels.CompletionHandler-">
<!--   -->
</a><a name="write-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>write</h4>
<pre>&lt;A&gt;&nbsp;void&nbsp;write(java.nio.ByteBuffer[]&nbsp;srcs,
               int&nbsp;offset,
               int&nbsp;length,
               long&nbsp;timeout,
               java.util.concurrent.TimeUnit&nbsp;unit,
               A&nbsp;attach,
               java.nio.channels.CompletionHandler&lt;java.lang.Long,? super A&gt;&nbsp;handler)</pre>
<div class="block">Writes a sequence of bytes to this channel from a subsequence of the given
 buffers. This operation, sometimes called a <em>gathering write</em>, is
 often useful when implementing network protocols that group data into
 segments consisting of one or more fixed-length headers followed by a
 variable-length body. The <code>handler</code> parameter is a completion
 handler that is invoked when the write operation completes (or fails).
 The result passed to the completion handler is the number of bytes written.

 <p> This method initiates a write of up to <i>r</i> bytes to this channel,
 where <i>r</i> is the total number of bytes remaining in the specified
 subsequence of the given buffer array, that is,

 <blockquote><pre>
 srcs[offset].remaining()
     + srcs[offset+1].remaining()
     + ... + srcs[offset+length-1].remaining()</pre></blockquote>
 <p>
 at the moment that the write is attempted.

 <p> Suppose that a byte sequence of length <i>n</i> is written, where
 <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
 Up to the first <tt>srcs[offset].remaining()</tt> bytes of this sequence
 are written from buffer <tt>srcs[offset]</tt>, up to the next
 <tt>srcs[offset+1].remaining()</tt> bytes are written from buffer
 <tt>srcs[offset+1]</tt>, and so forth, until the entire byte sequence is
 written.  As many bytes as possible are written from each buffer, hence
 the final position of each updated buffer, except the last updated
 buffer, is guaranteed to be equal to that buffer's limit. The underlying
 operating system may impose a limit on the number of buffers that may be
 used in an I/O operation. Where the number of buffers (with bytes
 remaining), exceeds this limit, then the I/O operation is performed with
 the maximum number of buffers allowed by the operating system.

 <p> If a timeout is specified and the timeout elapses before the operation
 completes then it completes with the exception <code>InterruptedByTimeoutException</code>. Where a timeout occurs, and the
 implementation cannot guarantee that bytes have not been written, or will
 not be written to the channel from the given buffers, then further attempts
 to write to the channel will cause an unspecific runtime exception to be
 thrown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcs</code> - The buffers from which bytes are to be retrieved</dd>
<dd><code>offset</code> - The offset within the buffer array of the first buffer from which
                bytes are to be retrieved; must be non-negative and no larger
                than <code>srcs.length</code></dd>
<dd><code>length</code> - The maximum number of buffers to be accessed; must be non-negative
                and no larger than <code>srcs.length - offset</code></dd>
<dd><code>timeout</code> - The maximum time for the I/O operation to complete</dd>
<dd><code>unit</code> - The time unit of the <code>timeout</code> argument</dd>
<dd><code>attach</code> - The object to attach to the I/O operation; can be <code>null</code></dd>
<dd><code>handler</code> - The handler for consuming the result</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - If the pre-conditions for the <code>offset</code>  and <code>length</code>
                                       parameter aren't met</dd>
<dd><code>java.nio.channels.WritePendingException</code> - If a write operation is already in progress on this channel</dd>
<dd><code>java.nio.channels.ShutdownChannelGroupException</code> - If the channel group has terminated</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/mongodb/internal/connection/ElementExtendingBsonWriter.html" title="class in com.mongodb.internal.connection"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/mongodb/internal/connection/FieldTrackingBsonWriter.html" title="class in com.mongodb.internal.connection"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/mongodb/internal/connection/ExtendedAsynchronousByteChannel.html" target="_top">Frames</a></li>
<li><a href="ExtendedAsynchronousByteChannel.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &copy; 2010 - 2023 Adobe. All Rights Reserved</small></p>
</body>
</html>
