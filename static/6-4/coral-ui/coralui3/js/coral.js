/* global Typekit */
/* jshint -W033,-W116 */
(function(window, undefined) {
  "use strict"

  var typeKitId = 'ruf7eed';

  if (window.Coral && window.Coral.options && window.Coral.options.typeKitId) {
    typeKitId = window.Coral.options.typeKitId;
  }

  var config = {
    kitId: typeKitId,
    scriptTimeout: 3000
  };

  if (!window.Typekit) { // we load the typescript only once
    var h = document.getElementsByTagName("html")[0];
    h.className += " wf-loading";
    var t = setTimeout(function() {
      h.className = h.className.replace(/(\s|^)wf-loading(\s|$)/g, " ");
      h.className += " wf-inactive";
    }, config.scriptTimeout);
    var tk = document.createElement("script"),
      d = false;

    // Always load over https
    tk.src = 'https://use.typekit.net/' + config.kitId + '.js'
    tk.type = "text/javascript";
    tk.async = "true";
    tk.onload = tk.onreadystatechange = function() {
      var a = this.readyState;
      if (d || a && a !== "complete" && a !== "loaded") {
        return;
      }
      d = true;
      clearTimeout(t);
      try {
        Typekit.load(config);
      } catch (b) {}
    };
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(tk, s);
  }

}(this));

/*!
 * jQuery UI Core @VERSION
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 */

/*
  Note: This code has been lifted directly from jQuery UI
  https://github.com/jquery/jquery-ui/blob/master/ui/core.js
*/
(function ($) {

  // selectors
  function focusable( element, isTabIndexNotNaN ) {
    var map, mapName, img,
      nodeName = element.nodeName.toLowerCase();
    if ( "area" === nodeName ) {
      map = element.parentNode;
      mapName = map.name;
      if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
        return false;
      }
      img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
      return !!img && visible( img );
    }
    return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
      !element.disabled :
      "a" === nodeName ?
        element.href || isTabIndexNotNaN :
        isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible( element );
  }

  function visible( element ) {
    return $.expr.filters.visible( element ) &&
      !$( element ).parents().addBack().filter(function() {
        return $.css( this, "visibility" ) === "hidden";
      }).length;
  }

  $.extend( $.expr[ ":" ], {
    data: $.expr.createPseudo ?
      $.expr.createPseudo(function( dataName ) {
        return function( elem ) {
          return !!$.data( elem, dataName );
        };
      }) :
      // support: jQuery <1.8
      function( elem, i, match ) {
        return !!$.data( elem, match[ 3 ] );
      },

    focusable: function( element ) {
      return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
    },

    tabbable: function( element ) {
      var tabIndex = $.attr( element, "tabindex" ),
        isTabIndexNaN = isNaN( tabIndex );
      return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
    }
  });

}(jQuery));

/*!
 * jQuery UI Position b3a9b13a218cd90b7cf67be5d5f8ad6e76c557b0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: UI Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/

( function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {
( function() {

$.ui = $.ui || {};

var cachedScrollbarWidth, supportsOffsetFractions,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

// Support: IE <=9 only
supportsOffsetFractions = function() {
	var element = $( "<div>" )
			.css( "position", "absolute" )
			.appendTo( "body" )
			.offset( {
				top: 1.5,
				left: 1.5
			} ),
		support = element.offset().top === 1.5;

	element.remove();

	supportsOffsetFractions = function() {
		return support;
	};

	return support;
};

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !supportsOffsetFractions() ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

return $.ui.position;

} ) );

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  // initialize moment
  if (typeof moment !== 'undefined') {
    moment.locale(document.documentElement.lang || window.navigator.language || 'en');
  }

}());

/**
 Crockford's new_constructor pattern, modified to allow walking the prototype chain, automatic constructor/destructor chaining, easy toString methods, and syntactic sugar for calling superclass methods

 @see Base

 @function

 @param {Object} descriptor                        Descriptor object
 @param {String|Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
 @param {Object} descriptor.extend                 The class to extend
 @param {Function} descriptor.construct            The constructor (setup) method for the new class
 @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
 @param {Mixed} descriptor.*                       Other methods and properties for the new class

 @returns {Base} The created class.
 */
var Class;
var Exception;

(function () {
  /**
   @name Base

   @classdesc The abstract class which contains methods that all classes will inherit.
   Base cannot be extended or instantiated and does not exist in the global namespace.
   If you create a class using <code class="prettyprint">new Class()</code> or <code class="prettyprint">MyClass.extend()</code>, it will come with Base' methods.

   @desc Base is an abstract class and cannot be instantiated directly. Constructors are chained automatically, so you never need to call the constructor of an inherited class directly
   @constructs

   @param {Object} options  Instance options. Guaranteed to be defined as at least an empty Object
   */

  /**
   Binds a method of this instance to the execution scope of this instance.

   @name bind
   @memberOf Base.prototype
   @function

   @param {Function} func The this.method you want to bind
   */
  var bindFunc = function (func) {
    // Bind the function to always execute in scope
    var boundFunc = func.bind(this);

    // Store the method name
    boundFunc._methodName = func._methodName;

    // Store the bound function back to the class
    this[boundFunc._methodName] = boundFunc;

    // Return the bound function
    return boundFunc;
  };

  /**
   Extends this class using the passed descriptor.
   Called on the Class itself (not an instance), this is an alternative to using <code class="prettyprint">new Class()</code>.
   Any class created using Class will have this static method on the class itself.

   @name extend
   @memberOf Base
   @function
   @static

   @param {Object} descriptor                        Descriptor object
   @param {String|Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
   @param {Object} descriptor.extend                 The class to extend
   @param {Function} descriptor.construct            The constructor (setup) method for the new class
   @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
   @param {Anything} descriptor.*                    Other methods and properties for the new class
   */
  var extendClass = function (descriptor) {
    descriptor.extend = this;
    return new Class(descriptor);
  };

  Class = function (descriptor) {
    descriptor = descriptor || {};

    if (descriptor.hasOwnProperty('extend') && !descriptor.extend) {
      throw new Class.NonTruthyExtendError(typeof descriptor.toString === 'function' ? descriptor.toString() : descriptor.toString);
    }

    // Extend Object by default
    var extend = descriptor.extend || Object;

    // Construct and destruct are not required
    var construct = descriptor.construct;
    var destruct = descriptor.destruct;

    // Remove special methods and keywords from descriptor
    delete descriptor.bind;
    delete descriptor.extend;
    delete descriptor.destruct;
    delete descriptor.construct;

    descriptor._construct = construct;
    descriptor._destruct = destruct;

    // Add toString method, if necessary
    if (descriptor.hasOwnProperty('toString') && typeof descriptor.toString !== 'function') {
      // Return the string provided
      var classString = descriptor.toString;
      descriptor.toString = function () {
        return classString.toString();
      };
    }
    else if (!descriptor.hasOwnProperty('toString') && extend.prototype.hasOwnProperty('toString')) {
      // Use parent's toString
      descriptor.toString = extend.prototype.toString;
    }

    // The remaining properties in descriptor are our methods
    var methodsAndProps = descriptor;

    // Create an object with the prototype of the class we're extending
    var prototype = Object.create(extend && extend.prototype);

    // Store super class as a property of the new class' prototype
    prototype.superClass = extend.prototype;

    // Copy new methods into prototype
    if (methodsAndProps) {
      for (var key in methodsAndProps) {
        if (methodsAndProps.hasOwnProperty(key)) {
          prototype[key] = methodsAndProps[key];

          // Store the method name so calls to inherited() work
          if (typeof methodsAndProps[key] === 'function') {
            prototype[key]._methodName = key;
            prototype[key]._parentProto = prototype;
          }
        }
      }
    }

    /**
     Call the superclass method with the same name as the currently executing method

     @name inherited
     @memberOf Base.prototype
     @function

     @param {Arguments} args  Unadulterated arguments array from calling function
     */
    prototype.inherited = function (args) {
      // Get the function that call us from the passed arguments objected
      var caller = args.callee;

      // Get the name of the method that called us from a property of the method
      var methodName = caller._methodName;

      if (!methodName) {
        throw new Class.MissingCalleeError(this.toString());
      }

      // Start iterating at the prototype that this function is defined in
      var curProto = caller._parentProto;
      var inheritedFunc = null;

      // Iterate up the prototype chain until we find the inherited function
      while (curProto.superClass) {
        curProto = curProto.superClass;
        inheritedFunc = curProto[methodName];
        if (typeof inheritedFunc === 'function')
          break;
      }

      if (typeof inheritedFunc === 'function') {
        // Store our inherited function
        var oldInherited = this.inherited;

        // Overwrite our inherited function with that of the prototype so the called function can call its parent
        this.inherited = curProto.inherited;

        // Call the inherited function our scope, apply the passed args array
        var retVal = inheritedFunc.apply(this, args);

        // Revert our inherited function to the old function
        this.inherited = oldInherited;

        // Return the value called by the inherited function
        return retVal;
      }
      else {
        throw new Class.InheritedMethodNotFoundError(this.toString(), methodName);
      }
    };

    // Add bind to the prototype of the class
    prototype.bind = bindFunc;

    /**
     Destroys this instance and frees associated memory. Destructors are chained automatically, so the <code class="prettyprint">destruct()</code> method of all inherited classes will be called for you

     @name destruct
     @memberOf Base.prototype
     @function
     */
    prototype.destruct = function () {
      // Call our destruct method first
      if (typeof destruct === 'function') {
        destruct.apply(this);
      }

      // Build a list of all destructors
      var destructors = [];
      var superClass = this.superClass;
      while (superClass) {
        if (typeof superClass._destruct === 'function') {
          destructors.push(superClass._destruct);
        }

        if (superClass === superClass.superClass) {
          throw new Class.InfiniteInheritanceLoopError(superClass.toString());
        }

        superClass = superClass.superClass;
      }

      // Execute desdestructors in child-first order
      for (var i = 0; i < destructors.length; i++) {
        destructors[i].apply(this);
      }
    };

    // Create a chained construct function which calls the superclass' construct function
    prototype.construct = function (option) {
      // Add a blank object as the first arg to the constructor, if none provided
      var args = Array.prototype.slice.call(arguments);
      if (args[0] === undefined) {
        args[0] = {};
      }

      // Build a list of all constructors
      var constructors = [];
      var superClass = this.superClass;
      while (superClass) {
        if (typeof superClass._construct === 'function') {
          constructors.push(superClass._construct);
        }

        if (superClass === superClass.superClass) {
          throw new Class.InfiniteInheritanceLoopError(superClass.toString());
        }

        superClass = superClass.superClass;
      }

      // Execute constructors in parent-first order
      for (var i = constructors.length - 1; i >= 0; i--) {
        constructors[i].apply(this, args);
      }

      // call constructor
      if (typeof construct === 'function') {
        construct.apply(this, args);
      }
    };

    // Create a function that generates instances of our class and calls our construct functions
    /** @ignore */
    var instanceGenerator = function () {
      // Create a new object with the prototype we built
      var instance = Object.create(prototype);

      // Call all inherited construct functions
      prototype.construct.apply(instance, arguments);

      return instance;
    };

    instanceGenerator.toString = prototype.toString;

    // Set the prototype of our instance generator to the prototype of our new class so things like MyClass.prototype.method.apply(this) work
    instanceGenerator.prototype = prototype;

    // Add extend to the instance generator for the class
    instanceGenerator.extend = extendClass;

    // The constructor, as far as JS is concerned, is actually our instance generator
    prototype.constructor = instanceGenerator;

    return instanceGenerator;
  };

  if (!Object.create) {
    /**
     Polyfill for Object.create. Creates a new object with the specified prototype.

     @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create/">Mozilla MDN</a>

     @param {Object} prototype  The prototype to create a new object with
     */
    Object.create = function (prototype) {
      if (arguments.length > 1) {
        throw new Error('Object.create implementation only accepts the first parameter.');
      }
      function Func() {
      }

      Func.prototype = prototype;
      return new Func();
    };
  }

  if (!Function.prototype.bind) {
    /**
     Polyfill for Function.bind. Binds a function to always execute in a specific scope.

     @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Mozilla MDN</a>

     @param {Object} scope  The scope to bind the function to
     */
    Function.prototype.bind = function (scope) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1);
      var fToBind = this;
      /** @ignore */
      var NoOp = function () {
      };
      /** @ignore */
      var fBound = function () {
        return fToBind.apply(this instanceof NoOp ? this : scope, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      NoOp.prototype = this.prototype;
      fBound.prototype = new NoOp();

      return fBound;
    };
  }

  Exception = new Class({
    extend: Error,
    construct: function () {
      this.name = 'Error';
      this.message = 'General exception';
    },

    toString: function () {
      return this.name + ': ' + this.message;
    }
  });

  var ClassException = Exception.extend({
    name: 'Class Exception'
  });

  // Exceptions
  Class.NonTruthyExtendError = ClassException.extend({
    construct: function (className) {
      this.message = className + ' attempted to extend a non-truthy object';
    }
  });

  Class.InheritedMethodNotFoundError = ClassException.extend({
    construct: function (className, methodName) {
      this.message = className + " can't call method '" + methodName + "', no method defined in parent classes";
    }
  });

  Class.MissingCalleeError = ClassException.extend({
    construct: function (className) {
      this.message = className + " can't call inherited method: calling method did not have _methodName";
    }
  });

  Class.InfiniteInheritanceLoopError = ClassException.extend({
    construct: function (className) {
      this.message = className + " seems to inherit from itself, cannot construct an object";
    }
  });
}());

/*!
* toe.js
* version 3.0.2
* author: Damien Antipa
* https://github.com/dantipa/toe.js
*/
(function ($, window, undefined) {

    var state, gestures = {}, touch = {

        active: false,

        on: function () {
            $(document).on('touchstart', touchstart)
                .on('touchmove', touchmove)
                .on('touchend touchcancel', touchend);

            touch.active = true;
        },

        off: function () {
            $(document).off('touchstart', touchstart)
                .off('touchmove', touchmove)
                .off('touchend touchcancel', touchend);

            touch.active = false;
        },

        track: function (namespace, gesture) {
            gestures[namespace] = gesture;
        },

        addEventParam: function (event, extra) {
            var $t = $(event.target),
                pos = $t.offset(),
                param = {
                    pageX: event.point[0].x,
                    pageY: event.point[0].y,
                    offsetX: pos.left - event.point[0].x,
                    offsetY: pos.top - event.point[0].y
                };

            return $.extend(param, extra);
        },

        Event: function (event) { // normalizes and simplifies the event object
            var normalizedEvent = {
                type: event.type,
                timestamp: new Date().getTime(),
                target: event.target,   // target is always consistent through start, move, end
                point: []
            }, points = event.changedTouches ||
                event.originalEvent.changedTouches ||
                event.touches ||
                event.originalEvent.touches;

            $.each(points, function (i, e) {
                normalizedEvent.point.push({
                    x: e.pageX,
                    y: e.pageY
                });
            });

            return normalizedEvent;
        },

        State: function (start) {
            var p = start.point[0];

            return {   // TODO add screenX etc.
                start: start,
                move: [],
                end: null
            };
        },

        calc: {
            getDuration: function (start, end) {
                return end.timestamp - start.timestamp;
            },

            getDistance: function (start, end) {
                return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            },

            getAngle: function (start, end) {
                return Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;
            },

            getDirection: function (angle) {
                return angle < -45 && angle > -135 ? 'top':
                    angle >= -45 && angle <= 45 ? 'right':
                        angle >= 45 && angle < 135 ? 'down':
                            angle >= 135 || angle <= -135 ? 'left':
                                'unknown';
            },

            getScale: function (start, move) {
                var sp = start.point,
                    mp = move.point;

                if(sp.length === 2 && mp.length === 2) { // needs to have the position of two fingers
                    return (Math.sqrt(Math.pow(mp[0].x - mp[1].x, 2) + Math.pow(mp[0].y - mp[1].y, 2)) / Math.sqrt(Math.pow(sp[0].x - sp[1].x, 2) + Math.pow(sp[0].y - sp[1].y, 2))).toFixed(2);
                }

                return 0;
            },

            getRotation: function (start, move) {
                var sp = start.point,
                    mp = move.point;

                if(sp.length === 2 && mp.length === 2) {
                    return ((Math.atan2(mp[0].y - mp[1].y, mp[0].x - mp[1].x) * 180 / Math.PI) - (Math.atan2(sp[0].y - sp[1].y, sp[0].x - sp[1].x) * 180 / Math.PI)).toFixed(2);
                }

                return 0;
            }
        }

    }; // touch obj

    function loopHandler(type, event, state, point) {
        $.each(gestures, function (i, g) {
            g[type].call(this, event, state, point);
        });
    }

    function touchstart(event) {
        var start = touch.Event(event);
        state = touch.State(start); // create a new State object and add start event

        loopHandler('touchstart', event, state, start);
    }

    function touchmove(event) {
        var move = touch.Event(event);
        state.move.push(move);

        loopHandler('touchmove', event, state, move);
    }

    function touchend(event) {
        var end = touch.Event(event);
        state.end = end;

        loopHandler('touchend', event, state, end);
    }

    touch.on();

    // add to namespace
    $.toe = touch;

}(jQuery, this));
(function ($, touch, window, undefined) {

    var namespace = 'swipe', cfg = {
            distance: 40, // minimum
            duration: 1200, // maximum
            direction: 'all'
        };

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            state[namespace] = {
                finger: start.point.length
            };
        },
        touchmove: function (event, state, move) {
            // if another finger was used then increment the amount of fingers used
            state[namespace].finger = move.point.length > state[namespace].finger ? move.point.length : state[namespace].finger;
        },
        touchend: function (event, state, end) {
            var opt = $.extend(cfg, event.data),
                duration,
                distance;

            // calc
            duration = touch.calc.getDuration(state.start, end);
            distance = touch.calc.getDistance(state.start.point[0], end.point[0]);

            // check if the swipe was valid
            if (duration < opt.duration && distance > opt.distance) {

                state[namespace].angle = touch.calc.getAngle(state.start.point[0], end.point[0]);
                state[namespace].direction = touch.calc.getDirection(state[namespace].angle);

                // fire if the amount of fingers match
                if (opt.direction === 'all' || state[namespace].direction === opt.direction) {
                    $(event.target).trigger($.Event(namespace, touch.addEventParam(state.start, state[namespace])));
                }
            }
        }
    });

}(jQuery, jQuery.toe, this));
(function ($, touch, window, undefined) {

    var namespace = 'tap', cfg = {
        distance: 10,
        duration: 300,
        finger: 1
    };

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            state[namespace] = {
                finger: start.point.length
            };
        },
        touchmove: function (event, state, move) {
            // if another finger was used then increment the amount of fingers used
            state[namespace].finger = move.point.length > state[namespace].finger ? move.point.length : state[namespace].finger;
        },
        touchend: function (event, state, end) {
            var opt = $.extend(cfg, event.data),
                duration,
                distance;

            // calc
            duration = touch.calc.getDuration(state.start, end);
            distance = touch.calc.getDistance(state.start.point[0], end.point[0]);

            // check if the tap was valid
            if (duration < opt.duration && distance < opt.distance) {
                // fire if the amount of fingers match
                if (state[namespace].finger === opt.finger) {
                    $(event.target).trigger(
                        $.Event(namespace, touch.addEventParam(state.start, state[namespace]))
                    );
                }
            }
        }
    });

}(jQuery, jQuery.toe, this));
(function ($, touch, window, undefined) {

    var timer, abort,
        namespace = 'taphold', cfg = {
            distance: 20,
            duration: 500,
            finger: 1
        };

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            var opt = $.extend(cfg, event.data);

            abort = false;
            state[namespace] = {
                finger: start.point.length
            };

            clearTimeout(timer);
            timer = setTimeout(function () {
                if (!abort && touch.active) {
                    if (state[namespace].finger === opt.finger) {
                        $(event.target).trigger($.Event(namespace, touch.addEventParam(start, state[namespace])));
                    }
                }
            }, opt.duration);
        },
        touchmove: function (event, state, move) {
            var opt = $.extend(cfg, event.data),
                distance;

            // if another finger was used then increment the amount of fingers used
            state[namespace].finger = move.point.length > state[namespace].finger ? move.point.length : state[namespace].finger;

            // calc
            distance = touch.calc.getDistance(state.start.point[0], move.point[0]);
            if (distance > opt.distance) { // illegal move
                abort = true;
            }
        },
        touchend: function (event, state, end) {
            abort = true;
            clearTimeout(timer);
        }
    });

}(jQuery, jQuery.toe, this));
(function ($, touch, window, undefined) {

    var namespace = 'transform', cfg = {
            scale: 0.1, // minimum
            rotation: 15
        },
        started;

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            started = false;
            state[namespace] = {
                start: start,
                move: []
            };
        },
        touchmove: function (event, state, move) {
            var opt = $.extend(cfg, event.data);

            if (move.point.length !== 2) {
                return;
            }

            state[namespace].move.push(move);

            if (state[namespace].start.point.length !== 2 && move.point.length === 2) { // in case the user failed to start with 2 fingers
                state[namespace].start = $.extend({}, move);
            }

            state[namespace].rotation = touch.calc.getRotation(state[namespace].start, move);
            state[namespace].scale = touch.calc.getScale(state[namespace].start, move);

            if (Math.abs(1-state[namespace].scale) > opt.scale || Math.abs(state[namespace].rotation) > opt.rotation) {
                if(!started) {
                    $(event.target).trigger($.Event('transformstart', state[namespace]));
                    started = true;
                }

                $(event.target).trigger($.Event('transform', state[namespace]));
            }
        },
        touchend: function (event, state, end) {
            if(started) {
                started = false;

                if (end.point.length !== 2) { // in case the user failed to end with 2 fingers
                    state.end = $.extend({}, state[namespace].move[state[namespace].move.length - 1]);
                }

                state[namespace].rotation = touch.calc.getRotation(state[namespace].start, state.end);
                state[namespace].scale = touch.calc.getScale(state[namespace].start, state.end);

                $(event.target).trigger($.Event('transformend', state[namespace]));
            }
        }
    });

}(jQuery, jQuery.toe, this));
/* global CUI */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($, window, undefined) {
  'use strict';

  /**
   * @classdesc The main CUI namespace.
   * @namespace
   *
   * @property {Object} options Main options for CloudUI components.
   * @property {Boolean} options.debug If true, show debug messages for all components.
   * @property {Boolean} options.dataAPI If true, add listeners for widget data APIs.
   * @property {Object} Templates Contains templates used by CUI widgets
   *
   * @example
   * <caption>Change CUI options</caption>
   * <description>You can change CUI options by defining <code>CUI.options</code> before you load CUI.js</description>
   * &lt;script type=&quot;text/javascript&quot;&gt;
   * var CUI = {
   *   options: {
   *     debug: false,
   *     dataAPI: true
   *   }
   * };
   * &lt;/script&gt;
   * &lt;script src=&quot;js/CUI.js&quot;&gt;&lt;/script&gt;
   *
   * preferable include the CUI.js at the bottom before the body closes
   */
  window.CUI = window.CUI || {};

  CUI.options = $.extend({
    debug: false,
    dataAPI: true
  }, CUI.options);

  // REMARK: disabled for now
  // Register partials for all templates
  // Note: this requires the templates to be included BEFORE CUI.js
  /*for (var template in CUI.Templates) {
   Handlebars.registerPartial(template, CUI.Templates[template]);
   }*/

  /**
   * <p><code>cui-contentloaded</code> event is an event that is triggered when a new content is injected to the DOM,
   * which is very similar to {@link https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/DOMContentLoaded|DOMContentLoaded} event.</p>
   * <p>This event is normally used so that a JavaScript code can be notified when new content needs to be enhanced (applying event handler, layout, etc).
   * The element where the new content is injected is available at event.target, like so:
   * <pre class="prettyprint linenums jsDocExample">$(document).on("cui-contentloaded", function(e) {
   * var container = e.target;
   * // the container is the element where new content is injected.
   * });</pre>
   * This way the listener can limit the scope of the selector accordingly.</p>
   * <p>It will be triggered at DOMContentLoaded event as well, so component can just listen to this event instead of DOMContentLoaded for enhancement purpose.
   * In that case, the value of event.target is <code>document</code>.</p>
   *
   * @event cui-contentloaded
   */
  $(function() {
    $(document).trigger('cui-contentloaded');
  });

}(jQuery, this));

/* global CUI */
/* jshint -W033,-W116 */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($, window, undefined) {
  'use strict';

  var nextId = 1;

  /**
   * Utility functions used by CoralUI widgets
   * @namespace
   */
  CUI.util = {

    /**
     * Flag if a touch device was detected
     * @type {Boolean}
     */
    isTouch: (function() {
      // CUI-2327 Special value for Win8.x/Chrome
      if (/Windows NT 6\.[23];.*Chrome/.test(window.navigator.userAgent)) {
        return false;
      }

      return 'ontouchstart' in window;
    })(),

    /**
     * delivers a unique id within Coral
     * meant to be used in case a id attribute is necessary but missing
     */
    getNextId: function() {
      return 'coral-' + nextId++;
    },

    /**
     * Get the target element of a data API action using the data attributes of an element.
     *
     * @param {jQuery} $element The jQuery object representing the element to get the target from
     * @return {jQuery} The jQuery object representing the target element
     */
    getDataTarget: function($element) {
      var href = $element.attr('href');
      var $target = $($element.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))); // Strip for ie7
      return $target;
    },

    /**
     * Decapitalize a string by converting the first letter to lowercase.
     *
     * @param {String} str The string to de-capitalize
     * @return {String} The de-capitalized string
     */
    decapitalize: function(str) {
      return str.slice(0, 1).toLowerCase() + str.slice(1);
    },

    /**
     * Capitalize a string by converting the first letter to uppercase.
     *
     * @param {String} str The string to capitalize
     * @return {String} The capitalized string
     */
    capitalize: function(str) {
      return str.slice(0, 1).toUpperCase() + str.slice(1);
    },

    /**
     * Create a jQuery plugin from a class
     * @param {Class} PluginClass The class to create to create the plugin for
     * @param {String} [pluginName=PluginClass.toString()] The name of the plugin to create. The de-capitalized return value of PluginClass.toString() is used if left undefined
     * @param {Function} [callback]                              A function to execute in the scope of the jQuery object when the plugin is activated. Used for tacking on additional initialization procedures or behaviors for other plugin functionality.
     */
    plugClass: function(PluginClass, pluginName, callback) {
      pluginName = pluginName || CUI.util.decapitalize(PluginClass.toString());

      $.fn[pluginName] = function(optionsIn) {
        var pluginArgs = arguments;
        return this.each(function() {
          var $element = $(this);

          // Combine defaults, data, options, and element config
          var options = $.extend({}, $element.data(), typeof optionsIn === 'object' && optionsIn, {
            element: this
          });

          // Get instance, if present already
          var instance = $element.data(pluginName) || new PluginClass(options);

          if (typeof optionsIn === 'string') { // Call method, pass args
            instance[optionsIn].apply(instance, Array.prototype.slice.call(pluginArgs, 1));
          }
          else if ($.isPlainObject(optionsIn)) { // Apply options
            instance.set(optionsIn);
          }

          if (typeof callback === 'function') {
            callback.call(this, instance);
          }
        });
      };

      $.fn[pluginName].Constructor = PluginClass;
    },

    /**
     * Register a callback from a string
     *
     * @param {String} callbackAsString The string containing the callback function to register
     * @param {Object} [params] Parameters to provide when executing callback
     * @return {Function} The callback function generated from the provided string
     */
    buildFunction: function(callbackAsString, params) {
      params = params || [];

      if (typeof params === 'string') {
        params = [params];
      }

      if (callbackAsString) {
        try {
          var Fn = Function;
          return new Fn(params, 'return ' + callbackAsString + '(' + params.join(', ') + ');');
        } catch (e) {
          return null;
        }
      }
    },

    /**
     * Selects text in the provided field
     * @param {Number} start (optional) The index where the selection should start (defaults to 0)
     * @param {Number} end (optional) The index where the selection should end (defaults to the text length)
     */
    selectText: function(field, start, end) {
      var value = field.val();

      if (value.length > 0) {
        start = start || 0;
        end = end || value.length;
        var domEl = $(field)[0];
        if (domEl.setSelectionRange) {
          // Mostly all browsers
          domEl.blur();
          domEl.setSelectionRange(start, end);
          domEl.focus();
        }
        else if (domEl.createTextRange) {
          // IE
          var range = domEl.createTextRange();
          range.collapse(true);
          range.moveEnd('character', end - value.length);
          range.moveStart('character', start);
          range.select();
        }
      }
    },

    /**
     * Utility function to get the value of a nested key within an object
     *
     * @param {Object} object The object to retrieve the value from
     * @param {String} nestedKey The nested key. For instance 'foo.bar.baz'
     * @return {Object} The object value for the nested key
     */
    getNested: function(object, nestedKey) {
      if (!nestedKey) {
        return object;
      }

      // Split key into a table
      var keys = typeof nestedKey === 'string' ? nestedKey.split('.') : nestedKey;

      // Browse object
      var result = object;
      while (result && keys.length > 0) {
        result = result[keys.shift()];
      }

      return result;
    },

    /**
     * Utility function to transform a string representation of a boolean value into that boolean value
     *
     * @param {String} string representation
     * @return {Boolean} The boolean value of the string
     */
    isTrue: function(str) {
      return str === 'true';
    }

  };

  // add touch class to <html>
  $('html').toggleClass('touch', CUI.util.isTouch);

}(jQuery, this));

/* global CUI */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($, window, undefined) {
  'use strict';

  /**
   * Load remote content in an element with a CUI spinner
   * @param {String} remote The remote URL to pass to $.load
   * @param {Boolean} [force] Set force to true to force the load to happen with every call, even if it has succeeded already. Otherwise, subsequent calls will simply return.
   * @param {Function} [callback] A function to execute in the scope of the jQuery $.load call when the load finishes (whether success or failure). The arguments to the callback are the load results: response, status, xhr.
   */
  $.fn.loadWithSpinner = function(remote, force, callback) {
    var $target = $(this);

    // load remote link, if necessary
    if (remote && (force || $target.data('loaded-remote') !== remote)) {
      // only show the spinner if the request takes an appreciable amount of time, otherwise
      // the flash of the spinner is a little ugly
      var timer = setTimeout(function() {
        $target.html('<div class="spinner large"></div>');
      }, 50);

      $target.load(remote, function(response, status, xhr) {
        clearTimeout(timer); // no need for the spinner anymore!

        if (status === 'error') {
          $target.html('<div class="alert error"><strong>ERROR</strong> Failed to load content: ' + xhr.statusText + ' (' + xhr.status + ')</div>');
          $target.data('loaded-remote', '');
        }

        if (typeof callback === 'function') {
          callback.call(this, response, status, xhr);
        }
      }); // load

      $target.data('loaded-remote', remote);
    } // end if remote
  };

  /**
   * $.fn.on for touch devices only
   * @return {jquery} this, chainable
   */
  $.fn.finger = function() {
    if (CUI.util.isTouch) {
      this.on.apply(this, arguments);
    }
    return this;
  };

  /**
   * $.fn.on for pointer devices only
   * @return {jquery} this, chainable
   */
  $.fn.pointer = function() {
    if (!CUI.util.isTouch) {
      this.on.apply(this, arguments);
    }
    return this;
  };

  /**
   * $.fn.on for touch and pointer devices
   * the first parameter is the finger event the second the pointer event
   * @return {jquery} this, chainable
   */
  $.fn.fipo = function() {
    var args = Array.prototype.slice.call(arguments, 1, arguments.length);

    this.pointer.apply(this, args);

    args[0] = arguments[0];
    this.finger.apply(this, args);

    return this;
  };

}(jQuery, this));

/* global CUI, Class */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($, window, undefined) {
  'use strict';

  CUI.Widget = new Class( /** @lends CUI.Widget# */ {
    toString: 'Widget',

    /**
     * @classdesc The base class for all widgets
     *
     * @desc Creates a new widget
     * @constructs CUI.Widget
     *
     * @param {Object} options Widget options
     * @param {Boolean} [options.visible=false] If True, show the widget immediately
     */
    construct: function(options) {

      // Store the target element jQuery object:
      this.$element = $(options.element);

      // Get widget name:
      var widgetName = CUI.util.decapitalize(this.toString());

      // See if the target element has a widget instance attached already:
      if (this.$element.data(widgetName) !== undefined) {
        var message = [
          'An instance of',
          this,
          'is already attached to the specified target element.',
          'Future versions of CoralUI will throw an exception at this point.'
        ].join(' ');

        window.console.log(message);
      }

      // Cascade and store options:
      this.options = $.extend(
        {},
        (typeof this.defaults === 'object' && this.defaults),
        this.$element.data(),
        options);

      // Add instance to element's data
      this.$element.data(widgetName, this);

      // Bind functions commonly called by listeners
      this.bind(this.hide);
      this.bind(this.show);
      this.bind(this.toggleVisibility);

      // Show/hide when this.options.visible changes
      this.on('change:visible', function(evt) {
        this[evt.value ? '_show' : '_hide']();
      }.bind(this));
    },

    /**
     * Set a number of options using an object or a string
     * @name set
     * @memberOf CUI.Widget#
     * @function
     *
     * @param {String|Object} option The option to set as a string, or an object of key/value pairs to set
     * @param {String} value The value to set the option to (is ignored when first argument is an object)
     *
     * @return {CUI.Widget} this, chainable
     */
    set: function(optionOrObj, value) {
      if ($.isPlainObject(optionOrObj)) {
        // Set multiple options
        for (var option in optionOrObj) {
          this._set(option, optionOrObj[option]);
        }
      }
      else {
        // Set single option
        this._set(optionOrObj, value);
      }

      return this;
    },

    /**
     * @ignore
     */
    _set: function(option, value) {
      // Trigger a change event
      var e = $.Event('beforeChange:' + option, {
        widget: this, // We want to know who fired this event (used by CUI.Filters, CUI.DropdownList)
        option: option,
        currentValue: this.options[option],
        value: value
      });
      this.$element.trigger(e);

      // Don't set if prevented
      if (e.isDefaultPrevented()) {
        return this;
      }

      // Set value
      this.options[option] = value;

      e = $.Event('change:' + option, {
        widget: this,
        option: option,
        value: value
      });
      this.$element.trigger(e);
    },

    /**
     * Get the value of an option
     * @param {String} option The name of the option to fetch the value of
     * @return {Mixed} Option value
     */
    get: function(option) {
      return this.options[option];
    },

    /**
     * Add an event listener
     * @param {String} evtName The event name to listen for
     * @param {Function} func The function that will be called when the event is triggered
     * @return {CUI.Widget} this, chainable
     */
    on: function(evtName, func) {
      this.$element.on.apply(this.$element, arguments);
      return this;
    },

    /**
     * Remove an event listener
     * @param {String} evtName The event name to stop listening for
     * @param {Function} func     The function that was passed to on()
     * @return {CUI.Widget} this, chainable
     */
    off: function(evtName, func) {
      this.$element.off.apply(this.$element, arguments);
      return this;
    },

    /**
     * Show the widget
     * @return {CUI.Widget} this, chainable
     */
    show: function(evt) {
      evt = evt || {};

      if (this.options.visible) {
        return this;
      }

      if (!evt.silent) {
        // Trigger event
        var e = $.Event('show');
        this.$element.trigger(e);

        // Do nothing if event is prevented or we're already visible
        if (e.isDefaultPrevented()) {
          return this;
        }
      }

      this.options.visible = true;

      this._show(evt);

      return this;
    },

    /**
     * @ignore
     */
    _show: function(evt) {
      this.$element.show();
    },

    /**
     * Hide the widget
     *
     * @return {CUI.Widget} this, chainable
     */
    hide: function(evt) {
      evt = evt || {};

      if (!this.options.visible) {
        return this;
      }

      if (!evt.silent) {
        // Trigger event
        var e = $.Event('hide');
        this.$element.trigger(e);

        if (e.isDefaultPrevented()) {
          return this;
        }
      }

      this.options.visible = false;

      this._hide(evt);

      return this;
    },

    /**
     * @ignore
     */
    _hide: function(evt) {
      this.$element.hide();
    },

    /**
     * Toggle the visibility of the widget
     * @return {CUI.Widget} this, chainable
     */
    toggleVisibility: function() {
      return this[!this.options.visible ? 'show' : 'hide']();
    },

    /**
     * Set a custom name for this widget.
     *
     * @param {String} customName Component name
     * @return {CUI.Widget} this, chainable
     */
    setName: function(customName) {
      /** @ignore */
      this.toString = function() {
        return customName;
      };

      return this;
    }

    /**
     Triggered when the widget is shown

     @name CUI.Widget#show
     @event
     */

    /**
     Triggered when the widget is hidden

     @name CUI.Widget#hide
     @event
     */

    /**
     Triggered when before an option is changed

     @name CUI.Widget#beforeChange:*
     @event

     @param {Object} evt                    Event object
     @param {Mixed} evt.option              The option that changed
     @param {Mixed} evt.currentValue        The current value
     @param {Mixed} evt.value               The value this option will be changed to
     @param {Function} evt.preventDefault   Call to prevent the option from changing
     */

  /**
   Triggered when an option is changed

   @name CUI.Widget#change:*
   @event

   @param {Object} evt          Event object
   @param {Mixed} evt.option    The option that changed
   @param {Mixed} evt.value     The new value
   */
  });

  /**
   * Utility function to get the widget class instance that's attached to
   * the provided element.
   *
   * @param WidgetClass The type of widget instance to obtain.
   * @param $element The target element to obtain the instance from.
   * @returns The obtained Widget instance, if the target element has an
   * instance attached.
   */
  CUI.Widget.fromElement = function(WidgetClass, $element) {
    return $element.data(CUI.util.decapitalize(WidgetClass.toString()));
  };

  /**
   * The registry object maps data-init selector values to Widget
   * types.
   */
  CUI.Widget.registry = {

    /**
     * Registers the given Widget type as the type that belongs
     * to the provided selector.
     *
     * @param selector String representing the data-init value
     * mapping to Widget.
     * @param Widget Widget subclass that maps to the given
     * selector.
     */
    register: function(selector, Widget) {

      // Register as a jQuery plug-in:
      CUI.util.plugClass(Widget);

      this._widgets[selector] = Widget;

      // Extend the Widget with a static 'init' method:
      Widget.init = function($element) {
        this._init(Widget, $element);
      }.bind(this);

    },

    /**
     * Look-up the Widget subclass that is mapped to the provided
     * selector String value.
     *
     * @param selector String value to look-up the registered
     * Widget subclass for.
     * @returns a Widget subclass, or undefined if the selector
     * could not be resolved.
     */
    resolve: function(selector) {
      return this._widgets[selector];
    },

    /**
     * Initialize the given jQuery element(s) as Widgets of the
     * type as indicated by the selector argument.
     *
     * @param selector String that indicates what Widget subclass
     * must be used to initialize the element.
     * @param $element The jQuery element(s) that the instances
     * must be bound to.
     */
    init: function(selector, $element) {
      this._init(this.resolve(selector), $element);
    },

    getSelectors: function() {
      var selectors = [];
      for (var selector in this._widgets) {
        selectors.push(selector);
      }
      return selectors;
    },

    /**
     * Maps selector values to Widget types
     * @private
     */
    _widgets: {},

    /**
     * Implementation of the public init method, as well as the
     * init method that gets added to registering Widget classes
     *
     * @param Widget The Widget subclass to instantiate.
     * @param $element The jQuery element(s) that the instances
     * must be bound to.
     * @private
     */
    _init: function(Widget, $element) {
      if (Widget !== undefined) {
        $element.each(function() {
          var $item = $(this);

          if (CUI.Widget.fromElement(Widget, $item) === undefined) {
            new Widget({
              element: $item
            });
          }
        });
      }
    }
  };

}(jQuery, this));

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["commons"] = window["Coral"]["templates"]["commons"] || {};
window["Coral"]["templates"]["commons"]["resizeListener"] = (function anonymous(data_0
/**/) {
    var data = data_0;
    var el0 = document.createElement("object");
    el0.setAttribute("aria-hidden", "true");
    el0.setAttribute("tabindex", "-1");
    el0.setAttribute("style", "display:block; position:absolute; top:0; left:0; height:100%; width:100%; opacity:0; overflow:hidden; z-index:-100;");
    el0.textContent = "​";
    return el0;
});
/*
 ADOBE CONFIDENTIAL

 Copyright 2014 Adobe Systems Incorporated
 All Rights Reserved.

 NOTICE:  All information contained herein is, and remains
 the property of Adobe Systems Incorporated and its suppliers,
 if any.  The intellectual and technical concepts contained
 herein are proprietary to Adobe Systems Incorporated and its
 suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from Adobe Systems Incorporated.
 */
(function() {
  // A polyfill for HTMLElement.hidden property

  var testEl = document.createElement('div');

  if ('hidden' in testEl) {
    return;
  }

  Object.defineProperty(HTMLElement.prototype, 'hidden', {
    get: function() {
      return this.hasAttribute('hidden');
    },
    set: function set(v) {
      if (v) {
        this.setAttribute('hidden', '');
      } else {
        this.removeAttribute('hidden');
      }
    },
    configurable: true
  });
})();

/*! @source https://developer.mozilla.org/en/docs/Web/API/Element/matches */
(function() {
  // A polyfill for Element.matches property

  if (!Element.prototype.matches) {
    Element.prototype.matches =
      Element.prototype.matchesSelector ||
      Element.prototype.mozMatchesSelector ||
      Element.prototype.msMatchesSelector ||
      Element.prototype.oMatchesSelector ||
      Element.prototype.webkitMatchesSelector ||
      function(s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s),
          i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;
      };
  }
})();

/*! @source http://codegists.com/snippet/javascript/closest-polyfilljs_monochromer_javascript */
(function() {
  //closest polyfill
  if (!Element.prototype.closest) {
    Element.prototype.closest = function(selector) {
      var node = this;

      while (node) {
        if (node.matches(selector)) return node;
        else node = node.parentElement;
      }
      return null;
    };
  }
})();

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.24
"undefined"==typeof WeakMap&&!function(){var e=Object.defineProperty,t=Date.now()%1e9,n=function(){this.name="__st"+(1e9*Math.random()>>>0)+(t++ +"__")};n.prototype={set:function(t,n){var o=t[this.name];return o&&o[0]===t?o[1]=n:e(t,this.name,{value:[t,n],writable:!0}),this},get:function(e){var t;return(t=e[this.name])&&t[0]===e?t[1]:void 0},"delete":function(e){var t=e[this.name];return!(!t||t[0]!==e)&&(t[0]=t[1]=void 0,!0)},has:function(e){var t=e[this.name];return!!t&&t[0]===e}},window.WeakMap=n}(),function(e){function t(e){E.push(e),b||(b=!0,m(o))}function n(e){return window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(e)||e}function o(){b=!1;var e=E;E=[],e.sort(function(e,t){return e.uid_-t.uid_});var t=!1;e.forEach(function(e){var n=e.takeRecords();r(e),n.length&&(e.callback_(n,e),t=!0)}),t&&o()}function r(e){e.nodes_.forEach(function(t){var n=v.get(t);n&&n.forEach(function(t){t.observer===e&&t.removeTransientObservers()})})}function i(e,t){for(var n=e;n;n=n.parentNode){var o=v.get(n);if(o)for(var r=0;r<o.length;r++){var i=o[r],a=i.options;if(n===e||a.subtree){var d=t(a);d&&i.enqueue(d)}}}}function a(e){this.callback_=e,this.nodes_=[],this.records_=[],this.uid_=++_}function d(e,t){this.type=e,this.target=t,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function s(e){var t=new d(e.type,e.target);return t.addedNodes=e.addedNodes.slice(),t.removedNodes=e.removedNodes.slice(),t.previousSibling=e.previousSibling,t.nextSibling=e.nextSibling,t.attributeName=e.attributeName,t.attributeNamespace=e.attributeNamespace,t.oldValue=e.oldValue,t}function u(e,t){return y=new d(e,t)}function c(e){return N?N:(N=s(y),N.oldValue=e,N)}function l(){y=N=void 0}function f(e){return e===N||e===y}function p(e,t){return e===t?e:N&&f(e)?N:null}function w(e,t,n){this.observer=e,this.target=t,this.options=n,this.transientObservedNodes=[]}if(!e.JsMutationObserver){var m,v=new WeakMap;if(/Trident|Edge/.test(navigator.userAgent))m=setTimeout;else if(window.setImmediate)m=window.setImmediate;else{var h=[],g=String(Math.random());window.addEventListener("message",function(e){if(e.data===g){var t=h;h=[],t.forEach(function(e){e()})}}),m=function(e){h.push(e),window.postMessage(g,"*")}}var b=!1,E=[],_=0;a.prototype={observe:function(e,t){if(e=n(e),!t.childList&&!t.attributes&&!t.characterData||t.attributeOldValue&&!t.attributes||t.attributeFilter&&t.attributeFilter.length&&!t.attributes||t.characterDataOldValue&&!t.characterData)throw new SyntaxError;var o=v.get(e);o||v.set(e,o=[]);for(var r,i=0;i<o.length;i++)if(o[i].observer===this){r=o[i],r.removeListeners(),r.options=t;break}r||(r=new w(this,e,t),o.push(r),this.nodes_.push(e)),r.addListeners()},disconnect:function(){this.nodes_.forEach(function(e){for(var t=v.get(e),n=0;n<t.length;n++){var o=t[n];if(o.observer===this){o.removeListeners(),t.splice(n,1);break}}},this),this.records_=[]},takeRecords:function(){var e=this.records_;return this.records_=[],e}};var y,N;w.prototype={enqueue:function(e){var n=this.observer.records_,o=n.length;if(n.length>0){var r=n[o-1],i=p(r,e);if(i)return void(n[o-1]=i)}else t(this.observer);n[o]=e},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(e){var t=this.options;t.attributes&&e.addEventListener("DOMAttrModified",this,!0),t.characterData&&e.addEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.addEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.addEventListener("DOMNodeRemoved",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(e){var t=this.options;t.attributes&&e.removeEventListener("DOMAttrModified",this,!0),t.characterData&&e.removeEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.removeEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.removeEventListener("DOMNodeRemoved",this,!0)},addTransientObserver:function(e){if(e!==this.target){this.addListeners_(e),this.transientObservedNodes.push(e);var t=v.get(e);t||v.set(e,t=[]),t.push(this)}},removeTransientObservers:function(){var e=this.transientObservedNodes;this.transientObservedNodes=[],e.forEach(function(e){this.removeListeners_(e);for(var t=v.get(e),n=0;n<t.length;n++)if(t[n]===this){t.splice(n,1);break}},this)},handleEvent:function(e){switch(e.stopImmediatePropagation(),e.type){case"DOMAttrModified":var t=e.attrName,n=e.relatedNode.namespaceURI,o=e.target,r=new u("attributes",o);r.attributeName=t,r.attributeNamespace=n;var a=e.attrChange===MutationEvent.ADDITION?null:e.prevValue;i(o,function(e){if(e.attributes&&(!e.attributeFilter||!e.attributeFilter.length||e.attributeFilter.indexOf(t)!==-1||e.attributeFilter.indexOf(n)!==-1))return e.attributeOldValue?c(a):r});break;case"DOMCharacterDataModified":var o=e.target,r=u("characterData",o),a=e.prevValue;i(o,function(e){if(e.characterData)return e.characterDataOldValue?c(a):r});break;case"DOMNodeRemoved":this.addTransientObserver(e.target);case"DOMNodeInserted":var d,s,f=e.target;"DOMNodeInserted"===e.type?(d=[f],s=[]):(d=[],s=[f]);var p=f.previousSibling,w=f.nextSibling,r=u("childList",e.target.parentNode);r.addedNodes=d,r.removedNodes=s,r.previousSibling=p,r.nextSibling=w,i(e.relatedNode,function(e){if(e.childList)return r})}l()}},e.JsMutationObserver=a,e.MutationObserver||(e.MutationObserver=a,a._isPolyfilled=!0)}}(self),function(e){"use strict";if(!window.performance||!window.performance.now){var t=Date.now();window.performance={now:function(){return Date.now()-t}}}window.requestAnimationFrame||(window.requestAnimationFrame=function(){var e=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame;return e?function(t){return e(function(){t(performance.now())})}:function(e){return window.setTimeout(e,1e3/60)}}()),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(){return window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||function(e){clearTimeout(e)}}());var n=function(){var e=document.createEvent("Event");return e.initEvent("foo",!0,!0),e.preventDefault(),e.defaultPrevented}();if(!n){var o=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(o.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var r=/Trident/.test(navigator.userAgent);if((!window.CustomEvent||r&&"function"!=typeof window.CustomEvent)&&(window.CustomEvent=function(e,t){t=t||{};var n=document.createEvent("CustomEvent");return n.initCustomEvent(e,Boolean(t.bubbles),Boolean(t.cancelable),t.detail),n},window.CustomEvent.prototype=window.Event.prototype),!window.Event||r&&"function"!=typeof window.Event){var i=window.Event;window.Event=function(e,t){t=t||{};var n=document.createEvent("Event");return n.initEvent(e,Boolean(t.bubbles),Boolean(t.cancelable)),n},window.Event.prototype=i.prototype}}(window.WebComponents),window.CustomElements=window.CustomElements||{flags:{}},function(e){var t=e.flags,n=[],o=function(e){n.push(e)},r=function(){n.forEach(function(t){t(e)})};e.addModule=o,e.initializeModules=r,e.hasNative=Boolean(document.registerElement),e.isIE=/Trident/.test(navigator.userAgent),e.useNative=!t.register&&e.hasNative&&!window.ShadowDOMPolyfill&&(!window.HTMLImports||window.HTMLImports.useNative)}(window.CustomElements),window.CustomElements.addModule(function(e){function t(e,t){n(e,function(e){return!!t(e)||void o(e,t)}),o(e,t)}function n(e,t,o){var r=e.firstElementChild;if(!r)for(r=e.firstChild;r&&r.nodeType!==Node.ELEMENT_NODE;)r=r.nextSibling;for(;r;)t(r,o)!==!0&&n(r,t,o),r=r.nextElementSibling;return null}function o(e,n){for(var o=e.shadowRoot;o;)t(o,n),o=o.olderShadowRoot}function r(e,t){i(e,t,[])}function i(e,t,n){if(e=window.wrap(e),!(n.indexOf(e)>=0)){n.push(e);for(var o,r=e.querySelectorAll("link[rel="+a+"]"),d=0,s=r.length;d<s&&(o=r[d]);d++)o["import"]&&i(o["import"],t,n);t(e)}}var a=window.HTMLImports?window.HTMLImports.IMPORT_LINK_TYPE:"none";e.forDocumentTree=r,e.forSubtree=t}),window.CustomElements.addModule(function(e){function t(e,t){return n(e,t)||o(e,t)}function n(t,n){return!!e.upgrade(t,n)||void(n&&a(t))}function o(e,t){b(e,function(e){if(n(e,t))return!0})}function r(e){N.push(e),y||(y=!0,setTimeout(i))}function i(){y=!1;for(var e,t=N,n=0,o=t.length;n<o&&(e=t[n]);n++)e();N=[]}function a(e){_?r(function(){d(e)}):d(e)}function d(e){e.__upgraded__&&!e.__attached&&(e.__attached=!0,e.attachedCallback&&e.attachedCallback())}function s(e){u(e),b(e,function(e){u(e)})}function u(e){_?r(function(){c(e)}):c(e)}function c(e){e.__upgraded__&&e.__attached&&(e.__attached=!1,e.detachedCallback&&e.detachedCallback())}function l(e){for(var t=e,n=window.wrap(document);t;){if(t==n)return!0;t=t.parentNode||t.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&t.host}}function f(e){if(e.shadowRoot&&!e.shadowRoot.__watched){g.dom&&console.log("watching shadow-root for: ",e.localName);for(var t=e.shadowRoot;t;)m(t),t=t.olderShadowRoot}}function p(e,n){if(g.dom){var o=n[0];if(o&&"childList"===o.type&&o.addedNodes&&o.addedNodes){for(var r=o.addedNodes[0];r&&r!==document&&!r.host;)r=r.parentNode;var i=r&&(r.URL||r._URL||r.host&&r.host.localName)||"";i=i.split("/?").shift().split("/").pop()}console.group("mutations (%d) [%s]",n.length,i||"")}var a=l(e);n.forEach(function(e){"childList"===e.type&&(M(e.addedNodes,function(e){e.localName&&t(e,a)}),M(e.removedNodes,function(e){e.localName&&s(e)}))}),g.dom&&console.groupEnd()}function w(e){for(e=window.wrap(e),e||(e=window.wrap(document));e.parentNode;)e=e.parentNode;var t=e.__observer;t&&(p(e,t.takeRecords()),i())}function m(e){if(!e.__observer){var t=new MutationObserver(p.bind(this,e));t.observe(e,{childList:!0,subtree:!0}),e.__observer=t}}function v(e){e=window.wrap(e),g.dom&&console.group("upgradeDocument: ",e.baseURI.split("/").pop());var n=e===window.wrap(document);t(e,n),m(e),g.dom&&console.groupEnd()}function h(e){E(e,v)}var g=e.flags,b=e.forSubtree,E=e.forDocumentTree,_=window.MutationObserver._isPolyfilled&&g["throttle-attached"];e.hasPolyfillMutations=_,e.hasThrottledAttached=_;var y=!1,N=[],M=Array.prototype.forEach.call.bind(Array.prototype.forEach),O=Element.prototype.createShadowRoot;O&&(Element.prototype.createShadowRoot=function(){var e=O.call(this);return window.CustomElements.watchShadow(this),e}),e.watchShadow=f,e.upgradeDocumentTree=h,e.upgradeDocument=v,e.upgradeSubtree=o,e.upgradeAll=t,e.attached=a,e.takeRecords=w}),window.CustomElements.addModule(function(e){function t(t,o){if("template"===t.localName&&window.HTMLTemplateElement&&HTMLTemplateElement.decorate&&HTMLTemplateElement.decorate(t),!t.__upgraded__&&t.nodeType===Node.ELEMENT_NODE){var r=t.getAttribute("is"),i=e.getRegisteredDefinition(t.localName)||e.getRegisteredDefinition(r);if(i&&(r&&i.tag==t.localName||!r&&!i["extends"]))return n(t,i,o)}}function n(t,n,r){return a.upgrade&&console.group("upgrade:",t.localName),n.is&&t.setAttribute("is",n.is),o(t,n),t.__upgraded__=!0,i(t),r&&e.attached(t),e.upgradeSubtree(t,r),a.upgrade&&console.groupEnd(),t}function o(e,t){Object.__proto__?e.__proto__=t.prototype:(r(e,t.prototype,t["native"]),e.__proto__=t.prototype)}function r(e,t,n){for(var o={},r=t;r!==n&&r!==HTMLElement.prototype;){for(var i,a=Object.getOwnPropertyNames(r),d=0;i=a[d];d++)o[i]||(Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(r,i)),o[i]=1);r=Object.getPrototypeOf(r)}}function i(e){e.createdCallback&&e.createdCallback()}var a=e.flags;e.upgrade=t,e.upgradeWithDefinition=n,e.implementPrototype=o}),window.CustomElements.addModule(function(e){function t(t,o){var s=o||{};if(!t)throw new Error("document.registerElement: first argument `name` must not be empty");if(t.indexOf("-")<0)throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '"+String(t)+"'.");if(r(t))throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '"+String(t)+"'. The type name is invalid.");if(u(t))throw new Error("DuplicateDefinitionError: a type with name '"+String(t)+"' is already registered");return s.prototype||(s.prototype=Object.create(HTMLElement.prototype)),s.__name=t.toLowerCase(),s["extends"]&&(s["extends"]=s["extends"].toLowerCase()),s.lifecycle=s.lifecycle||{},s.ancestry=i(s["extends"]),a(s),d(s),n(s.prototype),c(s.__name,s),s.ctor=l(s),s.ctor.prototype=s.prototype,s.prototype.constructor=s.ctor,e.ready&&v(document),s.ctor}function n(e){if(!e.setAttribute._polyfilled){var t=e.setAttribute;e.setAttribute=function(e,n){o.call(this,e,n,t)};var n=e.removeAttribute;e.removeAttribute=function(e){o.call(this,e,null,n)},e.setAttribute._polyfilled=!0}}function o(e,t,n){e=e.toLowerCase();var o=this.getAttribute(e);n.apply(this,arguments);var r=this.getAttribute(e);this.attributeChangedCallback&&r!==o&&this.attributeChangedCallback(e,o,r)}function r(e){for(var t=0;t<_.length;t++)if(e===_[t])return!0}function i(e){var t=u(e);return t?i(t["extends"]).concat([t]):[]}function a(e){for(var t,n=e["extends"],o=0;t=e.ancestry[o];o++)n=t.is&&t.tag;e.tag=n||e.__name,n&&(e.is=e.__name)}function d(e){if(!Object.__proto__){var t=HTMLElement.prototype;if(e.is){var n=document.createElement(e.tag);t=Object.getPrototypeOf(n)}for(var o,r=e.prototype,i=!1;r;)r==t&&(i=!0),o=Object.getPrototypeOf(r),o&&(r.__proto__=o),r=o;i||console.warn(e.tag+" prototype not found in prototype chain for "+e.is),e["native"]=t}}function s(e){return g(M(e.tag),e)}function u(e){if(e)return y[e.toLowerCase()]}function c(e,t){y[e]=t}function l(e){return function(){return s(e)}}function f(e,t,n){return e===N?p(t,n):O(e,t)}function p(e,t){e&&(e=e.toLowerCase()),t&&(t=t.toLowerCase());var n=u(t||e);if(n){if(e==n.tag&&t==n.is)return new n.ctor;if(!t&&!n.is)return new n.ctor}var o;return t?(o=p(e),o.setAttribute("is",t),o):(o=M(e),e.indexOf("-")>=0&&b(o,HTMLElement),o)}function w(e,t){var n=e[t];e[t]=function(){var e=n.apply(this,arguments);return h(e),e}}var m,v=(e.isIE,e.upgradeDocumentTree),h=e.upgradeAll,g=e.upgradeWithDefinition,b=e.implementPrototype,E=e.useNative,_=["annotation-xml","color-profile","font-face","font-face-src","font-face-uri","font-face-format","font-face-name","missing-glyph"],y={},N="http://www.w3.org/1999/xhtml",M=document.createElement.bind(document),O=document.createElementNS.bind(document);m=Object.__proto__||E?function(e,t){return e instanceof t}:function(e,t){if(e instanceof t)return!0;for(var n=e;n;){if(n===t.prototype)return!0;n=n.__proto__}return!1},w(Node.prototype,"cloneNode"),w(document,"importNode"),document.registerElement=t,document.createElement=p,document.createElementNS=f,e.registry=y,e["instanceof"]=m,e.reservedTagList=_,e.getRegisteredDefinition=u,document.register=document.registerElement}),function(e){function t(){i(window.wrap(document)),window.CustomElements.ready=!0;var e=window.requestAnimationFrame||function(e){setTimeout(e,16)};e(function(){setTimeout(function(){window.CustomElements.readyTime=Date.now(),window.HTMLImports&&(window.CustomElements.elapsed=window.CustomElements.readyTime-window.HTMLImports.readyTime),document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})})}var n=e.useNative,o=e.initializeModules;e.isIE;if(n){var r=function(){};e.watchShadow=r,e.upgrade=r,e.upgradeAll=r,e.upgradeDocumentTree=r,e.upgradeSubtree=r,e.takeRecords=r,e["instanceof"]=function(e,t){return e instanceof t}}else o();var i=e.upgradeDocumentTree,a=e.upgradeDocument;if(window.wrap||(window.ShadowDOMPolyfill?(window.wrap=window.ShadowDOMPolyfill.wrapIfNeeded,window.unwrap=window.ShadowDOMPolyfill.unwrapIfNeeded):window.wrap=window.unwrap=function(e){return e}),window.HTMLImports&&(window.HTMLImports.__importsParsingHook=function(e){e["import"]&&a(wrap(e["import"]))}),"complete"===document.readyState||e.flags.eager)t();else if("interactive"!==document.readyState||window.attachEvent||window.HTMLImports&&!window.HTMLImports.ready){var d=window.HTMLImports&&!window.HTMLImports.ready?"HTMLImportsLoaded":"DOMContentLoaded";window.addEventListener(d,t)}else t()}(window.CustomElements);
/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

(function(global) {
  // The next ID we'll use for scoped delegation
  var lastID = 0;

  /*
    Matches selectors that are scoped, such as:
      > selector
      :scope > selector
  */
  var scopedSelectorRegex = /^\s*(>|:scope\s*>)/;

  /**
    Check if the first array contains every element in the second array

    @ignore
  */
  function contains(set, subSet) {
    for (var i = 0; i < subSet.length; i++) {
      if (set.indexOf(subSet[i]) === -1) {
        return false;
      }
    }
    return true;
  }

  /**
    Check if the provided selector is scoped (has context)

    @ignore
  */
  function isScoped(selector) {
    return selector && scopedSelectorRegex.test(selector);
  }

  /**
    Replaces the stopPropagation() method of an event object

    @ignore
  */
  function ventStopPropagation() {
    this._ventPropagationStopped = true;
    Event.prototype.stopPropagation.call(this);
  }

  /**
    Replaces the stopImmediatePropagation() method of an event object

    @ignore
  */
  function ventStopImmediatePropagation() {
    this._ventImmediatePropagationStopped = true;
    Event.prototype.stopImmediatePropagation.call(this);
  }

  /**
    Get the right method to match selectors on

    @ignore
  */
  var matchesSelector = (function() {
    var proto = Element.prototype;
    var matchesSelector = (
      proto.matches ||
      proto.matchesSelector ||
      proto.webkitMatchesSelector ||
      proto.mozMatchesSelector ||
      proto.msMatchesSelector ||
      proto.oMatchesSelector
    );

    if (!matchesSelector) {
      throw new Error('Vent: Browser does not support matchesSelector');
    }

    return matchesSelector;
  }());

  /**
    @class Vent
    @classdesc DOM event delegation

    @param {HTMLElement|String} elementOrSelector
      The element or selector indicating the element to use as the delegation root.
  */
  function Vent(elementOrSelector) {
    if (this === global) {
      throw new Error('Vent must be invoked with the new keyword');
    }

    var root;
    if (typeof elementOrSelector === 'string') {
      root = document.querySelector(elementOrSelector);
    }
    else {
      root = elementOrSelector;
    }

    // Store a reference to the root element
    // This is the node at which we'll listen to events
    this.root = root;

    // Map of event names to array of events
    // Don't inherit from Object so we don't collide with properties on its prototype
    this._listenersByType = Object.create(null);

    /*
      A list of all of the listener objects tracked by this instance
      Each item takes the following form:
      {
        eventName: String,
        handler: Function,
        namespaces: Array<string>,
        selector: String | null,
        useCapture: Boolean,
        isScoped: Boolean
      }
    */
    this._allListeners = [];

    // Ensure listeners always execute in the scope of this instance
    this._executeCaptureListeners = this._executeCaptureListeners.bind(this);
    this._executeBubbleListeners = this._executeBubbleListeners.bind(this);

    // All Vent instances get an ID
    this._id = this._id || lastID++;
  }

  /**
    Check if the listener should fire on the given rooted target

    @ignore
  */
  Vent.prototype._listenerMatchesRootTarget = function(listener, target) {
    return (
      // When no selector is provided
      listener.selector === null &&
      (
        // Execute if we've landed on the root
        target === this.root
      )
    );
  };

  /**
    Check if the listener should fire on the given delegated target

    @ignore
  */
  Vent.prototype._listenerMatchesDelegateTarget = function(listener, target) {
    return (
      // document does not support matches()
      target !== document &&
      // Don't bother with delegation on the root element
      target !== this.root &&
      // Check if the event is delegated
      listener.selector !== null &&
      // Only execute  if the selector matches
      (
        // Check if the selector has context
        listener.isScoped ?
        // Run the match using the root element's ID
        matchesSelector.call(target, '[__vent-id__="'+this._id+'"] '+listener.selector)
        // Run the match without context
        : matchesSelector.call(target, listener.selector)
      )
    );
  };

  /**
    Check if the listener matches the given event phase

    @ignore
  */
  Vent.prototype._listenerMatchesEventPhase = function(listener, useCapture) {
    // Check if the event is the in right phase
    return (listener.useCapture === useCapture);
  };

  /**
    This function is responsible for checking if listeners should be executed for the current event

    @ignore
  */
  Vent.prototype._executeListenersAtElement = function(target, listeners, event, useCapture) {
    var listener;
    var returnValue;

    // Execute each listener that meets the criteria
    executeListeners: for (var listenerIndex = 0; listenerIndex < listeners.length; listenerIndex++) {
      listener = listeners[listenerIndex];

      if (
        // Do not process events on disabled items #1
        !(event.type === 'click' && target.disabled === true)
        &&
        // Check if the target element matches for this listener
        (
          this._listenerMatchesRootTarget(listener, target) ||
          this._listenerMatchesDelegateTarget(listener, target)
        ) &&
        this._listenerMatchesEventPhase(listener, useCapture)
      ) {
        // Store the target that matches the event currently
        event.matchedTarget = target;

        // Call handlers in the scope of the delegate target, passing the event along
        returnValue = listener.handler.call(target, event);

        // Prevent default and stopPropagation if the handler returned false
        if (returnValue === false) {
          event.preventDefault();
          event.stopPropagation();
        }

        if (event._ventImmediatePropagationStopped) {
          // Do not process any more event handlers and stop bubbling
          break executeListeners;
        }
      } // end if
    } // end executeListeners
  };

  /**
    Handles all events added with Vent

    @private
    @memberof Vent
  */
  Vent.prototype._executeCaptureListeners = function(event) {
    var listeners = this._listenersByType[event.type];

    if (!listeners) {
      throw new Error('Vent: _executeListeners called in response to '+event.type+', but we are not listening to it');
    }

    if (listeners.length) {
      // Get a copy of the listeners
      // Without this, removing an event inside of a callback will cause errors
      listeners = listeners.slice();

      // Decorate the event object so we know when stopPropagation is called
      this._decorateEvent(event);

      // Get the event's path through the DOM
      var eventPath = this._getPath(event);

      // Simulate the capture phase by trickling down the target list
      trickleDown: for (var eventPathIndex = eventPath.length - 1; eventPathIndex >= 0; eventPathIndex--) {
        if (!listeners.length) {
          // Stop trickling down if there are no more listeners to execute
          break trickleDown;
        }

        var currentTargetElement = eventPath[eventPathIndex];
        this._executeListenersAtElement(currentTargetElement, listeners, event, true);

        // Stop if a handler told us to stop trickling down the DOM
        if (
          event._ventImmediatePropagationStopped ||
          event._ventPropagationStopped
        ) {
          // Stop simulating trickle down
          break trickleDown;
        }
      }
    }

    // Clean up after Vent
    // We'll be re-decorating the event object in the bubble phase, if the event gets there
    this._undecorateEvent(event);
  };

  /**
    Handles all events added with Vent

    @private
    @memberof Vent
  */
  Vent.prototype._executeBubbleListeners = function(event) {
    var listeners = this._listenersByType[event.type];

    if (!listeners) {
      throw new Error('Vent: _executeListeners called in response to '+event.type+', but we are not listening to it');
    }

    if (listeners.length) {
      // Get a copy of the listeners
      // Without this, removing an event inside of a callback will cause errors
      listeners = listeners.slice();

      // Decorate the event object so we know when stopPropagation is called
      this._decorateEvent(event);

      /*
        Figure out if the bubble phase should be simulated

        Both focus and blur do not bubble:
          https://developer.mozilla.org/en-US/docs/Web/Events/focus
          https://developer.mozilla.org/en-US/docs/Web/Events/blur

        However, focusin, focusout, change, and other events do.
      */
      var shouldBubble = event.type !== 'focus' && event.type !== 'blur';

      // Re-use the event path as calculated during the capture phase
      var eventPath = this._getPath(event);

      // If listeners remain and propagation was not stopped, simulate the bubble phase by bubbling up the target list
      bubbleUp: for (var eventPathIndex = 0; eventPathIndex < eventPath.length; eventPathIndex++) {
        if (!listeners.length) {
          // Stop bubbling up if there are no more listeners to execute
          break bubbleUp;
        }

        var currentTargetElement = eventPath[eventPathIndex];
        this._executeListenersAtElement(currentTargetElement, listeners, event, false);

        // Stop simulating the bubble phase if a handler told us to
        if (
          event._ventImmediatePropagationStopped ||
          event._ventPropagationStopped
        ) {
          break bubbleUp;
        }

        // If the event shouldn't bubble, only simulate it on the target
        if (!shouldBubble) {
          break bubbleUp;
        }
      }
    }

    // Clean up after Vent
    this._undecorateEvent(event);

    // Clear the path
    event['_ventPath'+this._id] = null;
  };

  /**
    Override stopPropagation/stopImmediatePropagation so we know if we should stop processing events
  */
  Vent.prototype._decorateEvent = function(event) {
    event.stopPropagation = ventStopPropagation;
    event.stopImmediatePropagation = ventStopImmediatePropagation;
  };

  /**
    Restore the normal stopPropagation methods
  */
  Vent.prototype._undecorateEvent = function(event) {
    event.stopPropagation = Event.prototype.stopPropagation;
    event.stopImmediatePropagation = Event.prototype.stopImmediatePropagation;
  };

  /**
    Restore the normal stopPropagation methods
  */
  Vent.prototype._getPath = function(event) {
    if (event['_ventPath'+this._id]) {
      return event['_ventPath'+this._id];
    }

    // If the event was fired on a text node, delegation should assume the target is its parent
    var target = event.target;
    if (target.nodeType === Node.TEXT_NODE) {
      target = target.parentNode;
    }

    // Build an array of the DOM tree between the root and the element that dispatched the event
    // The HTML specification states that, if the tree is modified during dispatch, the event should bubble as it was before
    // Building this list before we dispatch allows us to simulate that behavior
    var pathEl = target;
    var eventPath = [];
    buildPath: while (pathEl && pathEl !== this.root) {
      eventPath.push(pathEl);
      pathEl = pathEl.parentNode;
    }
    eventPath.push(this.root);

    event['_ventPath'+this._id] = eventPath;

    return eventPath;
  };

  /**
    Add an event listener.
    @memberof Vent

    @param {String} eventName
      The event name to listen for, including optional namespace(s).
    @param {String} [selector]
      The selector to use for event delegation.
    @param {Function} handler
      The function that will be called when the event is fired.
    @param {Boolean} [useCapture]
      Whether or not to listen during the capturing or bubbling phase.

    @returns {Vent} this, chainable.
  */
  Vent.prototype.on = function(eventName, selector, handler, useCapture) {
    if (typeof selector === 'function') {
      useCapture = handler;
      handler = selector;
      selector = null;
    }

    if (typeof handler !== 'function') {
      throw new Error('Vent: Cannot add listener with non-function handler');
    }

    // Be null if every falsy (undefined or empty string passed)
    if (!selector) {
      selector = null;
    }


    if (typeof useCapture === 'undefined') {
      // Force useCapture for focus and blur events
      if (eventName === 'focus' || eventName === 'blur') {
        // true by default for focus and blur events only
        useCapture = true;
      }
      else {
        // false by default
        // This matches the HTML API
        useCapture = false;
      }
    }

    // Extract namespaces
    var namespaces = null;
    var dotIndex = eventName.indexOf('.');
    if (dotIndex !== -1) {
      namespaces = eventName.slice(dotIndex+1).split('.');
      eventName = eventName.slice(0, dotIndex);
    }

    // Get/create the list for the event type
    var listenerList = this._listenersByType[eventName];
    if (!listenerList) {
      listenerList = this._listenersByType[eventName] = [];

      // Add the actual listener
      this.root.addEventListener(eventName, this._executeCaptureListeners, true);
      this.root.addEventListener(eventName, this._executeBubbleListeners, false);
    }

    // Set the special ID attribute if the selector is scoped
    var listenerIsScoped = isScoped(selector);
    if (listenerIsScoped) {
      // Normalize selectors so they don't use :scope
      selector = selector.replace(scopedSelectorRegex, '>');

      // Store a unique ID and set a special attribute we'll use to scope
      this.root.setAttribute('__vent-id__', this._id);
    }

    // Create an object with the event's information
    var eventObject = {
      eventName: eventName,
      handler: handler,
      namespaces: namespaces,
      selector: selector,
      useCapture: useCapture,
      isScoped: listenerIsScoped
    };

    // Store relative to the current type and with everyone else
    listenerList.push(eventObject);
    this._allListeners.push(eventObject);
  };

  /**
    Remove an event listener.
    @memberof Vent

    @param {String} [eventName]
      The event name to stop listening for, including optional namespace(s).
    @param {String} [selector]
      The selector that was used for event delegation.
    @param {Function} [handler]
      The function that was passed to <code>on()</code>.
    @param {Boolean} [useCapture]
      Only remove listeners with <code>useCapture</code> set to the value passed in.

    @returns {Vent} this, chainable.
  */
  Vent.prototype.off = function(eventName, selector, handler, useCapture) {
    if (typeof selector === 'function') {
      useCapture = handler;
      handler = selector;
      selector = null;
    }

    // Be null if not provided
    if (typeof eventName === 'undefined') {
      eventName = null;
    }

    if (typeof selector === 'undefined') {
      selector = null;
    }

    if (typeof handler === 'undefined') {
      handler = null;
    }

    if (typeof useCapture === 'undefined') {
      useCapture = null;
    }

    // Extract namespaces
    var namespaces = null;
    if (eventName) {
      var dotIndex = eventName.indexOf('.');
      if (dotIndex !== -1) {
        namespaces = eventName.slice(dotIndex+1).split('.');
        eventName = eventName.slice(0, dotIndex);
      }
    }

    // Be null
    if (eventName === '') {
      eventName = null;
    }

    var listener;
    var index;
    var listeners = this._allListeners;
    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];

      if (
        (eventName === null || listener.eventName === eventName) &&
        (selector === null || listener.selector === selector) &&
        (handler === null || listener.handler === handler) &&
        (useCapture === null || listener.useCapture === useCapture) &&
        (
          // Remove matching listeners, regardless of namespace
          namespaces === null ||
          // Listener matches all specified namespaces
          (listener.namespaces && contains(listener.namespaces, namespaces))
        )
      ) {
        // Remove the listeners info
        this._allListeners.splice(i, 1);

        // Array length changed, so check the same index on the next iteration
        i--;

        // Get index in listenersByType map
        if (!this._listenersByType[listener.eventName]) {
          throw new Error('Vent: Missing listenersByType for '+listener.eventName);
        }

        // Find the event info in the other lookup list
        index = this._listenersByType[listener.eventName].indexOf(listener);
        if (index !== -1) {
          var mapList = this._listenersByType[listener.eventName];

          // Remove from the map
          mapList.splice(index, 1);

          // Check if we've removed all the listeners for this event type
          if (mapList.length === 0) {
            // Remove the actual listener, if necessary
            this.root.removeEventListener(listener.eventName, this._executeCaptureListeners, true);
            this.root.removeEventListener(listener.eventName, this._executeBubbleListeners, false);

            // Avoid using delete operator for performance
            this._listenersByType[listener.eventName] = null;
          }
        }
        else {
          throw new Error('Vent: Event existed in allEvents, but did not exist in listenersByType');
        }
        // Don't stop now! We want to remove all matching listeners, so continue to loop
      }
    }

    return this;
  };

  if (typeof CustomEvent === 'function') {
    // Use native CustomEvent on platforms that support it
    // Note: defaultPrevented will not be set correctly if CustomEvent is polyfilled

    /**
      Dispatch a custom event at the root element.
      @memberof Vent

      @param {String} eventName
        The name of the event to dispatch.
      @param {Object} [options]
        CustomEvent options.
      @param {Object} [options.bubbles=true]
        Whether the event should bubble.
      @param {Object} [options.cancelable=true]
        Whether the event should be cancelable.
      @param {Object} [options.detail]
        Data to pass to handlers as <code>event.detail</code>
    */
    Vent.prototype.dispatch = function(eventName, options) {
      options = options || {};

      if (typeof options.bubbles === 'undefined') {
        options.bubbles = true;
      }

      if (typeof options.cancelable === 'undefined') {
        options.cancelable = true;
      }

      var event = new CustomEvent(eventName, options);
      this.root.dispatchEvent(event);

      return event;
    };
  }
  else {
    // Use createEvent for old browsers
    Vent.prototype.dispatch = function(eventName, options) {
      options = options || {};

      if (typeof options.bubbles === 'undefined') {
        options.bubbles = true;
      }

      if (typeof options.cancelable === 'undefined') {
        options.cancelable = true;
      }

      var event = document.createEvent('CustomEvent');
      event.initCustomEvent(eventName, options.bubbles, options.cancelable, options.detail);

      // Dispatch the event, checking the return value to see if preventDefault() was called
      var defaultPrevented = !this.root.dispatchEvent(event);

      // Check if the defaultPrevented status was correctly stored back to the event object
      if (defaultPrevented !== event.defaultPrevented) {
        // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
        // However, it does return false if preventDefault() was called
        // Unfortunately, the returned event's defaultPrevented property is read-only
        // We need to work around this such that (patchedEvent instanceof Event) === true
        // First, we'll create an object that uses the event as its prototype
        // This gives us an object we can modify that is still technically an instanceof Event
        var patchedEvent = Object.create(event);

        // Next, we set the correct value for defaultPrevented on the new object
        // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
        // For some reason, defineProperty doesn't cause this
        Object.defineProperty(patchedEvent, 'defaultPrevented', { value: defaultPrevented });

        return patchedEvent;
      }

      return event;
    };
  }

  /**
    Destroy this instance, removing all events and references.
    @memberof Vent
  */
  Vent.prototype.destroy = function() {
    if (this.destroyed) {
      // Instance is already destroyed, do nothing
      return;
    }

    // Remove all events
    this.off();

    // Remove all references
    this._listenersByType = null;
    this._allListeners = null;
    this.root = null;
    this.destroyed = true;
  };

  // Expose globally
  global.Vent = Vent;
}(window));

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/* global Vent: true */
/**
  The main Coral namespace.
  @namespace
*/
var Coral = window.Coral = window.Coral || {};
Coral.strings = Coral.strings || {};
Coral.strings['generic'] = Coral.strings['generic'] || {};
Coral.events = new Vent(window);

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/**
  The Coral utility belt.
  @namespace
*/
Coral.commons = Coral.commons || {};

/**
  Copy the properties from all provided objects into the first object.

  @param {Object} dest
    The object to copy properties to
  @param {...Object} source
    An object to copy properties from. Additional objects can be passed as subsequent arguments.

  @returns {Object}
    The destination object, <code>dest</code>

  @memberof Coral.commons
  @static
*/
Coral.commons.extend = function() {
  'use strict';
  var dest = arguments[0];
  for (var i = 1, ni = arguments.length; i < ni; i++) {
    var source = arguments[i];
    for (var prop in source) {
      dest[prop] = source[prop];
    }
  }
  return dest;
};

/**
  Copy the properties from the source object to the destination object, but calls the callback if the property is
  already present on the destination object.

  @param {Object} dest
    The object to copy properties to
  @param {...Object} source
    An object to copy properties from. Additional objects can be passed as subsequent arguments.
  @param {Coral.commons~handleCollision} [handleCollision]
    Called if the property being copied is already present on the destination.
    The return value will be used as the property value.

  @returns {Object}
    The destination object, <code>dest</code>

  @memberof Coral.commons
  @static
*/
Coral.commons.augment = function() {
  'use strict';
  var dest = arguments[0];
  var handleCollision;
  var argCount = arguments.length;
  var lastArg = arguments[argCount - 1];

  if (typeof lastArg === 'function') {
    handleCollision = lastArg;

    // Don't attempt to augment using the last argument
    argCount--;
  }

  for (var i = 1; i < argCount; i++) {
    var source = arguments[i];

    for (var prop in source) {
      if (typeof dest[prop] !== 'undefined') {
        if (typeof handleCollision === 'function') {
          // Call the handleCollision callback if the property is already present
          var ret = handleCollision(dest[prop], source[prop], prop, dest, source);
          if (typeof ret !== 'undefined') {
            dest[prop] = ret;
          }
        }
      // Otherwise, do nothing
      }
      else {
        dest[prop] = source[prop];
      }
    }
  }

  return dest;
};

/**
  Called when a property already exists on the destination object.

  @callback Coral.commons~handleCollision

  @param {*} oldValue
    The value currently present on the destination object.
  @param {*} newValue
    The value on the destination object.
  @param {*} prop
    The property that collided.
  @param {*} dest
    The destination object.
  @param {*} source
    The source object.

  @returns {*} The value to use. If <code>undefined</code>, the old value will be used.
*/

/**
  Return a new object with the swapped keys and values of the provided object.

  @param {Object} obj
    The object to copy.

  @returns {Object}
    An object with its keys as the values and values as the keys of the source object.

  @memberof Coral.commons
  @static
*/
Coral.commons.swapKeysAndValues = function(obj) {
  'use strict';

  var map = {};
  for (var key in obj) {
    map[obj[key]] = key;
  }
  return map;
};

/**
  Execute the provided callback on the next animation frame.
  @function
  @param {Function} callback
    The callback to execute.
*/
Coral.commons.nextFrame = (window.requestAnimationFrame || window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame || window.msRequestAnimationFrame ||
  function(callback) {'use strict'; return window.setTimeout(callback, 1000 / 60); }).bind(window);

(function() {
  'use strict';

  // Threshold time in milliseconds that the setTimeout will wait for the transitionEnd event to be triggered.
  var TRANSITION_DURATION_THRESHOLD = 100;

  /**
    Converts CSS time to milliseconds. It supports both s and ms units. If the provided value has an unrecogenized unit,
    zero will be returned.

    @param {String} time
      The time string to convert to milliseconds.

    @returns {Number} the time in milliseconds.
  */
  function cssTimeToMilliseconds(time) {
    var num = parseFloat(time, 10);
    var unit = time.match(/m?s/);

    if (unit) {
      unit = unit[0];
    }

    if (unit === 's') {
      return num * 1000;
    }
    else if (unit === 'ms') {
      return num;
    }

    // unrecognized unit, so we return 0
    return 0;
  }

  /**
    Execute the callback once a CSS transition has ended.

    @callback Coral.commons~transitionEndCallback
    @param event
      The event passed to the callback.
    @param {HTMLElement} event.target
      The DOM element that was affected by the CSS transition.
    @param {Boolean} event.cssTransitionSupported
      Whether CSS transitions are supported by the browser.
    @param {Boolean} event.transitionStoppedByTimeout
      Whether the CSS transition has been ended by a timeout (should only happen as a fallback).
   */
  /**
    Execute the provided callback once a CSS transition has ended. This method listens for the next transitionEnd event
    on the given DOM element. In case the provided element does not have a transition defined, the callback will be
    called in the next macrotask to allow a normal application execution flow. It cannot be used to listen continuously
    on transitionEnd events.

    @param {HTMLElement} element
      The DOM element that is affected by the CSS transition.
    @param {Coral.commons~transitionEndCallback} callback
      The callback to execute.
   */
  Coral.commons.transitionEnd = function(element, callback) {
    var propertyName;
    var hasTransitionEnded = false;
    var transitionEndEventName = null;
    var transitions = {
      'transition': 'transitionend',
      'WebkitTransition': 'webkitTransitionEnd',
      'MozTransition': 'transitionend',
      'MSTransition': 'msTransitionEnd'
    };

    var transitionEndTimeout = null;
    var onTransitionEnd = function(event) {
      var transitionStoppedByTimeout = (typeof event === 'undefined');

      if (!hasTransitionEnded) {
        hasTransitionEnded = true;

        clearTimeout(transitionEndTimeout);

        // Remove event listener (if any was used by the current browser)
        element.removeEventListener(transitionEndEventName, onTransitionEnd);

        // Call callback with specified element
        callback({
          target: element,
          cssTransitionSupported: true,
          transitionStoppedByTimeout: transitionStoppedByTimeout
        });
      }
    };

    // Find transitionEnd event name used by browser
    for (propertyName in transitions) {
      if (element.style[propertyName] !== undefined) {
        transitionEndEventName = transitions[propertyName];
        break;
      }
    }

    if (transitionEndEventName !== null) {
      var timeoutDelay = 0;
      // Gets the animation time (in milliseconds) using the computed style
      var transitionDuration = cssTimeToMilliseconds(window.getComputedStyle(element).transitionDuration);

      // We only setup the event listener if there is a valid transition
      if (transitionDuration !== 0) {
        // Register on transitionEnd event
        element.addEventListener(transitionEndEventName, onTransitionEnd);

        // As a fallback we use the transitionDuration plus a threshold. This can happen in IE10/11 where
        // transitionEnd events are sometimes skipped
        timeoutDelay = transitionDuration + TRANSITION_DURATION_THRESHOLD;
      }

      // Fallback in case the event does not trigger (IE10/11) or if the element does not have a valid transition
      transitionEndTimeout = setTimeout(onTransitionEnd, timeoutDelay);
    }
  };
}());

/**
  Execute the provided callback when all web components are ready.

  @param {HTMLElement} parent
    The element to check readiness of
  @param {Function} callback
    The callback to execute.
*/
(function() {
  'use strict';

  // Array used to tracked pending inits while waiting for the WebComponentsReady event.
  var initQueue = [];

  // Track whether web components are ready
  var webComponentsReady = false;

  window.addEventListener('WebComponentsReady', function handleWebComponentsReady() {
    webComponentsReady = true;

    var entry;
    for (var i = 0, initQueueCount = initQueue.length; i < initQueueCount; i++) {
      entry = initQueue[i];
      initElement(entry.element, entry.callback);
    }

    // we make sure no items are referenced
    initQueue.splice(0, initQueueCount);

    window.removeEventListener('WebComponentsReady', handleWebComponentsReady);
  });

  /**
    Forces the given element to be upgraded and then calls the callback.

    @param {HTMLElement} element
      The element to initialize.
    @param {Function} callback
      The callback to execute once it is initialized.
  */
  function initElement(element, callback) {
    // Throws if undefined on browsers that do not support CEv0 OOTB
    if (element) {
      window.CustomElements.upgradeAll(element);
    }

    // As the createdCallbacks of inner web components are not called synchronously by CustomElements.upgradeAll(...) we
    // have to wait until all createdCallbacks of sub components have been called. see test: it('should be possible to
    // check child components using Coral.commons.ready() method inside of _initialize() method', ...)
    Coral.commons.nextFrame(function(){
      callback(element);
    });
  }

  /**
    Execute the callback once a component and sub-components are [ready]{@link Coral.commons.ready}.

    @callback Coral.commons~readyCallback
    @param {HTMLElement} element
      The element that is ready.
  */

  /**
    Checks, if a Coral components and all nested components are ready, which means their
    <code>_initialize</code> and <code>_render</code> methods have been called. If so, the provided callback function is executed

    @param {HTMLElement} element
      The element that should be watched for ready events.
    @param {Coral.commons~readyCallback} callback
      The callback to call when all components are ready.
  */
  Coral.commons.ready = function(element, callback) {
    if (typeof element === 'function') {
      callback = element;
      element = window;
    }

    // if the webcomponents are ready we call the callback immediatelly
    if (webComponentsReady) {
      initElement(element, callback);
    }
    // otherwise we queue the rest to make sure that the WebComponentsReady has been triggered
    else {
      initQueue.push({
        element: element,
        callback: callback
      });
    }
  };
}());

/**
  Assign an object given a nested path

  @param {Object} root
    The root object on which the path should be traversed.
  @param {String} path
    The path at which the object should be assignment.
  @param {String} obj
    The object to assign at path.

  @throws Will throw an error if the path is not present on the object.
*/
Coral.commons.setSubProperty = function(root, path, obj) {
  'use strict';

  var nsParts = path.split('.');
  var curObj = root;

  if (nsParts.length === 1) {
    // Assign immediately
    curObj[path] = obj;
    return;
  }

  // Make sure we can assign at the requested location
  while (nsParts.length > 1) {
    var part = nsParts.shift();
    if (curObj[part]) {
      curObj = curObj[part];
    }
    else {
      throw new Error('Coral.commons.setSubProperty: could not set ' + path + ', part ' + part + ' not found');
    }
  }

  // Do the actual assignment
  curObj[nsParts.shift()] = obj;
};

/**
  Get the value of the property at the given nested path.

  @param {Object} root
    The root object on which the path should be traversed.
  @param {String} path
    The path of the sub-property to return.

  @returns {*}
    The value of the provided property.

  @throws Will throw an error if the path is not present on the object.
*/
Coral.commons.getSubProperty = function(root, path) {
  'use strict';

  var nsParts = path.split('.');
  var curObj = root;

  if (nsParts.length === 1) {
    // Return property immediately
    return curObj[path];
  }

  // Make sure we can assign at the requested location
  while (nsParts.length) {
    var part = nsParts.shift();
    // The property might be undefined, and that's OK if it's the last part
    if (nsParts.length === 0 || typeof curObj[part] !== 'undefined') {
      curObj = curObj[part];
    }
    else {
      throw new Error('Coral.commons.getSubProperty: could not get ' + path + ', part ' + part + ' not found');
    }
  }

  return curObj;
};

(function() {
  /* jshint validthis: true */
  'use strict';

  /**
    Apply a mixin to the given object.

    @param {Object}
      The object to apply the mixin to.
    @param {Object|Function} mixin
      The mixin to apply.
    @param {Object} options
      An objcet to pass to functional mixins.

    @ignore
  */
  function applyMixin(target, mixin, options) {
    var mixinType = typeof mixin;

    if (mixinType === 'function') {
      mixin(target, options);
    }
    else if (mixinType === 'object' && mixin !== null) {
      Coral.commons.extend(target, mixin);
    }
    else {
      throw new Error('Coral.commons.mixin: Cannot mix in ' + mixinType + ' to ' + target.toString());
    }
  }

  /**
    Mix a set of mixins to a target object.

    @param {Object} target
      The target prototype or instance on which to apply mixins.
    @param {Object|Coral~mixin|Array<Object|Coral~mixin>} mixins
      A mixin or set of mixins to apply.
    @param {Object} options
      An object that will be passed to functional mixins as the second argument (options).
  */
  Coral.commons.mixin = function(target, mixins, options) {
    if (Array.isArray(mixins)) {
      for (var i = 0; i < mixins.length; i++) {
        applyMixin(target, mixins[i], options);
      }
    }
    else {
      applyMixin(target, mixins, options);
    }
  };

  /**
    A functional mixin.

    @callback Coral~mixin

    @param {Object} target
      The target prototype or instance to apply the mixin to.
    @param {Object} options
      Options for this mixin.
    @param {Coral~PropertyDescriptor.properties} options.properties
      The properties object as passed to {@link Coral.register}. This can be modified in place.
  */
}());

(function() {
  'use strict';

  var nextID = 0;

  /**
    Get a unique ID.

    @memberof Coral.commons
    @static
    @returns {String} unique identifier.
  */
  Coral.commons.getUID = function() {
    return 'coral-id-' + (nextID++);
  };
}());

(function() {
  'use strict';

  function noop() {
  }

  function returnFirst(first, second) {
    return function returnFirst() {
      var ret = first.apply(this, arguments);
      second.apply(this, arguments);
      return ret;
    };
  }

  /**
    Check if the provided object is a function

    @ignore

    @param {*} object
      The object to test

    @returns {Boolean} Whether the provided object is a function.
  */
  function isFunction(object) {
    return typeof object === 'function';
  }

  /**
    Call all of the provided functions, in order, returning the return value of the specified function.

    @param {...Function} func
      A function to call
    @param {Number} [nth=0]
      A zero-based index indicating the noth argument to return the value of.
      If the nth argument is not a function, <code>null</code> will be returned.

    @returns {Function} The aggregate function.
  */
  Coral.commons.callAll = function() {
    var nth = arguments[arguments.length - 1];
    if (typeof nth !== 'number') {
      nth = 0;
    }

    // Get the function whose value we should return
    var funcToReturn = arguments[nth];

    // Only use arguments that are functions
    var functions = Array.prototype.filter.call(arguments, isFunction);

    if (functions.length === 2 && nth === 0) {
      // Most common usecase: two valid functions passed
      return returnFirst(functions[0], functions[1]);
    }
    else if (functions.length === 1) {
      // Common usecase: one valid function passed
      return functions[0];
    }
    else if (functions.length === 0) {
      // Fail case: no valid functions passed
      return noop;
    }

    if (typeof funcToReturn !== 'function') {
      // If the argument at the provided index wasn't a function, just return the value of the first valid function
      funcToReturn = functions[0];
    }

    return function() {
      var finalRet;
      var ret;
      var func;

      // Skip first arg
      for (var i = 0; i < functions.length; i++) {
        func = functions[i];
        ret = func.apply(this, arguments);

        // Store return value of desired function
        if (func === funcToReturn) {
          finalRet = ret;
        }
      }
      return finalRet;
    };
  };
}());

(function() {
  'use strict';

  // Adaptation of http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/
  function ResizeEventTrigger() {
    // User agent toggles
    var isIE = navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/Edge/);
    this.useNativeResizeSupport = document.attachEvent && !isIE;
  }

  var resizeListenerObject;
  function getResizeListenerObject() {
    if (!resizeListenerObject) {
      resizeListenerObject = Coral.templates.commons.resizeListener.call();
    }
    return resizeListenerObject.cloneNode(true);
  }

  ResizeEventTrigger.prototype._addTriggerElement = function(element, listenerFunction) {
    if (getComputedStyle(element).position === 'static') {
      element.style.position = 'relative';
    }

    var obj = getResizeListenerObject();
    element._resizeTriggerElement = obj;

    obj.onload = function(e) {
      var contentDocument = this.contentDocument;
      var defaultView = contentDocument.defaultView;
      var documentElement = contentDocument.documentElement;

      defaultView._originalElement = element;
      defaultView._listenerFunction = listenerFunction;
      defaultView.addEventListener('resize', listenerFunction);

      // CUI-6523 Set lang and document title to avoid automated accessibility testing failures.
      documentElement.lang = 'en';
      contentDocument.title = '\u200b';

      // Call one initial resize for all browsers
      // Required, as in WebKit this callback adding the event listeners is called too late. Layout has already finished.
      listenerFunction({
        target: defaultView
      });
    };

    obj.type = 'text/html';

    // InternetExplorer is picky about the order of "obj.data = ..." and element.appendChild(obj) so make sure to get it right
    element.appendChild(obj);
    obj.data = 'about:blank';
  };

  ResizeEventTrigger.prototype._removeTriggerElement = function(element) {
    if (!element._resizeTriggerElement) {
      return;
    }

    var triggerElement = element._resizeTriggerElement;

    // processObjectLoadedEvent might never have been called
    if (triggerElement.contentDocument && triggerElement.contentDocument.defaultView) {
      triggerElement.contentDocument.defaultView.removeEventListener('resize', triggerElement.contentDocument.defaultView._listenerFunction);
    }

    element._resizeTriggerElement = !element.removeChild(element._resizeTriggerElement);
  };

  ResizeEventTrigger.prototype._fireResizeListeners = function(event) {
    var targetElement = event.target || event.srcElement;

    var trigger = targetElement._originalElement || targetElement;
    trigger._resizeListeners.forEach(function(fn) {
      fn.call(trigger, event);
    });
  };

  /**
    Adds a resize listener to the given element.

    @param {HTMLElement} element
      The element to add the resize event to.
    @param {Function} callback
      The resize callback.
  */
  ResizeEventTrigger.prototype.addResizeListener = function(element, callback) {
    if (!element) {
      return;
    }

    if (this.useNativeResizeSupport) {
      element.addEventListener('resize', callback);
      return;
    }

    // The array may still exist, so we check its length too
    if (!element._resizeListeners || element._resizeListeners.length === 0) {
      element._resizeListeners = [];
      this._addTriggerElement(element, this._fireResizeListeners.bind(this));
    }

    element._resizeListeners.push(callback);
  };

  /**
    Removes a resize listener from the given element.

    @param {HTMLElement} element
      The element to remove the resize event from.
    @param {Function} callback
      The resize callback.
  */
  ResizeEventTrigger.prototype.removeResizeListener = function(element, callback) {
    if (!element) {
      return;
    }

    if (this.useNativeResizeSupport) {
      element.removeEventListener('resize', callback);
      return;
    }

    // resizeListeners and resizeTrigger must be present
    if (!element._resizeListeners || !element._resizeTriggerElement) {
      return;
    }

    var fnIndex = element._resizeListeners.indexOf(callback);

    // Don't remove the function unless it is already registered
    if (fnIndex === -1) {
      return;
    }

    element._resizeListeners.splice(fnIndex, 1);

    if (!element._resizeListeners.length) {
      this._removeTriggerElement(element);
    }
  };

  /**
    Bind static methods
  */
  var resizeEvent = new ResizeEventTrigger();
  Coral.commons.addResizeListener = resizeEvent.addResizeListener.bind(resizeEvent);
  Coral.commons.removeResizeListener = resizeEvent.removeResizeListener.bind(resizeEvent);
}());

(function() {
  'use strict';

  var focusableElements = [
    'input:not([disabled])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'button:not([disabled])',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]'
  ];

  /**
    Focusable elements are defined by https://www.w3.org/TR/html5/editing.html#focus-management.
    Caution: the selector doesn't verify if elements are visible.

    @const
    @type {String}

    @memberof Coral.commons
    @static
  */
  Coral.commons.FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(',');

  focusableElements.push('[tabindex]:not([tabindex="-1"])');

  /**
    Tabbable elements are defined by https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute.
    Caution: the selector doesn't verify if elements are visible.

    @const
    @type {String}

    @memberof Coral.commons
    @static
  */
  Coral.commons.TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([tabindex="-1"]),');
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/**
  Property value transform functions.
  @namespace
*/
Coral.transform = {};

/**
  Transform the provided value into a boolean. Follows the behavior of JavaScript thruty/falsy.

  @param {*} value
    The value to convert to Boolean.

  @returns {Boolean} The corresponding boolean value.
*/
Coral.transform.boolean = function(value) {
  'use strict';
  return !!value;
};

/**
  Transform the provided value into a boolean. Follows the behavior of the HTML specification, in which the existence of
  the attribute indicates <code>true</code> regardless of the attribute's value.

  @param {*} value
    The value to convert to Boolean.

  @returns {Boolean} The corresponding boolean value.
*/
Coral.transform.booleanAttr = function(value) {
  'use strict';
  return !(value === null || typeof value === 'undefined');
};

/**
  Transforms the provided value into a floating point number.

  @param {*} value
    The value to convert to a Number.

  @returns {?Number} The corresponding number or <code>null</code> if the passed value cannot be converted to a number.
*/
Coral.transform.number = function(value) {
  'use strict';

  value = parseFloat(value);
  return isNaN(value) ? null : value;
};


/**
  Transforms the provided value into a floating number. The conversion is strict in the sense that if non numeric values
  are detected, <code>null</code> is returned instead.

  @param {*} value
    The value to be converted to a Number.

  @retuns {?Number} The corresponding number or <code>null</code> if the passed value cannot be converted to number.
*/
Coral.transform.float = function(value) {
  'use strict';

  if (/^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value)) {
    return Number(value);
  }

  return null;
};

/**
  Transform the provided value into a string. When given <code>null</code> or <code>undefined</code> it will be
  converted to an empty string("").

  @param {*} value
    The value to convert to String.

  @returns {String} The corresponding string value.
*/
Coral.transform.string = function(value) {
  'use strict';
  if (value === null || typeof value === 'undefined') {
    return '';
  }
  return typeof value === 'string' ? value : String(value);
};

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/**
  Property value validators
  @namespace
*/
Coral.validate = {};

/**
  Signature of the function used to validate new input. It accepts a newValue and an oldValue which are used to
  determine if the newValue is valid.

  @callback Coral.validate~validationFunction

  @param {*} newValue
    The new value to validate.
  @param {*} oldValue
    The existing value.

  @returns {Boolean} <code>true</code> if the validation succeeded, otherwise <code>false</code>.
*/

/**
  Ensures that the value has changed.

  @param {*} newValue
    The new value.
  @param {*} oldValue
    The existing value.

  @returns {Boolean} <code>true</code> if the values are different.
*/
Coral.validate.valueMustChange = function(newValue, oldValue) {
  'use strict';

  // We can use exact equality here as validation functions are called after transform. Thus, the input value will be
  // converted to the same type as a stored value
  return newValue !== oldValue;
};

/**
  Ensures that the new value is within the enumeration. The enumeration can be given as an array of values or as a
  key/value Object. Take into consideration that enumerations are case sensitive.

  @example // Enumeration as Array
Coral.validate.enumeration(['xs', 's', 'm', 'l']);
  @example // Enumeration as Object
Coral.validate.enumeration({EXTRA_SMALL : 'xs', SMALL : 's', MEDIUM : 'm', LARGE : 'l'});
  @param {Object} enumeration
    Object that represents an enum.

  @returns {Coral.validate~validationFunction}
    a validation function that ensures that the given value is within the enumeration.
*/
Coral.validate.enumeration = function(enumeration) {
  'use strict';

  // Reverses the enumeration, so that we can check that the variable new value exists inside
  var enumReversed = Coral.commons.swapKeysAndValues(enumeration);

  // Returns a new function that matches the newValue, oldValue signature
  return function(newValue, oldValue) {
    return typeof enumReversed[newValue] !== 'undefined';
  };
};

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/**
  Property descriptor factory factories
  @namespace
*/
Coral.property = {};

/**
  A factory that creates descriptor factories that proxy a local property/attribute to a sub-property.
  This factory should be used when you need the property of an sub-object to be set or queued for sync when a local
  property changes.
  This is especially useful for setting the innerHTML or other properties of sub-elements.

  @param {Coral~PropertyDescriptor} descriptor
    The property descriptor
  @param {String} path
    The path under <code>this</code> to proxy to. For instance, <code>_elements.header.innerHTML</code> would proxy
    to the <code>innerHTML</code> of the element with the handle <code>header</code>
  @param {Boolean} [needsDOMSync=false]
    Whether the property set should happen asynchronously on the next animation frame.

  @returns {Function} The descriptor factory.
*/
Coral.property.proxy = function(descriptor) {
  'use strict';

  // Store the path
  var path = descriptor.path;

  function setProxy(value, silent) {
    /* jshint validthis: true */
    Coral.commons.setSubProperty(this, path, value);
  }

  function getProxy() {
    /* jshint validthis: true */
    return Coral.commons.getSubProperty(this, path);
  }

  var functionalDescriptor = function(proto, propName) {
    var tempPropName = '_' + propName;

    if (descriptor.needsDOMSync) {
      // If a sync needs to happen, define a method
      descriptor.sync = function() {
        Coral.commons.setSubProperty(this, path, this[tempPropName]);

        // Use undefined here, not null
        this[tempPropName] = undefined;
      };

      descriptor.set = function(value, silent) {
        this[tempPropName] = value;
      };

      descriptor.get = function() {
        // Return the temporary variable if it's set, otherwise get the property we're proxying
        return typeof this[tempPropName] === 'undefined' ?
          Coral.commons.getSubProperty(this, path) : this[tempPropName];
      };
    }
    else {
      // If we don't need to sync, simply delegate to the property
      // @todo test if it's faster to compose a function with new Function()
      descriptor.set = setProxy;
      descriptor.get = getProxy;
      descriptor.sync = null;
    }

    return descriptor;
  };

  // Override by default
  // Store this on the function so Coral.register can check it
  functionalDescriptor.override = typeof descriptor.override !== 'undefined' ? descriptor.override : true;

  // Return a function that sets up the property
  return functionalDescriptor;
};

/**
  A factory that creates descriptor factories that proxy a local property/attribute to a sub-element's attribute.

  This is useful when you want to proxy a property/attrubute to a sub-element as an attribute set/removal.
  For instance, you may want to proxy the <code>aria-labelledby</code> property of a field component to the actual
  input inside of the component for accessibility purposes.

  When using this property factory, be sure to specify a property name not implemented by the browser already.

  @param {Coral~PropertyDescriptor} descriptor
    The property descriptor.
  @param {String} descriptor.attribute
    The attribute to proxy.
  @param {String} descriptor.handle
    The handle of the element to proxy the attribute to.
*/
Coral.property.proxyAttr = function(descriptor) {
  'use strict';

  var attribute = descriptor.attribute;
  var handle = descriptor.handle;

  var functionalDescriptor = function(proto, propName) {
    return Coral.commons.extend({
      attribute: attribute,
      set: function(value) {
        // Both false and null should remove the attribute
        // This supports the behavior of Coral.transform.boolean as well as non-transformed attributes
        // Any other value, including empty string, should set it
        this._elements[handle][value === false || value === null ? 'removeAttribute' : 'setAttribute'](attribute, value);
      },
      get: function() {
        return this._elements[handle].getAttribute(attribute);
      }
    }, descriptor);
  };

  // Override by default
  // Store this on the function so Coral.register can check it
  functionalDescriptor.override = typeof descriptor.override !== 'undefined' ? descriptor.override : true;

  return functionalDescriptor;
};

/**
  A factory that creates descriptor factories for content zones.

  @param {Coral~PropertyDescriptor} descriptor
    The property descriptor.
  @param {String} descriptor.handle
    The handle of the element to proxy the attribute to.
  @param {String} [descriptor.tagName]
    The tag name to expect. If not provided, any tag will be accepted.
  @param {Function} [descriptor.set]
    Executed after the property is set.
  @param {Function} [descriptor.get]
    An alternate getter. If not provided, the element specified by the handle will be returned.
  @param {Function} [descriptor.insert]
    The method that inserts the content zone into the element.
  @param {Booelean} defaultContentZone
    Set to true if this is the default content zone that {@link Coral.Component#render} moves orphaned elements into.
*/
Coral.property.contentZone = function(descriptor) {
  'use strict';

  var handle = descriptor.handle;
  var expectedTagName = descriptor.tagName;
  var additionalSetter = descriptor.set;
  var alternateGetter = descriptor.get;
  var insert = descriptor.insert;

  var functionalDescriptor = function(proto, propName) {
    if (descriptor.defaultContentZone) {
      // Alias the setter/getter to the content zone's property
      Object.defineProperty(proto, 'defaultContentZone', {
        set: function(value) {
          this[propName] = value;
        },
        get: function() {
          return this[propName];
        }
      });
    }

    // Combine the provided descriptor with the factory's properties
    // Give precidence to the factory's properties
    return Coral.commons.extend({}, descriptor, {
      contentZone: true,
      set: function(value) {
        var oldNode;

        if (!!value) {
          if (!(value instanceof HTMLElement)) {
            throw new Error('DOMException: Failed to set the "' + propName + '" property on "' + this.toString() +
              '": The provided value is not of type "HTMLElement".');
          }

          if (expectedTagName && value.tagName.toLowerCase() !== expectedTagName) {
            throw new Error('DOMException: Failed to set the "' + propName + '" property on "' + this.toString() +
              '": The new ' + propName + ' element is of type "' + value.tagName + '". It must be a "' +
              expectedTagName.toUpperCase() + '" element.');
          }

          oldNode = this._elements[handle];

          // Replace the existing element
          if (insert) {
            // Remove old node
            if (oldNode && oldNode.parentNode) {
              oldNode.parentNode.removeChild(oldNode);
            }
            // Insert new node
            insert.call(this, value);
          }
          else {
            if (oldNode && oldNode.parentNode) {
              console.warn(this._componentName + ' does not define an insert method for content zone ' + handle + ', falling back to replace.');
              // Old way -- assume we have an old node
              this._elements[handle].parentNode.replaceChild(value, this._elements[handle]);
            }
            else {
              console.error(this._componentName + ' does not define an insert method for content zone ' + handle + ', falling back to append.');
              // Just append, which may introduce bugs, but at least doesn't crazy
              this.appendChild(value);
            }
          }
        }
        else {
          // we need to remove the content zone if it exists
          oldNode = this._elements[handle];
          if (oldNode && oldNode.parentNode) {
            oldNode.parentNode.removeChild(oldNode);
          }
        }

        // Re-assign the handle to the new element
        this._elements[handle] = value;

        // Invoke the setter
        if (typeof additionalSetter === 'function') {
          additionalSetter.call(this, value);
        }
      },
      get: alternateGetter || function() {
        return this._elements[handle];
      }
    });
  };

  return functionalDescriptor;
};

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/* global module: true, exports: true */
var Coral = window.Coral = window.Coral || {};

// CommonJS and Node.js module support
if (typeof exports !== 'undefined') {
  // Support Node.js specific `module.exports` (which can be a function)
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = Coral;
  }
  // But always support CommonJS module 1.1.1 spec, Coral is an object
  exports = Coral;
}

/**
  A property descriptor.

  @typedef {Object} Coral~PropertyDescriptor
  @property {Function} [transform=null]
    The value transformation function. Values passed to setters will be ran through this function first.
  @property {Function} [attributeTransform=transform]
    The value transformation function for attribute. The value given by <code>attributeChangedCallback</code> will be
    ran through this function first before passed to setters.
  @property {Coral.validate~validationFunction} [validate={@link Coral.validate.valueMustChange}]
    The value validation function. A validation function that takes two arguments, <code>newValue</code> and
    <code>oldValue</code>, returning true if the setter should run or false if not.
  @property {String|Function} [trigger=null]
    The name of the event to trigger after this property changes, or a {Function} to call that will trigger the event.
    The function is passed the <code>newValue</code> and <code>oldValue</code>.
  @property {String|Function} [triggerBefore=null]
    The name of the event to trigger before this property changes, a {Function} to call that will trigger the event,
    or <code>true</code> to set the name automatically. The function is passed the <code>newValue</code> and
    <code>oldValue</code> and must return the Event object for <code>preventDefault()</code> to work within handlers. If
    set to <code>true</code>, {@link Coral~PropertyDescriptor} must be a string with a colon in it, such as
    <code>coral-component:change</code>, which results in <code>coral-component:beforechange</code>. If set to
    <code>false</code>, no event will be triggered before the setter is ran.
  @property {String} [attribute=propName]
    The name of the attribute corresponding to this property. If not provided, the property name itself will be used.
    If <code>null</code> is provided, the property will not be set by a corresponding attribute.
  @property {Boolean} [reflectAttribute=false]
    Whether this property should be reflected as an attribute when changed. This is useful when you want to style CSS
    according to the property's existence or value.
  @property {Function} [sync=null]
    The method to be called when this property's value should be synced to the DOM.
  @property {String|Array.<String>} [alsoSync=null]
    A property or list of properties that should be synced after this property is synced.
  @property {Function} [set={@link Coral~defaultSet}]
    The setter for this property.
  @property {Function} [get={@link Coral~defaultGet}]
    The getter for this property.
  @property {Boolean} [override=false]
    Whether this property descriptor should completely override. If <code>false</code>, this descriptor will augment
    the existing descriptor. See {@link Coral.register.augmentProperties} for details.
  @property {Boolean} [contentZone=false]
    Whether this property represents a content zone. Content zones are treated differently when set() is invoked such
    that the provided value is passed to the content zone's set() method.
*/
(function() {
  'use strict';

  // These properties won't be treated as methods
  var specialProperties = {
    extend: true,
    properties: true,
    events: true,
    _elements: true,
    name: true,
    tagName: true,
    baseTagName: true,
    className: true
  };

  function noop() {
  }
  function passThrough(value) {
    return value;
  }

  /**
    Creates an array with validation functions for the given properties. If no validate is specified, then the default
    validator is used.
    @ignore
  */
  function makeValidate(descriptor) {
    if (!descriptor.validate) {
      return [Coral.validate.valueMustChange];
    }

    if (Array.isArray(descriptor.validate)) {
      return descriptor.validate;
    }

    return [descriptor.validate];
  }

  /**
    Make a attribute reflect function for the given property. If the property is not reflected, return a noop.
    @ignore
  */
  function makeReflect(propName, descriptor) {
    if (!descriptor.reflectAttribute) {
      return noop;
    }

    var attrName = descriptor.attribute || propName;

    return function doReflect(value, silent) {
      // Reflect the property
      if (value === false || value === null) {
        // Non-truthy attributes should be destroyed
        this.removeAttribute(attrName);
      }
      else {
        // Boolean true for a value just means the property should exist
        if (value === true) {
          value = '';
        }

        // Only perform the set if the attribute is of a different value
        // This avoids triggering mutation observers unnecessarily
        if (this.getAttribute(attrName) !== value) {
          this.setAttribute(attrName, value);
        }
      }
    };
  }

  /**
    Make an event trigger function for the given property. If no event should be triggered, return a noop.
    @ignore
  */
  function makeTrigger(trigger) {
    if (!trigger) {
      return noop;
    }

    if (typeof trigger === 'function') {
      return trigger;
    }

    var eventName = trigger;

    return function doTrigger(newValue, oldValue) {
      // Trigger an event that has the new and old values under detail
      return this.trigger(eventName, {
        oldValue: oldValue,
        value: newValue
      });
    };
  }

  /**
    Make a queue sync function for the given property. If nothing needs to be synced, return a noop.
    @ignore
  */
  function makeQueueSync(propName, descriptor) {
    var propList = descriptor.alsoSync;
    var sync = descriptor.sync;

    if (!sync && !propList) {
      return noop;
    }

    if (propList) {
      // Other properties in addition to ours
      if (Array.isArray(propList)) {
        propList.unshift(propName);
      }
      else {
        propList = [propName, propList];
      }
      return function doMultiSync(value) {
        // Sync the list of properties
        this._queueSync.apply(this, propList);
      };
    }

    return function doSync(value) {
      // Sync the property
      this._queueSync(propName);
    };
  }

  /**
    Create and store the methods back to the property descriptor, then store the descriptor on the prototype.
    This enables overriding descriptor parts.

    @ignore
  */
  function storeDescriptor(proto, propName, descriptor) {
    // triggerBefore can be function, boolean, or string
    var triggerBeforeValue;
    if (typeof descriptor.triggerBefore === 'function' || typeof descriptor.triggerBefore === 'string') {
      // Directly use string or function, makeTrigger will do the rest
      triggerBeforeValue = descriptor.triggerBefore;
    }
    else if (descriptor.triggerBefore === true) {
      // Automatically set name based on descriptor.trigger
      if (typeof descriptor.trigger === 'string' && descriptor.trigger.indexOf(':') !== -1) {
        triggerBeforeValue = descriptor.trigger.replace(':', ':before');
      }
      else {
        throw new Error('Coral.register: Cannot automatically set "before" event name unless descriptor.trigger ' +
          'is a string that conatins a colon');
      }
    }

    // Use provided setter, or make a setter that sets a "private" underscore-prefixed variable
    descriptor.set = descriptor.set || makeBasicSetter(propName);

    // Use provided getter, or make a getter that returns a "private" underscore-prefixed variable
    descriptor.get = descriptor.get || makeBasicGetter(propName);

    // Store methods
    var inheritedMethods = descriptor._methods;
    descriptor._methods = {};

    // store references to inherited methods in descriptor._methods
    if (inheritedMethods) {
      for (var methodName in inheritedMethods) {
        descriptor._methods[methodName] = inheritedMethods[methodName];
      }
    }

    descriptor._methods.triggerBefore = makeTrigger(triggerBeforeValue);
    descriptor._methods.trigger = makeTrigger(descriptor.trigger);
    descriptor._methods.transform = descriptor.transform || passThrough;
    descriptor._methods.attributeTransform = descriptor.attributeTransform || passThrough;
    descriptor._methods.reflectAttribute = makeReflect(propName, descriptor);
    descriptor._methods.queueSync = makeQueueSync(propName, descriptor);

    // We need to store the list of validators back on the descriptor as we modify this inside of makeValidate
    descriptor._methods.validate = makeValidate(descriptor);

    // Store reverse mapping of attribute -> property
    if (descriptor.attribute) {
      proto._attributes[descriptor.attribute] = propName;
    }
    else {
      // Remove the mapping in case it was overridden
      proto._attributes[descriptor.attribute] = null;
    }

    // Store the descriptor
    proto._properties[propName] = descriptor;
  }

  /**
    Create a generic getter.

    @param {String} propName
      The property name whose getter should be invoked.

    @ignore
  */
  function makeGetter(propName) {
    return function getter() {
      // Invoke the original getter
      return this._properties[propName].get.call(this);
    };
  }

  /**
    Create a genertic setter.

    @param {String} propName
      The name of the property.

    @alias Coral.register.makeSetter

    @returns {Function} The setter function.
  */
  function makeSetter(propName) {
    return function setter(value, silent) {
      var descriptor = this._properties[propName];
      var methods = descriptor._methods;

      // Transform the value, passing the default
      // The default value cannot be cached in the outer closure as that would prevent monkey-patching
      var newValue = methods.transform.call(this, value, this._properties[propName].default);

      // Store the old value before the setter is invoked
      var oldValue = this[propName];

      // Performs all the validations until one of them fails
      var self = this;
      var failed = methods.validate.some(function(validator) {
        return !validator.call(self, newValue, oldValue);
      });

      // If a validation failed then we return
      if (failed) {
        return;
      }

      if (!silent) {
        var event = methods.triggerBefore.call(this, newValue, oldValue);
        if (event && event.defaultPrevented) {
          // Allow calls to preventDefault() to stop events
          return;
        }
      }

      // Invoke the original setter
      descriptor.set.call(this, newValue, silent);

      // Reflect the attribute
      methods.reflectAttribute.call(this, newValue);

      // Queue property sync. Do this before trigger, in case an event listener wants to unroll the sync queue
      methods.queueSync.call(this);

      // Trigger an event
      if (!silent) {
        methods.trigger.call(this, newValue, oldValue);
      }

      // Store that this prop has been set
      // This is used during initialization when deciding whether to apply default values
      this._setProps[propName] = true;
    };
  }

  function makeBasicGetter(propName) {
    var tempVarName = '_' + propName;

    /**
      Gets the corresponding underscore prefixed "private" property by the same name.

      @function Coral~defaultGet
      @returns The prefixed property
    */
    return function getter() {
      return this[tempVarName];
    };
  }

  function makeBasicSetter(propName) {
    var tempVarName = '_' + propName;

    /**
      Sets the corresponding underscore prefixed "private" property by the same name.

      @param {*} value  The value to set
      @function Coral~defaultSet
    */
    return function setter(value) {
      this[tempVarName] = value;
    };
  }

  /**
    Define a set of {@link Coral~PropertyDescriptors} on the passed object

    @param {Object} proto
      The object to define properties on, usually a prototype.
    @param {Object.<String, Coral~PropertyDescriptor>} properties
      A map of property names to their corresponding descriptors.

    @alias Coral.register.defineProperties
  */
  function defineProperties(proto, properties) {
    // Loop over properties and define them on the prototype
    for (var propName in properties) {
      if (!properties[propName]) {
        // Skip properties that were removed to avoid redefinition
        continue;
      }
      defineProperty(proto, propName, properties[propName]);
    }
  }

  /**
    Define a single {@link Coral~PropertyDescriptors} on the passed object

    @param {Object} proto
      The object to define properties on, usually a prototype.
    @param {String} propName
      The name of the property.
    @param {Coral~PropertyDescriptor} descriptor
      A property descriptor

    @alias Coral.register.defineProperty
  */
  function defineProperty(proto, propName, descriptor) {
    // Handle mixin case
    if (typeof descriptor === 'function') {
      // Let descriptor apply itself to the prototype
      // This allows it to add methods
      // Use its return value as the actual descriptor
      descriptor = descriptor(proto, propName);

      // If nothing is returned, we're done with this property
      if (!descriptor) {
        throw new Error('Coral.register.defineProperty: Property function did not return a descriptor for ' + propName);
      }
    }

    // Store the associated methods
    storeDescriptor(proto, propName, descriptor);

    // Create the generic setters and getters for this property
    // Store them back so we can access them for silent sets
    // These do not need to be overridden as they delegate to this._properties._methods
    var actualSetter = descriptor._methods.set = makeSetter(propName);
    var actualGetter = descriptor._methods.get = makeGetter(propName);

    // Define the property
    Object.defineProperty(proto, propName, {
      // All properties are enumerable
      enumerable: true,
      // No properties are configurable
      configurable: false,
      set: actualSetter,
      get: actualGetter
    });
  }

  var tagPrototypes = {};
  /**
    Memoized getProtoTypeOf for HTML tags
    @ignore
  */
  function getPrototypeOfTag(tagName) {
    tagPrototypes[tagName] = tagPrototypes[tagName] || Object.getPrototypeOf(document.createElement(tagName));
    return tagPrototypes[tagName];
  }

  /**
    Register a Coral component, setting up inheritance, mixins, properties, and the associated custom element.

    @memberof Coral
    @static

    @param {Object} options
      Component options.
    @param {String} options.name
      Name of the constructor (i.e. 'Accordion.Item'). The constructor will be available under 'Coral' at the path
      specified by the name.
    @param {String} options.tagName
      Name of the new element (i.e 'coral-component').
    @param {String} [options.baseTagName = (none)]
      Name of the tag to extend (i.e. 'button'). This is only required when extending an existing HTML element such that
      the <code>&lt;button is="custom-element"&gt;</code> style will be used.
    @param {Object} [options.extend = Coral.Component]
      Base class of the component. When extending an existing HTML element, this should match the interface implemented
      by the tag -- that is, for <code>baseTagName: 'button'</code> you should pass
      <code>extend: HTMLButtonElement</code>.
    @param {Array.<Object|Coral~mixin>} [options.mixins]
      Mixin or {Array} of mixins to add. Mixins can be an {Object} or a {Coral~mixin}.
    @param {Object.<String, Coral~PropertyDescriptor>} [options.properties]
      A map of property names to their corresponding descriptors.
    @param {Object} [options.events]
      Map of the events and their handler.
    @param {Object} [options._elements]
      Map of elements and their locations used for caching.
  */
  Coral.register = function(options) {
    // Throw away options.extend if baseTagName provided and the prototype isn't part of Coral.Component
    if (options.extend && !options.extend.prototype._methods) {
      options.extend = Coral.Component;
    }

    // Extend Coral.Component if nothing is provided
    var extend = options.extend || Coral.Component;

    // We'll use the prototype of the argument passed constructor we're extending
    var baseComponentProto = extend.prototype;
    var actualPrototype = baseComponentProto;

    // Use passed or be an empty object so mixins can add properties to components that don't define any
    // Don't modify the passed properties object directly
    var properties = options.properties ? Coral.commons.extend({}, options.properties) : {};

    if (options.baseTagName) {
      // If we're extending a base tag, we need to use its prototype, not the Component's
      actualPrototype = getPrototypeOfTag(options.baseTagName);
    }

    // Setup the prototype chain
    var proto = Object.create(
      actualPrototype
    );

    // Store a reference to the next component's prototype in the chain
    // This allows us to crawl up the component prototype chain later
    proto._proto = baseComponentProto;

    if (options.baseTagName) {
      var protoChain = [];

      // Build the prototype chain
      var curBaseProto = baseComponentProto;
      while (curBaseProto && curBaseProto._methods) {
        protoChain.unshift(curBaseProto);
        curBaseProto = curBaseProto._proto;
      }

      // Iterate over the prototype chain and mix all the methods in
      while (curBaseProto = protoChain.shift()) {
        for (var methodName in curBaseProto._methods) {
          proto[methodName] = curBaseProto[methodName];
        }
      }

      // Note that we'll already get a flattened list of properties from _properties
      // So we don't have to do something similar there
    }

    // Create attribute -> property mappings and the property descriptor map
    // Do this before we mixin/override properties as storeDescriptor() will write back to _attributes and _properties
    proto._attributes = Coral.commons.extend({}, baseComponentProto._attributes);
    proto._properties = {};

    // Define and inherit events from parent class
    proto._events = Coral.commons.extend({}, baseComponentProto._events, options.events);

    // Define and inherit sub-elements from parent class
    proto._elements = Coral.commons.extend({}, baseComponentProto._elements, options._elements);

    // Store the name on the prototype
    // the toString method of Coral.Component uses this
    proto._componentName = options.name;

    // CSS className
    proto._className = options.className;

    // Add methods to the prototype, and store them in an object for easy access
    // We'll use this object when extending base tagnames later
    var _methods = proto._methods = {};
    for (var method in options) {
      if (!specialProperties[method]) {
        proto[method] = _methods[method] = options[method];
      }
    }

    // Add mixins to the prototype
    // Do this before combining properties to allow seemless modification of properties overridden by mixins
    if (options.mixins) {
      Coral.commons.mixin(
        proto,
        // A single Object, Function, or Array thereof
        options.mixins,
        {
          // Pass properties so functional mixins can augment them
          properties: properties
        }
      );
    }

    // Store and override property descriptors
    Coral.commons.augment(proto._properties, baseComponentProto._properties, properties, function(existingDesc, newDesc, propName) {
      // Drop properties that are not defined
      if (!newDesc) {
        return null;
      }

      // The child component (newDesc) determines whether to ignore the base component's descriptor
      if (newDesc.override === true) {
        // The new component wants to ignore the base component's descriptor
        return newDesc;
      }

      // Combine and override as necessary
      // The order of arguments seems backwards because we use this method in Coral.register.augmentProperties
      // This makes it so the existing setter is called first
      // It also makes it so the new descriptor will override other properties
      var combinedDesc = Coral.commons.augment(
        // Don't modify the existing descriptor
        {},
        newDesc,
        existingDesc,
        handleAugmentPropertyCollision
      );

      // Store the new methods and descriptor
      storeDescriptor(proto, propName, combinedDesc);

      // The property is already defined, so tell defineProperties not to define it again
      properties[propName] = undefined;

      // storeDescriptor() already stored the descriptor, but we have to return it anyway
      return combinedDesc;
    });

    // Removed properties that have been removed by inheriting components
    for (var propName in proto._properties) {
      if (!proto._properties[propName]) {
        delete proto._properties[propName];
      }
    }

    // Define properties last
    // This allows mixins to merge and modify properties
    if (options.baseTagName) {
      // Define ALL properties as we don't pick up any from the prototype
      defineProperties(proto, proto._properties);
    }
    else {
      // Define just the new properties
      defineProperties(proto, properties);
    }

    // The options to be passed to registerElement
    var registrationOptions = {
      prototype: proto
    };

    if (options.baseTagName) {
      // When a base tag is provided, we need to tell registerElement
      registrationOptions.extends = options.baseTagName;
    }

    // Register the element
    // This returns a constructor
    var Constructor = document.registerElement(options.tagName, registrationOptions);

    // Assign the constructor at the correct location within the Coral namespace
    Coral.commons.setSubProperty(Coral, options.name, Constructor);

    return Constructor;
  };

  // Expose globally
  Coral.register.defineProperties = defineProperties;
  Coral.register.defineProperty = defineProperty;

  /**
    Augment a set of property descriptors with another set.
    The <code>dest</code> property descriptors map is modified in place.
    The individual property descriptors (values of <code>dest</code>) are not modified.

    @param {Object<String,Coral~PropertyDescriptor>} dest
      The set of property descriptors to agument.
    @param {Object<String,Coral~PropertyDescriptor>} source
      The set of property descriptors to use.
    @param {Coral.commons~handleCollision} [handleCollision]
      Called if the descriptor property being copied is already present on the destination.
      The return value will be used as the property value.
      By default, if <code>sync</code> or <code>set</code> collides, both provided methods will be called.
      By default, if any other descriptor property collides, the destination's value will be used.
  */
  Coral.register.augmentProperties = function(dest, source, handleCollision) {
    Coral.commons.augment(dest, source, function(existingDesc, newDesc, propName) {
      // The mixin target (dest) determines whether to ignore the mixin's properties
      if (existingDesc.override === true) {
        // The mixin target (dest) wants to ignore the mixin's descriptor
        return existingDesc;
      }

      // Deep-augment individual property descriptor properties
      var combinedDesc = Coral.commons.augment(
        // Don't modify the existing descriptor
        {},
        existingDesc,
        newDesc,
        handleCollision || handleAugmentPropertyCollision
      );

      return combinedDesc;
    });
  };

  /**
    Default collision handler when augmenting properties
    @ignore
  */
  function handleAugmentPropertyCollision(destValue, sourceValue, descPropName) {
    switch (descPropName) {
    case 'sync':
    case 'set':
      // Use both methods
      return callBoth(sourceValue, destValue);
    default:
      // Use component's value
      return destValue;
    }
  }

  /**
    Return a function that calls both functions and ignores their return values
    @ignore
  */
  function callBoth(first, second) {
    return function() {
      first.apply(this, arguments);
      second.apply(this, arguments);
    };
  }
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/**
  Mixins for Coral components.
  @namespace
*/
Coral.mixin = Coral.mixin || {};

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';
  /* jshint -W040 */

  /**
    A map of modifier names to their corresponding keycodes.
    @ignore
  */
  /* jshint -W015 */
  var modifierCodes = {
    '⇧': 16, 'shift': 16,
    '⌥': 18, 'alt': 18, 'option': 18,
    '⌃': 17, 'ctrl': 17, 'control': 17,
    '⌘': 91, 'cmd': 91, 'command': 91, 'meta': 91
  };

  /**
    Used to check if a key is a modifier.
    @ignore
  */
  var modifierCodeMap = {
    16: true,
    17: true,
    18: true,
    91: true
  };

  /**
    A list of modifier event property names in sorted key code order. Used to add keycodes for modifiers.
    @ignore
  */
  var modifierEventPropertyNames = [
    'shiftKey',
    'ctrlKey',
    'altKey',
    'metaKey'
  ];

  /**
    A map of key codes to normalize. These are duplicate keys such as the number pad.
    @ignore
  */
  var normalizedCodes = {
    // Numpad 0-9
    '96': 48,
    '97': 49,
    '98': 50,
    '99': 51,
    '100': 52,
    '101': 53,
    '102': 54,
    '103': 55,
    '104': 56,
    '105': 57
  };

  var specialKeyCodes = {
    'backspace': 8,
    'tab': 9,
    'return': 13,
    'enter': 13,
    'pause': 19,
    'capslock': 20,
    'esc': 27,
    'escape': 27,
    'space': 32,
    'pageup': 33,
    'pagedown': 34,
    'end': 35,
    'home': 36,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40,
    'insert': 45,
    'del': 46,
    'delete': 46,
    ';': 186,
    '=': 187,
    '*': 106,
    'plus': 107,
    'minus': 189,
    '.': 190,
    'period': 190,
    '/': 191,
    'f1': 112,
    'f2': 113,
    'f3': 114,
    'f4': 115,
    'f5': 116,
    'f6': 117,
    'f7': 118,
    'f8': 119,
    'f9': 120,
    'f10': 121,
    'f11': 122,
    'f12': 123,
    'f13': 124,
    'f14': 125,
    'f15': 126,
    'f16': 127,
    'f17': 128,
    'f18': 129,
    'f19': 130,
    'numlock': 144,
    'scroll': 145,
    ',': 188,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    '\'': 222
  };

  // Match a namespaced event, such as ctrl+r.myNS
  var namespaceRE = /(.*?)(\..+)$/;
  // Match a selector that requires context
  var needsContextRE = /^[\x20\t\r\n\f]*[>+~]/;

  /**
    The set of tags to ignore hot keys when focused within for the default filter.

    @ignore
  */
  var restrictedTagNames = {
    'INPUT': true,
    'SELECT': true,
    'TEXTAREA': true
  };

  /**
    The default keycombo event filter function. Ignores key combos triggered on input, select, and textarea.

    @function Coral.Keys.filterInputs

    @param event
      The event passed

    @returns {Boolean} True, if event.target is not editable and event.target.tagname is not restricted
  */
  function filterInputs(event) {
    // Escape keycode doesn't have to be filtered
    if (event.keyCode === specialKeyCodes.escape) {
      return true;
    }
    
    var target = event.target;
    var tagName = target.tagName;
    var isContentEditable = target.isContentEditable;
    var isRestrictedTag = restrictedTagNames[tagName];
    return !isContentEditable && !isRestrictedTag;
  }

  /**
    Convert a key to its character code representation.

    @function Coral.Keys.keyToCode

    @param {String} key
      The key character that needs to be converted. If the String contains more than one character, an error will be
      produced.

    @returns {Number} The character code of the given String.
  */
  function keyToCode(key) {
    key = key.toLowerCase();

    // Map special string representations to their character code equivalent
    var code = specialKeyCodes[key] || modifierCodes[key];

    if (!code && key.length > 1) {
      throw new Error('Coral.Keys: Key ' + key + ' not recognized');
    }

    // Return the special code from the map or the char code repesenting the character
    return code || key.toUpperCase().charCodeAt(0);
  }

  /**
    Normalize duplicate codes.
    @ignore
  */
  function normalizeCode(code) {
    return normalizedCodes[code] || code;
  }

  /**
    Convert a combination of keys separated by + into the corresponding code string.
    @ignore
  */
  function keyComboToCodeString(keyCombo) {
    return keyCombo
      // Convert to string so numbers are supported
      .toString()
      .split('+')
      .map(keyToCode)
      // Sort keys for easy comparison
      .sort()
      .join('+');
  }

  /**
    Handle key combination events.

    @class Coral.Keys
    @param {*} elOrSelector
      The selector or element to listen for keyboard events on. This should be the common parent of all
      elements you wish to listen for events on.
    @param {Object} [options]
      Options for this combo handler.
    @param {Function} [options.context]
      The desired value of the <code>this</code> keyword context when executing listeners. Defaults to the element on
      which the event is listened for.
    @param {Function} [options.preventDefault=false]
      Whether to prevent the default behavior when a key combo is matched.
    @param {Function} [options.stopPropagation=false]
      Whether to stop propagation when a key combo is matched.
    @param {Function} [options.filter={@link Coral.Keys.filterInputs}]
      The filter function for keyboard events. This can be used to stop events from being triggered when they originate
      from specific elements.
  */
  function makeComboHandler(elOrSelector, options) {
    options = options || {};

    if (typeof elOrSelector === 'undefined') {
      throw new Error('Coral.Keys: Cannot create a combo handler for ' + elOrSelector);
    }

    // Cache the element object
    var el = typeof elOrSelector === 'string' ? document.querySelector(elOrSelector) : elOrSelector;

    // Use provided context
    var context = options.context;

    /**
      The filter function to use when evaluating keypresses
    */
    var filter = options.filter || filterInputs;

    /**
      Whether to prevent default
    */
    var preventDefault = options.preventDefault || false;

    /**
      Whether to stop propagation and prevent default
    */
    var stopPropagation = options.stopPropagation || false;

    /**
      A map of key code combinations to arrays of listener functions
      @ignore
    */
    var keyListeners;

    /**
      A an array of key sequences objects
      @ignore
    */
    var keySequences;

    /**
      The sorted array of currently pressed keycodes
      @ignore
    */
    var currentKeys;

    /**
      The joined string representation of currently pressed keycodes
      @ignore
    */
    var currentKeyCombo;

    /**
      The timeout that cooresponds to sequences
      @ignore
    */
    var sequenceTimeout;

    function handleKeyDown(event) {
      clearTimeout(sequenceTimeout);
      sequenceTimeout = setTimeout(resetSequence, Coral.Keys.sequenceTime);

      // Store pressed key in array
      var key = normalizeCode(event.keyCode);

      // Don't do anything when a modifier is pressed
      if (modifierCodeMap[key]) {
        return;
      }

      if (currentKeys.indexOf(key) === -1) {
        currentKeys.push(key);

        setCurrentKeyCombo(event);
      }

      executeListeners.call(this, event);

      // Workaround: keyup events are never triggered while the command key is down, so reset the list of keys
      if (event.metaKey) {
        reset();
      }

      if (!event.target.parentNode) {
        // Workaround: keyup events are never triggered if the element does not have a parent node
        reset();
      }
    }

    function setCurrentKeyCombo(event) {
      // Build string for modifiers
      var currentModifiers = [];
      for (var i = 0; i < modifierEventPropertyNames.length; i++) {
        var propName = modifierEventPropertyNames[i];

        if (event[propName]) {
          currentModifiers.push(modifierCodes[propName.slice(0, -3)]);
        }
      }

      // Store current key combo
      currentKeyCombo = currentKeys.concat(currentModifiers).sort().join('+');
    }

    function handleKeyUp(event) {
      var key = normalizeCode(event.keyCode);

      if (modifierCodeMap[key]) {
        // Workaround: keyup events are not triggered when command key is down on Mac, so if the command key is
        // released, consider all keys released
        // Test: comment this out, press K, press L, press Command, release L, release Command, then release K -- L is
        // triggered. This also prevents handlers for related key combos to be triggered
        // Test: comment this out, press Control, press Alt, press A, press S, release Alt, release S -- Control+A is
        // triggered
        reset();

        // We don't ever want to execute handlers when a modifier is released, and we can't since they don't end up in
        // currentKeys. If we weren't doing the index check below, that could result in key combo handlers for ctrl+r to
        // be triggered when someone released alt first after triggering ctrl+alt+r. In any case, return to avoid the
        // uselss extra work
        return;
      }

      // Remove key from array
      var index = currentKeys.indexOf(key);
      if (index !== -1) {
        currentKeys.splice(index, 1);

        // If too many keys are pressed, then one is removed, make sure to check for a match
        setCurrentKeyCombo(event);
        executeListeners.call(this, event, true);
      }
    }

    function processSequences() {
      var activeSequenceListeners = [];

      // Check each sequence's state
      keySequences.forEach(function(sequence) {
        if (sequence.parts[sequence.currentPart] === currentKeyCombo) {
          // If the current key combo in the sequence was pressed, increment the pointer
          sequence.currentPart++;
        }
        else {
          // Reset the sequence if a key was encountered out of sequence
          sequence.currentPart = 0;
        }

        if (sequence.currentPart === sequence.parts.length) {
          // If we've reached the end of the sequence, add it to the list of active sequences
          activeSequenceListeners.push(sequence);

          // Reset the sequence's state so it can be triggered again
          sequence.currentPart = 0;
        }
      });

      return activeSequenceListeners;
    }

    function executeListeners(event, keyup) {
      // Don't do anything if we don't have any keys pressed
      if (!currentKeyCombo) {
        return;
      }

      // Evaluate whether we should filter this keypress
      if (!filter(event)) {
        return;
      }

      var target = (event.target || event.srcElement);
      var doc = Object.prototype.toString.call(this) === '[object Window]' ? this.document : this;

      var listeners = [];

      // Execute listeners associated with the current key combination
      var comboListeners = keyListeners[currentKeyCombo];

      var sequenceListeners;
      if (!keyup) {
        // Process sequences and get listeners associated with the current sequence
        // Don't do this on keyup as this breaks sequences with modifiers
        sequenceListeners = processSequences();
      }

      if (comboListeners && comboListeners.length) {
        listeners = listeners.concat(comboListeners);
      }

      if (sequenceListeners && sequenceListeners.length) {
        listeners = listeners.concat(sequenceListeners);
      }

      if (listeners && listeners.length) {
        for (var i = 0; i < listeners.length; i++) {
          var listener = listeners[i];

          // Perform event delegation
          if (listener.selector) {
            var matches;
            var selector = '';
            
            // This allows us to match when the delegation selector includes context
            if (listener.needsContext) {
              doc.id = doc.id || Coral.commons.getUID();
              selector = '#' + doc.id + ' ';
            }
  
            matches = Array.prototype.indexOf.call(doc.querySelectorAll(selector + listener.selector), target) >= 0;
            
            // Skip if the originating element doesn't match the selector
            if (!matches) {
              continue;
            }
          }

          // Add data to event object
          if (typeof listener.data !== undefined) {
            event.data = listener.data;
          }

          // Add matchedTarget
          event.matchedTarget = target;
  
          // Add keys that triggered the event
          event.keys = listener.originalString;

          listener.listener.call(context || doc, event);
        }

        // Don't do the default thing
        if (preventDefault) {
          event.preventDefault();
        }
        if (stopPropagation) {
          event.stopPropagation();
        }
      }
    }

    /**
      Add a key combo listener.

      @function on
      @memberof Coral.Keys#
      @param {String} keyCombo
        The key combination to listen for, such as <code>'ctrl-f'</code>.
      @param {String} [selector]
        A selector to use for event delegation.
      @param {String} [data]
        Data to pass to listeners as <code>event.data</code>.
      @param {Function} listener
        The listener to execute when this key combination is pressed. Executes on keydown, or, if too many keys are
        pressed and one is released, resulting in the correct key combination, executes on keyup.

      @returns {Coral.Keys} this, chainable.
    */
    function on(keyCombo, selector, data, listener) {
      // keyCombo can be a map of keyCombos to handlers
      if (typeof keyCombo === 'object') {
        // ( keyCombo-Object, selector, data )
        if (typeof selector !== 'string') {
          // ( keyCombo-Object, data )
          // ( keyCombo-Object, null, data )
          data = data || selector;
          selector = undefined;
        }
        for (var combo in keyCombo) {
          this.on(combo, selector, data, keyCombo[combo]);
        }
        return this;
      }

      if (typeof data === 'undefined' && typeof listener === 'undefined') {
        // ( keyCombo, listener )
        listener = selector;
        data = selector = undefined;
      }
      else if (typeof listener === 'undefined') {
        if (typeof selector === 'string') {
          // ( keyCombo, selector, listener )
          listener = data;
          data = undefined;
        }
        else {
          // ( keyCombo, data, listener )
          listener = data;
          data = selector;
          selector = undefined;
        }
      }

      if (typeof listener !== 'function') {
        throw new Error('Coral.Keys: Cannot add listener of type ' + (typeof listener));
      }

      var namespace;
      var namespaceMatch = namespaceRE.exec(keyCombo);
      if (namespaceMatch) {
        keyCombo = namespaceMatch[1];
        namespace = namespaceMatch[2];
      }

      // Determine if this selector needs context when evaluating event delegation
      // A selector needs context when it includes things like >, ~, :first-child, etc
      var needsContext = selector ? needsContextRE.test(selector) : false;

      // Check if the stirng is a sequence or a keypress
      if (keyCombo.toString().indexOf('-') !== -1) {
        // It's a sequence!

        // Divide it into its parts and convert to a code string
        var sequenceParts = keySequenceStringToArray(keyCombo);

        // Store the listener and associated information in the list for this sequence
        keySequences.push({
          originalString: keyCombo,
          currentPart: 0,
          parts: sequenceParts,
          needsContext: needsContext,
          selector: selector,
          listener: listener,
          data: data,
          namespace: namespace
        });
      }
      else {
        var originalString = keyCombo.toString();
        // It's a key combo!
        keyCombo = keyComboToCodeString(keyCombo);

        var listeners = keyListeners[keyCombo] = keyListeners[keyCombo] || [];

        // Store the listener and associated information in the list for this keyCombo
        listeners.push({
          originalString: originalString,
          // Determine if this selector needs context when evaluating event delegation
          // A selector needs context when it includes things like >, ~, :first-child, etc
          needsContext: selector ? needsContextRE.test(selector) : false,
          selector: selector,
          listener: listener,
          data: data,
          namespace: namespace
        });
      }

      return this;
    }

    function keySequenceStringToArray(keyCombo) {
      return keyCombo.toString().split('-').map(keyComboToCodeString);
    }

    function offByKeyComboString(keyComboString, namespace, selector, listener) {
      var i;
      var listeners = keyListeners[keyComboString];

      if (listeners && listeners.length) {
        if (typeof selector === 'undefined' && typeof listener === 'undefined' && typeof namespace === 'undefined') {
          // Unbind all listeners for this key combo
          listeners.length = 0;
        }
        else if (typeof listener === 'undefined') {
          // Unbind all listeners of a specific selector and or namespace
          for (i = 0; i < listeners.length; i++) {
            // This comparison works because selector and namespace are undefined by default
            if (listeners[i].selector === selector && listeners[i].namespace === namespace) {
              listeners.splice(i, 1);
              i--;
            }
          }
        }
        else {
          // Unbind a specific listener, optionally on a specific selector and specific namespace
          for (i = 0; i < listeners.length; i++) {
            if (listeners[i].listener === listener &&
              listeners[i].selector === selector &&
              listeners[i].namespace === namespace) {
              listeners.splice(i, 1);
              i--;
            }
          }
        }
      }
    }

    /**
      Remove a key combo listener.

      @function off
      @memberof Coral.Keys#
      @param {String} keyCombo
        The key combination to listen for, such as <code>'ctrl-f'</code>.
      @param {String} [selector]
        A selector to use for event delegation.
      @param {Function} listener
        The listener that was passed to on.

      @returns {Coral.Keys} this, chainable.
    */
    function off(keyCombo, selector, listener) {
      if (typeof listener === 'undefined') {
        listener = selector;
        selector = undefined;
      }

      var i;
      var namespace;
      var namespaceMatch = namespaceRE.exec(keyCombo);
      if (namespaceMatch) {
        keyCombo = namespaceMatch[1];
        namespace = namespaceMatch[2];
      }

      if (keyCombo === '' && namespace !== undefined) {
        // If we have a namespace by no keyCombo, remove all events of the namespace for each key combo
        for (keyCombo in keyListeners) {
          offByKeyComboString(keyCombo, namespace, selector, listener);
        }

        // Remove sequences
        for (i = 0; i < keySequences.length; i++) {
          if (keySequences[i].namespace === namespace) {
            keySequences.splice(i, 1);
            i--;
          }
        }

        return this;
      }

      if (keyCombo.indexOf('-') !== -1) {
        // Unbind a specific key sequence listener, optionally on a specific selector and specific namespace
        for (i = 0; i < keySequences.length; i++) {
          if (
            (keyCombo === undefined || keySequences[i].originalString === keyCombo) &&
            (listener === undefined || keySequences[i].listener === listener) &&
            (selector === undefined || keySequences[i].selector === selector) &&
            (namespace === undefined || keySequences[i].namespace === namespace)
          ) {
            keySequences.splice(i, 1);
            i--;
          }
        }
      }
      else {
        keyCombo = keyComboToCodeString(keyCombo);

        offByKeyComboString(keyCombo, namespace, selector, listener);
      }

      return this;
    }

    function resetSequence() {
      clearTimeout(sequenceTimeout);
      keySequences.forEach(function(sequence) {
        // Reset each sequence
        sequence.currentPart = 0;
      });
    }

    /**
      Reset the state of this instance. This resets the currently pressed keys.

      @function reset
      @memberof Coral.Keys#

      @returns {Coral.Keys} this, chainable.
    */
    function reset() {
      // Only reset variables related to currently pressed keys
      // Don't mess with sequences
      currentKeys = [];
      currentKeyCombo = '';

      return this;
    }

    /**
      Initialize an instance created without the <code>new</code> keyword or revive a destroyed instance. This method
      will be called automatically if an instance is created with <code>new Coral.keys</code>, but otherwise will not be
      called.

      @function init
      @param {Boolean} globalsOnly
        Whether only global listeners should be added
      @memberof Coral.Keys#

      @returns {Coral.Keys} this, chainable.
    */
    function init(globalsOnly) {
      if (!globalsOnly) {
        // Reset all variable states
        currentKeys = [];
        currentKeyCombo = '';
        keyListeners = {};
        keySequences = [];
  
        el.addEventListener('keydown', handleKeyDown);
      }
      
      // Remove window event listeners first to avoid memory leak
      destroy(true);
  
      // Watching on capture so it is immune to stopPropagation(). It's very important this event
      // is handled so key entries previously added on keydown can be cleared out.
      window.addEventListener('keyup', handleKeyUp, true);
      window.addEventListener('focus', reset);

      return this;
    }

    /**
      Destroy this instance. This removes all event listeners, references, and state.

      @function destroy
      @param {Boolean} globalsOnly
        Whether only global listeners should be removed
      @memberof Coral.Keys#

      @returns {Coral.Keys} this, chainable.
    */
    function destroy(globalsOnly) {
      if (!globalsOnly) {
        keyListeners = null;
        currentKeys = null;
        currentKeyCombo = null;
  
        el.removeEventListener('keydown', handleKeyDown);
      }
  
      window.removeEventListener('keyup', handleKeyUp, true);
      window.removeEventListener('focus', reset);

      return this;
    }

    // @todo is this insane?
    if (this instanceof makeComboHandler) {
      // Initialize immediately if new keyword used
      init();
    }


    return {
      on: on,
      off: off,
      reset: reset,
      init: init,
      destroy: destroy
    };
  }

  Coral.Keys = makeComboHandler;

  Coral.Keys.filterInputs = filterInputs;

  Coral.Keys.keyToCode = keyToCode;

  /**
    The time allowed between keypresses for a sequence in miliseconds
    @type Number
    @default 1500
  */
  Coral.Keys.sequenceTime = 1500;

  /**
    A key listener for global hotkeys.

    @static
    @type Coral.keys
  */
  // Register against the documentElement, <html>, so event delegation works
  Coral.keys = new Coral.Keys(document.documentElement, {
    // Don't let global hotkeys trigger default actions
    stopPropagation: true,
    preventDefault: true
  });

}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for locale values.
    @enum {String}
    @memberof Coral.i18n
  */
  var locales = {
    /** English (U.S.) */
    'en': 'en-US',
    /** English (U.S.)*/
    'en-us': 'en-US',
    /** Czech (Czechia) */
    'cs': 'cs-CZ',
    /** Czech (Czechia) */
    'cs-cz': 'cs-CZ',
    /** Danish (Denmark)*/
    'da': 'da-DK',
    /** Danish (Denmark)*/
    'da-dk': 'da-DK',
    /** German (Germany)*/
    'de': 'de-DE',
    /** German (Germany)*/
    'de-de': 'de-DE',
    /** Spanish (Spain)*/
    'es': 'es-ES',
    /** Spanish (Spain)*/
    'es-es': 'es-ES',
    /** Finnish (Finland) */
    'fi': 'fi-FI',
    /** Finnish (Finland) */
    'fi-fi': 'fi-FI',
    /** French (France)*/
    'fr': 'fr-FR',
    /** French (France)*/
    'fr-fr': 'fr-FR',
    /** Italian (Italy)*/
    'it': 'it-IT',
    /** Italian (Italy)*/
    'it-it': 'it-IT',
    /** Japanese (Japan)*/
    'ja': 'ja-JP',
    /** Japanese (Japan)*/
    'ja-jp': 'ja-JP',
    /** Korean (Korea)*/
    'ko': 'ko-KR',
    /** Korean (Korea)*/
    'ko-kr': 'ko-KR',
    /** Norwegian Bokmål (Norway) */
    'nb': 'nb-NO',
    /** Norwegian Bokmål (Norway) */
    'nb-no': 'nb-NO',
    /** Dutch (Netherlands)*/
    'nl': 'nl-NL',
    /** Dutch (Netherlands)*/
    'nl-nl': 'nl-NL',
    /** Polish (Poland) */
    'pl': 'pl-PL',
    /** Polish (Poland) */
    'pl-pl': 'pl-PL',
    /** Portuguese (Brazil) */
    'pt': 'pt-BR',
    /** Portuguese (Brazil) */
    'pt-br': 'pt-BR',
    /** Russian (Russia) */
    'ru': 'ru-RU',
    /** Russian (Russia) */
    'ru-ru': 'ru-RU',
    /** Swedish (Sweden) */
    'sv': 'sv-SE',
    /** Swedish (Sweden) */
    'sv-se': 'sv-SE',
    /** Turkish (Turkey) */
    'tr': 'tr-TR',
    /** Turkish (Turkey) */
    'tr-tr': 'tr-TR',
    /** Simplified Chinese */
    'zh-cn': 'zh-CN',
    /** Simplified Chinese */
    'zh-hans-cn': 'zh-CN',
    /** Simplified Chinese */
    'zh-hans': 'zh-CN',
    /** Traditional Chinese */
    'zh-tw': 'zh-TW',
    /** Traditional Chinese */
    'zh-hant-tw': 'zh-TW',
    /** Traditional Chinese */
    'zh-hant': 'zh-TW'
  };

  /**
    I18n service for CoralUI.

    @class Coral.i18n
    @classdesc An I18n service to get/set localized strings.
    @param {Object} [options]
      Options for this combo handler.
    @param {String} [options.locale]
      The <code>locale</code> property defines the locale of the I18nProvider.
      @ignore
  */
  var I18nProvider = function(options) {
    options = options || {};

    if (options.locale) {
      this._locale = options.locale;
    }
  };

  I18nProvider.prototype._locale = 'en-US';

  /**
    Coral.i18n current locale value.
    @member {Coral.i18n.locales} locale
    @memberof Coral.i18n
  */
  Object.defineProperty(I18nProvider.prototype, 'locale', {
    set: function(newLocale) {
      this._locale = newLocale;
    },
    get: function() {
      return this._locale;
    }
  });

  /**
    evaluate
    @type {RegExp}
    @ignore
  */
  I18nProvider.prototype._evaluate = /(\{.+?\})/g;

  /**
    Sets a localized string.

    @function set
    @param {String} key the key to set
    @param {String} value the value associated with the given key.
    @memberof Coral.i18n
    @example
    Coral.i18n.set('English string', 'Translated string');
Coral.i18n.set('English string: {0}', 'Translated string: {0}');
Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string: {2}, {0}, and {1}');
Coral.i18n.set('English string: {name}', 'Translated string: {name}');
Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string: {name3}, {name1}, and {name2}');
  */

  /**
    Sets multiple localized strings.

    @function set
    @param {Array<String, String>} map  a key-value map to add to the strings dictionary.
    @memberof Coral.i18n
    @example
    Coral.i18n.set([
      ['English string 1', 'Translated string 1'],
      ['English string 2', 'Translated string 2'],
      ['English string 1 with {0} items','Translated string 1 with {0} items'],
      ['English string 2 with {0} items','Translated string 2 with {0} items'],
      ['English string 1: {0}, {1}, and {2}','Translated string 1: {2}, {0}, and {1}'],
      ['English string 2: {0}, {1}, and {2}','Translated string 2: {2}, {0}, and {1}'],
      ['English string 1: {name}', 'Translated string 1: {name}'],
      ['English string 2: {name}', 'Translated string 2: {name}'],
      ['English string 1: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}'],
      ['English string 2: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}']
    ]);
   */

   /**
    Sets a localized string, using translation hint.

    @function set
    @param {String} key the key to set
    @param {String} value the value associated with the given key.
    @param {String} translation_hint the translation hint associated with the given key.
    @memberof Coral.i18n
    @example
    Coral.i18n.set('English string', 'Translated string 1', 'Translation hint 1');
Coral.i18n.set('English string', 'Translated string 2', 'Translation hint 2');
Coral.i18n.set('English string with {0} items' , 'Translated string 1 with {0} items', 'Translation hint 1');
Coral.i18n.set('English string with {0} items' , 'Translated string 2 with {0} items', 'Translation hint 2');
Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string 1: {2}, {0}, and {1}', 'Translation hint 1');
Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string 2: {2}, {0}, and {1}', 'Translation hint 2');
Coral.i18n.set('English string: {name}', 'Translated string 1: {name}', 'Translation hint 1');
Coral.i18n.set('English string: {name}', 'Translated string 2: {name}', 'Translation hint 2');
Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}', 'Translation hint 1');
Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}', 'Translation hint 2');
  */

  /**
    Sets multiple localized strings, using translation hints.

    @function set
    @param {Array<String, String, String>} map  a key-value object map to add to the strings dictionary.
    @memberof Coral.i18n
    @example
    Coral.i18n.set([
      ['English string', 'Translated string 1', 'Translation hint 1'],
      ['English string', 'Translated string 2', 'Translation hint 2'],
      ['English string with {0} items', 'Translated string 1 with {0} items', 'Translation hint 1'],
      ['English string with {0} items', 'Translated string 2 with {0} items', 'Translation hint 2'],
      ['English string with {0}, {1} and {2} items', 'Translated string 1 with {0}, {1} and {2} items', 'Translation hint 1'],
      ['English string with {0}, {1} and {2} items', 'Translated string 2 with {0}, {1} and {2} items', 'Translation hint 2'],
      ['English string: {name}', 'Translated string 1: {name}', 'Translation hint 1'],
      ['English string: {name}', 'Translated string 2: {name}', 'Translation hint 2'],
      ['English string: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}', 'Translation hint 1'],
      ['English string: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}', 'Translation hint 2']
    ]);
   */

  I18nProvider.prototype.set = function() {
    Coral.strings['generic'][this._locale] = Coral.strings['generic'][this._locale] || {};

    var key, value, translationHint;
    if (arguments.length === 0) {
      // Return empty string if called without arguments
      return '';
    }
    else if (arguments.length === 1) {
      if (!arguments[0]) {
        throw new Error('Coral.i18n.set: Single argument must be an array of arrays of key/value/(translation hint).');
      }
      // multiple keys
      else if (typeof arguments[0] === 'object' && (typeof arguments[0][0] === 'object')) {
        for (var i=0; i < arguments[0].length; i++) {
          key = arguments[0][i][0];
          value = arguments[0][i][1];
          translationHint = arguments[0][i][2];

          if (translationHint) {
            key = key + '/[translation hint:' + translationHint.replace(/&period;/g, '.') + ']';
          }
          Coral.strings['generic'][this._locale][key] = value;
        }
      }
      else {
        throw new Error('Coral.i18n.set: Single argument must be an array of key-value pairs.');
      }
    }
    // single key, no translation hint
    else if (arguments.length === 2) {
      if (typeof arguments[0] === 'string' && !!arguments[0] && typeof arguments[1] === 'string' && !!arguments[1] ) {
        key = arguments[0];
        value = arguments[1];
        Coral.strings['generic'][this._locale][key] = value;
      }
      else {
        throw new Error('Coral.i18n.set: Both arguments must be non-empty string values.');
      }
    }
    // single key, with translation hint
    else if (arguments.length === 3) {
      if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string' && typeof arguments[2] === 'string') {
        key = arguments[0];
        value = arguments[1];
        translationHint = arguments[2];

        if (translationHint !== 'null') {
          key = key + '/[translation hint:' + translationHint.replace(/&period;/g, '.') + ']';
        }

        Coral.strings['generic'][this._locale][key] = value;
      }
      else {
        throw new Error('Coral.i18n.set: All arguments must be of string type.');
      }
    }
    else {
      throw new Error('Coral.i18n.set: Too many arguments provided.');
    }

    return this;
  };

  /**
    Gets a localized string, using named arguments, and translation hint.

    @function get
    @param {String} key the key of the string to retrieve
    @param {Object} args one more named arguments
    @param {String} translation_hint context information for translators
    @returns {String} the localized string with arguments
    @memberof Coral.i18n
    @example
    Coral.i18n.get('English string: {name}', { name: 'foo' }, 'Translation hint 1'); // => 'Translated string 1: foo'
Coral.i18n.get('English string: {name}', { name: 'foo' }, 'Translation hint 2'); // => 'Translated string 2: foo'
Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }, 'Translation hint 1'); // => 'Translated string 1: qux, foo, and bar'
Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }, 'Translation hint 2'); // => 'Translated string 2: qux, foo, and bar'
  */

  /**
    Gets a localized string, using arguments, and translation hint.

    @function get
    @param {String} key the key of the string to retrieve
    @param {String} args one more arguments
    @param {String} translation_hint context information for translators
    @returns {String} the localized string with arguments
    @memberof Coral.i18n
    @example
    Coral.i18n.get('English string: {0}', 10, 'Translation hint 1'); // => 'Translated string 1: 10')
Coral.i18n.get('English string: {0}', 10, 'Translation hint 2'); // => 'Translated string 2: 10')
Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30, 'Translation hint 1'); // => 'Translated string 1: 30, 10, and 20'
Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30, 'Translation hint 2'); // => 'Translated string 2: 30, 10, and 20'
  */

  /**
    Gets a localized string, using translation hint.

    @function get
    @param {String} key the key of the string to retrieve
    @param {String} translation_hint context information for translators
    @returns {String} the localized string
    @memberof Coral.i18n
    @example
    Coral.i18n.get('English string', 'Translation hint 1'); // => 'Translated string 1'
Coral.i18n.get('English string', 'Translation hint 2'); // => 'Translated string 2'
  */  

  /**
    Gets a localized string, using named arguments.

    @function get
    @param {String} key the key of the string to retrieve
    @param {Object} args one more named arguments
    @returns {String} the localized string with arguments
    @memberof Coral.i18n
    @example
    Coral.i18n.get('English string: {name}', { name: 'foo' }); // => 'Translated string: foo'
Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }); // => 'Translated string: qux, foo, and bar'
  */

  /**
    Gets a localized string, using arguments.

    @function get
    @param {String} key the key of the string to retrieve
    @param {String} args one more arguments
    @returns {String} the localized string with arguments
    @memberof Coral.i18n
    @example
    Coral.i18n.get('English string: {0}', 10); // => 'Translated string: 10'
Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30); // => 'Translated string: 30, 10, and 20'
  */
  /**
    Gets a localized string.

    @function get
    @param {String} key the key of the string to retrieve
    @returns {String} the localized string
    @memberof Coral.i18n
    @example
    Coral.i18n.get('English string'); // => 'Translated String'
  */

  I18nProvider.prototype.get = function() {
    if (arguments.length === 0) {
      // Return empty string if called without arguments
      return '';
    }

    // The first argument is always the key
    // Aladdin server stores periods in keys as HTML entities, so we need to match this
    var key = arguments[0].replace('.', '&period;');

    // The number of required variables can be determined by parsing the string
    var placeholderMatches = key.match(this._evaluate);
    var variablePlaceholderCount = placeholderMatches ? placeholderMatches.length : 0;

    // The hint we'll use to translate
    var translationHint = '';

    var variables = {};
    var variableCount = 0;
    var i;

    // Verify the number of provided arguments matches the placeholder count
    if (arguments[1] !== null && typeof arguments[1] === 'object') {
      variables = arguments[1];

      // Check if provided variables object is complete
      var placeholderName = '';
      for (i = 0; i < placeholderMatches.length; i++) {
        placeholderName = placeholderMatches[i].slice(1).slice(0, -1);
        if (variables[placeholderName] === null || typeof variables[placeholderName] === 'undefined') {
          throw new Error('Coral.i18n.get: Named key "'+placeholderName+'" not present in provided object.');
        }
      }

      // If an additional argument is present, it's the translation hint
      if (typeof arguments[2] === 'string') {
        translationHint = arguments[2];
      }
    }
    else {
      // Assume no translation hint
      variableCount = arguments.length - 1;

      if (variableCount === variablePlaceholderCount + 1) {
        // If we've got an extra argument, assume it's a translation hint
        translationHint = arguments[arguments.length - 1];
      }
      else if (variableCount !== variablePlaceholderCount) {
        throw new Error('Coral.i18n.get: Number of variable placeholders ('+variablePlaceholderCount+') does not match number of variables ('+variableCount+').');
      }

      // Build variables object
      for (i = 0; i < variableCount; i++) {
        variables[i] = arguments[i + 1];
      }
    }

    // Include translation hint
    if (translationHint) {
      key = key + '/[translation hint:' + translationHint + ']';
    }

    // Fetch the string
    var str = key;
    for (var component in Coral.strings) {
      if (typeof Coral.strings[component] !== 'undefined' &&
          typeof Coral.strings[component][this._locale] !== 'undefined') {
        str = Coral.strings[component][this._locale][key] || str;
      }
    }

    // Optimization for a string with no placeholder
    if (variablePlaceholderCount === 0) { // e.g. Coral.i18n.get('English string');
      return str;
    }

    // Replace all variables
    return str.replace(this._evaluate, function(placeholderName) {
      placeholderName = placeholderName.slice(1).slice(0, -1);
      return variables[placeholderName];
    });

    // @todo use .toLocaleString(Coral.i18n.locale) in a future release
  };

  // sets default locale, based on document lang attribute, if it exists, or en-US otherwise
  var docLang = document.documentElement.lang.toLowerCase();
  var locale = locales[docLang] || 'en-US';

  /**
    A Coral I18n service
    @namespace
  */
  Coral.i18n = new I18nProvider({ locale: locale });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/* global Vent: true */
/* jshint -W064 */
(function() {
  'use strict';

  // Used to split events by type/target
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // Enum value is referenced for speed
  var ELEMENT_NODE = Node.ELEMENT_NODE;

  /**
    Return the method corresponding to the method name or the function, if passed.

    @ignore
  */
  function getListenerFromMethodNameOrFunction(obj, eventName, methodNameOrFunction) {
    // Try to get the method
    if (typeof methodNameOrFunction === 'function') {
      return methodNameOrFunction;
    }
    else if (typeof methodNameOrFunction === 'string') {
      if (!obj[methodNameOrFunction]) {
        throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() +
          ', method ' + methodNameOrFunction + ' not found');
      }

      var listener = obj[methodNameOrFunction];

      if (typeof listener !== 'function') {
        throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() +
          ', listener is a ' + (typeof listener) + ' but should be a function');
      }

      return listener;
    }
    else if (methodNameOrFunction) {
      // If we're passed something that's truthy (like an object), but it's not a valid method name or a function, get
      // angry
      throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() + ', ' +
        methodNameOrFunction + ' is neither a method name or a function');
    }

    return null;
  }

  /**
    @class Coral.Component
    @classdesc The base element for all Coral components
    @extends HTMLElement
  */
  Coral.Component = function() {
    throw new Error('Coral.Component is not meant to be invoked directly. Inherit from its prototype instead.');
  };

  // Inherit from HTMLElement
  Coral.Component.prototype = Object.create(HTMLElement.prototype);

  // Store a reference to properties
  Coral.Component.prototype._properties = {};

  /**
    Return this component's name.

    @ignore
  */
  Coral.Component.prototype.toString = function() {
    return 'Coral.' + this._componentName;
  };

  /**
    Events map. Key is Backbone-style event description, value is string indicating method name or function. Handlers
    are always called with <code>this</code> as the element.

    @type {Object}
    @protected
  */
  Coral.Component.prototype._events = {

  };

  /**
    Called when the component is being constructed. This method applies the CSS class, renders the component, binds
    events, and sets initial property values.

    {@link Coral.Component#_initialize} is called after the above operations are complete.
    @protected
  */
  Coral.Component.prototype.createdCallback = function() {
    // We have to add toString directly on the instance or it doesn't work in IE 9
    // A side-effect of this is that toString cannot be overridden
    if (this.toString !== Coral.Component.prototype.toString) {
      this.toString = Coral.Component.prototype.toString;
    }

    // Track which properties have been set
    // This is used when setting defaults
    this._setProps = {};

    this._syncQueue = [];

    // Make sure context is correct when called by nextFrame
    this._syncDOM = this._syncDOM.bind(this);

    // Create a Vent instance to handle local events
    this._vent = new Vent(this);

    // Apply the class name
    if (this._className) {
      this.classList.add.apply(this.classList, this._className.split(' '));
    }

    // Create the elements property before the template. Templates that use handle="someName" attrs will need this
    this._elements = {};

    // Render template, if necessary
    if (typeof this._render === 'function') {
      this._render();
    }

    var prop;
    var attr;
    var value;
    var descriptor;
    var methods;

    // A hash where all the content zone names are stored using the tagName as key and property as value
    this._contentZones = {};

    // A list of attribute values indexed by property name
    // prop -> attrValue
    var attrValues = {};

    // Build a cache of attribute values provided via the markup and check for content zones
    for (prop in this._properties) {
      descriptor = this._properties[prop];

      if (descriptor.contentZone) {
        // Check if the tag name is unique
        if (this._contentZones[descriptor.tagName]) {
          console.warn('Coral.Component: content zone for "%s" is already defined', descriptor.tagName);
        }

        // Add the prop to the hash
        this._contentZones[descriptor.tagName] = prop;
      }

      // Use the attribute name specified by the map
      attr = descriptor.attribute || prop;

      // Fetch the attribute corresponding to the property from the element
      attrValues[prop] = this.getAttribute(attr);
    }

    // Apply default values for all properties and their associated attributes
    for (prop in this._properties) {
      descriptor = this._properties[prop];
      methods = descriptor._methods;

      // Get the attribute value from the cache
      value = attrValues[prop];

      if (value !== null) {
        // Since the value is loaded as an attribute, it needs to be transformed from its attribute value
        if (methods.attributeTransform) {
          value = methods.attributeTransform.call(this, value, descriptor.default);
        }

        // Run the value transform function
        if (descriptor.transform) {
          value = methods.transform.call(this, value, descriptor.default);
        }

        // Check if the value valdiates
        if (methods.validate) {
          for (var i = 0; i < methods.validate.length; i++) {
            // Don't pass the old value
            if (!methods.validate[i].call(this, value)) {
              // If it fails validation, we'll use the default
              value = null;
              break;
            }
          }
        }
      }

      if (value === null) {
        // If the property has already been set in another setter, don't apply the default
        if (this._setProps[prop]) {
          continue;
        }

        // If the default is a function we call it
        if (typeof descriptor.default === 'function') {
          // Call method if the default value is a method
          value = descriptor.default.call(this);
        }
        else {
          // Otherwise we set it from the descriptor directly
          value = descriptor.default;
        }

        // If the value that came out of the default is undefined,
        // this means that the property does not really have a default value
        // so we continue in order to avoid setting it
        if (typeof value === 'undefined') {
          continue;
        }
      }

      // Invoke the setter silently so we don't trigger "change" events on initialization
      this.set(prop, value, true);
    }

    this._delegateEvents();

    // Call the initialize method, if necessary
    if (typeof this._initialize === 'function') {
      this._initialize();
    }

    // Add MutationObserver for content zones
    if (Object.keys(this._contentZones).length) {
      // Watch for childlist modifications
      this._observer = new MutationObserver(this._handleContentZones.bind(this));
      this._observer.observe(this, {
        childList: true,
        subtree: false // don't care about nested stuff
      });
    }

    // Trigger ready event
    this._componentReady = true;
  };

  /**
    Detects when items are added and removed to make sure that the state of the content zone is accurate.

    @param {Array.<MutationRecord>} records

    @private
  */
  Coral.Component.prototype._handleContentZones = function(records) {
    var record;
    var addedNodes;
    var removedNodes;
    var node;
    var tagName;
    var propertyName;

    for (var i = 0, recordsCount = records.length; i < recordsCount; i++) {
      record = records[i];

      addedNodes = record.addedNodes;
      removedNodes = record.removedNodes;

      // Handle removed nodes
      for (var k = 0, removedNodesCount = removedNodes.length; k < removedNodesCount; k++) {
        node = removedNodes[k];

        // only bother with element nodes
        if (node.nodeType === ELEMENT_NODE) {
          tagName = node.tagName.toLowerCase();

          // we use the content zone hash to check if there is an item assigned
          propertyName = this._contentZones[tagName];

          // the content zone needs to be cleared if it matches the previous item; while calling the insert, content
          // zones are removed and added again in the correct location triggering a mutation
          if (propertyName && this[propertyName] === node && node.parentNode === null) {
            this[propertyName] = undefined;
          }
        }
      }

      // Handle added nodes
      for (var j = 0, addedNodesCount = addedNodes.length; j < addedNodesCount; j++) {
        node = addedNodes[j];

        // only bother with element nodes
        if (node.nodeType === ELEMENT_NODE) {
          tagName = node.tagName.toLowerCase();

          // check if the added node matches a content zone; use the content zone hash to find if the tag name exists
          propertyName = this._contentZones[tagName];

          // we update the content zone if the value is different than the current
          if (propertyName && this[propertyName] !== node) {
            // assign to content zone
            this[propertyName] = node;
          }
        }
      }
    }
  };

  /**
    Called after the element has been constructed, template rendered, and attributes applied.

    @function _initialize
    @protected
    @memberof Coral.Component#
  */

  /**
    The CSS class name to apply to the element.

    @type {String}
    @member _className
    @protected
    @memberof Coral.Component#
  */

  /**
    Called during construction, is responsible for rendering any required sub-elements.

    @function _render
    @protected
    @memberof Coral.Component#
  */

  /**
    The filter function for keyboard events. By default, any child element can trigger keyboard events. You can pass
    {@link Coral.Keys.filterInputs} to avoid listening to key events triggered from within inputs.

    @function _filterKeys
    @protected
    @memberof Coral.Component#
  */
  Coral.Component.prototype._filterKeys = function() {
    return true;
  };

  /**
    Called when this element is inserted into the DOM.

    @fires Coral.Component#coral-component:attached
    @private
  */
  Coral.Component.prototype.attachedCallback = function() {
    this.trigger('coral-component:attached');

    // A component that is in the DOM should respond to global events
    this._delegateGlobalEvents();
  };

  /**
    Called when this element is removed from the DOM.

    @fires Coral.Component#coral-component:detached
    @private
  */
  Coral.Component.prototype.detachedCallback = function() {
    this.trigger('coral-component:detached');

    // A component that isn't in the DOM should not be responding to global events
    this._undelegateGlobalEvents();
  };

  /**
    Apply attribute changes by invoking setters. This creates a one-way relationship between attributes and properties.
    Changing an attribute updates the property, but changing the property does not update the attribute.

    @private
  */
  Coral.Component.prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
    // Use the property name from the attribute map, otherwise just set the property by the same name
    var propName = this._attributes[attrName] || attrName;

    // Case 1: We are handling sets/gets for this property
    var descriptor = this._properties[propName];
    if (typeof descriptor !== 'undefined') {
      if (descriptor.attribute === null) {
        // Don't set properties that have explicitly asked to have no corresponding attribute
        return;
      }

      ['attributeTransform', 'transform'].forEach(function(v) {
        // Use the stored methods
        var transform = descriptor._methods[v];
        if (transform) {
          newValue = transform.call(this, newValue, descriptor.default);
        }
      }, this);

      // Don't bother with the setter unless the value changed
      if (newValue !== this[propName]) {
        // Just invoke setter
        this[propName] = newValue;
      }
    }

    // Case 2: We have a passive setter for this attribute
    if (this._properties['_' + propName]) {
      this._properties['_' + propName].set.call(this, newValue);
    }
  };

  /**
    Queue a DOM sync for the next animation frame. In order for this to work as expected, sync methods should never
    rely on the result of another value being synced.

    @protected
  */
  Coral.Component.prototype._queueSync = function() {
    for (var i = 0, ni = arguments.length; i < ni; i++) {
      var propName = arguments[i];

      // Check if a sync is already queued
      var currentIndex = this._syncQueue.indexOf(propName);
      if (currentIndex !== -1) {
        // Move to the bottom of the queue.
        // This is necessary if a sync has already been queued for a property,
        // but another property sync is queued and specifies that this sync should come later.
        // This happens when Button.text is synced, as it wants to sync icon afterwards
        this._syncQueue.splice(currentIndex, 1);
      }

      // Queue the sync
      this._syncQueue.push(propName);
    }

    if (!this._syncPending) {
      Coral.commons.nextFrame(this._syncDOM);
      this._syncPending = true;
    }
  };

  /**
    Sync the specified property to the DOM.

    @param {String} propName
      The name of the property to sync.
    @param {Boolean} [leaveInQueue=false]
      Whether the property should be left in the queue.

    @protected
  */
  Coral.Component.prototype._syncProp = function(propName, leaveInQueue) {
    // De-queue each sync operation
    var method = this._properties[propName].sync;
    if (method) {
      method.call(this);
    }
    else {
      console.warn('Coral.Component: sync method for %s is not defined', propName);
    }

    if (!leaveInQueue) {
      var index = this._syncQueue.indexOf(propName);
      if (index !== -1) {
        this._syncQueue.splice(index, 1);
      }
    }
  };

  /**
    Sync all changed properties to the DOM.

    @protected
  */
  Coral.Component.prototype._syncDOM = function() {
    var propName;

    // De-queue each sync operation
    while (propName = this._syncQueue.shift()) {
      // Sync the property, and avoid removing it because we already have
      this._syncProp(propName, true);
    }

    this._syncPending = false;
  };

  /**
    Add local event and key combo listeners for this component, store global event/key combo listeners for later.

    @private

    @returns {Coral.Component} this, chainable.
  */
  Coral.Component.prototype._delegateEvents = function() {
    /*
      Add listeners to new event
        - Include in hash
      Add listeners to existing event
        - Override method and use super
      Remove existing event
        - Pass null
    */
    var match;
    var eventName;
    var eventInfo;
    var listener;
    var selector;
    var elements;
    var isGlobal;
    var isKey;
    var isResize;
    var isCapture;

    for (eventInfo in this._events) {
      listener = this._events[eventInfo];

      // Extract the event name and the selector
      match = eventInfo.match(delegateEventSplitter);
      eventName = match[1] + '.CoralComponent';
      selector = match[2];

      if (selector === '') {
        // instead of null because the key module checks for undefined
        selector = undefined;
      }

      // Try to get the method corresponding to the value in the map
      listener = getListenerFromMethodNameOrFunction(this, eventName, listener);

      if (listener) {
        // Always execute in the context of the object
        // @todo is this necessary? this should be correct anyway
        listener = listener.bind(this);

        // Check if the listener is on the window
        isGlobal = eventName.indexOf('global:') === 0;
        if (isGlobal) {
          eventName = eventName.substr(7);
        }

        // Check if the listener is a capture listener
        isCapture = eventName.indexOf('capture:') === 0;
        if (isCapture) {
          // @todo Limitation: It should be possible to do capture:global:, but it isn't
          eventName = eventName.substr(8);
        }

        // Check if the listener is a key listener
        isKey = eventName.indexOf('key:') === 0;
        if (isKey) {
          if (isCapture) {
            throw new Error('Coral.Keys does not currently support listening to key events with capture');
          }
          eventName = eventName.substr(4);
        }

        // Check if the listener is a resize listener
        isResize = eventName.indexOf('resize') === 0;
        if (isResize) {
          if (isCapture) {
            throw new Error('Coral.commons.addResizeListener does not currently support listening to resize event with capture');
          }
        }

        if (isGlobal) {
          // Store for adding/removal
          if (isKey) {
            this._globalKeys = this._globalKeys || [];
            this._globalKeys.push({
              keyCombo: eventName,
              selector: selector,
              listener: listener
            });
          }
          else {
            this._globalEvents = this._globalEvents || [];
            this._globalEvents.push({
              eventName: eventName,
              selector: selector,
              listener: listener,
              isCapture: isCapture
            });
          }
        }
        else {
          // Events on the element itself
          if (isKey) {
            // Create the keys instance only if its needed
            this._keys = this._keys || new Coral.Keys(this, {
                filter: this._filterKeys,
                // Execute key listeners in the context of the element
                context: this
              });

            // Add listener locally
            this._keys.on(eventName, selector, listener);
          }
          else if (isResize) {
            if (selector) {
              elements = document.querySelectorAll(selector);
              for (var i = 0; i < elements.length; ++i) {
                Coral.commons.addResizeListener(elements[i], listener);
              }
            }
            else {
              Coral.commons.addResizeListener(this, listener);
            }
          }
          else {
            this._vent.on(eventName, selector, listener, isCapture);
          }
        }
      }
    }
  };

  /**
    Remove global event listeners for this component.

    @private

    @returns {Coral.Component} this, chainable.
  */
  Coral.Component.prototype._undelegateGlobalEvents = function() {
    var i;
    if (this._globalEvents) {
      // Remove global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        Coral.events.off(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Remove global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        Coral.keys.off(key.keyCombo, key.selector, key.listener);
      }
    }
    
    if (this._keys) {
      this._keys.destroy(true);
    }

    return this;
  };

  /**
    Add global event listeners for this component.

    @private

    @returns {Coral.Component} this, chainable.
  */
  Coral.Component.prototype._delegateGlobalEvents = function() {
    var i;
    if (this._globalEvents) {
      // Add global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        Coral.events.on(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Add global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        Coral.keys.on(key.keyCombo, key.selector, key.listener);
      }
    }
    
    if (this._keys) {
      this._keys.init(true);
    }

    return this;
  };

  /**
    Add an event listener.

    @param {String} eventName
      The event name to listen for.
    @param {String} [selector]
      The selector to use for event delegation.
    @param {Function} func
      The function that will be called when the event is triggered.
    @param {Boolean} [useCapture=false]
      Whether or not to listen during the capturing or bubbling phase.

    @returns {Coral.Component} this, chainable.
  */
  Coral.Component.prototype.on = function(eventName, selector, func, useCapture) {
    this._vent.on(eventName, selector, func, useCapture);
    return this;
  };

  /**
    Remove an event listener.

    @param {String} eventName
      The event name to stop listening for.
    @param {String} [selector]
      The selector that was used for event delegation.
    @param {Function} func
      The function that was passed to <code>on()</code>.
    @param {Boolean} [useCapture]
      Only remove listeners with <code>useCapture</code> set to the value passed in.

    @returns {Coral.Component} this, chainable.
  */
  Coral.Component.prototype.off = function(eventName, selector, func, useCapture) {
    this._vent.off(eventName, selector, func, useCapture);
    return this;
  };

  /**
    Trigger an event.

    @param {String} eventName
      The event name to trigger.
    @param {Object} [props]
      Additional properties to make available to handlers as <code>event.detail</code>.
    @param {Boolean} [bubbles=true]
      Set to <code>false</code> to prevent the event from bubbling.
    @param {Boolean} [cancelable=true]
      Set to <code>false</code> to prevent the event from being cancelable.

    @returns {CustomEvent} CustomEvent object
  */
  Coral.Component.prototype.trigger = function(eventName, props, bubbles, cancelable) {
    // When 'bubbles' is not set, then default to true:
    bubbles = bubbles || bubbles === undefined;

    // When 'cancelable' is not set, then default to true:
    cancelable = cancelable || cancelable === undefined;

    // CustomEvent is polyfilled for IE via Polymer:
    // https://github.com/Polymer/CustomElements/blob/master/src/boot.js#L84-L93
    var event = new CustomEvent(eventName, {
      bubbles: bubbles,
      cancelable: cancelable,
      detail: props
    });

    // default value in case the dispatching fails
    var defaultPrevented = false;

    try {
      // leads to NS_ERROR_UNEXPECTED in Firefox
      // https://bugzilla.mozilla.org/show_bug.cgi?id=329509
      defaultPrevented = !this.dispatchEvent(event);
    } catch (e) {}

    // Check if the defaultPrevented status was correctly stored back to the event object
    if (defaultPrevented !== event.defaultPrevented) {
      // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
      // However, it does return false if preventDefault() was called
      // Unfortunately, the returned event's defaultPrevented property is read-only
      // We need to work around this such that (patchedEvent instanceof Event) === true
      // First, we'll create an object that uses the event as its prototype
      // This gives us an object we can modify that is still technically an instanceof Event
      var patchedEvent = Object.create(event);

      // Next, we set the correct value for defaultPrevented on the new object
      // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
      // For some reason, defineProperty doesn't cause this
      Object.defineProperty(patchedEvent, 'defaultPrevented', {
        value: defaultPrevented
      });

      return patchedEvent;
    }

    return event;
  };

  /**
    Non-destructively remove this element. It can be re-added by simply appending it to the document again.
    It will be garbage collected if there are no more references to it.
  */
  Coral.Component.prototype.remove = function() {
    if (this.parentNode) {
      // Just remove the element from its parent. This will automatically invoke detachedCallback
      this.parentNode.removeChild(this);
    }
  };

  /**
    @ignore
    @private
  */
  Coral.Component.prototype._doSet = function(property, value, silent) {
    // Get property descriptor from constructor. Property descriptors are stored on constructor with methods
    // dereferenced to actual functions
    var descriptor = this._properties && this._properties[property];

    if (descriptor) {
      if (descriptor.contentZone && !(value instanceof HTMLElement) && this[property].set) {
        // If the property is a content zone and the passed value is not a HTML element,
        // assume we're setting multiple properties of the existing content zone with an object
        this[property].set(value);
      }
      // In case the Content Zone is not a Coral.Component, we still want to be able to set the new values into it
      else if (descriptor.contentZone && !(value instanceof HTMLElement) && typeof value === 'object' && this[property] instanceof HTMLElement) {
        Object.keys(value).forEach(function(prop) {
          this[prop] = value[prop];
        }, this[property]);
      }
      else if (descriptor._methods && descriptor._methods.set) {
        // Call and pass true silent
        // Use the actual setter method instead of the original method so events are triggered etc
        descriptor._methods.set.call(this, value, !!silent);
      }
      else {
        this[property] = value;
      }
    }
    else {
      // Simply set the property if it doesn't exist or has no setter
      this[property] = value;
    }
  };

  /**
    Set a single property.

    @name Coral.Component#set
    @function

    @param {String} property
      The name of the property to set.
    @param {*} value
      The value to set the property to.
    @param {Boolean} silent
      If true, events should not be triggered as a result of this set.

    @returns {Coral.Component} this, chainable.
  */

  /**
    Set multiple properties.

    @name Coral.Component#set
    @function

    @param {Object.<String, *>} properties
      An object of property/value pairs to set.
    @param {Boolean} silent
      If true, events should not be triggered as a result of this set.

    @returns {Coral.Component} this, chainable.
  */
  Coral.Component.prototype.set = function(propertyOrProperties, valueOrSilent, silent) {
    var property;
    var properties;
    var value;

    if (typeof propertyOrProperties === 'string') {
      // Set a single property
      property = propertyOrProperties;
      value = valueOrSilent;
      this._doSet(property, value, silent);
    }
    else {
      properties = propertyOrProperties;
      silent = valueOrSilent;

      // Set a map of properties
      for (property in properties) {
        value = properties[property];

        this._doSet(property, value, silent);
      }
    }

    return this;
  };

  /**
    Get the value of a property.

    @param {String} property
      The name of the property to fetch the value of.

    @returns {*} Property value.
  */
  Coral.Component.prototype.get = function(property) {
    return this[property];
  };

  /**
    Show this component.

    @returns {Coral.Component} this, chainable
  */
  Coral.Component.prototype.show = function() {
    if (!this.hidden) {
      return this;
    }

    this.hidden = false;
    return this;
  };

  /**
    Hide this component.

    @returns {Coral.Component} this, chainable
  */
  Coral.Component.prototype.hide = function() {
    if (this.hidden) {
      return this;
    }

    this.hidden = true;
    return this;
  };

  // Copy all methods for baseTagName-style inheritance
  Coral.Component.prototype._methods = {};
  for (var prop in Coral.Component.prototype) {
    if (Coral.Component.prototype.hasOwnProperty(prop)) {
      Coral.Component.prototype._methods[prop] = Coral.Component.prototype[prop];
    }
  }

  /**
    Whether this component is hidden or not.

    @name hidden
    @type {Boolean}
    @default false
    @htmlattribute hidden
    @htmlattributereflected
    @memberof Coral.Component#
  */

  /**
    Triggered when the component is attached to the DOM.

    @event Coral.Component#coral-component:attached
    @deprecated since 1.14.0, use <code>MutationObserver</code> instead.

    @param {Object} event
      Event object.
  */

  /**
    Triggered when the component is detached to the DOM.

    @event Coral.Component#coral-component:detached
    @deprecated since 1.14.0, use <code>MutationObserver</code> instead.

    @param {Object} event
      Event object.
  */

  /**
    Triggerred when the component has been upgraded and is ready for use.

    @event Coral.Component#coral-component:ready
    @deprecated since 1.9.0, use <code>Coral.commons.ready()</code> instead.

    @param {Object} event
      Event object.
  */
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
     Unique id used to idenfity the collection.

     @private
   */
  var nextID = 0;

  /**
     Attribute used to identify the items of a collection.

     @private
   */
  var COLLECTION_ID = 'coral-collection-id-';

  /**
    Selector used to determine if nested items should be allowed.

    @private
  */
  var SCOPE_SELECTOR = ':scope > ';

  /** @private */
  function getTagSelector(tag, nativeTag) {
    return nativeTag ? (nativeTag + '[is="' + tag + '"]') : tag;
  }

  /** @private */
  function listToArray(list) {
    for (var res = [], i = 0, listCount = res.length = list.length; i < listCount; i++) {
      res[i] = list[i];
    }
    return res;
  }

  /**
    Helper function used to determine if the item should be filtered. If the filter is <code>undefined</code>, then the
    item will pass the filter.

    @param {HTMLElement} item
      The item that should be filtered.
    @param {Function} filter
      Function used to filter the item

    @returns {Boolean} true if the item passes the filter, otherwise false.

    @private
  */
  function filterItem(item, filter) {
    return typeof filter !== 'function' || filter(item);
  }

  /**
    The Collection API as used as an interface to manipulate item collections within the components.

    @param {HTMLElement} options.host
      The element that hosts the collection.
    @param {String} options.itemTagName
      The tag name of the elements that constitute a collection item.
    @param {String} options.itemBaseTagName
      The optional base tag name of the elements that constitute a collection item. This is required for elements that
      extend native elements, like Button.
    @param {String} [options.itemSelector]
      Optional, derived from itemTagName and itemBaseTagName by default. Used to query the host element for its
      collection items.
    @param {HTMLElement} [options.container]
      Optional element that wraps the collection. Defines where the new items will be added when <code>add</code> method
      is called. Is the same as options.host by default.
    @param {Coral.Collection~filter} [options.filter]
      Optional function used to filter the results.
    @param {Coral.Collection~onItemAdded} [options.onItemAdded]
      Function called once an item is added to the DOM. If the Collection has been configured to handle the items
      automatically, the callback will be called once the collection detects that the item has been added to the DOM and
      not synchronously with <code>add()</code>.
    @param {Coral.Collection~onItemRemoved} [options.onItemRemoved]
      Function called once an item is removed from the DOM. If the Collection has been configured to handle the items
      automatically, the callback will be called once the collection detects that the item has been removed from the DOM
      not synchronously with <code>add()</code>.
    @param {Coral.Collection~onCollectionChange} [options.onCollectionChange]
      Function called after there has been a change in the collection. This allows components to handle state changes
      after an item(s) has been added or removed. This callback will only be called if the Collection is configured to
      handle the items automatically.
      is <code>true</code>.

    @interface
  */
  Coral.Collection = function(options) {
    options = options || {};

    // we create an unique collection identifier
    this._id = nextID++;

    this._host = options.host;
    this._itemTagName = options.itemTagName;
    this._itemBaseTagName = options.itemBaseTagName;
    this._itemSelector = options.itemSelector || getTagSelector(this._itemTagName, this._itemBaseTagName);

    // the container where the new items are added
    this._container = options.container || this._host;
    this._filter = options.filter;

    // internal variable to determine if collection events will be handled internally
    this._handleItems = false;

    // we provide support for the :scope selector and swap it for an id
    if (this._itemSelector && this._itemSelector.indexOf(SCOPE_SELECTOR) === 0) {
      this._container.id = this._container.id || (COLLECTION_ID + this._id);
      // we create a special selector to make sure that the items are direct children of the container. given that
      // :scope is not fully supported by all browsers, we use an id to query
      this._allItemsSelector = this._itemSelector.replace(SCOPE_SELECTOR, '#' + this._container.id + ' > ');

      // we remove the :scope from the selector to be able to use it to determine if the item matches the collection
      this._itemSelector = this._itemSelector.replace(SCOPE_SELECTOR, '');
      // in case they match, we enable this optimization
      if (this._itemSelector === this._itemTagName) {
        this._useItemTagName = this._itemSelector.toUpperCase();
      }
    }
    // live collections are not supported when nested items is used
    else {
      this._allItemsSelector = this._itemSelector;

      // live collections can only be used when a tagname is used to query the items
      if (this._container && this._allItemsSelector === this._itemTagName) {
        this._liveCollection = true;
        this._useItemTagName = this._allItemsSelector.toUpperCase();
      }
    }

    this._onItemAdded = options.onItemAdded;
    this._onItemRemoved = options.onItemRemoved;
    this._onCollectionChange = options.onCollectionChange;
  };

  var properties = {
    /**
      Number of items inside the Collection.

      @type {Number}
      @default 0
      @memberof Coral.Collection#
    */
    'length': {
      get: function() {
        return this.getAll().length;
      }
    }
  };

  Coral.Collection.prototype = Object.create(Object.prototype, properties);
  Coral.Collection.prototype._properties = properties;

  /**
    Adds an item to the Collection. The item can be either a <code>HTMLElement</code> or an Object with the item
    properties. If the index is not provided the element appended to the end. If <code>options.onItemAdded</code> was
    provided, it will be called after the element is added from the DOM.

    @param {HTMLElement|Object} item
      The item to add to the Collection.
    @param {HTMLElement} [insertBefore]
      Existing item used as a reference to insert the new item before. If the value is <code>null</code>, then the new
      item will be added at the end.

    @fires Coral.Collection#coral-collection:add

    @returns {HTMLElement} the item added.
   */
  Coral.Collection.prototype.add = function(item, insertBefore) {
    // container and itemtagname are the minimum options that need to be provided to automatically handle this function
    if (this._container && this._itemTagName) {
      if (!(item instanceof HTMLElement)) {
        // creates an instance of an item from the object
        if (this._itemBaseTagName) {
          item = document.createElement(this._itemBaseTagName, this._itemTagName).set(item, true);
        }
        else {
          item = document.createElement(this._itemTagName).set(item, true);
        }
      }

      // inserts the element in the specified container
      this._container.insertBefore(item, insertBefore || null);

      // when items are handled automatically there is no need to call this immediatelly
      if (!this._handleItems && typeof this._onItemAdded === 'function' && this._host && filterItem(item, this._filter)) {
        this._onItemAdded.call(this._host, item);
      }

      return item;
    }

    throw new Error('Please provide host and itemTagName or override add() to provide your own implementation.');
  };

  /**
    Removes all the items from the Collection.

    @returns {Array.<HTMLElement>} an Array with all the removed items.
   */
  Coral.Collection.prototype.clear = function() {
    var items = this.getAll();

    var removed = [];

    for (var i = items.length - 1; i > -1; i--) {
      removed.push(this.remove(items[i]));
    }

    return removed;
  };

  /**
    Returns an array with all the items inside the Collection. Each element is of type <code>HTMLElement</code>.

    @returns {Array.<HTMLElement>} an Array with all the items inside the collection.
   */
  Coral.Collection.prototype.getAll = function() {
    // in order to perform the automatic getAll query, the _host and _allItemsSelector must be provided
    if (this._container && this._allItemsSelector) {
      var items = this._liveCollection ?
        // instead of querying the DOM, we just convert the live collection to an array, this way we obtain a
        // "snapshot" of the DOM
        listToArray(this._container.getElementsByTagName(this._allItemsSelector)) :
        listToArray(this._container.querySelectorAll(this._allItemsSelector));

      if (this._filter) {
        items = items.filter(this._filter);
      }

      return items;
    }

    throw new Error('Please provide host and itemTagName or override getAll() to provide your own implementation.');
  };

  /**
    Removes the given item from the Collection. If <code>options.onItemRemoved</code> was provided, it will be called
    after the element is removed from the DOM.

    @param {HTMLElement} item
      The item to add to the Collection.

    @fires Coral.Collection#coral-collection:remove

    @returns {HTMLElement} the item removed.
   */
  Coral.Collection.prototype.remove = function(item) {
    if (item.parentNode) {
      item.parentNode.removeChild(item);

      // when items are handled automatically there is no need to call this immediatelly
      if (!this._handleItems && typeof this._onItemRemoved === 'function' && this._host && filterItem(item, this._filter)) {
        this._onItemRemoved.call(this._host, item);
      }
    }

    return item;
  };

  /**
    Returns the first item of the collection.

    @returns {?HTMLElement} the first item of the collection.
  */
  Coral.Collection.prototype.first = function() {
    // Use getAll() so filter() is applied
    return this.getAll()[0] || null;
  };

  /**
    Returns the last item of the collection.

    @returns {?HTMLElement} the last item of the collection.
  */
  Coral.Collection.prototype.last = function() {
    // Use getAll() so filter() is applied
    var all = this.getAll();
    return all[all.length - 1] || null;
  };

  /**
    Checks if the given Node belongs to the current collection. It is said that a Node belongs to a given collection
    if it passes <code>options.filter</code> and it matches <code>options.itemSelector</code>. Text nodes cannot be
    part of a collection.

    @param {Node} node
      The node to check if it belongs to the collection.

    @returns {Boolean} true if the node is part of the collection, otherwise false.

    @protected
  */
  Coral.Collection.prototype._isPartOfCollection = function(node) {
    // we exclude Text nodes as they cannot be part of the collection. Text nodes do not implement matches and tagName
    return !(node instanceof Text) &&
      filterItem(node, this._filter) &&
      // this is an optimization to avoid using matches
      (this._useItemTagName ? this._useItemTagName === node.tagName : node.matches(this._itemSelector));
  };

  /**
    Handles the attachment of an item to the collection. It triggers automatically the collection event.

    @param {HTMLElement} item
      The item that was attached to the collection.

    @fires Coral.Collection#coral-collection:add

    @protected
  */
  Coral.Collection.prototype._onItemAttached = function(item) {
    // if options.onItemAdded was provided, we call the function
    if (typeof this._onItemAdded === 'function') {
      this._onItemAdded.call(this._host, item);
    }

    // the usage of trigger assumes that the host is a coral component
    this._host.trigger('coral-collection:add', {
      item: item
    });
  };

  /**
    Handles the detachment of a item to the collection. It triggers automatically the collection event.

    @param {HTMLElement} item
      The item that was detached of the collection

    @fires Coral.Collection#coral-collection:remove

    @protected
  */
  Coral.Collection.prototype._onItemDetached = function(item) {
    // if options.onItemRemoved was provided, we call the function
    if (typeof this._onItemRemoved === 'function') {
      this._onItemRemoved.call(this._host, item);
    }

    // the usage of trigger assumes that the host is a coral component
    this._host.trigger('coral-collection:remove', {
      item: item
    });
  };

  /**
    Enables the automatic detection of collection items. The collection will take care of triggering the appropiate
    collection event when an item is added or removed, as well the related callbacks. Components can decide to skip the
    initialization of the starting items by providing <code>skipInitialItems</code> as <code>false</code>.

    @param {Boolean} [skipInitialItems=false]
      If <code>true</code>, <code>onItemAdded</code> will be called for every starting item. A collection event will not
      be triggered for these items.

    @protected
  */
  Coral.Collection.prototype._startHandlingItems = function(skipInitialItems) {
    if (this._host && this._container) {
      // we reuse the observer if it already exists, this way we do not need to disconnect it if this function is called
      // again
      this._observer = this._observer || new MutationObserver(this._handleMutation.bind(this));

      // this changes the way that _onItemAdded and _onItemRemoved behave, since they well be delayed until a mutation
      // detects them
      this._handleItems = true;

      // we need to wait for the container to be ready to be sure that host component is ready to handle the items
      Coral.commons.ready(this._container, function() {

        this._observer.observe(this._container, {
          // we only need to observe for items that were added and removed, no need to check attributes and contents
          childList: true,
          // we need to listen to subtree mutations as items may not be direct children
          subtree: true
        });

        // by default we handle the initial items unless otherwise indicated
        if (skipInitialItems !== true) {
          // since we are handling the items for the component, we need to make sure the _onItemAdded is called for the
          // initial items. collection events will not be triggered for these items as they represent the initial state
          var items;
          var itemCount = 0;

          if (typeof this._onItemAdded === 'function' || typeof this._onCollectionChange === 'function') {
            items = this.getAll();
            itemCount = items.length;
          }

          if (typeof this._onItemAdded === 'function') {
            for (var i = 0; i < itemCount; i++) {
              this._onItemAdded.call(this._host, items[i]);
            }
          }

          // we only call the _onCollectionChange callback if there are items inside the collection
          if (itemCount > 0 && typeof this._onCollectionChange === 'function') {
            this._onCollectionChange.call(this._host, items, []);
          }
        }
      }.bind(this));
    }
    else {
      throw new Error('Please provide options.host and/or options.container to enable handling the items.');
    }
  };

  /**
    Stops handling the items.

    @protected
  */
  Coral.Collection.prototype._stopHandlingItems = function() {
    if (this._observer) {
      this._observer.disconnect();
    }
  };

  /**
    Handles every time that an element is added or removed from the <code>options.container</code>. By default the
    collection events will be triggered. If <code>options.onItemAdded</code> or <code>options.onItemRemoved</code> were
    provided, they will be called where it applies.

    @param Array.<Object> mutations
      Array that contains the <code>MutationRecord> relevant to every registered mutation.

    @protected
  */
  Coral.Collection.prototype._handleMutation = function(mutations) {
    var mutation;
    var mutationsCount = mutations.length;
    var item;
    var addedNodes;
    var addedNodesCount;
    var removedNodes;
    var removedNodesCount;
    var validAddedNodes = [];
    var validRemovedNodes = [];

    // we need to count every addition and removal to notify the component that the collection changed
    var itemChanges = 0;
    for (var i = 0; i < mutationsCount; i++) {
      mutation = mutations[i];

      addedNodes = mutation.addedNodes;
      addedNodesCount = addedNodes.length;
      for (var j = 0; j < addedNodesCount; j++) {
        item = addedNodes[j];

        // filters the item
        if (this._isPartOfCollection(item)) {
          itemChanges++;
          validAddedNodes.push(item);
          this._onItemAttached(item);
        }
      }

      removedNodes = mutation.removedNodes;
      removedNodesCount = removedNodes.length;
      for (var k = 0; k < removedNodesCount; k++) {
        item = removedNodes[k];

        // filters the item
        if (this._isPartOfCollection(item)) {
          itemChanges++;
          validRemovedNodes.push(item);
          this._onItemDetached(item);
        }
      }
    }

    // if changes were done to the collection we need to notify the component. we do this after all the mutations were
    // processed to make sure we only do it once
    if (itemChanges !== 0 && typeof this._onCollectionChange === 'function' && this._host) {
      this._onCollectionChange.call(this._host, validAddedNodes, validRemovedNodes);
    }
  };

  /**
    Triggered when an item is added to the Collection. Collection events are not synchronous so the DOM may reflect
    a different reality although every addition or removal will be reported.

    @event Coral.Collection#coral-collection:add

    @param {Object} event
      Event object.
    @param {HTMLElement} event.detail.item
      The item that was added.
  */

  /**
    Triggered when an item is removed from a Collection. Collection events are not synchronous so the DOM may reflect
    a different reality although every addition or removal will be reported.

    @event Coral.Collection#coral-collection:remove

    @param {Object} event
      Event object.
    @param {HTMLElement} event.detail.item
      The item that was removed.
  */

  /**
    Signature of the function called to determine if an element should be included in the collection. If the function
    returns <code>true</code> for the given element it will be part of the collection, otherwise it will be excluded.

    @callback Coral.Collection~filter

    @param {HTMLElement} element
      The item to check whether it should be part of the collection.

    @returns {Boolean} true if should be part of the collection, otherwise false.
  */

  /**
    Signature of the function called when ever an item is added to the collection.

    @callback Coral.Collection~onItemAdded

    @param {HTMLElement} item
      The item that was added to the collection.
  */

  /**
    Signature of the function called when ever an item is removed from the collection.

    @callback Coral.Collection~onItemRemoved

    @param {HTMLElement} item
      The item that was added to the collection.
  */

  /**
    Signature of the function called when there is a change in the collection. The items that where added and removed
    will be provided.

    @callback Coral.Collection~onCollectionChange

    @param {Array.<HTMLElement>} addedNodes
      An array that contains the items that were added to the collection.
    @param {Array.<HTMLElement>} removedNodes
      An array that contains the items that were removed from the collection.
  */
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /** @private */
  function listToArray(list) {
    for (var res = [], i = 0, listCount = res.length = list.length; i < listCount; i++) {
      res[i] = list[i];
    }
    return res;
  }

  /**
    Private Collection capable of handling non-nested items with a selected attribute. It is useful to manage the
    internal state of selection. It currently does not support options.filter for the selection related functions.

    @extends Coral.Collection
    @protected
  */
  Coral.SelectableCollection = function(options) {
    // calls the 'super' constructor
    Coral.Collection.apply(this, arguments);

    if (this._filter) {
      console.warn('Coral.SelectableCollection does not support the options.filter');
    }

    // disabled items will not be a selection candicate although hidden items might
    this._selectableItemSelector = this._itemSelector + ':not([disabled])';
    this._selectedItemSelector = this._itemSelector + '[selected]';
    this._deselectAllExceptSelector = this._selectedItemSelector;
  };

  Coral.SelectableCollection.prototype = Object.create(Coral.Collection.prototype);

  /**
    Returns the first selectable item. Items that are disabled quality for selection. On the other hand, hidden items
    can be selected as this is the default behavior in HTML. Please note that an already selected item could be
    returned, since the selection could be toggled.

    @returns {HTMLElement}
      an item whose selection could be toggled.

    @protected
  */
  Coral.SelectableCollection.prototype._getFirstSelectable = function() {
    return this._host.querySelector(this._selectableItemSelector) || null;
  };

  /**
    Returns the last selectable item. Items that are disabled quality for selection. On the other hand, hidden items
    can be selected as this is the default behavior in HTML. Please note that an already selected item could be
    returned, since the selection could be toggled.

    @returns {HTMLElement}
      an item whose selection could be toggled.

    @protected
  */
  Coral.SelectableCollection.prototype._getLastSelectable = function() {
    var items = this._host.querySelectorAll(this._selectableItemSelector);
    return items[items.length - 1] || null;
  };

  /**
    Returns the first item that is selected in the Collection. It allows to configure the attribute used for selection
    so that components that use 'selected' and 'active' can share the same implementation.

    @param {String} [selectedAttribute=selected]
      the attribute that will be used to check for selection.

    @returns HTMLElment the first selected item.

    @protected
  */
  Coral.SelectableCollection.prototype._getFirstSelected = function(selectedAttribute) {
    var selector = this._selectedItemSelector;

    if (typeof selectedAttribute === 'string') {
      selector = selector.replace('[selected]', '[' + selectedAttribute + ']');
    }

    return this._host.querySelector(selector) || null;
  };

  /**
    Returns the last item that is selected in the Collection. It allows to configure the attribute used for selection
    so that components that use 'selected' and 'active' can share the same implementation.

    @param {String} [selectedAttribute=selected]
      the attribute that will be used to check for selection.

    @returns HTMLElment the last selected item.

    @protected
  */
  Coral.SelectableCollection.prototype._getLastSelected = function(selectedAttribute) {
    var selector = this._selectedItemSelector;

    if (typeof selectedAttribute === 'string') {
      selector = selector.replace('[selected]', '[' + selectedAttribute + ']');
    }

    // last-of-type did not work so we need to query all
    var items = this._host.querySelectorAll(selector);
    return items[items.length - 1] || null;
  };

  /**
    Returns an array that contains all the items that are selected.

    @param {String} [selectedAttribute=selected]
      the attribute that will be used to check for selection.

    @protected

    @returns Array.<HTMLElement> an array with all the selected items.
  */
  Coral.SelectableCollection.prototype._getAllSelected = function(selectedAttribute) {
    var selector = this._selectedItemSelector;

    if (typeof selectedAttribute === 'string') {
      selector = selector.replace('[selected]', '[' + selectedAttribute + ']');
    }

    return listToArray(this._host.querySelectorAll(selector));
  };

  /**
    Deselects all the items except the first selected item in the Collection. By default the <code>selected</code>
    attribute will be removed. The attribute to remove is configurable via the <code>selectedAttribute</code> parameter.
    The selected attribute will be removed no matter if the item is <code>disabled</code> or <code>hidden</code>.

    @param {String} [selectedAttribute=selected]
      the attribute that will be used to check for selection. This attribute will be removed from the matching elements.

    @protected
  */
  Coral.SelectableCollection.prototype._deselectAllExceptFirst = function(selectedAttribute) {
    var selector = this._deselectAllExceptSelector;
    var attributeToRemove = selectedAttribute || 'selected';

    if (typeof selectedAttribute === 'string') {
      selector = selector.replace('[selected]', '[' + selectedAttribute + ']');
    }

    // we select all the selected attributes except the last one
    var items = this._host.querySelectorAll(selector);
    var itemsCount = items.length;

    // ignores the first item of the list, everything else is deselected
    for (var i = 1; i < itemsCount; i++) {
      // we use remoteAttribute since we do not know if the element is upgraded
      items[i].removeAttribute(attributeToRemove);
    }
  };

  /**
    Deselects all the items except the last selected item in the Collecton. By default the <code>selected</code>
    attribute will be removed. The attribute to remove is configurable via the <code>selectedAttribute</code> parameter.

    @param {String} [selectedAttribute=selected]
      the attribute that will be used to check for selection. This attribute will be removed from the matching elements.

    @protected
  */
  Coral.SelectableCollection.prototype._deselectAllExceptLast = function(selectedAttribute) {
    var selector = this._deselectAllExceptSelector;
    var attributeToRemove = selectedAttribute || 'selected';

    if (typeof selectedAttribute === 'string') {
      selector = selector.replace('[selected]', '[' + selectedAttribute + ']');
    }

    // we query for all matching items with the given attribute
    var items = this._host.querySelectorAll(selector);
    // we ignore the last item
    var itemsCount = items.length - 1;

    for (var i = 0; i < itemsCount; i++) {
      // we use remoteAttribute since we do not know if the element is upgraded
      items[i].removeAttribute(attributeToRemove);
    }
  };

  /**
    Deselects all the items by removing the provided attribute from the item. By default the <code>selected</code>
    attribute will be removed. The attribute to remove is configurable via the <code>selectedAttribute</code> parameter.

    @name Coral.SelectableCollection#_deselectAllExcept
    @function

    @param {String} [selectedAttribute=selected]
      the attribute that will be used to check for selection. This attribute will be removed from the matching elements.

    @protected
  */

  /**
    Deselects all the items except the given item. The provided attribute will be remove from all matching items. By
    default the <code>selected</code> attribute will be removed. The attribute to remove is configurable via the
    <code>selectedAttribute</code> parameter.

    @name Coral.SelectableCollection#_deselectAllExcept
    @function

    @param {HTMLElement} [item]
      The item to keep selected. If the item is not provided, all elements will be deselected.

    @param {String} [selectedAttribute=selected]
      the attribute that will be used to check for selection. This attribute will be removed from the matching elements.

    @protected
  */
  Coral.SelectableCollection.prototype._deselectAllExcept = function(itemOrSelectedAttribute, selectedAttribute) {
    // if no selectedAttribute we use the unmodified selector as default
    var selector = this._deselectAllExceptSelector;

    var item;
    var attributeToRemove;
    // an item was not provided so we use it as 'selectedAttribute'
    if (typeof itemOrSelectedAttribute === 'string') {
      item = null;
      attributeToRemove = itemOrSelectedAttribute || 'selected';
      selector = selector.replace('[selected]', '[' + attributeToRemove + ']');
    }
    else {
      item = itemOrSelectedAttribute;
      attributeToRemove = selectedAttribute || 'selected';

      if (typeof selectedAttribute === 'string') {
        selector = selector.replace('[selected]', '[' + attributeToRemove + ']');
      }
    }

    // we query for all matching items with the given attribute
    var items = this._host.querySelectorAll(selector);
    var itemsCount = items.length;

    for (var i = 0; i < itemsCount; i++) {
      // we use remoteAttribute since we do not know if the element is upgraded
      if (item !== items[i]) {
        items[i].removeAttribute(attributeToRemove);
      }
    }
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/* global Vent: true */
(function() {
  /* jshint validthis: true */
  'use strict';

  // The tab capture element that lives at the top of the body
  var topTabCaptureEl;
  var bottomTabCaptureEl;

  // A reference to the backdrop element
  var backdropEl;

  // The starting zIndex for overlays
  var startZIndex = 10000;

  // Tab keycode
  var TAB_KEY = 9;

  /**
    Focus trap options.
    @memberof Coral.mixin.overlay
    @enum {String}
  */
  var trapFocus = {
    /** Focus is trapped such that the use cannot focus outside of the overlay. */
    ON: 'on',
    /** The user can focus outside the overlay as normal. */
    OFF: 'off'
  };

  /**
    Return focus options.

    @memberof Coral.mixin.overlay
    @enum {String}
  */
  var returnFocus = {
    /** When the overlay is closed, the element that was focused before the it was shown will be focused again. */
    ON: 'on',
    /** Nothing will be focused when the overlay is closed. */
    OFF: 'off'
  };

  /**
    Focus behavior options.

    @memberof Coral.mixin.overlay
    @enum {String}
  */
  var focusOnShow = {
    /** When the overlay is opened, it will be focused. */
    ON: 'on',
    /** The overlay will not focus itself when opened. */
    OFF: 'off'
  };

  // A stack interface for overlays
  var _overlays = [];
  var overlays = {
    pop: function(instance) {
      // Get overlay index
      var index = this.indexOf(instance);

      if (index === -1) {
        return null;
      }

      // Get the overlay
      var overlay = _overlays[index];

      // Remove from the stack
      _overlays.splice(index, 1);

      // Return the passed overlay or the found overlay
      return overlay;
    },

    push: function(instance) {
      // Pop overlay
      var overlay = this.pop(instance) || {
          instance: instance
        };

      // Get the new highest zIndex
      var zIndex = this.getHighestZIndex() + 10;

      // Store the zIndex
      overlay.zIndex = zIndex;
      instance.style.zIndex = zIndex;

      // Push it
      _overlays.push(overlay);

      if (overlay.backdrop) {
        // If the backdrop is shown, we'll need to reposition it
        // Generally, a component will not call _pushOverlay unnecessarily
        // However, attachedCallback is asynchronous in polyfilld environments,
        // so _pushOverlay will be called when shown and when attached
        doRepositionBackdrop();
      }

      return overlay;
    },

    indexOf: function(instance) {
      // Loop over stack
      // Find overlay
      // Return index
      for (var i = 0; i < _overlays.length; i++) {
        if (_overlays[i].instance === instance) {
          return i;
        }
      }
      return -1;
    },

    get: function(instance) {
      // Get overlay index
      var index = this.indexOf(instance);

      // Return overlay
      return index === -1 ? null : _overlays[index];
    },

    top: function() {
      var length = _overlays.length;
      return length === 0 ? null : _overlays[length - 1];
    },

    getHighestZIndex: function() {
      var overlay = this.top();
      return overlay ? overlay.zIndex : startZIndex;
    },

    some: function() {
      return _overlays.some.apply(_overlays, arguments);
    },

    forEach: function() {
      return _overlays.forEach.apply(_overlays, arguments);
    }
  };

  /**
    Hide the backdrop if no overlays are using it.
  */
  function hideOrRepositionBackdrop() {
    if (!backdropEl || !backdropEl._isOpen) {
      // Do nothing if the backdrop isn't shown
      return;
    }

    // Loop over all overlays
    var keepBackdrop = overlays.some(function(overlay) {
      // Check for backdrop usage
      if (overlay.backdrop) {
        return true;
      }
    });

    if (!keepBackdrop) {
      // Hide the backdrop
      doBackdropHide();
    }
    else {
      // Reposition the backdrop
      doRepositionBackdrop();
    }

    // Hide/create the document-level tab capture element as necessary
    // This only applies to modal overlays (those that have backdrops)
    var top = overlays.top();
    if (!top || !(top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop)) {
      hideDocumentTabCaptureEls();
    }
    else if (top && top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop) {
      createDocumentTabCaptureEls();
    }
  }

  /**
    Actually reposition the backdrop to be under the topmost overlay.
  */
  function doRepositionBackdrop() {
    // Position under the topmost overlay
    var top = overlays.top();

    if (top) {

      // The backdrop, if shown, should be positioned under the topmost overlay that does have a backdrop
      for (var i = _overlays.length - 1; i > -1; i--) {
        if (_overlays[i].backdrop) {
          backdropEl.style.zIndex = _overlays[i].zIndex - 1;
          break;
        }
      }

      // ARIA: Set hidden properly
      hideEverythingBut(top.instance);
    }
  }

  /**
    Cancel the backdrop hide mid-animation.
  */
  var fadeTimeout;
  function cancelBackdropHide() {
    clearTimeout(fadeTimeout);
  }

  /**
    Actually hide the backdrop.
  */
  function doBackdropHide() {
    document.body.classList.remove('u-coral-noscroll');

    // Start animation
    Coral.commons.nextFrame(function() {
      backdropEl.classList.remove('is-open');

      cancelBackdropHide();
      fadeTimeout = setTimeout(function() {
        backdropEl.style.display = 'none';
      }, Coral.mixin.overlay.FADETIME);
    });

    // Set flag for testing
    backdropEl._isOpen = false;

    // Wait for animation to complete
    showEverything();
  }

  /**
    Actually show the backdrop.
  */
  function doBackdropShow(zIndex, instance) {
    document.body.classList.add('u-coral-noscroll');

    if (!backdropEl) {
      backdropEl = document.createElement('div');
      backdropEl.className = 'coral3-Backdrop';
      document.body.appendChild(backdropEl);

      backdropEl.addEventListener('click', handleBackdropClick);
    }

    // Show just under the provided zIndex
    // Since we always increment by 10, this will never collide
    backdropEl.style.zIndex = zIndex - 1;

    // Set flag for testing
    backdropEl._isOpen = true;

    // Start animation
    backdropEl.style.display = '';
    Coral.commons.nextFrame(function() {
      // Add the class on the next animation frame so backdrop has time to exist
      // Otherwise, the animation for opacity will not work.
      backdropEl.classList.add('is-open');

      cancelBackdropHide();
    });

    hideEverythingBut(instance);
  }

  /**
    Handles clicks to the backdrop, calling backdropClickedCallback for every overlay
  */
  function handleBackdropClick(event) {
    overlays.forEach(function(overlay) {
      if (typeof overlay.instance.backdropClickedCallback === 'function') {
        overlay.instance.backdropClickedCallback(event);
      }
    });
  }

  /**
    Set aria-hidden on every immediate child except the one passed, which should not be hidden.
  */
  function hideEverythingBut(instance) {
    // ARIA: Hide all the things
    var children = document.body.children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      // If it's not a parent of or not the instance itself, it needs to be hidden
      if (child !== instance && !child.contains(instance)) {
        var currentAriaHidden = child.getAttribute('aria-hidden');
        if (currentAriaHidden) {
          // Store the previous value of aria-hidden if present
          // Don't blow away the previously stored value
          child._previousAriaHidden = child._previousAriaHidden || currentAriaHidden;
          if (currentAriaHidden === 'true') {
            // It's already true, don't bother setting
            continue;
          }
        }
        else {
          // Nothing is hidden by default, store that
          child._previousAriaHidden = 'false';
        }

        // Hide it
        child.setAttribute('aria-hidden', 'true');
      }
    }

    // Always show ourselves
    instance.setAttribute('aria-hidden', 'false');
  }

  /**
    Show or restore the aria-hidden state of every child of body.
  */
  function showEverything() {
    // ARIA: Show all the things
    var children = document.body.children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      // Restore the previous aria-hidden value
      child.setAttribute('aria-hidden', child._previousAriaHidden || 'false');
    }
  }

  /**
    Create the global tab capture element.
  */
  function createDocumentTabCaptureEls() {
    if (!topTabCaptureEl) {
      topTabCaptureEl = document.createElement('div');
      topTabCaptureEl.setAttribute('coral-tabcapture', '');
      topTabCaptureEl.tabIndex = 0;
      document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      topTabCaptureEl.addEventListener('focus', function(event) {
        var top = overlays.top();
        if (top && top.instance.trapFocus === trapFocus.ON) {
          // Focus on the first tabbable element of the top overlay
          Array.prototype.some.call(top.instance.querySelectorAll(Coral.commons.TABBABLE_ELEMENT_SELECTOR), function(item) {
            if (item.offsetParent !== null && !item.hasAttribute('coral-tabcapture')) {
              item.focus();
              return true;
            }
          });
        }
      });

      bottomTabCaptureEl = document.createElement('div');
      bottomTabCaptureEl.setAttribute('coral-tabcapture', '');
      bottomTabCaptureEl.tabIndex = 0;
      document.body.appendChild(bottomTabCaptureEl);
      bottomTabCaptureEl.addEventListener('focus', function(event) {
        var top = overlays.top();
        if (top && top.instance.trapFocus === trapFocus.ON) {
          var tabbableElement = Array.prototype.filter.call(top.instance.querySelectorAll(Coral.commons.TABBABLE_ELEMENT_SELECTOR), function(item) {
            return item.offsetParent !== null && !item.hasAttribute('coral-tabcapture');
          }).pop();

          // Focus on the last tabbable element of the top overlay
          if (tabbableElement) {
            tabbableElement.focus();
          }
        }
      });
    }
    else {
      if (document.body.firstElementChild !== topTabCaptureEl) {
        // Make sure we stay at the very top
        document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      }

      if (document.body.lastElementChild !== bottomTabCaptureEl) {
        // Make sure we stay at the very bottom
        document.body.appendChild(bottomTabCaptureEl);
      }
    }

    // Make sure the tab capture elemenst are shown
    topTabCaptureEl.style.display = 'inline';
    bottomTabCaptureEl.style.display = 'inline';
  }

  /**
    Called after all overlays are hidden and we shouldn't capture the first tab into the page.
  */
  function hideDocumentTabCaptureEls() {
    if (topTabCaptureEl) {
      topTabCaptureEl.style.display = 'none';
      bottomTabCaptureEl.style.display = 'none';
    }
  }

  // Properties to add to the object
  var properties = {
    /**
      Whether to trap tabs and keep them within the overlay.

      @type {Coral.mixin.overlay.trapFocus}
      @default Coral.mixin.overlay.trapFocus.OFF
      @htmlattribute trapfocus
      @memberof Coral.mixin.overlay#
    */
    'trapFocus': {
      attribute: 'trapfocus',
      default: trapFocus.OFF,
      validate: Coral.validate.enumeration(trapFocus),
      set: function(value) {
        if (value === trapFocus.ON) {
          // Give ourselves tabIndex if we are not focusable
          if (this.tabIndex < 0) {
            this.tabIndex = 0;
          }

          // Create elements
          this._elements.topTabCapture = document.createElement('div');
          this._elements.topTabCapture.setAttribute('coral-tabcapture', 'top');
          this._elements.topTabCapture.tabIndex = 0;
          this.insertBefore(this._elements.topTabCapture, this.firstElementChild);
          this._elements.intermediateTabCapture = document.createElement('div');
          this._elements.intermediateTabCapture.setAttribute('coral-tabcapture', 'intermediate');
          this._elements.intermediateTabCapture.tabIndex = 0;
          this.appendChild(this._elements.intermediateTabCapture);
          this._elements.bottomTabCapture = document.createElement('div');
          this._elements.bottomTabCapture.setAttribute('coral-tabcapture', 'bottom');
          this._elements.bottomTabCapture.tabIndex = 0;
          this.appendChild(this._elements.bottomTabCapture);

          // Add listeners
          this._handleTabCaptureFocus = this._handleTabCaptureFocus.bind(this);
          this._handleRootKeypress = this._handleRootKeypress.bind(this);
          this._vent.on('keydown', this._handleRootKeypress);
          this._vent.on('focus', '[coral-tabcapture]', this._handleTabCaptureFocus);
        }
        else {
          // Don't just put this in an else, check if we currently have it disabled
          // so we only attempt to remove elements if we were previously capturing tabs
          if (this.trapFocus === trapFocus.ON) {
            // Remove elements
            this.removeChild(this._elements.topTabCapture);
            this.removeChild(this._elements.intermediateTabCapture);
            this.removeChild(this._elements.bottomTabCapture);
            this._elements.topTabCapture = null;
            this._elements.intermediateTabCapture = null;
            this._elements.bottomTabCaptureEl = null;

            // Remove listeners
            this._vent.off('keydown', this._handleRootKeypress);
            this._vent.off('focus', '[coral-tabcapture]', this._handleTabCaptureFocus);
          }
        }

        this._trapFocus = value;
      }
    },

    /**
      Whether to return focus to the previously focused element when closed.

      @type {Coral.mixin.overlay.returnFocus}
      @default Coral.mixin.overlay.returnFocus.OFF
      @htmlattribute returnfocus
      @memberof Coral.mixin.overlay#
    */
    'returnFocus': {
      attribute: 'returnfocus',
      default: returnFocus.OFF,
      validate: Coral.validate.enumeration(returnFocus),
    },

    /**
      Whether to focus the overlay, when opened or not. By default the overlay itself will get the focus. It also
      accepts an instance of HTMLElement or a selector like ':first-child' or 'button:last-of-type'. If the selector
      returns multiple elements, it will focus the first element inside the overlay that matches the selector.

      @type {Coral.mixin.overlay.focusOnShow|HTMLElement|String}
      @default [Coral.mixin.overlay.focusOnShow.ON]{@link Coral.mixin.overlay.focusOnShow}
      @htmlattribute focusonshow
      @memberof Coral.mixin.overlay#
    */
    'focusOnShow': {
      attribute: 'focusonshow',
      default: focusOnShow.ON,
      validate: [
        Coral.validate.valueMustChange,
        function(value) {
          return typeof value === 'string' || value instanceof HTMLElement;
        }
      ]
    },

    /**
      Whether this overlay is open or not.

      @type {Boolean}
      @default false
      @htmlattribute open
      @htmlattributereflected
      @memberof Coral.mixin.overlay#
      @fires Coral.mixin.overlay#coral-overlay:open
      @fires Coral.mixin.overlay#coral-overlay:close
      @fires Coral.mixin.overlay#coral-overlay:beforeopen
      @fires Coral.mixin.overlay#coral-overlay:beforeclose
    */
    'open': {
      default: false,
      reflectAttribute: true,
      transform: Coral.transform.boolean,
      attributeTransform: Coral.transform.booleanAttr,
      triggerBefore: function(newValue, oldValue) {
        // We have to manually implement triggerBefore since we can trigger multiple events
        return this.trigger(newValue ? 'coral-overlay:beforeopen' : 'coral-overlay:beforeclose');
      },
      set: function(value, silent) {
        // We need to store the value here as we're not using the default setter
        this._open = value;
        this._openSilently = !!silent;

        // Set synchronously as it does not affect rendering
        if (this.open) {
          // Set aria-hidden false before we show
          // Otherwise, screen readers will not announce
          this.setAttribute('aria-hidden', 'false');
        }
        else {
          // Doesn't matter when we set aria-hidden true (nothing being announced)
          this.setAttribute('aria-hidden', 'true');
        }

        // Synchronous operations
        if (this.parentNode) {
          // Don't do anything if we're not in the DOM yet
          // This prevents errors related to allocating a zIndex we don't need
          if (this.open) {
            // Do this check afterwards as we may have been appended inside of _show()

            // Set z-index
            this._pushOverlay();

            if (this.returnFocus === returnFocus.ON) {
              this._elementToFocusWhenHidden =
                // cached element
                this._elementToFocusWhenHidden ||
                // element passed via returnFocusTo()
                this._returnFocusToElement ||
                // element that had focus before opening the overlay
                (document.activeElement === document.body ? null : document.activeElement);
            }
          }
          else {
            // Release zIndex
            this._popOverlay();
          }
        }
      },
      sync: function() {
        var self = this;

        if (this.open) {
          if (this.trapFocus === trapFocus.ON) {
            // Make sure tab capture elements are positioned correctly
            if (
              // Tab capture elements are no longer at the bottom
              this._elements.topTabCapture !== this.firstElementChild ||
              this._elements.bottomTabCapture !== this.lastElementChild ||
              // Tab capture elements have been separated
              this._elements.bottomTabCapture.previousElementSibling !== this._elements.intermediateTabCapture
            ) {
              this.insertBefore(this._elements.intermediateTabCapture, this.firstElementChild);
              this.appendChild(this._elements.intermediateTabCapture);
              this.appendChild(this._elements.bottomTabCapture);
            }
          }

          // The default style should be display: none for overlays
          // Show ourselves first for centering calculations etc
          this.style.display = 'block';

          Coral.commons.nextFrame(function() {
            self.classList.add('is-open');

            var openComplete = function() {
              if (self.open) {

                // handles the focus behavior based on accessibility recommendations
                self._handleFocus();

                if (!self._openSilently) {
                  self.trigger('coral-overlay:open');
                }
              }
            };

            if (self._overlayAnimationTime) {
              // Wait for animation to complete
              Coral.commons.transitionEnd(self, openComplete);
            }
            else {
              // Execute immediately
              openComplete();
            }
          });
        }
        else {
          // Fade out
          Coral.commons.nextFrame(function() {
            self.classList.remove('is-open');

            var closeComplete = function() {
              if (!self.open) {
                // Hide self
                self.style.display = 'none';

                // makes sure the focus is returned per accessibility recommendations
                self._handleReturnFocus();

                if (!self._openSilently) {
                  self.trigger('coral-overlay:close');
                }
              }
            };

            if (self._overlayAnimationTime) {
              // Wait for animation to complete
              Coral.commons.transitionEnd(self, closeComplete);
            }
            else {
              // Execute immediately
              closeComplete();
            }
          });
        }
      }
    }

    /**
      The time it takes for the overlay to animate opening/closing.
      This value should match the CSS animation time for the overlay in question.

      @name _overlayAnimationTime
      @type {Number}
      @default 0
      @protected
      @memberof Coral.mixin.overlay#
    */
  };

  var methods = {
    detachedCallback: function() {
      if (this.open) {
        // Release zIndex as we're not in the DOM any longer
        // When we're re-added, we'll get a new zIndex
        this._popOverlay();

        if (this._requestedBackdrop) {
          // Mark that we'll need to show the backdrop when attached
          this._showBackdropOnAttached = true;
        }
      }
    },

    attachedCallback: function() {
      if (this.open) {
        this._pushOverlay();

        if (this._showBackdropOnAttached) {
          // Show the backdrop again
          this._showBackdrop();
        }
      }
    },

    /**
      Open the overlay and set the z-index accordingly.

      @returns {Coral.Component} this, chainable
      @memberof Coral.mixin.overlay#
    */
    show: function() {
      this.open = true;

      return this;
    },

    /**
      Close the overlay.

      @returns {Coral.Component} this, chainable
      @memberof Coral.mixin.overlay#
    */
    hide: function() {
      this.open = false;

      return this;
    },

    /**
      Set the element that focus should be returned to when the overlay is hidden.

      @param {HTMLElement} element
        The element to return focus to. This must be a DOM element, not a jQuery object or selector.

      @returns {Coral.Component} this, chainable
      @memberof Coral.mixin.overlay#
    */
    returnFocusTo: function(element) {
      if (this.returnFocus === returnFocus.OFF) {
        // Switch on returning focus if it's off
        this.returnFocus = returnFocus.ON;
      }

      // If the element is not focusable,
      if (element.offsetParent === null || !element.matches(Coral.commons.FOCUSABLE_ELEMENT_SELECTOR)) {

        // add tabindex so that it is programmatically focusable.
        element.setAttribute('tabindex', -1);

        // On blur, restore element to its prior, not-focusable state
        var tempVent = new Vent(element);
        tempVent.on('blur.afterFocus', function(event) {

          // Wait a frame before testing whether focus has moved to an open overlay or to some other element.
          Coral.commons.nextFrame(function() {

            // If overlay remains open, don't remove tabindex event handler until after it has been closed
            var top = overlays.top();
            if (top && top.instance.contains(document.activeElement)) {
              return;
            }
            tempVent.off('blur.afterFocus');
            event.matchedTarget.removeAttribute('tabindex');
          });
        }, true);
      }

      this._returnFocusToElement = element;
      return this;
    },

    /**
      Check if this overlay is the topmost.

      @protected
      @memberof Coral.mixin.overlay#
    */
    _isTopOverlay: function() {
      var top = overlays.top();
      return top && top.instance === this;
    },

    /**
      Push the overlay to the top of the stack.

      @protected
      @memberof Coral.mixin.overlay#
    */
    _pushOverlay: function() {
      overlays.push(this);
    },

    /**
      Remove the overlay from the stack.

      @protected
      @memberof Coral.mixin.overlay#
    */
    _popOverlay: function() {
      overlays.pop(this);

      // Automatically hide the backdrop if required
      hideOrRepositionBackdrop();
    },

    /**
      Show the backdrop.

      @protected
      @memberof Coral.mixin.overlay#
    */
    _showBackdrop: function() {
      var overlay = overlays.get(this);

      // Overlay is not tracked unless the component is in the DOM
      // Hence, we need to check
      if (overlay) {
        overlay.backdrop = true;
        doBackdropShow(overlay.zIndex, this);
      }

      // Mark on the instance that the backdrop has been requested for this overlay
      this._requestedBackdrop = true;

      // Mark that the backdrop was requested when not attached to the DOM
      // This allows us to know whether to push the overlay when the component is attached
      if (!this.parentNode) {
        this._showBackdropOnAttached = true;
      }

      if (this.trapFocus === trapFocus.ON) {
        createDocumentTabCaptureEls();
      }
    },

    /**
      Show the backdrop.

      @protected
      @memberof Coral.mixin.overlay#
    */
    _hideBackdrop: function() {
      var overlay = overlays.get(this);

      if (overlay) {
        overlay.backdrop = false;

        // If that was the last overlay using the backdrop, hide it
        hideOrRepositionBackdrop();
      }

      // Mark on the instance that the backdrop is no longer needed
      this._requestedBackdrop = false;
    },

    /**
      Handles keypresses on the root of the overlay and marshalls focus accordingly.

      @protected
    */
    _handleRootKeypress: function(event) {
      if (event.target === this && event.keyCode === TAB_KEY) {
        // Skip the top tabcapture and focus on the first focusable element
        this._focusOn('first');

        // Stop the normal tab behavior
        event.preventDefault();
      }
    },

    /**
      Handles focus events on tab capture elements.

      @protected
      @memberof Coral.mixin.overlay#
    */
    _handleTabCaptureFocus: function(event) {
      // Avoid moving around if we're trying to focus on coral-tabcapture
      if (this._ignoreTabCapture) {
        this._ignoreTabCapture = false;
        return;
      }

      // Focus on the correct tabbable element
      var target = event.target;
      var which = (target === this._elements.intermediateTabCapture ? 'first' : 'last');

      this._focusOn(which);
    },

    /**
      Handles the focus behavior. When "on" is specified it would try to find the first tababble descendent in the
      content and if there are no valid candidates it will focus the element itself.

      @protected
      @memberof Coral.mixin.overlay#
    */
    _handleFocus: function() {
      // ON handles the focusing per accessibility recommendations
      if (this.focusOnShow === focusOnShow.ON) {
        this._focusOn('first');
      }
      else if (this.focusOnShow instanceof HTMLElement) {
        this.focusOnShow.focus();
      }
      else if (typeof this.focusOnShow === 'string' && this.focusOnShow !== focusOnShow.OFF) {
        // we need to add :not([coral-tabcapture]) to avoid selecting the tab captures
        var selectedElement = this.querySelector(this.focusOnShow + ':not([coral-tabcapture])');

        if (selectedElement) {
          selectedElement.focus();
        }
        // in case the selector does not match, it should fallback to the default behavior
        else {
          this._focusOn('first');
        }
      }
    },

    /**
      @protected
      @memberof Coral.mixin.overlay#
    */
    _handleReturnFocus: function() {
      if (this.returnFocus === returnFocus.ON && this._elementToFocusWhenHidden) {
        if (document.activeElement && !this.contains(document.activeElement)) {
          // Don't return focus if the user focused outside of the overlay
          return;
        }

        // Return focus, ignoring tab capture if it is an overlay
        this._elementToFocusWhenHidden._ignoreTabCapture = true;
        this._elementToFocusWhenHidden.focus();
        this._elementToFocusWhenHidden._ignoreTabCapture = false;

        // Drop the reference to avoid memory leaks
        this._elementToFocusWhenHidden = null;
      }
    },

    /**
      Focus on the first or last element.

      @param {String} which
        one of "first" or "last"
      @protected
    */
    _focusOn: function(which) {
      var tabTarget;
      if (which === 'first' || which === 'last') {
        // @todo: shall this be focussable or tabbable?
        tabTarget = Array.prototype.filter.call(this.querySelectorAll(Coral.commons.TABBABLE_ELEMENT_SELECTOR), function(item) {
          return item.offsetParent !== null && !item.hasAttribute('coral-tabcapture');
        })[which === 'first' ? 'shift' : 'pop']();
      }

      // if we found a focusing target we focus it
      if (tabTarget) {
        tabTarget.focus();
      }
      // otherwise the element itself should get focus
      else {
        this.focus();
      }
    }
  };

  /**
    Make an object an overlay (prototype or instance).
    @mixin
  */
  Coral.mixin.overlay = function(object, options) {
    // Augment property descriptors
    Coral.register.augmentProperties(options.properties, properties);

    // Add methods
    Coral.commons.augment(object, methods, function(objectMethod, mixinMethod, prop) {
      if (prop === 'hide' || prop === 'show') {
        return mixinMethod;
      }
      return Coral.commons.callAll(mixinMethod, objectMethod);
    });
  };

  // Expose methods on prototype so they may be called by implementing components
  Coral.mixin.overlay.prototype = methods;

  // The time it should take for overlays to fade in milliseconds
  // Important: This should be greater than or equal to the CSS transition time
  Coral.mixin.overlay.FADETIME = 350;

  /**
    Called when the overlay is clicked.

    @function backdropClickedCallback
    @memberof Coral.mixin.overlay#
    @protected
  */

  /**
    Triggerred before the component is opened with <code>show()</code> or <code>instance.open = true</code>.

    @event Coral.mixin.overlay#coral-overlay:beforeopen

    @param {Object} event
      Event object.
    @param {Function} event.preventDefault
      Call to stop the overlay from opening.
  */

  /**
    Triggerred after the overlay is opened with <code>show()</code> or <code>instance.open = true</code>

    @event Coral.mixin.overlay#coral-overlay:open

    @param {Object} event
      Event object.
  */

  /**
    Triggerred before the component is closed with <code>hide()</code> or <code>instance.open = false</code>.

    @event Coral.mixin.overlay#coral-overlay:beforeclose

    @param {Object} event
      Event object.
    @param {Function} event.preventDefault
      Call to stop the overlay from closing.
  */

  /**
    Triggerred after the component is closed with <code>hide()</code> or <code>instance.open = false</code>

    @event Coral.mixin.overlay#coral-overlay:close

    @param {Object} event
      Event object.
  */

  Coral.mixin.overlay.trapFocus = trapFocus;
  Coral.mixin.overlay.returnFocus = returnFocus;
  Coral.mixin.overlay.focusOnShow = focusOnShow;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  function getTagSelector(tag, nativeTag) {
    return nativeTag ? (nativeTag + '[is="' + tag + '"]') : tag;
  }

  var events = function(options) {

    var itemTagName = options.itemTagName;
    var itemBaseTagName = options.itemBaseTagName;
    var itemSelectors = options.itemSelectors || [getTagSelector(itemTagName, itemBaseTagName)];
    var itemSelectorsFlattened = itemSelectors.join(',');

    var events = {};
    events['coral-component:attached ' + itemSelectorsFlattened] = '_onItemAttached';

    return events;
  };

  var properties = function(options) {

    var itemTagName = options.itemTagName;
    var itemBaseTag = options.itemBaseTagName;
    var itemSelectors = options.itemSelectors || [getTagSelector(itemTagName, itemBaseTag)];
    var itemSelectorsFlattened = itemSelectors.join(',');
    var supportMultiple = typeof options.supportMultiple === 'undefined' || options.supportMultiple;
    var containerSelector = options.containerSelector;

    var result = {

      /**
        Returns the first selected item in the selectionList. The value <code>null</code> is returned if no element is
        selected.

        @type {HTMLElement}
        @readonly
        @memberof Coral.mixin.selectionList#
      */
      'selectedItem': {
        get: function() {
          if (this.multiple) {
            // Return the first item when in multiple mode:
            return this.items.getFirstSelected();
          }
          else {
            // Return the last item when in single selection mode:
            return this.items.getLastSelected();
          }
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Returns an Array containing the set selected items.

        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.mixin.selectionList#
      */
      'selectedItems': {
        get: function() {
          return this.items.getSelected();
        },
        set: function() {
          // Read-only
        }
      },

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.mixin.selectionList#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {

            var container = this.querySelector(containerSelector);
            var options = {
              itemTagName: itemTagName,
              itemBaseTag: itemBaseTag,
              itemSelector: itemSelectorsFlattened,
              container: container
            };
            this._items = this._constructCollection(options);
          }

          return this._items;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Whether multiple items can be selected.

        @type {Boolean}
        @default false
        @htmlattribute multiple
        @memberof Coral.mixin.selectionList#
      */
      'multiple': {
        default: false,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.setAttribute('aria-multiselectable', this.multiple);
          this._mutateSelection(function() {
            if (!this.multiple) {
              this.items.deselectAllExceptLast();
            }
          });
        }
      }
    };

    if (!supportMultiple) {
      delete result.selectedItems;
      result.multiple.get = function() {
        return false;
      };
      result.multiple.set = function() {
        // Read-only.
      };
    }

    return result;
  };

  var methods = function(options) {

    var itemTagName = options.itemTagName;
    var itemBaseTag = options.itemBaseTagName;

    var itemSelectors = options.itemSelectors || [getTagSelector(itemTagName, itemBaseTag)];
    var itemSelectorsFlattened = itemSelectors.join(',');

    var role = options.role || 'listbox';
    var tabIndex = options.tabIndex;
    var allowSingleModeDeselect = options.allowSingleModeDeselect;
    var forceSelection = options.forceSelection;

    return {

      /** @private */
      _onItemAttached: function(event) {

        var item = event.target;

        // ':attached' events bubble, so components that hold child components may signal multiple
        // attached events, and lists might be nested. We are only interested in the attachment
        // of list items for which this list is the closest ancestor:
        if (!item.matches(itemSelectorsFlattened) ||
          item.closest(this.tagName.toLowerCase()) !== this
        ) {
          return;
        }

        // Listen to the item being detached directly on the item (delegation will not work in this
        // case because the item will be removed from the display list when the event fires). Bind
        // (just once) the listener to the selectionList instance so it can trigger a
        // 'coral-collection:remove' event from there:
        if (!this._boundOnItemDetached) {
          this._boundOnItemDetached = this._onItemDetached.bind(this);
        }
        item.on('coral-component:detached', this._boundOnItemDetached);

        // See if this affects our selection (we might require a selection when an item is available):
        this._validateSelection();

        this.trigger('coral-collection:add', {
          item: item
        });
      },

      /** @private */
      _onItemDetached: function(event) {
        var item = event.target;

        // Ignore events that came bubbling in (see _onItemAttached comments for detail):
        if (item !== event.currentTarget) {
          return;
        }

        // Stop listening to the item being detached:
        item.off('coral-component:detached', this._boundOnItemDetached);

        // We shouldn't let an item be in a selected state when it is not a child of a selectionList otherwise there can
        // be unexpected behavior in polyfilled environments when the selectionList.Item is re-added to a selectionList.
        // See details in selectionList.Item#selected.
        if (item.selected) {
          // since we removed a selected item, we need to make sure our internals are working correctly. we can do it
          // here since the element has already been removed from the DOM.
          this._oldSelection = this._getSelection();

          // The item is off the display list, so delegate 'deselected' events won't reach us at this point. Hence
          // re-validate the selection here:
          this._validateSelection(item);
        }

        this.trigger('coral-collection:remove', {
          item: item
        });
      },

      /**
        This method should be used by host components to indicate that an item has been interacted with. The routine
        decides what's applicable: toggling the items selection state, or to set it to <code>true</code>.

        Depending on the set properties, the list may decide to mutate the state of other items. It does this such that
        only a single ':change' event will be fired.

        @private
      */
      _selectItem: function(item) {

        // We ignore the select if the item is disabled, or if selection
        // is turned off:
        if (item.disabled) {
          return;
        }

        // Depending on the combination of list parameters, the selection of one item may result in the deselection of
        // others. If that's the case we still want the client to recieve only a single change event. By applying the
        // mutations via _mutateSelection, the old selection is compared to the new after all mutations have been
        // applied. If change is detected, a single event gets triggered.
        this._mutateSelection(function() {

          // If we are in multiple mode, or if we support deselection in single select mode, a click means that the
          // selected state of the selected item gets toggled, rather than set to true:
          if (allowSingleModeDeselect || this.multiple) {
            // Toggle the selection of the item:
            item.selected = !item.selected;
          }
          else {
            // Select the clicked item:
            item.selected = true;
          }
        });
      },

      /**
        Invoked by the item when an item's selected property is set to 'true'.

        @private
      */
      _onItemSelected: function(item) {
        this._mutateSelection(function() {
          if (!this.multiple) {
            this.items.deselectAllExcept(item);
          }
        });
      },

      /**
        Invoked by the item when an item's selected property is set to 'false'.

        @private
      */
      _onItemDeselected: function(item) {
        this._mutateSelection(function() {
          this._validateSelection(item);
        });
      },

      /** @ignore */
      _initialize: function() {
        this.setAttribute('role', role);

        if (typeof tabIndex !== 'undefined') {
          this.setAttribute('tabindex', tabIndex);
        }

        // makes sure that the initial selection is valid. Setting this in the initialize instead of waiting for the
        // itemAttached callback avoids triggering a change event for the initial state
        this._validateSelection();

        // we keep a list of the last selection to determine if something changed. we need to do this after
        // validateSelection since it modifies the initial state based on the option
        this._oldSelection = this._getSelection();
      },

      /** @ignore */
      attachedCallback: function() {
        if (!this.multiple) {
          // Under single-selection mode, deselect all but the selected item that comes last.
          this.items.deselectAllExceptLast();
        }
      },

      /**
        Provide a way for hosts to construct a custom Collection by overriding this method.

        @ignore
      */
      _constructCollection: function(options) {
        options.host = this;
        return new Coral.mixin.selectionList.Collection(options);
      },

      /**
        Used to perform item selected state mutations while making sure only a single ':change' event is emitted when
        done. When the routine exits finding the mutation counter to be zero, it will compare the selection as it found
        it when starting the mutations with the selection when it was done. When there's a diff, the ':change' event is
        fired.

        Works nested if need be.

        @param {Function} mutationsCallback
          function that should contain the item selected state mutions. It gets invoked in the scope of the list.

        @ignore
      */
      _mutateSelection: function(mutationsCallback) {
        this._increaseMutationCounter();

        mutationsCallback.call(this);

        this._decreaseMutationCounter();

        if (this._mutatingSelection === 0) {
          var newSelection = this._getSelection();
          if (this._selectionDiffersFromOldSelection(newSelection)) {
            this._onSelectionChange(newSelection, this._oldSelection);
            // changes the old selection array since we selected something new
            this._oldSelection = newSelection;
          }
        }
      },

      /** @ignore */
      _onSelectionChange: function(newSelection, oldSelection) {
        this.trigger(this.tagName.toLowerCase() + ':change', {
          oldSelection: oldSelection,
          selection: newSelection
        });
      },

      /** @ignore */
      _selectionDiffersFromOldSelection: function(selection) {
        // When both the new and the old selection resolve as empty, do not signal change:
        if (this._isEmptySelection(selection) && this._isEmptySelection(this._oldSelection)) {
          return false;
        }

        // Assess if the new selection differs from the current:
        var oldIsArray = Array.isArray(this._oldSelection);
        var newIsArray = Array.isArray(selection);
        if (!oldIsArray && !newIsArray) {
          return selection !== this._oldSelection;
        }
        else if (oldIsArray && newIsArray) {
          var diff = this._oldSelection.filter(function(item) {
            return selection.indexOf(item) === -1;
          });
          
          return this._oldSelection.length !== selection.length || diff.length !== 0;
        }
        else {
          return true;
        }
      },

      /** @ignore */
      _isEmptySelection: function(selection) {
        return selection === null || typeof selection === 'undefined' || selection.length === 0;
      },

      /** @ignore */
      _getSelection: function() {
        return this.multiple ? this.selectedItems : this.selectedItem;
      },

      /**
        When <code>forceSelection</code> is <code>true</code>, it makes sure that at at least one item is selected.

        @private
      */
      _validateSelection: function(deselectedItem) {
        if (forceSelection) {
          // gets the current selection
          var selection = this.items.getSelected();

          // if no item is currently selected, we need to find a candidate
          if (selection.length === 0) {
            // gets the first candidate for selection
            var selectable = this.items.getNextSelectable(deselectedItem);

            if (selectable) {
              // selects using the attribute in case the item is not yet initialized
              selectable.setAttribute('selected', true);
            }
          }
        }
      },

      _increaseMutationCounter: function() {
        if (typeof this._mutatingSelection === 'undefined') {
          this._mutatingSelection = 1;
        }
        else {
          this._mutatingSelection++;
        }
      },

      _decreaseMutationCounter: function() {
        this._mutatingSelection--;
      }
    };
  };

  /**
    The <code>selectionList</code> mixin adds support for items and their selection to the host component.

    @mixin

    @param {String} mixinOptions.itemTagName
      Defines the type of tag that the list should construct on being passed a configuration object to its
      <code>add</code> method.
    @param {String} [mixinOptions.itemBaseTagName]
      Defines the base type of tag that the list should construct on being passed a configuration object to its
      <code>add</code> method. Specify this option when <code>itemTagName</code> refers to a component that inherits a
      native element.
    @param {Array.<String>} [mixinOptions.itemSelectors]
      The set of selectors that the list uses to fetch all of its children. When unspecified the list creates a selector
      based on the itemTagName and itemBaseTagName.
    @param {String} [mixinOptions.role=listbox]
      Value for the <code>role</code> attribute on the host component.
    @param {Number} [mixinOptions.tabIndex=undefined]
      When defined, adds a <code>tabindex</code> attribute with the to given value to the host component.
    @param {Boolean} [mixinOptions.allowSingleModeDeselect=false]
      When <code>true</code>, clicking a selected item in single select mode will cause it to be unselected.
    @param {Boolean} [mixinOptions.supportMultiple=true]
      When <code>false</code>, the host will not get the <code>selectedItems</code> mixed in, and its
      <code>multiple</code> property will be read-only, set to <code>false</code>.
    @param {Boolean} [mixinOptions.forceSelection=false]
      When <code>true</code>, the host component will enforce at least a single item to be selected, if available.
    @param {String} [mixinOptions.containerSelector]
      Defines where the new items will be added when <code>add</code> method is called.
      Specify this option when items should not be direct children of the host component but should be wrapped instead.
  */
  Coral.mixin.selectionList = function(mixinOptions) {

    return function(prototype, options) {

      // Add methods:
      Coral.commons.augment(prototype, methods(mixinOptions), function(objectMethod, mixinMethod, prop) {
        return Coral.commons.callAll(mixinMethod, objectMethod);
      });

      // Define events, letting the object override the mixin:
      prototype._events = Coral.commons.augment({}, prototype._events, events(mixinOptions));

      // Augment props:
      Coral.register.augmentProperties(options.properties, properties(mixinOptions));
    };
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  function getTagSelector(tag, nativeTag) {
    return nativeTag ? (nativeTag + '[is="' + tag + '"]') : tag;
  }

  /**
    The default Collection as used by 'selectionList'.

    @param options.host {HTMLElement}
      The element that hosts the collection
    @param options.itemTagName {String}
      The tag name of the elements that constitute a collection item.
    @param options.itemBaseTag {String}
      The optional base tag name of the elements that constitute a collection item. This is required for elements that
      extend native elements, like Button.
    @param options.itemSelector {String}
      Optional, derived from itemTagName and itemBaseTag by default. Used to query the host element for its collection
      items.
    @param options.container {HTMLElement}
      Optional element that wraps the collection.
      Defines where the new items will be added when <code>add</code> method is called.
      Is the same as options.host by default.

    @constructor
    @ignore
   */
  var Collection = function(options) {
    this._host = options.host;
    this._itemTagName = options.itemTagName;
    this._itemBaseTag = options.itemBaseTag;
    this._itemSelector = options.itemSelector || getTagSelector(this._itemTagName, this._itemBaseTag);
    this._host.id = this._host.id || Coral.commons.getUID();
    this._nonNestedItemSelector = '#' + this._host.id  + ' ' + this._host.tagName.toLowerCase() + ' ' + this._itemSelector;

    // container where the new items are added
    this._container = options.container || this._host;
  };

  // Assigns the prototype to get access to the Collection signature methods:
  Collection.prototype = Object.create(Coral.Collection.prototype);

  // Create a new element from a given configuration object:
  Collection.prototype.createElement = function(itemTagName, itemBaseTag) {
    return itemBaseTag ? document.createElement(itemBaseTag, itemTagName) : document.createElement(itemTagName);
  };

  Collection.prototype.add = function(item, before) {
    var config;
    if (!(item instanceof HTMLElement)) {
      // Creates a new item and initializes its values:
      config = item;
      item = this.createElement(this._itemTagName, this._itemBaseTag, item);
    }

    // Configurate the item, but don't apply selection yet (for we do not allow this before
    // the item is attached).
    var selected = config && config.selected;
    if (config) {
      delete config.selected;
      // Silently apply the settings:
      item.set(config, true);
    }

    // 'insertBefore' with an undefined "before" argument fails on IE9.
    this._container.insertBefore(item, before || null);

    // Now apply the selected state, non-silently, so that the host will be informed of this
    // item being added selected:
    if (selected) {
      item.selected = selected;
    }

    return item;
  };

  Collection.prototype.getAll = function() {
    return this._getNonNestedItems();
  };

  Collection.prototype.getNextSelectable = function(item, wrap) {
    var items = this._getSelectableItems();
    var index = items.indexOf(item);
  
    // in case the item is not specified, or it is not inside the collection, we need to return the first selectable
    if (index === -1) {
      return items[0] || null;
    }
  
    if (wrap) {
      return index === (items.length - 1) ? items[0] : items[index + 1];
    }
    else {
      return index === (items.length - 1) ? item : items[index + 1];
    }
  };

  Collection.prototype.getPreviousSelectable = function(item, wrap) {
    var items = this._getSelectableItems();
    var index = items.indexOf(item);
  
    // in case the item is not specified, or it is not inside the collection, we need to return the first selectable
    if (index === -1) {
      return items[0] || null;
    }
    
    if (wrap) {
      return index === 0 ? (items[items.length - 1] || null) : items[index - 1];
    }
    else {
      return index === 0 ? item : items[index - 1];
    }
  };

  Collection.prototype.getFirstSelectable = function() {
    return this._getSelectableItems()[0] || null;
  };

  Collection.prototype.getLastSelectable = function() {
    return this._getSelectableItems().pop() || null;
  };

  Collection.prototype.getSelected = function() {
    return this._getSelectedItems();
  };

  Collection.prototype.getFirstSelected = function() {
    return this._getSelectedItems()[0] || null;
  };

  Collection.prototype.getLastSelected = function() {
    return this._getSelectedItems().pop() || null;
  };

  Collection.prototype.deselectAll = function() {
    this
      ._getNonNestedItems()
      .filter(function(item) {
        return item.hasAttribute('selected');
      })
      .forEach(function(item) {
        item.removeAttribute('selected');
      });
  };

  Collection.prototype.deselectAllExcept = function(item) {
    this
      ._getNonNestedItems()
      .filter(function(item) {
        return item.hasAttribute('selected');
      })
      .forEach(function(el) {
        if (el !== item) {
          el.removeAttribute('selected');
        }
      });
  };

  Collection.prototype.deselectAllExceptLast = function() {
    this
      ._getNonNestedItems()
      .filter(function(item) {
        return item.hasAttribute('selected');
      })
      .slice(0, -1)
      .forEach(function(item) {
        item.removeAttribute('selected');
      });
  };

  /*
    Internal
  */

  /**
    Gets a list of all non nested child items.

    @private

    @returns {Array.<HTMLElement>} items.
  */
  Collection.prototype._getNonNestedItems = function() {
    var nonNestedItems = Array.prototype.slice.call(this._host.querySelectorAll(this._nonNestedItemSelector));
    var items = Array.prototype.slice.call(this._host.querySelectorAll(this._itemSelector));
    
    return items.filter(function(item) {
      return nonNestedItems.indexOf(item) === -1;
    });
  };

  /**
    Gets a list of all selectable items. For an item to be selectable it cannot be disabled or hidden.

    @private

    @returns {Array.<HTMLElement>} items.
  */
  Collection.prototype._getSelectableItems = function() {
    return this._getNonNestedItems()
      .filter(function(item) {
        return !(item.hasAttribute('disabled') || item.hasAttribute('hidden'));
      });
  };

  /**
    Gets a list of all selected items. A selected item can be hidden.

    @private

    @returns {Array.<HTMLElement>} items.
  */
  Collection.prototype._getSelectedItems = function() {
    return this._getNonNestedItems()
      .filter(function(item) {
        return item.hasAttribute('selected') && !item.hasAttribute('disabled');
      });
  };

  /**
    The default Collection as used by 'selectionList'.
    @class
    @extends Coral.Collection
    @ignore
  */
  Coral.mixin.selectionList.Collection = Collection;
})();

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var properties = function(options) {

    var alwaysEnabled = options.alwaysEnabled;

    var properties = {

      /**
        Whether the item is selected. Selected cannot be set to <code>true</code> if the item is disabled.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.mixin.selectionList.Item#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        validate: [
          Coral.validate.valueMustChange,
          function(value) {
            return !value || !this.disabled;
          }
        ],
        trigger: function(newValue, oldValue) {
          // Although we're not dispatching an event, we do use the 'trigger' property because
          // we do not want to invoke the callback on first change (and since the initial value
          // is set 'silently', invoking the callback from here will achieve just that).
          var list = this._getSelectionList();
          if (list) {
            var callback = newValue ? list._onItemSelected : list._onItemDeselected;
            if (callback && Object.prototype.toString.call(callback) === '[object Function]') {
              callback.call(list, this);
            }
          }
          // No event, no prevent-default:
          return false;
        },
        set: function(value, silent) {
          this._selected = value;
        },
        sync: function() {
          this.classList.toggle('is-selected', this.selected);
          this.setAttribute('aria-selected', this.selected);
        }
      },

      /**
        Whether this item is disabled. When set to <code>true</code>, this will prevent every user interaction with the
        item. If disabled is set to <code>true</code> for a selected item it will be deselected.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.mixin.selectionList.Item#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value, silent) {
          this._disabled = value;

          if (this.selected && value) {
            this.selected = false;
          }
        },
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this.setAttribute('aria-disabled', this.disabled);
        }
      }

    };

    if (alwaysEnabled) {
      delete properties.disabled;
    }

    return properties;
  };

  var methods = function(options) {

    var role = options.role || 'option';
    var tabIndex = options.tabIndex;
    var listSelector = options.listSelector;

    return {
      /** @ignore */
      _initialize: function() {
        this.setAttribute('role', role);
        if (typeof tabIndex !== 'undefined') {
          this.setAttribute('tabindex', tabIndex);
        }
      },

      /** @private */
      _getSelectionList: function() {
        return this.closest(listSelector);
      }

    };
  };

  /**
    The <code>selectionList.Item</code> mixes in features that are expected to be present on child elements of
    components that mixin <code>selectionList</code>.

    @mixin

    @param {String} mixinOptions.listSelector
      Used to allow the item to obtain a reference to its <code>selectionList</code> implementing ancestor.
    @param {String} [mixinOptions.role=option]
      Value for the <code>role</code> attribute on the host component.
    @param {Number} [mixinOptions.tabIndex=undefined]
      When defined, ads a <code>tabindex</code> attribute with the to given value to the host component.
    @param {Boolean} [mixinOptions.alwaysEnabled=undefined]
      When <code>true</code>, the <code>disabled</code> property will not be added to the host component.
  */
  Coral.mixin.selectionList.Item = function(mixinOptions) {
    return function(prototype, options) {

      // Add methods:
      Coral.commons.augment(prototype, methods(mixinOptions), function(objectMethod, mixinMethod, prop) {
        return Coral.commons.callAll(mixinMethod, objectMethod);
      });

      // Augment props:
      Coral.register.augmentProperties(options.properties, properties(mixinOptions));
    };
  };
})();

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories
  var LABELLABLE_ELEMENTS_SELECTOR = 'button,input:not([type=hidden]),keygen,meter,output,progress,select,textarea';
  // @polyfill ie11
  // IE11 throws syntax error because of the "not()" in the selector for some reason in ColorInputColorProperties
  if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
    LABELLABLE_ELEMENTS_SELECTOR = 'button,keygen,meter,output,progress,select,textarea,';
    
    // Since we can't use :not() we have to indicate all input types
    [
      'text',
      'password',
      'submit',
      'reset',
      'radio',
      'checkbox',
      'button',
      'color',
      'date',
      'datetime-local',
      'email',
      'month',
      'number',
      'range',
      'search',
      'tel',
      'time',
      'url',
      'week'
    ].forEach(function(type) {
      LABELLABLE_ELEMENTS_SELECTOR += 'input[type="'+ type +'"],';
    });
    
    // Remove last ","
    LABELLABLE_ELEMENTS_SELECTOR = LABELLABLE_ELEMENTS_SELECTOR.slice(0, -1);
  }
  // _onInputChange is only triggered on non-hidden inputs
  var TARGET_INPUT_SELECTOR = 'input:not([type=hidden])';

  var properties = {
    /**
      Whether this field is disabled or not.

      @type {Boolean}
      @default false
      @htmlattribute disabled
      @htmlattributereflected
      @memberof Coral.mixin.formField#
    */
    'disabled': {
      default: false,
      reflectAttribute: true,
      transform: Coral.transform.boolean,
      attributeTransform: Coral.transform.booleanAttr,
      sync: function() {
        this.setAttribute('aria-disabled', this.disabled);
      }
    },

    /**
      Whether the current value of this field is invalid or not.

      @type {Boolean}
      @default false
      @htmlattribute invalid
      @htmlattributereflected
      @memberof Coral.mixin.formField#
    */
    'invalid': {
      default: false,
      reflectAttribute: true,
      transform: Coral.transform.boolean,
      attributeTransform: Coral.transform.booleanAttr,
      sync: function() {
        this.setAttribute('aria-invalid', this.invalid);
      }
    },

    /**
      Name used to submit the data in a form.

      @type {String}
      @default ""
      @htmlattribute name
      @htmlattributereflected
      @memberof Coral.mixin.formField#
    */
    'name': {
      default: '',
      reflectAttribute: true,
      transform: Coral.transform.string
    },

    /**
      Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
      This is ignored for checkbox, radio or fileupload.

      @type {Boolean}
      @default false
      @htmlattribute readonly
      @htmlattributereflected
      @memberof Coral.mixin.formField#
    */
    'readOnly': {
      default: false,
      reflectAttribute: true,
      attribute: 'readonly',
      transform: Coral.transform.boolean,
      attributeTransform: Coral.transform.booleanAttr,
      sync: function() {
        this.setAttribute('aria-readonly', this.readOnly);
      }
    },

    /**
      Whether this field is required or not.

      @type {Boolean}
      @default false
      @htmlattribute required
      @htmlattributereflected
      @memberof Coral.mixin.formField#
    */
    'required': {
      default: false,
      reflectAttribute: true,
      transform: Coral.transform.boolean,
      attributeTransform: Coral.transform.booleanAttr,
      sync: function() {
        this.setAttribute('aria-required', this.required);
      }
    },

    /**
      This field's current value.

      @type {String}
      @default ""
      @htmlattribute value
      @memberof Coral.mixin.formField#

      @fires Coral.mixin.formField#change
    */
    'value': {
      default: '',
      transform: Coral.transform.string
    },

    /**
      Reference to a space delimited set of ids for the HTML elements that provide a label for the formField.
      Implementers should override this method to ensure that the appropriate descendant elements are labelled using the
      <code>aria-labelledby</code> attribute. This will ensure that the component is properly identified for
      accessibility purposes. It reflects the <code>aria-labelledby</code> attribute to the DOM.

      @type {?String}
      @default null
      @htmlattribute labelledby
      @memberof Coral.mixin.formField#
    */
    'labelledBy': {
      attribute: 'labelledby',
      transform: Coral.transform.string,
      get: function() {
        return this._getLabellableElement().getAttribute('aria-labelledby');
      },
      set: function(value) {
        // gets the element that will get the label assigned. the _getLabellableElement method should be overriden to
        // allow other bevaviors.
        var element = this._getLabellableElement();
        // we get and assign the it that will be passed around
        var elementId = element.id = element.id || Coral.commons.getUID();

        var currentLabelledBy = element.getAttribute('aria-labelledby');

        // we clear the old label asignments
        if (currentLabelledBy && currentLabelledBy !== value) {
          this._updateForAttributes(currentLabelledBy, elementId, true);
        }

        if (value) {
          element.setAttribute('aria-labelledby', value);
          if (element.matches(LABELLABLE_ELEMENTS_SELECTOR)) {
            this._updateForAttributes(value, elementId);
          }
        }
        else {
          // since no labelledby value was set, we remove everything
          element.removeAttribute('aria-labelledby');
        }
      }
    }
  };

  // Methods to add
  var methods = {
    /**
      Gets the element that should get the label. In case none of the valid labelelable items are found, the component
      will be labelled instead.

      @protected
      @memberof Coral.mixin.formField#

      @returns {HTMLElement} the labellable element.
    */
    _getLabellableElement: function() {
      var element = this.querySelector(LABELLABLE_ELEMENTS_SELECTOR);

      // Use the found element or the container
      return element || this;
    },

    /**
      Gets the internal input that the mixin.formField would watch for change. By default, it searches if the
      <code>_getLabellableElement()</code> is an input. Components can override this function to be able to provide a
      different implementation. In case the value is <code>null</code>, the change event will be handled no matter
      the input that produced it.

      @protected
      @memberof Coral.mixin.formField#

      @return {HTMLElement} the input to watch for changes.
    */
    _getTargetChangeInput: function() {
      // we use this._targetChangeInput as an internal cache to avoid querying the DOM again every time
      return this._targetChangeInput ||
        // assignment returns the value
        (this._targetChangeInput = this._getLabellableElement().matches(TARGET_INPUT_SELECTOR) ?
          this._getLabellableElement() : null);
    },

    /**
      Function called whenever the target component triggers a change event. <code>_getTargetChangeInput</code> is used
      internally to determine if the input belongs to the component. If the component decides to override this function,
      the default from the mixin will not be called.

      @protected
      @memberof Coral.mixin.formField#
    */
    _onInputChange: function(event) {
      // stops the current event
      event.stopPropagation();

      this[this._componentTargetProperty] = event.target[this._eventTargetProperty];

      // Explicitly re-emit the change event after the property has been set
      if (this._triggerChangeEvent) {
        this.trigger('change');
      }
    },

    /**
      Resets the formField when a reset is triggered on the parent form.

      @protected
      @memberof Coral.mixin.formField#
    */
    _onFormReset: function(event) {
      if (event.target.contains(this)) {
        this.reset();
      }
    },

    /**
      We capture every input change and validate that it belongs to our target input. If this is the case,
      <code>_onInputChange</code> will be called with the same event.

      @protected
      @memberof Coral.mixin.formField#
    */
    _onTargetInputChange: function(event) {
      var targetInput = this._getTargetChangeInput();
      // if the targetInput is null we still call _onInputChange to be backwards compatible
      if (targetInput === event.target || targetInput === null) {
        // we call _onInputChange since the target matches
        this._onInputChange(event);
      }
    },

    /**
      A utility method for adding the appropriate <code>for</code> attribute to any <code>label</code> elements
      referenced by the <code>labelledBy</code> property value.

      @param {String} labelledBy
        The value of the <code>labelledBy<code> property providing a space-delimited list of the <code>id</code>
        attributes for elements that label the formField.
      @param {String} elementId
        The <code>id</code> of the formField or one of its descendants that should be labelled by
        <code>label</code> elements referenced by the <code>labelledBy</code> property value.
      @param {Boolean} remove
        Whether the existing <code>for</code> attributes should be removed.

      @protected
      @memberof Coral.mixin.formField#
    */
    _updateForAttributes: function(labelledBy, elementId, remove) {
      // labelledby contains whitespace sparated items, so we need to separate each individual id
      var labelIds = labelledBy.split(/\s+/);
      // we update the 'for' attribute for every id.
      labelIds.forEach(function(currentValue) {
        var labelElement = document.getElementById(currentValue);
        if (labelElement && labelElement.tagName === 'LABEL') {
          var forAttribute = labelElement.getAttribute('for');

          if (remove) {
            // we just remove it when it is our target
            if (forAttribute === elementId) {
              labelElement.removeAttribute('for');
            }
          }
          else {
            // if we do not have to remove, it does not matter the current value of the label, we can set it in every
            // case
            labelElement.setAttribute('for', elementId);
          }
        }
      });
    },

    /**
      Clears the <code>value</code> of formField to the default value.
    */
    clear: function() {
      this.value = '';
    },

    /**
      Resets the <code>value</code> to the initial value.
    */
    reset: function() {
      // since the 'value' property is not reflected, form components use it to restore the initial value. When a
      // component has support for values, this method needs to be overwritten
      this.value = Coral.transform.string(this.getAttribute('value'));
    }
  };

  // Events to add
  var events = {
    'capture:change input': '_onTargetInputChange',
    'global:reset': '_onFormReset'
  };

  // The properties whose set/get methods must be implemented by the component we're mixed into
  var requiredPropertySet = [
    'name',
    'value'
  ];

  // Props we should not add if we inhert from HTMLInputElement
  var defaultProps = [
    'disabled',
    'name',
    'required',
    'readOnly',
    'value'
  ];

  // Basic properties to add to the prototype
  var basicProperties = {
    /**
      Target property inside the component that will be updated when a change event is triggered.

      @type {String}
      @default "value"
      @protected
      @memberof Coral.mixin.formField#
    */
    _componentTargetProperty: 'value',

    /**
      Target property that will be taken from <code>event.target</code> and set into
      {@link Coral.mixin.formField#_componentTargetProperty} when a change event is triggered.

      @type {String}
      @default "value"
      @protected
      @memberof Coral.mixin.formField#
    */
    _eventTargetProperty: 'value',


    /**
      Whether the change event needs to be triggered when {@link Coral.mixin.formField#_onInputChange} is called.

      @type {Boolean}
      @default true
      @protected
      @memberof Coral.mixin.formField#
    */
    _triggerChangeEvent: true
  };

  /**
    Configure a component to have the basic properties that are expected inside a form.

    @class
  */
  Coral.mixin.formField = function(prototype, options) {
    // Add methods
    Coral.commons.augment(prototype, methods, function(objectMethod, mixinMethod, propName) {
      // Use the provided methods if overridden
      if (propName === 'reset' ||
        propName === 'clear' ||
        propName === '_onTargetInputChange' ||
        propName === '_onInputChange' ||
        propName === '_getTargetChangeInput' ||
        propName === '_getLabellableElement') {
        return objectMethod;
      }
      return Coral.commons.callAll(mixinMethod, objectMethod);
    });

    // Define events, letting the object override the mixin
    prototype._events = Coral.commons.augment({}, prototype._events, events);

    // Define basic properties, letting the object override the mixin
    Coral.commons.augment(prototype, basicProperties);

    // Only try to include properties that are not defined in this or any parent prototype
    var targetProperties = {};
    var prop;

    // Check if the prototype inherits from HTMLInputElement
    var skipDefaultProps = false;
    var curProto = prototype;
    while (curProto) {
      if (curProto === HTMLInputElement.prototype || curProto === HTMLTextAreaElement.prototype) {
        skipDefaultProps = true;
        break;
      }
      curProto = Object.getPrototypeOf(curProto);
    }

    for (prop in properties) {
      // Skip properties implemented by HTMLInputElement if necessary
      if (skipDefaultProps && defaultProps.indexOf(prop) !== -1) {
        continue;
      }
      targetProperties[prop] = properties[prop];
    }

    // Property sync is not reinforced if they were not added
    if (!skipDefaultProps) {
      // Throw if required set methods are not implemented
      requiredPropertySet.forEach(function(propName) {
        if (!targetProperties[propName]) {
          // Do not complain if it is already implemented
          return;
        }

        if (
          !options.properties[propName] ||
          typeof options.properties[propName].set !== 'function' ||
          typeof options.properties[propName].get !== 'function'
        ) {
          throw new Error('Coral.mixin.formField: You must implement properties.' + propName +
            '.set() and properties.' + propName + '.get()');
        }
      });
    }

    // Augment property descriptors
    Coral.register.augmentProperties(options.properties, targetProperties);
  };

  /**
    Triggered when the value has changed. This event is only triggered by user interaction.

    @event Coral.mixin.formField#change

    @param {Object} event
      Event object.
  */
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Regex used to remove the modifier classes. Size related classes are not matched this regex.

    @ignore
  */
  var ICON_REGEX = /[\s?]coral3-Icon--(?!size(XXS|XS|S|M|L))\w+/g;

  /**
    Regex used to match URLs. Assume it's a URL if it has a slash, colon, or dot.

    @ignore
  */
  var URL_REGEX = /\/|:|\./g;

  /**
    Regex used to split camel case icon names into more screen-reader friendly alt text.

    @ignore
  */
  var SPLIT_CAMELCASE_REGEX = /([a-z0-9])([A-Z])/g;

  /**
    Icons can be rendered in different sizes. It follows the shirt sizing naming convention to help you remember them
    easily.

    @enum {String}
    @memberof Coral.Icon
  */
  var size = {
    /** Extra extra small size icon, typically 9px size. */
    EXTRA_EXTRA_SMALL: 'XXS',
    /** Extra small size icon, typically 12px size. */
    EXTRA_SMALL: 'XS',
    /** Small size icon, typically 18px size. This is the default size. */
    SMALL: 'S',
    /** Medium size icon, typically 24px size. */
    MEDIUM: 'M',
    /** Large icon, typically 36px size. */
    LARGE: 'L',
    /** Extra large icon, typically 48px size. */
    EXTRA_LARGE: 'XL',
    /** Extra extra large icon, typically 72px size. */
    EXTRA_EXTRA_LARGE: 'XXL'
  };

  // icon's base classname
  var CLASSNAME = 'coral3-Icon';

  // builds an array containing all possible size classnames. this will be used to remove classnames when the size
  // changes
  var ALL_SIZE_CLASSES = [];
  for (var sizeValue in size) {
    ALL_SIZE_CLASSES.push(CLASSNAME + '--size' + size[sizeValue]);
  }

  Coral.register( /** @lends Coral.Icon# */ {
    /**
      @class Coral.Icon
      @classdesc An Icon component
      @extends Coral.Component
      @htmltag coral-icon
    */
    name: 'Icon',
    tagName: 'coral-icon',
    className: CLASSNAME,

    properties: {
      /**
        Icon name accordion to the CloudUI Icon sheet.

        @type {String}
        @default ""
        @htmlattribute icon
        @htmlattributereflected
        @memberof Coral.Icon#
      */
      'icon': {
        default: '',
        reflectAttribute: true,
        transform: function(value) {
          // we need to trim posible values because classList does not support trailing whitespaces
          return Coral.transform.string(value).trim();
        },
        sync: function() {
          // removes the old class.
          this.className = this.className.replace(ICON_REGEX, '').trim();

          // sets the desired icon
          if (this.icon) {
            // Detect if it's a URL
            if (this.icon.match(URL_REGEX)) {
              // Note that we're an image so we hide the font-related goodies
              this.classList.add('is-image');

              // Create an image and add it to the icon
              var img = this._elements.image = this._elements.image || document.createElement('img');
              img.className = this._className + '-image';
              img.src = this.icon;
              this.appendChild(img);
            }
            else {
              if (this._elements.image && this._elements.image.parentNode === this) {
                // Remove image related stuff
                this.removeChild(this._elements.image);
                this.classList.remove('is-image');
              }
              this.classList.add(this._className + '--' + this._icon);
            }
          }
        },
        alsoSync: 'alt'
      },

      /**
        Size of the icon. It accepts both lower and upper case sizes.

        @type {Coral.Icon.size}
        @default Coral.Icon.size.SMALL
        @htmlattribute size
        @htmlattributereflected
        @memberof Coral.Icon#
      */
      'size': {
        default: size.SMALL,
        reflectAttribute: true,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        sync: function() {
          // removes all the existing sizes
          this.classList.remove.apply(this.classList, ALL_SIZE_CLASSES);
          // adds the new size
          this.classList.add(this._className + '--size' + this.size);
        }
      },

      /**
        Alternative text to identify the icon for accessibility.
        <p>When no <code>alt</code> attribute is provided, the icon will fallback to using either the <code>title</code> attribute or icon name as alternative text for accessibility. However, by explicitly setting the <code>alt</code> attribute to an empty string in markup or by using the <code>setAttribute</code> method, one can override the default behavior to avoid redundancy or to indicate that the icon is purely decorative in elements like labelled icon buttons.</p>

        @type {String}
        @htmlattribute alt
        @htmlattributereflected
        @memberof Coral.Icon#
      */
      'alt': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        get: function() {
          return this._alt || '';
        },
        sync: function() {
          this._updateAltText();
        }
      }
    },

    /**
      Updates the aria-label or img alt attribute depending on value of alt, title or icon.
      @protected
    */
    _updateAltText: function() {
      var isImage = this.classList.contains('is-image');

      // If alt has explicitly been set to null, remove all attributes
      if (!this._alt) {
        this.removeAttribute('aria-label');
        if (isImage) {
          this._elements.image.setAttribute('alt', '');
        }
      }

      // Fall back to the title attribute, then the icon name
      var altText = !!this._alt || this.hasAttribute('alt') ? this.alt : this.getAttribute('title') || (isImage ? '' : this.icon.replace(SPLIT_CAMELCASE_REGEX, '$1 $2').toLowerCase());

      // If no other role has been set, provide the appropriate
      // role depending on whether or not the icon is an arbitrary image URL.
      var role = this.getAttribute('role');
      var roleOverride = (role && (role !== 'presentation' && role !== 'img'));
      if (!roleOverride) {
        this.setAttribute('role', isImage ? 'presentation' : 'img');
      }

      // Set accessibility attributes accordingly
      if (isImage) {
        this.removeAttribute('aria-label');
        this._elements.image.setAttribute('alt', altText);
      }
      else if (altText === '') {
        this.removeAttribute('aria-label');
        if (!roleOverride) {
          this.removeAttribute('role');
        }
      }
      else {
        this.setAttribute('aria-label', altText);
      }
    },

    /** @ignore */
    _initialize: function() {
      this._queueSync();
    },

    /** @ignore */
    attributeChangedCallback: function(attrName, oldValue, newValue) {
      attrName = attrName.toLowerCase();
      if (attrName === 'title') {
        this._updateAltText();
        return;
      }

      // Call top level attributeChangedCallback, which sets internal property values
      Coral.Component.prototype.attributeChangedCallback.apply(this, arguments);

      // In cases where the alt attribute has been removed or set to an empty string,
      // for example, when the alt property is undefined and we add the attribute alt=''
      // to explicitly override the default behavior, or when we remove an alt attribute
      // thus restoring the default behavior, we make sure to update the alt text.
      if (attrName === 'alt' && (newValue === null || (oldValue === null && newValue === ''))) {
        this._updateAltText();
      }
    }
  });

  // exports the sizes enumeration
  Coral.Icon.size = size;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for button variant values.

    @enum {String}
    @memberof Coral.Button
  */
  var variant = {
    /** A button that is meant to grab the user's attention. */
    CTA: 'cta',
    /** A button that indicates that the button's action is the primary action. */
    PRIMARY: 'primary',
    /** A default, gray button */
    SECONDARY: 'secondary',
    /** An alias to secondary, included for backwards compatibility. */
    DEFAULT: 'secondary',
    /** A button with no border or background. */
    QUIET: 'quiet',
    /** A button that indicates that the button's action is dangerous. */
    WARNING: 'warning',
    /** A minimal button with no background or border. */
    MINIMAL: 'minimal'
  };

  // the button's base classname
  var CLASSNAME = 'coral3-Button';

  // builds an array containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  /**
    Enumeration representing button sizes.

    @memberof Coral.Button
    @enum {String}
  */
  var size = {
    /** A medium button is the default, normal sized button. */
    MEDIUM: 'M',
    /** A large button, which is larger than a medium button. */
    LARGE: 'L'
  };

  /**
    Enumeration representing the icon position inside the button.

    @memberof Coral.Button
    @enum {String}
  */
  var iconPosition = {
    /** Position should be right of the button label. */
    RIGHT: 'right',
    /** Position should be left of the button label. */
    LEFT: 'left'
  };

  Coral.register( /** @lends Coral.Button# */ {
    /**
      @class Coral.Button
      @classdesc A Button component
      @htmltag coral-button
      @htmlbasetag button
      @extends Coral.Component
      @extends HTMLButtonElement
    */
    name: 'Button',
    tagName: 'coral-button',
    baseTagName: 'button',
    extend: HTMLButtonElement,
    className: CLASSNAME,

    events: {
      'mousedown': '_onMouseDown'
    },

    properties: {
      /**
        The label of the button.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Button#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-button-label',
        defaultContentZone: true,
        insert: function(label) {
          this.appendChild(label);
        }
      }),

      /**
        Position of the icon relative to the label. If no <code>iconPosition</code> is provided, it will be set on the
        left side by default.

        @type {Coral.Button.iconPosition}
        @default Coral.Button.iconPosition.LEFT
        @htmlattribute iconposition
        @htmlattributereflected
        @memberof Coral.Button#
      */
      'iconPosition': {
        attribute: 'iconposition',
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(iconPosition)
        ],
        transform: function(value) {
          // defaults the icon positon to LEFT in case the attribute is removed or null is set
          return value !== null ? value : iconPosition.LEFT;
        },
        get: function() {
          // if the value is not explicitely set, we assume that it is LEFT
          return typeof this._iconPosition === 'undefined' ? iconPosition.LEFT : this._iconPosition;
        },
        set: function(value) {
          this._iconPosition = value;

          if (this.icon) {
            this._updateIcon(this.icon);
          }
        }
      },

      /**
        Specifies the icon name used inside the button. See {@link Coral.Icon} for valid icon names.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Button#

        @see {@link Coral.Icon}
      */
      'icon': {
        get: function() {
          var iconElement = this._elements.icon;
          return iconElement ? iconElement.icon : '';
        },
        set: function(value) {
          this._updateIcon(value);
        }
      },

      /**
        Size of the icon. It accepts both lower and upper case sizes.

        @type {Coral.Icon.size}
        @default Coral.Icon.size.SMALL
        @htmlattribute iconsize
        @memberof Coral.Button#

        @see {@link Coral.Icon#size}
      */
      'iconSize': {
        attribute: 'iconsize',
        get: function() {
          var iconElement = this._elements.icon;
          return iconElement ? iconElement.size : Coral.Icon.size.SMALL;
        },
        set: function(value) {
          this._getIconElement().size = value;
        }
      },

      /**
        The size of the button. It accepts both lower and upper case sizes. Currently only "M" (the default) and "L"
        are available.

        @type {Coral.Button.size}
        @default Coral.Button.size.MEDIUM
        @htmlattribute size
        @htmlattributereflected
        @memberof Coral.Button#
      */
      'size': {
        default: size.MEDIUM,
        reflectAttribute: true,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        set: function(newSize) {
          this._size = newSize;

          this.classList.toggle(CLASSNAME + '--large', this.size === size.LARGE);
        }
      },

      /**
        Whether the button is selected.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Button#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(selected) {
          this._selected = selected;

          this.classList.toggle('is-selected', this.selected);
        }
      },

      /**
        Expands the button to the full width of the parent.

        @type {Boolean}
        @default false
        @htmlattribute block
        @htmlattributereflected
        @memberof Coral.Button#
      */
      'block': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(block) {
          this._block = block;

          this.classList.toggle(this._className + '--block', this.block);
        }
      },

      /**
        The button's variant.

        @type {Coral.Button.variant}
        @default Coral.Button.variant.SECONDARY
        @htmlattribute variant
        @htmlattributereflected
        @memberof Coral.Button#
      */
      'variant': {
        default: variant.SECONDARY,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        set: function(variant) {
          this._variant = variant;

          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          this.classList.add(this._className + '--' + this.variant);
        }
      }
    },

    /** @ignore */
    _updateIcon: function(value) {
      var iconElement = this._getIconElement();
      iconElement.icon = value;

      // removes the icon element from the DOM.
      if (this.icon === '') {
        iconElement.remove();
      }
      // add or adjust the icon. Add it back since it was blown away by textContent
      else if (!iconElement.parentNode || this._iconPosition) {
        // insertBefore with <code>null</code> appends
        this.insertBefore(iconElement, this.iconPosition === iconPosition.LEFT ? this.firstChild : null);
      }

      // makes sure the button is correctly annotated
      this._makeAccessible();
    },

    /**
      Forces button to receive focus on mousedown
      @param {MouseEvent} event mousedown event
      @ignore
    */
    _onMouseDown: function(event) {
      var target = event.matchedTarget;

      // Wait a frame or button won't receive focus in Safari.
      Coral.commons.nextFrame(function() {
        if (target !== document.activeElement) {
          target.focus();
        }
      });
    },

    /**
      Sets the correct accessibility annotations on the icon element.

      @protected
    */
    _makeAccessible: function() {
      var hasLabel = this.label && this.label.textContent.length > 0;

      // when the button has a icon, we need to make sure it is labelled correctly
      if (this.icon !== '') {
        // in case there is a label, we set alt='' to treat the icon as decorative. if this is not the case, we remove
        // the alt which causes the icon to provide its default behavior
        this._elements.icon[hasLabel ? 'setAttribute' : 'removeAttribute']('alt', '');
      }
    },

    /** @ignore */
    _initialize: function() {
      // Listen for mutations
      this._observer = new MutationObserver(this._makeAccessible.bind(this));

      // Watch for changes to the label element
      this._observer.observe(this.label, {
        childList: true, // Catch changes to childList
        characterData: true, // Catch changes to textContent
        subtree: true // Monitor any child node
      });
    },

    /** @ignore */
    _getIconElement: function() {
      if (!this._elements.icon) {
        this._elements.icon = document.createElement('coral-icon');
      }
      return this._elements.icon;
    },

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var fragment = document.createDocumentFragment();

      // Create or fetch the label element.
      var label = this.querySelector('coral-button-label') || document.createElement('coral-button-label');

      // Remove it so we can process children
      if (label.parentNode) {
        this.removeChild(label);
      }

      // Process remaining elements as necessary
      while (this.firstChild) {
        var child = this.firstChild;

        if (child.tagName === 'CORAL-ICON') {
          // Conserve existing icon element to content
          this._elements.icon = child;
          fragment.appendChild(child);
        }
        else {
          // Move anything else into the label
          label.appendChild(child);
        }
      }

      // Add the frag to the component
      this.appendChild(fragment);

      // Assign the content zones, moving them into place in the process
      this.label = label;
    }
  });

  /**
    @class Coral.Button.Label
    @classdesc The Button label content
    @htmltag coral-button-label
    @extends HTMLElement
  */
  Coral.Button.Label = function() {
    return document.createElement('coral-button-label');
  };

  // exports the variants enumeration
  Coral.Button.variant = variant;
  Coral.Button.size = size;
  Coral.Button.iconPosition = iconPosition;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Key code
  var SPACE = 32;

  Coral.register( /** @lends Coral.AnchorButton# */ {
    /**
      @class Coral.AnchorButton
      @classdesc A Link component rendering as a button.
      @htmltag coral-anchorbutton
      @htmlbasetag a
      @extends Coral.Component
      @extends HTMLAnchorElement
    */
    name: 'AnchorButton',
    tagName: 'coral-anchorbutton',
    baseTagName: 'a',
    extend: HTMLAnchorElement,
    className: Coral.Button.prototype._className,

    events: {
      'keydown': '_onKeyDown',
      'keyup': '_onKeyUp'
    },

    properties: Coral.commons.extend({}, Coral.Button.prototype._properties, {

      /**
        The label of the button.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Button#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-anchorbutton-label',
        defaultContentZone: true,
        insert: function(label) {
          this.appendChild(label);
        }
      }),

      /**
        Disables the button from user interaction.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.AnchorButton#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this.setAttribute('tabindex', this.disabled ? '-1' : '0');
          this.setAttribute('aria-disabled', this.disabled);
        }
      }
    }),

    // since we do not properly extend Coral.Button we need to copy some private methods
    _makeAccessible: Coral.Button.prototype._makeAccessible,
    _getIconElement: Coral.Button.prototype._getIconElement,
    _updateIcon: Coral.Button.prototype._updateIcon,

    /**
      Keyboard handling per the WAI-ARIA button widget design pattern:
      https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_button_role

      @ignore
    */
    _onKeyDown: function(event) {
      if (event.keyCode === SPACE) {
        event.preventDefault();
        this.click();
        this.classList.add('is-selected');
      }
    },

    /** @ignore */
    _onKeyUp: function(event) {
      if (event.keyCode === SPACE) {
        event.preventDefault();
        this.classList.remove('is-selected');
      }
    },

    /** @ignore */
    _onClick: function(event) {
      if (this.disabled) {
        event.preventDefault();
      }
    },

    /**
      Initializes the AnchorButton. It adds the required accessibility features for it to behave like a button.

      @ignore
    */
    _initialize: function() {
      Coral.Button.prototype._initialize.call(this);
      this.setAttribute('role', 'button');
      this.setAttribute('tabindex', '0');
      // cannot use the events hash because events on disabled items are not reported
      this.addEventListener('click', this._onClick.bind(this));
    },

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var fragment = document.createDocumentFragment();

      // Create or fetch the label element.
      var label = this.querySelector('coral-anchorbutton-label') || document.createElement('coral-anchorbutton-label');

      // Move any remaining elements into the label
      while (this.firstChild) {
        var child = this.firstChild;

        if (child.nodeType === Node.TEXT_NODE) {
          // Move text elements to the label
          label.appendChild(child);
        }
        else if (child.tagName === 'CORAL-ICON') {
          // Conserve existing icon element to content
          this._elements.icon = child;
          fragment.appendChild(child);
        }
        else {
          // Remove anything else
          this.removeChild(child);
        }
      }

      // Add the frag to the component
      this.appendChild(fragment);

      // Assign the content zones, moving them into place in the process
      this.label = label;
    }
  });

  /**
    @class Coral.AnchorButton.Label
    @classdesc The AnchorButton label content
    @htmltag coral-anchorbutton-label
    @extends HTMLElement
  */
  Coral.AnchorButton.Label = function() {
    return document.createElement('coral-anchorbutton-label');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Progress"] = window["Coral"]["templates"]["Progress"] || {};
window["Coral"]["templates"]["Progress"]["base"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " coral3-Progress-bar";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["status"] = document.createElement("div");
  el2.className += " coral3-Progress-status";
  el2.setAttribute("handle", "status");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enumeration representing progress bar sizes.

    @enum {String}
    @memberof Coral.Progress
  */
  var size = {
    /** A small progress bar. */
    SMALL: 'S',
    /** A medium progress bar. */
    MEDIUM: 'M',
    /** A large progress bar. */
    LARGE: 'L'
  };

  /**
    Enumeration representing progress bar label positions.

    @enum {String}
    @memberof Coral.Progress
  */
  var labelPosition = {
    /** Show the label to the left of the bar. */
    LEFT: 'left',
    /** Show the label to the right of the bar. */
    RIGHT: 'right',
    /** Show the label below the bar. */
    BOTTOM: 'bottom'
  };

  // Base classname
  // We're not using coral-Progress here to avoid conflicts with core
  var CLASSNAME = 'coral3-Progress';

  // size mapping
  var SIZE_CLASSES = {
    'S': 'small',
    'M': 'medium',
    'L': 'large'
  };

  // A string of all possible size classnames
  var ALL_SIZE_CLASSES = [];
  for (var sizeValue in size) {
    ALL_SIZE_CLASSES.push(CLASSNAME + '--' + SIZE_CLASSES[size[sizeValue]]);
  }

  // A string of all possible label position classnames
  var ALL_LABEL_POSITION_CLASSES = [];
  for (var position in labelPosition) {
    ALL_LABEL_POSITION_CLASSES.push(CLASSNAME + '--' + labelPosition[position] + 'Label');
  }

  Coral.register( /** @lends Coral.Progress# */ {
    /**
      @class Coral.Progress
      @classdesc A Progress bar component
      @htmltag coral-progress
      @extends Coral.Component
    */
    name: 'Progress',
    tagName: 'coral-progress',
    className: CLASSNAME,

    properties: {
      /**
        The current progress in percent.

        @type {Number}
        @default 0
        @fires Coral.Progress.coral-progress:changed
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.Progress#
      */
      'value': {
        default: 0,
        reflectAttribute: true,
        trigger: 'coral-progress:change',
        transform: function(value) {
          value = Coral.transform.number(value);

          // Invalid input sets to 0
          if (value === null) {
            value = 0;
          }

          // Stay within bounds
          if (value > 100) {
            value = 100;
          }
          else if (value < 0) {
            value = 0;
          }

          return value;
        },
        sync: function() {
          this._elements.status.style.width = this.value + '%';

          if (!this.indeterminate) {
            // ARIA: Reflect value for screenreaders
            this.setAttribute('aria-valuenow', this.value);

            if (this.showPercent === true) {
              // Only update label text in percent mode
              this._setLabelContent(this.value + '%');
            }
          }
        },
        get: function() {
          return this.indeterminate ? 0 : this._value;
        }
      },

      /**
        Whether to hide the current value and show an animation. Set to true for operations whose progress cannot be
        determined.

        @type {Boolean}
        @default false
        @htmlattribute indeterminate
        @htmlattributereflected
        @memberof Coral.Progress#
      */
      'indeterminate': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        alsoSync: 'value',
        sync: function() {
          if (this.indeterminate) {

            this.classList.add(this._className + '--indeterminate');

            // ARIA: Remove attributes
            this.removeAttribute('aria-valuenow');
            this.removeAttribute('aria-valuemin');
            this.removeAttribute('aria-valuemax');
          }
          else {
            this.classList.remove(this._className + '--indeterminate');

            // ARIA: Add attributes
            this.setAttribute('aria-valuemin', '0');
            this.setAttribute('aria-valuemax', '100');
          }
        }
      },

      /**
        The vertical and text size of this progress bar. To adjust the width, simply set the CSS width property.

        @type {Coral.Progress.size}
        @default Coral.Progress.size.MEDIUM
        @htmlattribute size
        @memberof Coral.Progress#
      */
      'size': {
        default: size.MEDIUM,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_SIZE_CLASSES);
          this.classList.add(this._className + '--' + SIZE_CLASSES[this.size]);
        }
      },

      /**
        Boolean attribute to toggle showing progress percent as the label content.
        Default is true.

        @type {Boolean}
        @default false
        @htmlattribute showpercent
        @memberof Coral.Progress#
      */
      'showPercent': {
        // Do not provide a default, otherwise sync will run and blow away the label
        // default: false,
        attribute: 'showpercent',
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          if (this.showPercent === true) {
            var content = this.indeterminate ? '' : this.value + '%';
            this._setLabelContent(content);
            this._showLabel();
          }
          else {
            // This clears the content of the label when showPercent is turned off
            // Ideally, if a label was set and showPercent was set to false, we wouldn't mess with it
            // However, in this case, we don't want to leave incorrect label contents around, so we remove it to be safe
            this.label.innerHTML = '';
          }
        }
      },

      /**
        Used to access to the {@link Coral.Progress.Label} element. Keep in mind that the width of a custom label is
        limited for {@link Coral.Progress.labelPosition.LEFT} and {@link Coral.Progress.labelPosition.RIGHT}.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Progress#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-progress-label',
        defaultContentZone: true,
        insert: function(label) {
          this.appendChild(label);
        }
      }),

      /**
        Label position.

        @type {Coral.Progress.labelPosition}
        @default Coral.Progress.labelPosition.RIGHT
        @htmlattribute labelposition
        @memberof Coral.Progress#
      */
      'labelPosition': {
        default: labelPosition.RIGHT,
        attribute: 'labelposition',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(labelPosition)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_LABEL_POSITION_CLASSES);
          if (this._elements.label.textContent.length > 0) {
            this.classList.add(this._className + '--' + this.labelPosition + 'Label');
          }
        }
      }
    },

    /** @ignore */
    _initialize: function() {
      // ARIA
      this.setAttribute('role', 'progressbar');
      this.setAttribute('aria-valuenow', '0');
      this.setAttribute('aria-valuemin', '0');
      this.setAttribute('aria-valuemax', '100');

      // Watch for label changes
      this._observer = new MutationObserver(this._toggleLabelBasedOnContent.bind(this));
      this._observer.observe(this._elements.label, {
        characterData: true,
        childList: true,
        subtree: true
      });
    },

    /** @ignore */
    _render: function() {
      // Try to find the label content zone
      var foundLabel = this.querySelector('coral-progress-label');

      // Create the label content zone if necessary
      var label = foundLabel || document.createElement('coral-progress-label');

      // Add all children into the label content zone,
      // only if the label has not been provided.
      if (!foundLabel) {
        while (this.firstChild) {
          label.appendChild(this.firstChild);
        }
      }

      // Render the main template
      this.appendChild(Coral.templates.Progress.base.call(this._elements));

      // Assign the content zone so the insert function will be called
      this.label = label;

      // Toggle label based on content
      this._toggleLabelBasedOnContent();
    },

    /** @ignore */
    _toggleLabelBasedOnContent: function() {
      if (this._elements.label.textContent.length > 0) {
        this._showLabel();
      }
      else {
        this._hideLabel();
      }
    },

    /** @ignore */
    _hideLabel: function() {
      this._elements.label.hidden = true;
      this.classList.remove.apply(this.classList, ALL_LABEL_POSITION_CLASSES);
      this.classList.add(this._className + '--noLabel');

      // Remove the value for accessibility so the screenreader knows we're unlabelled
      this.removeAttribute('aria-valuetext');
    },

    /** @ignore */
    _showLabel: function() {
      this._elements.label.hidden = false;
      this.classList.remove(this._className + '--noLabel');
      this.classList.add(this._className + '--' + this.labelPosition + 'Label');

      if (this.showPercent === false) {
        // Update the value for accessibility as it was cleared when the label was hidden
        this.setAttribute('aria-valuetext', this.label.textContent);
      }
    },

    /** @ignore */
    _setLabelContent: function(content) {
      this._elements.label.textContent = content;

      // ARIA
      if (this.showPercent === true) {
        this.removeAttribute('aria-valuetext');
      }
      else {
        this.setAttribute('aria-valuetext', this.label.textContent);
      }
    }

    /**
      Triggered when the progress value is changed.

      @event Coral.Progress#coral-progress:change

      @param {Object} event
        Event object.
      @param {Object} event.detail.value
        The current progress value in percent.
      @param {Object} event.detail.oldValue
        The previous progress value in percent.
    */
  });

  Coral.register( /** @lends Coral.Progress.Label# */ {
    /**
      @class Coral.Progress.Label
      @classdesc The Progress label content
      @htmltag coral-progress-label
      @extends Coral.Component
    */
    name: 'Progress.Label',
    tagName: 'coral-progress-label',
    className: 'coral3-Progress-label'
  });

  // Expose enums globally
  Coral.Progress.size = size;
  Coral.Progress.labelPosition = labelPosition;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for wait variant values.

    @enum {String}
    @memberof Coral.Wait
  */
  var variant = {
    /** The default variant. */
    DEFAULT: 'default',
    /** A dot styled wait. */
    DOTS: 'dots'
  };

  /**
    Enumeration representing wait indicator sizes.

    @memberof Coral.Wait
    @enum {String}
  */
  var size = {
    /** A small wait indicator. This is the default size. */
    SMALL: 'S',
    /** A medium wait indicator. */
    MEDIUM: 'M',
    /** A large wait indicator. */
    LARGE: 'L'
  };


  // the waits's base classname
  var CLASSNAME = 'coral3-Wait';

  // builds a string containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.Wait# */ {
    /**
      @class Coral.Wait
      @classdesc A Wait component
      @extends Coral.Component
      @htmltag coral-wait
    */
    name: 'Wait',
    tagName: 'coral-wait',
    className: CLASSNAME,
    properties: {

      /**
        The size of the wait indicator. Currently 'S' (the default), 'M' and 'L' are available.
        See {@link Coral.Wait.size}
        @type {Coral.Wait.size}
        @default Coral.Wait.size.SMALL
        @htmlattribute size
        @memberof Coral.Wait#
      */
      'size': {
        default: size.SMALL,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        set: function(value) {
          this._size = value;

          // large css change
          this.classList.toggle(this._className + '--large', this.size === size.LARGE);

          // medium css change
          this.classList.toggle(this._className + '--medium', this.size === size.MEDIUM);
        }
      },

      /**
        Whether the component is centered or not. The container needs to have the style <code>position: relative</code>
        for the centering to work correctly.

        @type {Boolean}
        @default false
        @htmlattribute centered
        @htmlattributereflected
        @memberof Coral.Wait#
      */
      'centered': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(this._className + '--centered', this.centered);
        }
      },

      /**
        The wait's variant.

        @type {Coral.Wait.variant}
        @default Coral.Wait.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Wait#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        set: function(value) {
          this._variant = value;

          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }
        }
      }
    }
  });

  // expose enumerations
  Coral.Wait.size = size;
  Coral.Wait.variant = variant;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["ButtonGroup"] = window["Coral"]["templates"]["ButtonGroup"] || {};
window["Coral"]["templates"]["ButtonGroup"]["base"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["nativeSelect"] = document.createElement("select");
  el0.className += " coral3-ButtonGroup-select";
  el0.setAttribute("tabindex", "-1");
  el0.setAttribute("handle", "nativeSelect");
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enumeration representing buttongroup selection modes.

    @memberof Coral.ButtonGroup
    @enum {String}
   */
  var selectionMode = {
    /** None is default, selection of buttons doesn't happen based on click */
    NONE: 'none',
    /** Single selection mode, button group behaves like radio input elements */
    SINGLE: 'single',
    /** Multiple selection mode, button group behaves like checkbox input elements */
    MULTIPLE: 'multiple'
  };

  /** @const Selector used to recognized an item of the ButtonGroup */
  var ITEM_SELECTOR = 'button[is="coral-button"]';

  /**
    Extracts the value from the item in case no explicit value was provided.
    @param {HTMLElement} item
      the item whose value will be extracted.
    @returns {String} the value that will be submitted for this item.
    @private
  */
  var itemValueFromDOM = function(item) {
    var attr = item.getAttribute('value');
    // checking explicitely for null allows to differenciate between non set values and empty strings
    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };

  Coral.register( /** @lends Coral.ButtonGroup# */ {
    /**
      @class Coral.ButtonGroup
      @classdesc A ButtonGroup component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-buttongroup
    */
    name: 'ButtonGroup',
    tagName: 'coral-buttongroup',
    className: 'coral3-ButtonGroup',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'click button[is="coral-button"]': '_onButtonClick',

      'capture:focus button[is="coral-button"]': '_onButtonFocus',
      'capture:blur button[is="coral-button"]': '_onButtonBlur',

      'key:up button[is="coral-button"]': '_onButtonKeyUpLeft',
      'key:left button[is="coral-button"]': '_onButtonKeyUpLeft',
      'key:down button[is="coral-button"]': '_onButtonKeyDownRight',
      'key:right button[is="coral-button"]': '_onButtonKeyDownRight',
      'key:home button[is="coral-button"]': '_onButtonKeyHome',
      'key:end button[is="coral-button"]': '_onButtonKeyEnd'
    },

    properties: {

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.ButtonGroup#
      */
      'items': {
        get: function() {
          // we do lazy initialization of the collection
          if (!this._items) {
            this._items = new Coral.SelectableCollection({
              host: this,
              itemBaseTagName: 'button',
              itemTagName: 'coral-button',
              itemSelector: ITEM_SELECTOR,
              onItemAdded: this._onItemAdded,
              onItemRemoved: this._onItemRemoved,
              onCollectionChange: this._onCollectionChange
            });
          }

          return this._items;
        },
        // read-only
        set: function() {}
      },

      /**
        Selection mode of Button group

        @type {String}
        @default Coral.ButtonGroup.selectionMode.NONE
        @htmlattribute selectionmode
        @memberof Coral.ButtonGroup#
      */
      'selectionMode': {
        default: selectionMode.NONE,
        attribute: 'selectionmode',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(selectionMode)
        ],
        set: function(value) {
          this._selectionMode = value;
          // update select element if multiple
          // this is required while appplying default selection
          // if selection mode is single first elem gets selected but for multiple its not
          this._elements.nativeSelect.multiple = this._selectionMode === selectionMode.MULTIPLE;
        },
        sync: function() {
          if (this.selectionMode === selectionMode.SINGLE) {
            this.setAttribute('role', 'radiogroup');

            // makes sure the internal options are properly initialized
            this._syncItemOptions();

            // we make sure the selection is valid by explicitely finding a candidate or making sure just 1 item is
            // selected
            this._validateSelection();
          }
          else if (this.selectionMode === selectionMode.MULTIPLE) {
            this.setAttribute('role', 'group');

            // makes sure the internal options are properly initialized
            this._syncItemOptions();
          }
          else {
            this.setAttribute('role', 'group');

            this._removeItemOptions();
          }
        }
      },

      // JSDoc inherited
      'name': {
        get: function(value) {
          return this._elements.nativeSelect.name;
        },
        set: function(value) {
          this._elements.nativeSelect.name = value;
        }
      },

      // JSDoc inherited
      'value': {
        get: function() {
          return this._elements.nativeSelect.value;
        },
        set: function(value) {
          if (this.selectionMode === selectionMode.NONE) {
            return;
          }

          // we proceed to select the provided value
          this._selectItemByValue([value]);
        }
      },

      /**
        Returns an Array containing the selected buttons.

        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.ButtonGroup#
      */
      'selectedItems': {
        get: function() {
          if (this.selectionMode === selectionMode.MULTIPLE) {
            return this.items._getAllSelected();
          }
          else {
            var item = this.selectedItem;
            return item ? [item] : [];
          }
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Returns the first selected button in the Button Group. The value <code>null</code> is returned if no button is
        selected.

        @type {HTMLElement}
        @readonly
        @memberof Coral.ButtonGroup#
      */
      'selectedItem': {
        get: function() {
          return this.selectionMode === selectionMode.MULTIPLE ?
            this.items._getFirstSelected() :
            this.items._getLastSelected();
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Current selected values as submitted during form submission.

        @type {Array.<String>}
        @memberof Coral.ButtonGroup#
      */
      'values': {
        attribute: null,
        validate: [
          Coral.validate.valueMustChange,
          function(values) {
            return Array.isArray(values);
          }
        ],
        set: function(values) {
          if (this.selectionMode === selectionMode.NONE) {
            return;
          }

          // just keeps the first value if selectionMode is not multile
          if (this.selectionMode !== selectionMode.MULTIPLE && values.length > 1) {
            values = [values[0]];
          }

          // we proceed to select the provided values
          this._selectItemByValue(values);
        },
        get: function() {
          var values = [];

          // uses the nativeSelect since it holds the truth of what will be submitted with the form
          var selectedOptions = this._elements.nativeSelect.querySelectorAll(':checked');
          for (var i = 0, selectedOptionsCount = selectedOptions.length; i < selectedOptionsCount; i++) {
            values.push(selectedOptions[i].value);
          }

          return values;
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          var isDisabled = this.disabled || this.readOnly;
          this._elements.nativeSelect.disabled = isDisabled;
          // Also update for all the items the disabled property so it matches the native select.
          this.items.getAll().forEach(function(item) {
            item.disabled = isDisabled;
          });
          this.setAttribute('aria-disabled', isDisabled);
        }
      },

      // JSDoc inherited
      'readOnly': {
        sync: function() {
          var self = this;
          this._elements.nativeSelect.disabled = this.readOnly || this.disabled;
          // Also update for all the items the disabled property so it matches the native select.
          this.items.getAll().forEach(function(item) {
            item.disabled = self.disabled || (self.readOnly && !item.hasAttribute('selected'));
            if (self.readOnly) {
              item.setAttribute('aria-disabled', true);
            }
            else {
              item.removeAttribute('aria-disabled');
            }
          });
          // aria-readonly is not permitted on elements with role="radiogroup" or role="group"
          this.removeAttribute('aria-readonly');
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this._elements.nativeSelect.required = this.required;
          // aria-required is permitted on elements with role="radiogroup" but not with role="group"
          if (this.selectionMode !== selectionMode.SINGLE) {
            this.removeAttribute('aria-required');
          }
        }
      },

      // JSDoc inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
        }
      },

      // JSDoc inherited
      'labelledBy': {
        sync: function() {
          this._elements.nativeSelect.setAttribute('aria-labelledby', this.labelledBy);
        }
      }
    },

    // JSDocs inherited from coralui-mixin-formfield
    reset: function() {
      // reset the values to the initial values
      this.values = this._initalSelectedValues;
    },

    /** @private */
    _onButtonClick: function(event) {
      // uses matchTarget to make sure the buttons is handled and not an internal component
      var item = event.matchedTarget;

      this._onButtonFocus(event);

      if (this.readOnly) {
        event.preventDefault();
        event.stopImmediatePropagation();
        return;
      }

      if (this.selectionMode === selectionMode.SINGLE) {
        // prevent event only if selectionMode is not of type none
        event.preventDefault();

        // first unselect the other element
        var selectedElems = this.items._getAllSelected();

        // we deselect the previously selected item
        if (selectedElems.length !== 0 && selectedElems[0] !== item) {
          this._toggleItemSelection(selectedElems[0], false);
        }

        // forces the selection on the clicked item
        this._toggleItemSelection(item, true);

        // if the same button was clicked we do not need to trigger an event
        if (selectedElems[0] !== item) {
          this.trigger('change');
        }
      }
      else if (this.selectionMode === selectionMode.MULTIPLE) {
        // prevent event only if selectionMode is not of type none
        event.preventDefault();

        this._toggleItemSelection(item);

        // since we toggle the selection we always trigger a change event
        this.trigger('change');
      }
    },

    /** @private */
    _onButtonFocus: function(event) {
      var item = event.matchedTarget;
      var buttons = this.items.getAll();
      var buttonsCount = buttons.length;

      var button;
      for (var i = 0; i < buttonsCount; i++) {
        // stores the reference
        button = buttons[i];
        button.setAttribute('tabindex', button === item ? 0 : -1);
      }
    },

    /** @private */
    _onButtonBlur: function(event) {
      var item = event.matchedTarget;
      var buttons = this.items.getAll();
      var buttonsCount = buttons.length;

      var button;
      var tabindex;
      var selectedItemsLength = this.selectedItems.length;
      var firstSelectable = this.items._getFirstSelectable();
      var isSelected = false;
      for (var i = 0; i < buttonsCount; i++) {
        // stores the reference
        button = buttons[i];
        isSelected = button.hasAttribute('selected');
        if (this.selectionMode === selectionMode.SINGLE) {
          // selected item should be tabbable
          tabindex = isSelected ? 0 : -1;
        }
        else if (this.selectionMode === selectionMode.MULTIPLE) {
          tabindex =
            // if no items are selected, first item should be tabbable
            (!selectedItemsLength && i === 0) ||
            // if the element losing focus is selected, it should be tabbable
            (isSelected && button === item) ||
            // if the element losing focus is not selected, the last selected item should be tabbable
            (!item.hasAttribute('selected') &&
             button === (this.selectedItems[selectedItemsLength - 1] || firstSelectable)) ? 0 : -1;
        }
        else {
          // first item should be tabbable
          tabindex = button === firstSelectable ? 0 : -1;
        }
        button.setAttribute('tabindex', tabindex);
      }
    },

    /** @private */
    _onButtonKeyUpLeft: function(event) {
      event.preventDefault();

      var item = event.matchedTarget;
      var button = item.previousElementSibling;

      // skip disabled items
      while (!button || (button.disabled || button.nodeName !== 'BUTTON')) {
        if (!button) {
          button = this.items._getLastSelectable();
        }
        else {
          button = button.previousElementSibling;
        }
      }

      if (button !== item) {
        if (this.selectionMode === selectionMode.SINGLE) {
          button.click();
        }
        this._setFocusToButton(button);
      }
    },

    /** @private */
    _onButtonKeyDownRight: function(event) {
      event.preventDefault();

      var item = event.matchedTarget;
      var button = item.nextElementSibling;

      // skip disabled items
      while (!button || (button.disabled || button.nodeName !== 'BUTTON')) {
        if (!button) {
          button = this.items._getFirstSelectable();
        }
        else {
          button = button.nextElementSibling;
        }
      }

      if (button !== item) {
        if (this.selectionMode === selectionMode.SINGLE) {
          button.click();
        }
        this._setFocusToButton(button);
      }
    },

    /** @private */
    _onButtonKeyHome: function(event) {
      event.preventDefault();

      var item = event.matchedTarget;
      var button = this.items._getFirstSelectable();

      if (button !== item) {
        if (this.selectionMode === selectionMode.SINGLE) {
          button.click();
        }
        this._setFocusToButton(button);
      }
    },

    /** @private */
    _onButtonKeyEnd: function(event) {
      event.preventDefault();

      var item = event.matchedTarget;
      var button = this.items._getLastSelectable();

      if (button !== item) {
        if (this.selectionMode === selectionMode.SINGLE) {
          button.click();
        }
        this._setFocusToButton(button);
      }
    },

    /** @private */
    _setFocusToButton: function(button) {
      if (button) {
        button.focus();
      }
    },

    /** @private */
    _onItemAdded: function(item) {
      // we need to add button group specific classes to style the button correctly
      item.classList.add('coral3-ButtonGroup-item');
      if (this.selectionMode !== selectionMode.NONE) {
        if (this.selectionMode === selectionMode.SINGLE) {
          item.setAttribute('role', 'radio');
          item.setAttribute('tabindex', item.hasAttribute('selected') ? 0 : -1);
        }
        else {
          item.setAttribute('role', 'checkbox');
        }
        item.setAttribute('aria-checked', item.hasAttribute('selected'));
      }
      else {
        item.removeAttribute('role');
      }

      item.disabled = this.disabled || (this.readOnly && !item.hasAttribute('selected'));

      if (this.readOnly) {
        item.setAttribute('aria-disabled', true);
      }
      else {
        item.removeAttribute('aria-disabled');
      }

      this._addItemOption(item);

      // See if this affects our selection (we might require a selection when an item is available):
      this._validateSelection(item.hasAttribute('selected') ? item : null) ;
    },

    /** @private */
    _onItemRemoved: function(item) {
      // we clear the class that was added
      item.classList.remove('coral3-ButtonGroup-item');
      item.removeAttribute('role');

      // Wait one frame before removing value from the cached _initalSelectedValues. (In case the elements are only
      // moved in the dom e.g. some unit tests do wrap the buttongroup)
      var self = this;
      Coral.commons.nextFrame(function() {
        if (!item.parentNode) {
          // Remove the item from the initial selected values
          var index = self._initalSelectedValues.indexOf(item.value);
          if (index !== -1) {
            self._initalSelectedValues.splice(index, 1);
          }
        }
      });

      // delete option
      if (item.option) {
        item.option.parentNode.removeChild(item.option);
        item.option = undefined;
      }
    },

    /** @private */
    _onCollectionChange: function(addedNodes, removedNodes) {
      // we need to make sure that the state of the selectionMode is valid
      this._validateSelection();
    },

    /**
      Since we use button and not coral-buttongroup-item to control the items, we need to rely on mutations to detect
      any change in selection or value.

      @private
    */
    _handleMutations: function(mutations) {
      // monitors only attributes of name selected and values
      for (var i = 0, mutationsCount = mutations.length; i < mutationsCount; i++) {
        var elem = mutations[i].target;

        var attributeName = mutations[i].attributeName;
        if (attributeName === 'value') {
          // we only process a change in the button, options should be ignored
          if (elem.matches(ITEM_SELECTOR)) {
            elem.option.value = itemValueFromDOM(elem);
          }
        }
        else if (attributeName === 'selected') {
          // we only process a change in the button, options should be ignored
          if (elem.matches(ITEM_SELECTOR)) {
            var isSelected = elem.hasAttribute('selected');

            // when in single mode, we need to make sure the current selection is valid
            if (this.selectionMode === selectionMode.SINGLE) {
              this._validateSelection(isSelected ? elem : null);
            }
            else {
              // we simply toggle the selection
              this._toggleItemSelection(elem, isSelected);
            }
          }
        }
      }
    },

    /**
      Toggles the selected state of the item. When <code>selected</code> is provided, it is set as the current state. If
      the value is ommited, then the selected is toggled.

      @param {HTMLElement} item
        Item whose selection needs to be updated.
      @param {Boolean} [selected]
        Whether the item is selected. If it is not provided, then it is toggled.

      @private
    */
    _toggleItemSelection: function(item, selected) {
      var ariaCheckedAttr = item.getAttribute('aria-checked');
      var tabIndexAttr = item.getAttribute('tabindex');

      // if selected is provided it is used to enforce the selection, otherwise we toggle the current state
      selected = typeof selected !== 'undefined' ? selected : !item.hasAttribute('selected');

      // only manipulates the attributes when necessary to avoid unnecessary mutations
      if (selected) {
        if (!item.hasAttribute('selected')) {
          item.setAttribute('selected', '');
        }

        if (ariaCheckedAttr !== 'true') {
          item.setAttribute('aria-checked', true);
        }

        if (this.selectionMode === selectionMode.SINGLE && tabIndexAttr !== '0') {
          item.setAttribute('tabindex', 0);
        }
      }
      else if (!selected) {
        if (item.hasAttribute('selected')) {
          item.removeAttribute('selected');
        }

        if (this.selectionMode !== selectionMode.NONE) {
          if (ariaCheckedAttr !== 'false') {
            item.setAttribute('aria-checked', false);
          }

          if (this.selectionMode === selectionMode.SINGLE && tabIndexAttr !== '-1') {
            item.setAttribute('tabindex', -1);
          }
        }
        else {
          item.removeAttribute('aria-checked');
          item.removeAttribute('tabindex');
        }
      }

      // if element.option is present - absent when selection mode changed to none
      if (item.option) {
        item.option.selected = selected;
      }
    },

    /** @private */
    _selectItemByValue: function(values) {
      // queries all the buttons to change their selection state
      var buttons = this.items.getAll();
      var item;

      for (var i = 0, buttonsCount = buttons.length; i < buttonsCount; i++) {
        // stores the reference
        item = buttons[i];

        // if the value is inside the new values array it should be selected
        this._toggleItemSelection(item, values.indexOf(itemValueFromDOM(item)) !== -1);
      }
    },

    /** @private */
    _addItemOption: function(item) {
      if (this.selectionMode === selectionMode.NONE) {
        return;
      }

      // if already attached return
      if (item.option) {
        return;
      }

      var option = document.createElement('option');
      option.value = itemValueFromDOM(item);

      // Need to store the initially selected values in the native select so that it can reset
      if (this._initalSelectedValues.indexOf(option.value) !== -1) {
        option.setAttribute('selected', '');
      }

      // add it to DOM. In single selectionMode the first item gets selected automatically
      item.option = option;
      this._elements.nativeSelect.add(option);

      // we make sure the options reflect the state of the button
      this._toggleItemSelection(item, item.hasAttribute('selected'));
    },

    /** @private */
    _removeItemOptions: function() {
      // Find all buttons and try attaching corresponding option elem
      var buttons = this.items.getAll();

      var item;
      for (var i = 0, buttonsCount = buttons.length; i < buttonsCount; i++) {
        // stores the reference
        item = buttons[i];

        item.removeAttribute('role');
        item.removeAttribute('aria-checked');

        // single we are removing the options, selection must also go away
        if (item.hasAttribute('selected')) {
          this._toggleItemSelection(item, false);
        }

        // we clear the related option element
        if (item.option) {
          item.option.parentNode.removeChild(item.option);
          delete item.option;
        }
      }
    },

    /** @private */
    _syncItemOptions: function() {
      // finds all buttons and try attaching corresponding option elem
      var buttons = this.items.getAll();
      var buttonsCount = buttons.length;
      var i = 0;
      var role = this.selectionMode === selectionMode.SINGLE ?
        'radio' : (this.selectionMode === selectionMode.MULTIPLE ? 'checkbox' : null);
      var button;
      var isSelected = false;

      for (i; i < buttonsCount; i++) {
        // try attaching corresponding input element
        this._addItemOption(buttons[i]);
      }

      // We need to set the right state for the native select AFTER all buttons have been added
      // (as we can't disable options while there is only one option attached [at least in FF])
      for (i = buttonsCount - 1; i >= 0; i--) {
        button = buttons[i];
        isSelected = button.hasAttribute('selected');
        button.option.selected = isSelected;
        button.setAttribute('aria-checked', isSelected);

        if (role) {
          button.setAttribute('role', role);
        }
        else {
          button.removeAttribute('role');
        }
      }
    },

    /** @private */
    _validateSelection: function(item) {
      // when selectionMode = single, we need to force a selection
      if (this.selectionMode === selectionMode.SINGLE) {
        // gets the current selection
        var selection = this.items._getAllSelected();
        var selectionCount = selection.length;

        // if no item is currently selected, we need to find a candidate
        if (selectionCount === 0) {
          // gets the first candidate for selection
          var selectable = this.items._getFirstSelectable();

          if (selectable) {
            this._toggleItemSelection(selectable, true);
          }
        }
        // more items are selected, so we find a single item and deselect everything else
        else if (selectionCount > 1) {
          // if no item was provided we force the selection on the first item
          item = item || selection[0];

          // we make sure the item is selected, this is important to match the options with the selection
          this._toggleItemSelection(item, true);

          for (var i = 0; i < selectionCount; i++) {
            if (selection[i] !== item) {
              this._toggleItemSelection(selection[i], false);
            }
          }
        }
      }
    },

    /**
      Modifies the accessibility target to be the ButtonGroup itself and not any of the internal buttons.

      @private
    */
    _getLabellableElement: function() {
      return this;
    },

    /** list of handles from the template, that will be recreated on each render */
    _templateHandleNames: ['nativeSelect'],

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var frag = document.createDocumentFragment();

      // Render the template
      frag.appendChild(Coral.templates.ButtonGroup.base.call(this._elements));

      // Clean up
      while (this.firstChild) {
        var child = this.firstChild;
        if (child.nodeType === Node.TEXT_NODE ||
          this._templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
          // Add non-template elements to the content
          frag.appendChild(child);
        }
        else {
          // Remove anything else
          this.removeChild(child);
        }
      }

      // Append the fragment to the component
      this.appendChild(frag);
    },

    /** @ignore */
    _initialize: function() {
      // monitor only attributes of name selected and value. we need to do this because we do not use our own child
      // element such as coral-buttongroup-item
      this._observer = new MutationObserver(this._handleMutations.bind(this));
      this._observer.observe(this, {
        attributes: true,
        // required to detect option mutations
        subtree: true,
        attributeFilter: ['selected', 'value']
      });

      // save initial selection (used for reset)
      this._initalSelectedValues = [];
      for (var i = 0, selectedItemsCount = this.selectedItems.length; i < selectedItemsCount; i++) {
        this._initalSelectedValues.push(this.selectedItems[i].value);
      }

      // tells the collection to handle the addition and removal automatically
      this.items._startHandlingItems();
    }
  });

  // exports the selectionMode enumeration
  Coral.ButtonGroup.selectionMode = selectionMode;
})();

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Checkbox"] = window["Coral"]["templates"]["Checkbox"] || {};
window["Coral"]["templates"]["Checkbox"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["input"] = document.createElement("input");
  el0.setAttribute("type", "checkbox");
  el0.setAttribute("handle", "input");
  el0.className += " coral3-Checkbox-input";
  el0.id = Coral["commons"]["getUID"]();
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["checkbox"] = document.createElement("span");
  el2.className += " coral3-Checkbox-checkmark";
  el2.setAttribute("handle", "checkbox");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["labelWrapper"] = document.createElement("label");
  el4.className += " coral3-Checkbox-description";
  el4.setAttribute("handle", "labelWrapper");
  el4.setAttribute("for", this["input"]["id"]);
  frag.appendChild(el4);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var IS_IE_OR_EDGE = navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0 ||
                      window.navigator.userAgent.indexOf('Edge') !== -1;

  Coral.register( /** @lends Coral.Checkbox# */ {
    /**
      @class Coral.Checkbox
      @classdesc A Checkbox component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-checkbox
    */
    name: 'Checkbox',
    tagName: 'coral-checkbox',
    className: 'coral3-Checkbox',

    mixins: [
      Coral.mixin.formField
    ],

    // @polyfill ie
    events: {
      'click': '_onClick',
      'mousedown': '_onMouseDown'
    },

    properties: {
      /**
        Checked state for the checkbox. When the checked state is changed by user interaction a
        {@link Coral.mixin.formField#event:change} event is triggered.

        @type {Boolean}
        @default false
        @htmlattribute checked
        @htmlattributereflected
        @fires Coral.mixin.formField#change
        @memberof Coral.Checkbox#
      */
      'checked': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          this._checked = value;
          this._elements.input.checked = value;
        }
      },

      /**
        Indicates that the checkbox is neither on nor off.

        @type {Boolean}
        @default false
        @htmlattribute indeterminate
        @htmlattributereflected
        @memberof Coral.Checkbox#
      */
      'indeterminate': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this._elements.input.indeterminate = this.indeterminate;
          this._elements.input[this.indeterminate ? 'setAttribute' : 'removeAttribute']('aria-checked', 'mixed');
        }
      },

      /**
        The checkbox's label element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Checkbox#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-checkbox-label',
        defaultContentZone: true,
        insert: function(label) {
          this._elements.labelWrapper.appendChild(label);
        }
      }),

      /**
        The value that will be submitted when the checkbox is checked. Changing this value will not trigger an event.

        @type {String}
        @default "on"
        @htmlattribute value
        @memberof Coral.Checkbox#
      */
      'value': {
        default: 'on',
        set: function(value) {
          this._elements.input.value = value;
        },
        get: function() {
          return this._elements.input.value;
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this._elements.input.disabled = this.disabled;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this._elements.input.required = this.required;
        }
      }
    },

    /*
      Indicates to the formField that the 'checked' property needs to be set in this component.

      @protected
     */
    _componentTargetProperty: 'checked',

    /*
      Indicates to the formField that the 'checked' property has to be extracted from the event.

      @protected
     */
    _eventTargetProperty: 'checked',

    // JSDoc inherited
    clear: function() {
      this.checked = false;
    },

    // JSDoc inherited
    reset: function() {
      this.checked = this._initialCheckedState;
    },

    /** @private */
    _onInputChange: function(event) {
      // stops the current event
      event.stopPropagation();

      this[this._componentTargetProperty] = event.target[this._eventTargetProperty];

      // resets the indeterminate state after user interaction
      this.indeterminate = false;

      // Explicitly re-emit the change event after the property has been set
      if (this._triggerChangeEvent) {
        // @polyfill ie/edge
        if (IS_IE_OR_EDGE) {
          // We need 1 additional frame in case the indeterminate state is set manually on change event
          Coral.commons.nextFrame(function() {
            this.trigger('change');
          }.bind(this));
        }
        else {
          this.trigger('change');
        }
      }
    },

    /**
      @private
      @polyfill ie/edge
    */
    _onClick: function(event) {
      // Force the check/uncheck and trigger the change event since IE won't.
      if (IS_IE_OR_EDGE && this.indeterminate) {
        // Other browsers like Chrome and Firefox will trigger the change event and set indeterminate = false. So we
        // verify if indeterminate was changed and if not, we manually check/uncheck and trigger the change event.
        this.checked = !this.checked;
        this._onInputChange(event);
      }
      // Handle the click() just like the native checkbox
      else if (event.target === this) {
        this.indeterminate = false;
        this.checked = !this.checked;
        this.trigger('change');
      }
    },

    /**
      Forces checkbox to receive focus on mousedown
      @ignore
    */
    _onMouseDown: function() {
      var target = this._elements.input;
      Coral.commons.nextFrame(function () {
        if (target !== document.activeElement) {
          target.focus();
        }
      });
    },

    _templateHandleNames: ['input', 'checkbox', 'labelWrapper'],

    /** @private */
    _render: function() {
      // Create a temporary fragment
      var frag = document.createDocumentFragment();

      // Render the main template
      frag.appendChild(Coral.templates.Checkbox.base.call(this._elements));

      // Try to find the label content zone
      var label = this.querySelector('coral-checkbox-label') || document.createElement('coral-checkbox-label');

      // Remove it so we can process children
      if (label && label.parentNode) {
        label.parentNode.removeChild(label);
      }

      // Hide the labelWrapper by default (will be shown, via contentZone observer)
      this._elements.labelWrapper.hidden = true;

      while (this.firstChild) {
        var child = this.firstChild;
        if (child.nodeType === Node.TEXT_NODE ||
          this._templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
          // Add non-template elements to the label
          label.appendChild(child);
        }
        else {
          // Remove anything else (e.g labelWrapper)
          this.removeChild(child);
        }
      }

      // Add the frag to the component
      this.appendChild(frag);

      // Assign the content zones, moving them into place in the process
      this.label = label;
    },

    /** @private */
    _initialize: function() {
      // Check if the label is empty whenever we get a mutation
      this._observer = new MutationObserver(this._hideLabelIfEmpty.bind(this));

      // Watch for changes to the label element's children
      this._observer.observe(this._elements.labelWrapper, {
        childList: true, // Catch changes to childList
        characterData: true, // Catch changes to textContent
        subtree: true // Monitor any child node
      });

      // Cache the initial checked state of the checkbox (in order to implement reset)
      this._initialCheckedState = this.checked;
    },

    /**
      Hide the label if it's empty
      @ignore
    */
    _hideLabelIfEmpty: function() {
      var label = this._elements.label;

      // If it's empty and has no non-textnode children, hide the label
      var hiddenValue = label.children.length === 0 && label.textContent.replace(/\s*/g, '') === '';

      // Only bother if the hidden status has changed
      if (hiddenValue !== this._elements.labelWrapper.hidden) {
        this._elements.labelWrapper.hidden = hiddenValue;
      }
    },

    attachedCallback: function() {
      // Call top level class' attachedCallback
      Coral.Component.prototype.attachedCallback.call(this);

      // Check if we need to hide the label
      // We must do this because IE does not catch mutations when nodes are not in the DOM
      this._hideLabelIfEmpty();
    }
  });

  /**
    @class Coral.Checkbox.Label
    @classdesc The Checkbox label
    @htmltag coral-checkbox-label
    @extends HTMLElement
  */
  Coral.Checkbox.Label = function() {
    return document.createElement('coral-checkbox-label');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Radio"] = window["Coral"]["templates"]["Radio"] || {};
window["Coral"]["templates"]["Radio"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["input"] = document.createElement("input");
  el0.setAttribute("type", "radio");
  el0.setAttribute("handle", "input");
  el0.className += " coral3-Radio-input";
  el0.id = Coral["commons"]["getUID"]();
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["checkmark"] = document.createElement("span");
  el2.className += " coral3-Radio-checkmark";
  el2.setAttribute("handle", "checkmark");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["labelWrapper"] = document.createElement("label");
  el4.className += " coral3-Radio-description";
  el4.setAttribute("handle", "labelWrapper");
  el4.setAttribute("for", this["input"]["id"]);
  frag.appendChild(el4);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Radio# */ {
    /**
      @class Coral.Radio
      @classdesc A Radio component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-radio
    */
    name: 'Radio',
    tagName: 'coral-radio',
    className: 'coral3-Radio',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'click': '_onClick',
      'mousedown': '_onMouseDown'
    },

    properties: {
      /**
        Checked state for the radio, <code>true</code> is checked and <code>false</code> is unchecked. Changing the
        checked value will cause a {@link Coral.mixin.formField.event:change} event to be triggered.

        @type {Boolean}
        @default false
        @htmlattribute checked
        @htmlattributereflected
        @fires Coral.mixin.formField#change
        @memberof Coral.Radio#
      */
      'checked': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          this._checked = value;
          // we do this inmediatelly in the setter to be able to properly support forms
          this._elements.input.checked = value;

          // handles related radios
          this._syncRelatedRadios();
        }
      },

      /**
        The radios's label element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Radio#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-radio-label',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.labelWrapper.appendChild(content);
        }
      }),

      /**
        The value this radio should submit when checked. Changing this value will not trigger an event.

        @type {String}
        @default "on"
        @htmlattribute value
        @memberof Coral.Radio#
      */
      'value': {
        default: 'on',
        set: function(value, silent) {
          this._elements.input.value = value;
        },
        get: function() {
          return this._elements.input.value;
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this._elements.input.disabled = this.disabled;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this._elements.input.required = this.required;
        }
      }
    },

    /*
      Indicates to the formField that the 'checked' property needs to be set in this component.

      @protected
     */
    _componentTargetProperty: 'checked',

    /*
      Indicates to the formField that the 'checked' property has to be extracted from the event.

      @protected
     */
    _eventTargetProperty: 'checked',

    // JSDoc inherited
    clear: function() {
      this.checked = false;
    },

    // JSDoc inherited
    reset: function() {
      this.checked = this._initialCheckedState;
    },

    /**
      Takes care of keeping the checked property up to date, by unchecking every radio that has the same name. This is
      only done if the radio is already in the DOM, it has a name and it is checked, otherwise this is not needed.

      @ignore
    */
    _syncRelatedRadios: function() {
      // if the checkbox has a name defined and it is checked, we need to ensure that other radios that share the name
      // are not checked.
      if (this.parentNode !== null && this.name && this.checked) {
        // queries the document for all the coral-radios with the same name
        var items = document.querySelectorAll(this.tagName + '[name=' + JSON.stringify(this.name) + ']');
        var itemCount = items.length;
        
        for (var i = 0; i < itemCount; i++) {
          if (items[i] !== this) {
            items[i].removeAttribute('checked');
          }
        }
      }
    },

    /**
      Hide the label if it's empty.

      @ignore
    */
    _hideLabelIfEmpty: function() {
      var label = this.label;
      // If it's empty and has no non-textnode children, hide the label
      var hiddenValue = label.children.length === 0 && label.textContent.replace(/\s*/g, '') === '';
      // Only bother if the hidden status has changed
      if (hiddenValue !== this._elements.labelWrapper.hidden) {
        this._elements.labelWrapper.hidden = hiddenValue;
      }
    },

    /**
      @private
    */
    _onClick: function(event) {
      // Handle the click() just like the native radio
      if (event.target === this && !this.checked) {
        this.checked = true;
        this.trigger('change');
      }
    },

    /**
      Forces radio to receive focus on mousedown
      @ignore
    */
    _onMouseDown: function() {
      var target = this._elements.input;
      Coral.commons.nextFrame(function () {
        if (target !== document.activeElement) {
          target.focus();
        }
      });
    },

    /** @ignore */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      // handles the case where the attached component was checked
      this._syncRelatedRadios();

      // Check if we need to hide the label
      // We must do this because IE does not catch mutations when nodes are not in the DOM
      this._hideLabelIfEmpty();
    },

    /** @private */
    _initialize: function() {
      // Check if the label is empty whenever we get a mutation
      this._observer = new MutationObserver(this._hideLabelIfEmpty.bind(this));

      // Watch for changes to the label element's children
      this._observer.observe(this._elements.labelWrapper, {
        childList: true, // Catch changes to childList
        characterData: true, // Catch changes to textContent
        subtree: true // Monitor any child node
      });

      // Cache the initial checked state of the radio button (in order to implement reset)
      this._initialCheckedState = this.checked;
    },

    _templateHandleNames: ['input', 'checkmark', 'labelWrapper'],

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var frag = document.createDocumentFragment();

      // Render the main template
      frag.appendChild(Coral.templates.Radio.base.call(this._elements));

      // Try to find the label content zone
      var label = this.querySelector('coral-radio-label') || document.createElement('coral-radio-label');

      // Remove it so we can process children
      if (label && label.parentNode) {
        label.parentNode.removeChild(label);
      }

      // Hide the labelWrapper by default (will be shown, via contentZone observer)
      this._elements.labelWrapper.hidden = true;

      while (this.firstChild) {
        var child = this.firstChild;
        if (child.nodeType === Node.TEXT_NODE ||
          this._templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
          // Add non-template elements to the label
          label.appendChild(child);
        }
        else {
          // Remove anything else (e.g labelWrapper)
          this.removeChild(child);
        }
      }

      // Add the frag to the component
      this.appendChild(frag);

      // Assign the content zones, moving them into place in the process
      this.label = label;
    }
  });

  /**
    @class Coral.Radio.Label
    @classdesc The Radio label
    @htmltag coral-radio-label
    @extends HTMLElement
  */
  Coral.Radio.Label = function() {
    return document.createElement('coral-radio-label');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for textfield variant values.
    @enum {String}
    @memberof Coral.Textfield
  */
  var variant = {
    /** A default textfield */
    DEFAULT: 'default',
    /** A textfield with no border or background. */
    QUIET: 'quiet'
  };

  // the textfield's base classname
  var CLASSNAME = 'coral3-Textfield';

  // Builds a string containing all possible variant classnames. This will be used to remove classnames when the variant
  // changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.Textfield# */ {
    /**
      @class Coral.Textfield
      @classdesc A Textfield component
      @htmltag coral-textfield
      @htmlbasetag input
      @extends Coral.Component
      @extends Coral.mixin.formField
    */
    name: 'Textfield',
    tagName: 'coral-textfield',
    baseTagName: 'input',
    extend: HTMLInputElement,
    className: CLASSNAME,

    mixins: [
      Coral.mixin.formField
    ],

    properties: {
      // JSDoc inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
        }
      },
      /**
        The textfield's variant.
        @type {Coral.Textfield.variant}
        @default Coral.Textfield.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Textfield#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== Coral.Textfield.variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }
        }
      }
    }
  });

  // exports the variants enumeration
  Coral.Textfield.variant = variant;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var CLASSNAME_BASE = 'coral3-Textfield';

  /**
    Enum for textarea variant values.
    @enum {String}
    @memberof Coral.Textarea
  */
  var variant = {
    /** A default textarea */
    DEFAULT: 'default',
    /** A textarea with no border or background. */
    QUIET: 'quiet'
  };

  // Builds a string containing all possible variant classnames. This will be used to remove classnames when the variant
  // changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME_BASE + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.Textarea# */ {
    /**
      @class Coral.Textarea
      @classdesc A Textarea component
      @htmltag coral-textarea
      @htmlbasetag textarea
      @extends Coral.Component
      @extends Coral.mixin.formField
    */
    name: 'Textarea',
    tagName: 'coral-textarea',
    baseTagName: 'textarea',
    extend: HTMLTextAreaElement,
    className: CLASSNAME_BASE + ' ' + CLASSNAME_BASE + '--multiline',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'input': '_onInput'
    },

    properties: {
      // JSDoc inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
        }
      },

      /**
        The textarea's variant.
        @type {Coral.Textarea.variant}
        @default Coral.Textarea.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Textarea#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== variant.DEFAULT) {
            this.classList.add(CLASSNAME_BASE + '--' + this.variant);
          }

          if (this.variant === variant.QUIET) {
            this._defaultHeight = this.style.height;
          }
          else {
            this.style.height = this._defaultHeight;
          }

          this._onInput();
        }
      }
    },

    // JSDoc inherited from coralui-mixin-formfield
    reset: function() {
      // the textarea uses the textContent to save the old value and not the value attribute
      this.value = this.textContent;
    },

    /** @private */
    _onInput: function() {
      if (this.variant === variant.QUIET) {
        this.style.height = 'auto';
        this.style.height = this.scrollHeight + 'px';
      }
    }
  });

  // exports the variants enumeration
  Coral.Textarea.variant = variant;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Accordion"] = window["Coral"]["templates"]["Accordion"] || {};
window["Coral"]["templates"]["Accordion"]["item"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["acHeader"] = document.createElement("div");
  el0.className += " coral3-Accordion-header";
  el0.setAttribute("role", "tab");
  el0.id = Coral["commons"]["getUID"]();
  el0.setAttribute("handle", "acHeader");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["icon"] = document.createElement("coral-icon");
  el2.className += " coral3-Accordion-icon";
  el2.setAttribute("size", "xs");
  el2.setAttribute("handle", "icon");
  el2.setAttribute("icon", "chevronRight");
  el2.setAttribute("alt", "");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n  ");
  el0.appendChild(el3);
  var el4 = this["labelContainer"] = document.createElement("div");
  el4.className += " coral3-Accordion-label";
  el4.setAttribute("handle", "labelContainer");
  el0.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el0.appendChild(el5);
  frag.appendChild(el0);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = this["acContent"] = document.createElement("div");
  el7.className += " coral3-Accordion-content";
  el7.setAttribute("handle", "acContent");
  el7.id = Coral["commons"]["getUID"]();
  el7.setAttribute("role", "tabpanel");
  frag.appendChild(el7);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Key codes
  var PAGE_UP = 33;
  var PAGE_DOWN = 34;
  var LEFT_ARROW = 37;
  var UP_ARROW = 38;

  /**
    Enum for Accordion variant values.

    @enum {String}
    @memberof Coral.Accordion
  */
  var variant = {
    /** Default Tabpanel look and feel. */
    DEFAULT: 'default',
    /** Quiet variant with minimal borders. */
    QUIET: 'quiet',
    /** Large variant, typically used inside a navigation rail since it does not have borders on the sides. */
    LARGE: 'large'
  };

  // the accordions's base classname
  var CLASSNAME = 'coral3-Accordion';

  // builds a string with all the possible class names to be able to handle variant changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.Accordion# */ {
    /**
      @class Coral.Accordion
      @classdesc An Accordion component
      @extends Coral.Component
      @mixes Coral.mixin.selectionList
      @borrows Coral.mixin.selectionList#selectedItem as Coral.Accordion#selectedItem
      @borrows Coral.mixin.selectionList#items as Coral.Accordion#items
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:add as Coral.Accordion#coral-collection:add
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:remove as Coral.Accordion#coral-collection:remove

      @htmltag coral-accordion
    */
    name: 'Accordion',
    tagName: 'coral-accordion',
    className: CLASSNAME,

    mixins: [
      Coral.mixin.selectionList({
        role: 'tablist',
        itemTagName: 'coral-accordion-item',
        allowSingleModeDeselect: true
      })
    ],

    events: {
      'click [handle="acHeader"]': '_onItemClick',

      'key:space [handle="acHeader"]': '_onToggleItemKey',
      'key:return [handle="acHeader"]': '_onToggleItemKey',
      'key:pageup [handle="acHeader"]': '_focusPreviousItem',
      'key:left [handle="acHeader"]': '_focusPreviousItem',
      'key:up [handle="acHeader"]': '_focusPreviousItem',
      'key:pagedown [handle="acHeader"]': '_focusNextItem',
      'key:right [handle="acHeader"]': '_focusNextItem',
      'key:down [handle="acHeader"]': '_focusNextItem',
      'key:home [handle="acHeader"]': '_onHomeKey',
      'key:end [handle="acHeader"]': '_onEndKey',

      'keydown [handle="acContent"]': '_onItemContentKeyDown'
    },

    properties: {

      /**
        The Accordion's variant.

        @type {Coral.Accordion.variant}
        @default Coral.Accordion.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Accordion#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== Coral.Accordion.variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }
        }
      },

      /** @private **/
      '_tabTarget': {
        default: null,
        sync: function() {
          var value = this._tabTarget;
          var items = this.items.getAll();

          // Set all but the current set _tabTarget to not be a tab target:
          items.forEach(function(item) {
            item._isTabTarget = item === value;
          });
        }
      }
    },

    /** @private */
    _onHomeKey: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getFirstSelectable());
    },

    /** @private */
    _onEndKey: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getLastSelectable());
    },

    /**
      References:
      http://www.w3.org/WAI/PF/aria-practices/#accordion &

      Handlers for when focus is on an element inside of the panel:
      http://test.cita.illinois.edu/aria/tabpanel/tabpanel2.php

      @private
    */
    _onItemContentKeyDown: function(event) {
      // Required since sometimes the value is a number
      var key = parseFloat(event.keyCode);
      var item = event.matchedTarget.parentNode;

      switch (key) {
        case UP_ARROW:
        case LEFT_ARROW:
          // Set focus on the tab button for the currently displayed tab.
          if ((event.metaKey || event.ctrlKey) && Coral.Keys.filterInputs(event)) {
            event.preventDefault();
            event.stopPropagation();
            this._focusItem(item);
          }
          break;
        case PAGE_UP:
          // Show the previous tab and set focus on its corresponding tab button. Shows the last tab in the panel if
          // current tab is the first one.
          if (event.metaKey || event.ctrlKey) {
            event.preventDefault();
            event.stopPropagation();

            var prevItem = this.items.getPreviousSelectable(item);
            this._selectItem(prevItem);
            this._focusItem(prevItem);
          }
          break;
        case PAGE_DOWN:
          // Show the next tab and set focus on its corresponding tab button. Shows the first tab in the panel if current
          // tab is the last one.
          if (event.metaKey || event.ctrlKey) {
            event.preventDefault();
            event.stopPropagation();

            var nextItem = this.items.getNextSelectable(item);
            this._selectItem(nextItem);
            this._focusItem(nextItem);
          }
          break;
      }
    },

    /** @private */
    _focusPreviousItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getPreviousSelectable(event.target.parentNode));
    },

    /** @private */
    _focusNextItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getNextSelectable(event.target.parentNode));
    },

    /** @private */
    _onItemClick: function(event) {
      // Clickable elements included in an item header shouldn't automatically trigger the selection of that item
      if (event.target.hasAttribute('coral-interactive') || event.target.closest('[coral-interactive]')) {
        return;
      }

      // The click was performed on the header so we select the item (parentNode) the selection is toggled
      var item = event.target.closest('coral-accordion-item');
      if (item) {
        event.preventDefault();
        event.stopPropagation();

        this._selectItem(item);
        this._focusItem(item);
      }
    },

    /** @private */
    _onToggleItemKey: function(event) {
      event.preventDefault();
      event.stopPropagation();

      var item = event.target.parentNode;
      this._selectItem(item);
      this._focusItem(item);
    },

    /**
      Invocation of any of the 4 mixin.selectionList handlers referenced below may result in the internal '_tabTarget'
      property changing. Note that these are not overrides, but additions, invoked via 'Coral.commons.callAll'.

      @private
    */
    _onItemSelected: function() {
      this._resetTabTarget();
    },

    /** @private **/
    _onItemDeselected: function() {
      this._resetTabTarget();
    },

    /** @private **/
    _onItemAttached: function() {
      this._resetTabTarget();
    },

    /** @private **/
    _onItemDetached: function() {
      this._resetTabTarget();
    },

    /**
      Determine what item should get focus (if any) when the user tries to tab into the accordion. This should be the
      first selected panel, or the first selectable panel otherwise. When neither is available, to Accordion cannot be
      tabbed into.

      @private
    */
    _resetTabTarget: function() {
      if (!this._resetTabTargetScheduled) {
        this._resetTabTargetScheduled = true;

        Coral.commons.nextFrame(function() {
          this._resetTabTargetScheduled = false;

          // since hidden items cannot have focus, we need to make sure the tabTarget is not hidden
          var selectedItems = this.items._getNonNestedItems().filter(function(item) {
            return item.hasAttribute('selected') && !item.hasAttribute('disabled') && !item.hasAttribute('hidden');
          });

          this._tabTarget = selectedItems.length ? selectedItems[0] : this.items.getFirstSelectable();
        }.bind(this));
      }
    },

    /** @private */
    _focusItem: function(item) {
      if (item) {
        item.focus();
      }

      this._tabTarget = item;
    },

    /** @private */
    _initialize: function() {
      this.setAttribute('aria-multiselectable', 'true');
    }

    /**
      Triggered when the selected item has changed.

      @event Coral.Accordion#coral-accordion:change

      @param {Object} event Event object
      @param {Object} event.detail
      @param {HTMLElement} event.detail.oldSelection
        The prior selected item(s).
      @param {HTMLElement} event.detail.selection
        The newly selected item(s).
    */
  });

  // exports the variants enumeration
  Coral.Accordion.variant = variant;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Chevron classes for selected states
  var CHEVRON_CLASSES = {
    'true': 'chevronDown',
    'false': 'chevronRight'
  };

  Coral.register( /** @lends Coral.Accordion.Item# */ {
    /**
      @class Coral.Accordion.Item
      @classdesc An item in an accordion
      @extends Coral.Component
      @mixes Coral.mixin.selectionList.Item
      @borrows Coral.mixin.selectionList.Item#disabled as Coral.Accordion.Item#disabled
      @borrows Coral.mixin.selectionList.Item#selected as Coral.Accordion.Item#selected
      @htmltag coral-accordion-item
    */
    name: 'Accordion.Item',
    tagName: 'coral-accordion-item',
    className: 'coral3-Accordion-item',

    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-accordion',
        role: 'presentation'
      })
    ],

    properties: {
      /**
        The label of this accordion item.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Accordion.Item#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-accordion-item-label',
        insert: function(label) {
          this._elements.labelContainer.appendChild(label);
        }
      }),

      /**
        The content of this accordion item.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Accordion.Item#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-accordion-item-content',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.acContent.appendChild(content);
        }
      }),

      // JSDoc inherited
      'selected': {
        sync: function() {
          var offsetHeight;
          this.classList.toggle('is-selected', this.selected);

          this.removeAttribute('aria-selected');

          this._elements.acHeader.setAttribute('aria-selected', this.selected);
          this._elements.acHeader.setAttribute('aria-expanded', this.selected);

          this._elements.acContent.setAttribute('aria-hidden', !this.selected);

          this._elements.icon.icon = CHEVRON_CLASSES[this.selected];

          var animateElement = this._elements.acContent;

          if (!this._animate) {
            this._animate = true;
            if (this.selected) {
              animateElement.classList.add('is-open');
            }
            else {
              animateElement.classList.add('is-closed');
              animateElement.style.height = '0';
            }
          }
          else {
            if (this.selected) {
              animateElement.classList.remove('is-closed');
              animateElement.classList.add('is-collapsing');
              animateElement.style.height = animateElement.scrollHeight + 'px';
            }
            else {
              animateElement.style.height = animateElement.scrollHeight + 'px';
              // We read the offset height to force a reflow, this is needed to start the transition between absolute values
              // https://blog.alexmaccaw.com/css-transitions under Redrawing
              offsetHeight = animateElement.offsetHeight;
              animateElement.classList.add('is-collapsing');
              animateElement.classList.remove('is-open');
              animateElement.style.height = 0;
            }
  
            Coral.commons.transitionEnd(animateElement, function() {
              this._onCollapsed();
            }.bind(this));
          }
        }
      },

      // JSDoc inherited
      'disabled': {
        alsoSync: ['_isTabTarget'],
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);

          this.removeAttribute('aria-disabled');

          this._elements.acHeader.setAttribute('aria-disabled', this.disabled);
        }
      },

      /** @private **/
      '_isTabTarget': {
        default: false,
        sync: function() {
          if (this.disabled) {
            this._elements.acHeader.removeAttribute('tabindex');
          }
          else {
            this._elements.acHeader.setAttribute('tabindex', this.__isTabTarget ? '0' : '-1');
          }
        }
      }
    },

    /**
      Handles the focus of the item.

      @ignore
    */
    focus: function() {
      this._elements.acHeader.focus();
    },

    /**
     Handles styling of the container after collapsing.
     */
    _onCollapsed: function() {
      var animateElement = this._elements.acContent;
      animateElement.classList.remove('is-collapsing');
      animateElement.classList.add('is-closed');
      if (this._selected) {
        animateElement.classList.add('is-open');
        animateElement.classList.remove('is-closed');
        animateElement.style.height = '';
      }
      else {
        animateElement.classList.add('is-closed');
        animateElement.classList.remove('is-open');
      }
   },

    /** @private */
    _initialize: function() {
      var header = this._elements.acHeader;

      header.setAttribute('aria-controls', this._elements.acContent.id);
      this._elements.acContent.setAttribute('aria-labelledby', header.id);
    },

    _templateHandleNames: ['acHeader', 'icon', 'labelContainer', 'acContent'],

    /** @private */
    _render: function() {
      // Render the template and set element references
      var itemFragment = Coral.templates.Accordion.item.call(this._elements);

      // Fetch or create the label and content sub-components
      var label = this.querySelector('coral-accordion-item-label') ||
        document.createElement('coral-accordion-item-label');
      var content = this.querySelector('coral-accordion-item-content') ||
        document.createElement('coral-accordion-item-content');

      // Assign the content zones, moving them into place in the process
      this.label = label;
      this.content = content;

      // Move any remaining elements into the content sub-component
      while (this.firstChild) {
        var child = this.firstChild;
        if (child.nodeType === Node.TEXT_NODE ||
          this._templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
          // Add non-template elements to the content
          content.appendChild(child);
        }
        else {
          // Remove anything else element
          this.removeChild(child);
        }
      }

      // Lastly, add the fragment into the container
      this.appendChild(itemFragment);
    }
  });

  /**
    @class Coral.Accordion.Item.Content
    @classdesc Accordion item's content component
    @htmltag coral-accordion-item-content
    @extends HTMLElement
  */
  Coral.Accordion.Item.Content = function() {
    return document.createElement('coral-accordion-item-content');
  };

  /**
    @class Coral.Accordion.Item.Label
    @classdesc Accordion item's label component
    @htmltag coral-accordion-item-label
    @extends HTMLElement
  */
  Coral.Accordion.Item.Label = function() {
    return document.createElement('coral-accordion-item-label');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Valid alignment pairs.

    @enum {Object}
    @memberof Coral.Overlay
  */
  var align = {
    /** Use the top of the left side as an anchor point. */
    LEFT_TOP: 'left top',
    /** Use the center of the left side as an anchor point. */
    LEFT_CENTER: 'left center',
    /** Use the bottom of the left side as an anchor point. */
    LEFT_BOTTOM: 'left bottom',
    /** Use the center of the top side as an anchor point. */
    CENTER_TOP: 'center top',
    /** Use the center as an anchor point. */
    CENTER_CENTER: 'center center',
    /** Use the center of the bottom side as an anchor point. */
    CENTER_BOTTOM: 'center bottom',
    /** Use the top of the right side as an anchor point. */
    RIGHT_TOP: 'right top',
    /** Use the center of the right side as an anchor point. */
    RIGHT_CENTER: 'right center',
    /** Use the bottom of the right side as an anchor point. */
    RIGHT_BOTTOM: 'right bottom'
  };

  /**
    Collision detection strategies.

    @enum {String}
    @memberof Coral.Overlay
  */
  var collision = {
    /** Flips the element to the opposite side of the target and the collision detection is run again to see if it will fit. Whichever side allows more of the element to be visible will be used. */
    FLIP: 'flip',
    /** Shift the element away from the edge of the window. */
    FIT: 'fit',
    /** First applies the flip logic, placing the element on whichever side allows more of the element to be visible. Then the fit logic is applied to ensure as much of the element is visible as possible. */
    FLIP_FIT: 'flipfit',
    /** Does not apply any collision detection. */
    NONE: 'none'
  };

  /**
    Anchored overlay targets.

    @enum {String}
    @memberof Coral.Overlay
  */
  var target = {
    /** Use the previous sibling element in the DOM. */
    PREVIOUS: '_prev',
    /** Use the next sibling element in the DOM. */
    NEXT: '_next'
  };

  /**
    Overlay placement values.

    @enum {Object}
    @memberof Coral.Overlay
  */
  var placement = {
    /** An overlay anchored to the left of the target. */
    LEFT: 'left',
    /** An overlay anchored to the right of the target. */
    RIGHT: 'right',
    /** An overlay anchored at the bottom the target. */
    BOTTOM: 'bottom',
    /** An overlay anchored at the top target. */
    TOP: 'top'
  };

  /**
    Boolean enumeration for interaction values.

    @enum {String}
    @memberof Coral.Overlay
  */
  var interaction = {
    /** Keyboard interaction is enabled. */
    ON: 'on',
    /** Keyboard interaction is disabled. */
    OFF: 'off'
  };

  /**
    Re-position the overlay if it's currently open.

    @ignore
  */
  function repositionIfOpen() {
    /* jshint -W040 */
    if (this.open) {
      // Re-position accordingly
      this._position();
    }
  }

  /**
    Lowecase the passed string if it's a string, passthrough if not.

    @ignore
  */
  function transformAlignment(alignment) {
    // Just pass through non-strings
    return typeof alignment === 'string' ? alignment.toLowerCase() : alignment;
  }

  Coral.register( /** @lends Coral.Overlay# */ {
    /**
      @class Coral.Overlay
      @classdesc An overlay component
      @extends Coral.Component
      @mixes Coral.mixin.overlay
      @borrows Coral.mixin.overlay#focusOnShow as Coral.Overlay#focusOnShow
      @borrows Coral.mixin.overlay#open as Coral.Overlay#open
      @borrows Coral.mixin.overlay#returnFocus as Coral.Overlay#returnFocus
      @borrows Coral.mixin.overlay#trapFocus as Coral.Overlay#trapFocus
      @borrows Coral.mixin.overlay#show as Coral.Overlay#show
      @borrows Coral.mixin.overlay#hide as Coral.Overlay#hide
      @borrows Coral.mixin.overlay#returnFocusTo as Coral.Overlay#returnFocusTo
      @borrows Coral.mixin.overlay#event:coral-overlay:beforeopen as Coral.Overlay#coral-overlay:beforeopen
      @borrows Coral.mixin.overlay#event:coral-overlay:beforeclose as Coral.Overlay#coral-overlay:beforeclose
      @borrows Coral.mixin.overlay#event:coral-overlay:open as Coral.Overlay#coral-overlay:open
      @borrows Coral.mixin.overlay#event:coral-overlay:close as Coral.Overlay#coral-overlay:close

      @htmltag coral-overlay
    */
    name: 'Overlay',
    tagName: 'coral-overlay',
    className: 'coral3-Overlay',

    mixins: [
      Coral.mixin.overlay
    ],

    events: {
      'global:resize': '_position',
      'global:key:escape': '_handleEscape',
      'click [coral-close]': '_handleCloseClick'
    },

    properties: {
      /**
        The element the overlay should position relative to. It accepts values from {@link Coral.Overlay.target}, as
        well as a DOM element or a CSS selector. If a CSS selector is provided, the first matching element will be used.
        If a target is not specified, the overlay will not respect {@link Coral.Overlay#alignMy},
        {@link Coral.Overlay#alignAt}, or {@link Coral.Overlay#collision}.

        @type {Coral.Overlay.target|?HTMLElement|String}
        @default null
        @htmlattribute target
        @memberof Coral.Overlay#
      */
      'target': {
        default: null,
        // We don't want to validate that the value must change here
        // If a selector is provided, we'll take the first element matching that selector
        // If the DOM is modified and the user wants a new target with the same selector,
        // They should be able to set target = 'selector' again and get a different element
        validate: function(value) {
          return value === null || typeof value === 'string' || value instanceof Node;
        },
        set: function(value) {
          // Store new value
          this._target = value;

          if (this.target) {
            if (this.open) {
              // If the overlay is already visible, we should move it
              this._position();

              // To make it return focus to the right item, change the target
              if (this._returnFocus === Coral.mixin.overlay.returnFocus.ON) {
                this.returnFocusTo(this._getTarget());
              }
            }
          }
        }
      },

      /**
        The point on the overlay we should anchor from when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.CENTER_CENTER
        @htmlattribute alignmy
        @memberof Coral.Overlay#
      */
      'alignMy': {
        attribute: 'alignmy',
        default: align.CENTER_CENTER,
        transform: transformAlignment,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(align)
        ],
        sync: repositionIfOpen // @todo do this once if both align properties change
      },

      /**
        The point on the target we should anchor to when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.CENTER_CENTER
        @htmlattribute alignat
        @memberof Coral.Overlay#
      */
      'alignAt': {
        attribute: 'alignat',
        default: align.CENTER_CENTER,
        transform: transformAlignment,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(align)
        ],
        sync: repositionIfOpen // @todo do this once if both align properties change
      },

      /**
        The distance the overlay should be from its target.

        @type {Number}
        @default 0
        @htmlattribute offset
        @memberof Coral.Overlay#
      */
      'offset': {
        default: 0,
        transform: Coral.transform.number,
        validate: function(value) {
          return typeof value === 'number';
        },
        set: function(value) {
          this._offset = value;

          if (this.open) {
            // If the overlay is already visible, we should move it accordingly
            this._position();
          }
        }
      },

      /**
        The placement of the overlay. This property sets {@link Coral.Overlay#alignMy} and {@link Coral.Overlay#alignAt}.

        @type {Coral.Overlay.placement}
        @default null
        @htmlattribute placement
        @memberof Coral.Overlay#
      */
      'placement': {
        // default: null, // Don't provide a defualt here
        transform: transformAlignment,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(placement)
        ],
        set: function(value) {
          var alignValues = this._placementAlignValues[value];

          this.alignMy = alignValues.alignMy;
          this.alignAt = alignValues.alignAt;

          this._placement = value;
        }
      },

      /**
        The bounding element for the overlay. The overlay will be sized and positioned such that it is contained within
        this element. It accepts both a DOM Element or a CSS selector. If a CSS selector is provided, the first matching
        element will be used.

        @type {HTMLElement|String}
        @default window
        @memberof Coral.Overlay#
      */
      'within': {
        default: window,
        sync: repositionIfOpen
      },

      /**
        The collision handling strategy when positioning the overlay relative to a target.

        @type {Coral.Overlay.collision}
        @default Coral.Overlay.collision.FLIP_FIT
        @htmlattribute collision
        @memberof Coral.Overlay#
      */
      'collision': {
        default: collision.FLIP_FIT,
        sync: repositionIfOpen
      },

      // JSdoc inheritec
      'open': {
        sync: function() {
          if (this.open) {
            // Position when opened
            this._position();
          }
        }
      },

      /**
        Whether keyboard interaction is enabled.

        @type {Coral.Overlay.interaction}
        @default Coral.Overlay.interaction.ON
        @memberof Coral.Overlay#
      */
      'interaction': {
        default: interaction.ON,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(interaction)
        ]
      }
    },

    /** @protected */
    _overlayAnimationTime: 0,

    /** @ignore */
    _initialize: function() {
      // Hidden by default
      this.style.display = 'none';
    },

    /*
      Get the element the overlay is anchored to.

      @protected
      @param {HTMLElement|String} [target]
        A specific target value to use.
        If not provided, the current value of the {@link Coral.Overlay#target} property will be used.
      @memberof Coral.Overlay#
      @returns {HTMLElement|null}
    */
    _getTarget: function(targetValue) {
      // Use passed target
      targetValue = targetValue || this.target;

      if (targetValue instanceof Node) {
        // Just return the provided Node
        return targetValue;
      }

      // Dynamically get the target node based on target
      var newTarget = null;
      if (typeof targetValue === 'string') {
        if (targetValue === target.PREVIOUS) {
          newTarget = this.previousElementSibling;
        }
        else if (targetValue === target.NEXT) {
          newTarget = this.nextElementSibling;
        }
        else {
          newTarget = document.querySelector(targetValue);
        }
      }

      return newTarget;
    },

    /**
      A map of placement values to their corresponding alignMy and alignAt values.

      @protected
    */
    _placementAlignValues: {
      'right': {
        alignMy: 'left center',
        alignAt: 'right center'
      },
      'left': {
        alignMy: 'right center',
        alignAt: 'left center'
      },
      'top': {
        alignMy: 'center bottom',
        alignAt: 'center top'
      },
      'bottom': {
        alignMy: 'center top',
        alignAt: 'center bottom'
      }
    },

    /**
      Re-position the overlay if it's currently open.

      @function
      @memberof Coral.Overlay#
    */
    reposition: repositionIfOpen,

    /**
      Position the overlay according to {@link Coral.Overlay#target} and
      {@link Coral.Overlay#alignMy}/{@link Coral.Overlay#alignAt}.

      @protected
      @memberof Coral.Overlay#
    */
    _position: function() {
      // @todo do this sync style so we don't position more than necessary?

      // Do nothing unless open
      if (!this.open) {
        return;
      }

      var targetEl = this._getTarget();

      // Do nothing unless we have a target
      if (!targetEl) {
        return;
      }

      // A hook to allow implementation of strategies for preventing miscalculation
      this._beforePosition();

      // Apply offset
      var offset = this.offset;
      var offsetStrings = [];
      var alignMy = this.alignMy;
      var alignAt = this.alignAt;
      var alignMyParts = alignMy.split(' ');
      var alignAtParts = alignAt.split(' ');

      offsetStrings[0] = (offset > 0) ? '+' + offset : offset;
      offsetStrings[1] = (offset > 0) ? '-' + offset : '+' + -offset;

      if (offset) {
        if (alignMyParts[1] === 'top' && (alignAtParts[1] === 'bottom' || alignAtParts[1] === 'top')) {
          alignMy += offsetStrings[0];
        }
        else if (alignMyParts[1] === 'bottom' && (alignAtParts[1] === 'top' || alignAtParts[1] === 'bottom')) {
          alignMy += offsetStrings[1];
        }
        else if (alignMyParts[0] === 'left' && (alignAtParts[0] === 'right' || alignAtParts[0] === 'left')) {
          alignMy = alignMyParts.join(offsetStrings[0] + ' ');
        }
        else if (alignMyParts[0] === 'right' && (alignAtParts[0] === 'left' || alignAtParts[0] === 'right')) {
          alignMy = alignMyParts.join(offsetStrings[1] + ' ');
        }
      }

      // Perform the positioning calculation
      // TODO remove jQuery UI position dep
      $(this).position({
        my: alignMy,
        at: alignAt,
        using: this._positionCallback,
        of: targetEl,
        collision: this.collision,
        within: this.within
      });
    },

    /**
      Called before positioning to setup the element (width etc).

      @protected
    */
    _beforePosition: function() {
      var windowWidth = window.innerWidth;

      // Set max width if we're on the left or right
      if (this.alignMy.indexOf('left') === 0 || this.alignMy.indexOf('right') === 0) {
        // Make sure we're visible by setting display
        this.style.display = 'block';

        var target = this._getTarget();

        // Get the position and width of the target
        var targetPos = target.getBoundingClientRect();

        // Get the max width of the overlay
        var distanceFromRight = windowWidth - (targetPos.left + targetPos.width);
        var distanceFromLeft = targetPos.left;
        var maxWidth = Math.max(distanceFromLeft, distanceFromRight);

        // Set the width
        this.style.maxWidth = maxWidth + 'px';

        // Reset display value
        this.style.display = '';
      }
      else {
        // Top and bottom tooltips should never be wider than the screen
        this.style.maxWidth = windowWidth + 'px';
      }

      // Don't let the current position dictate the width of the element
      // If we're on the extreme left/right, we may be squishing
      this.style.left = '-9999px';
      this.style.top = '-9999px';
    },

    /**
      Receive the jQueryUI position utility's result and trigger events.

      @ignore

      @param {Object} position
        The calculated position.
      @param {Object} position.left
        The left position.
      @param {Object} position.right
        The right position.

      @fires Coral.Overlay#coral-overlay:positioned
    */
    _positionCallback: function(position, feedback) {
      this._applyPosition(position, feedback);
      this.trigger('coral-overlay:positioned', feedback);
    },

    /**
      Apply the calculated position.

      @protected

      @param {Object} position
        The calculated position.
      @param {Object} position.left
        The left position.
      @param {Object} position.right
        The right position.
    */
    _applyPosition: function(position, feedback) {
      this.style.top = position.top + 'px';
      this.style.left = position.left + 'px';
    },

    /**
      @todo maybe this should be mixin or something
      @ignore
    */
    _handleCloseClick: function(event) {
      var dismissTarget = event.matchedTarget;
      var dismissValue = dismissTarget.getAttribute('coral-close');
      if (!dismissValue || this.matches(dismissValue)) {
        this.hide();
        event.stopPropagation();
      }
    },

    /**
      Hides the overlay if it's on the top. When <code>interaction</code> is OFF it is ignored.

      @ignore
    */
    _handleEscape: function(event) {
      if (this.interaction === interaction.ON && this.open && this._isTopOverlay()) {
        this.hide();
      }
    },

    /**
      @name Coral.Component#hide
      @ignore
    */

    /**
      @name Coral.Component#show
      @ignore
    */

    /**
      Triggered after the overlay is positioned.

      @event Coral.Overlay#coral-overlay:positioned

      @param {Object} event
        Event object.
      @param {String} event.detail.vertical
        The vertical position of the target relative to the overlay.
        <code>top</code> when the overlay is at the bottom, <code>bottom</code> when it is at the top.
      @param {String} event.detail.horizontal
        The horizontal position of the target relative to the overlay.
        <code>left</code> when the overlay is to the right, <code>right</code> when it is to the left.
      @param {String} event.detail.target
        The target's position.
      @param {String} event.detail.element
        The overlay's position.
    */
  });

  // Expose enums globally
  Coral.Overlay.align = align;
  Coral.Overlay.collision = collision;
  Coral.Overlay.target = target;
  Coral.Overlay.placement = placement;
  Coral.Overlay.interaction = interaction;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Attributes
  var DRAG_ACTION_ATTRIBUTE = 'coral-dragaction';
  var DROP_ZONE_ATTRIBUTE = 'coral-dragaction-dropzone';
  var HANDLE_ATTRIBUTE = 'coral-dragaction-handle';
  var AXIS_ATTRIBUTE = 'coral-dragaction-axis';
  var SCROLL_ATTRIBUTE = 'coral-dragaction-scroll';
  var CONTAINMENT_ATTRIBUTE = 'coral-dragaction-containment';

  // Classes
  var OPEN_HAND_CLASS = 'u-coral-openHand';
  var CLOSE_HAND_CLASS = 'u-coral-closedHand';
  var IS_DRAGGING_CLASS = 'is-dragging';

  // Scroll offset default values
  var DEFAULT_SCROLL_OFFSET = 20;
  var DEFAULT_SCROLL_BY = 10;

  /**
    Enum for DragAction axis restriction values.

    @enum {String}
    @memberof Coral.DragAction
  */
  var axis = {
    /** Allows vertically and horizontally dragging. */
    FREE: 'free',
    /** Allows vertically dragging only. */
    VERTICAL: 'vertical',
    /** Allows horizontally dragging only. */
    HORIZONTAL: 'horizontal'
  };
  
  /**
    @ignore
    @param {HTMLElement} element
    @returns {HTMLElement}
      First parent element with overflow [hidden|scroll|auto]
  */
  function getViewContainer(element) {
    while (true) {
      var p = element.parentNode;

      if (!p) {
        return p;
      }
      if (p.matches('body')) {
        return p;
      }
  
      var computedStyle = window.getComputedStyle(p);
      var overflow = computedStyle.overflow;
      // IE11 can return a value for overflow even if it was not set compared to other browsers so we check for X and Y.
      var overflowX = computedStyle.overflowX;
      var overflowY = computedStyle.overflowY;
  
      if ((overflow === 'hidden' || overflow === 'auto' || overflow === 'scroll') &&
        // @polyfill IE11
        overflow === overflowX && overflow === overflowY) {
        return p;
      }

      element = p;
    }
  }
  
  /**
    @ignore
    @param {String|HTMLElement|NodeList} el
    @returns {Array.<HTMLElement>}
      X and y position whether event was generated by a click or a touch
  */
  function transformToArray(el) {
    if (typeof el === 'string') {
      return Array.prototype.slice.call(document.querySelectorAll(el));
    }
    else if (el instanceof HTMLElement) {
      return [el];
    }
    else if (Object.prototype.toString.call(el) === '[object NodeList]') {
      return Array.prototype.slice.call(el);
    }
  }

  /**
    @ignore
    @param {Object} event
    @returns {Object}
      X and y position whether event was generated by a click or a touch
  */
  function getPagePosition(event) {
    var touch = {};
    
    if (event.changedTouches && event.changedTouches.length > 0) {
      touch = event.changedTouches[0];
    }
    else if (event.touches && event.touches.length > 0) {
      touch = event.touches[0];
    }
    
    return {
      x: touch.pageX || event.pageX,
      y: touch.pageY || event.pageY
    };
  }

  /**
    @ignore
    @param {Coral.DragAction} self
      Coral.DragAction instance
    @returns {HTMLElement}
      The dropzone that is being hovered by the dragged element or null if none
  */
  function isOverDropZone(self) {
    var el = null;
    if (self._dropZones && self._dropZones.length) {
      self._dropZones.some(function(dropZone) {
        if (within(self._scrollingElement, self._dragElement, dropZone)) {
          el = dropZone;
          return true;
        }
      });
    }

    return el;
  }

  /**
    @ignore
    @param {HTMLElement} scrollingElement
      element that scrolls the document
    @param {HTMLElement} a
    @param {HTMLElement} b
    @returns {Boolean}
      Whether a is within b bounds
  */
  function within(scrollingElement, a, b) {
    var aBoundingClientRect = a.getBoundingClientRect();
    var bBoundingClientRect = b.getBoundingClientRect();
    var documentScrollTop = scrollingElement.scrollTop;
    var documentScrollLeft = scrollingElement.scrollLeft;
    
    var al = aBoundingClientRect.left + documentScrollLeft;
    var ar = al + aBoundingClientRect.width;
    var bl = bBoundingClientRect.left + documentScrollLeft;
    var br = bl + bBoundingClientRect.width;

    var at = aBoundingClientRect.top + documentScrollTop;
    var ab = at + aBoundingClientRect.height;
    var bt = bBoundingClientRect.top + documentScrollTop;
    var bb = bt + bBoundingClientRect.height;

    return !((bl > ar || br < al) || (bt > ab || bb < at));
  }

  /**
    @class Coral.DragAction
    @classdesc This a decorator which adds draggable functionality to DOM elements
    @param {String|HTMLElement} dragElement
      The draggable element.
  */
  Coral.DragAction = function(dragElement) {
    if (!dragElement) {
      throw new Error('Coral.DragAction: dragElement is missing');
    }
    
    var el = null;
    if (dragElement instanceof HTMLElement) {
      el = dragElement;
    }
    else if (typeof dragElement === 'string') {
      el = document.querySelector(dragElement);
      if (!el) {
        throw new Error('Coral.DragAction: dragElement is null');
      }
    }
    
    this._id = Coral.commons.getUID();
    this._dragElementValue = dragElement;
    this._dragElement = el;

    // Destroy instance if existing
    if (this._dragElement.dragAction) {
      this._dragElement.dragAction.destroy();
    }

    var computedStyle = window.getComputedStyle(this._dragElement);
    
    // Store initial position
    this._initialPosition = {
      position: computedStyle.position,
      left: computedStyle.left,
      top: computedStyle.top
    };

    // Prepare Vent
    this._dragEvents = new window.Vent(this._dragElement);

    // Handle options. Binds events to dragElement if no handles defined or found
    this.handle = this._dragElement.getAttribute(HANDLE_ATTRIBUTE);

    // DropZone options
    this.dropZone = this._dragElement.getAttribute(DROP_ZONE_ATTRIBUTE);

    // Axis horizontal|vertical
    this.axis = this._dragElement.getAttribute(AXIS_ATTRIBUTE);

    // Scroll options
    this.scroll = this._dragElement.matches('[' + SCROLL_ATTRIBUTE + ']');

    // Restriction to container
    this.containment = this._dragElement.matches('[' + CONTAINMENT_ATTRIBUTE + ']');

    this._drag = this._drag.bind(this);
    this._dragEnd = this._dragEnd.bind(this);

    Coral.events.on('touchmove.CoralDragAction' + this._id, this._drag);
    Coral.events.on('mousemove.CoralDragAction' + this._id, this._drag);
    Coral.events.on('touchend.CoralDragAction' + this._id, this._dragEnd);
    Coral.events.on('mouseup.CoralDragAction' + this._id, this._dragEnd);

    // Store reference on dragElement
    this._dragElement.dragAction = this;
  };

  Coral.DragAction.prototype = {};
  
  /** @private */
  Object.defineProperty(Coral.DragAction.prototype, '_scrollingElement', {
    get: function() {
      // @polyfill ie11
      // Element that scrolls the document.
      return document.scrollingElement || document.documentElement;
    }
  });

  /**
    The draggable element.

    @name dragElement
    @readonly
    @type {String|HTMLElement}
    @htmlattribute coral-dragaction
    @memberof Coral.DragAction#
  */
  Object.defineProperty(Coral.DragAction.prototype, 'dragElement', {
    get: function() {
      return this._dragElementValue;
    },
    set: function(value) {}
  });

  /**
    The handle allowing to drag the element.

    @name handle
    @type {String|HTMLElement}
    @htmlattribute coral-dragaction-handle
    @memberof Coral.DragAction#
  */
  Object.defineProperty(Coral.DragAction.prototype, 'handle', {
    get: function() {
      return this._handle;
    },
    set: function(value) {
      if (Coral.validate.valueMustChange(value, this._handle)) {
  
        // Set new value
        this._handle = value;

        // Unbind events
        this._dragEvents.off('.CoralDragAction');
        
        // Remove classes
        document.body.classList.remove(CLOSE_HAND_CLASS);
        this._dragElement.classList.remove(IS_DRAGGING_CLASS);
        if (this._handles && this._handles.length) {
          this._handles.forEach(function(handle) {
            handle._dragEvents.off('.CoralDragAction');
            handle.classList.remove(OPEN_HAND_CLASS);
          });
        }
        else {
          this._dragElement.classList.remove(OPEN_HAND_CLASS);
        }

        if (typeof value === 'string' ||
          value instanceof HTMLElement ||
          Object.prototype.toString.call(value) === '[object NodeList]') {
          
          this._handles = transformToArray(value);
          
          // Bind events
          if (this._handles && this._handles.length) {
            var self = this;
            this._handles.forEach(function(handle) {
              handle._dragEvents = handle._dragEvents || new window.Vent(handle);
              handle._dragEvents.on('mousedown.CoralDragAction', self._dragStart.bind(self));
              handle._dragEvents.on('touchstart.CoralDragAction', self._dragStart.bind(self));
              handle.classList.add(OPEN_HAND_CLASS);
            });
          }
          else {
            this._dragEvents.on('touchstart.CoralDragAction', this._dragStart.bind(this));
            this._dragEvents.on('mousedown.CoralDragAction', this._dragStart.bind(this));
            this._dragElement.classList.add(OPEN_HAND_CLASS);
          }
        }
        else {
          // Defaults to the dragElement
          this._handles = [];
          this._dragEvents.on('touchstart.CoralDragAction', this._dragStart.bind(this));
          this._dragEvents.on('mousedown.CoralDragAction', this._dragStart.bind(this));
          this._dragElement.classList.add(OPEN_HAND_CLASS);
        }
      }
    }
  });

  /**
    The dropZone to drop the dragged element.

    @name dropZone
    @type {String|HTMLElement}
    @htmlattribute coral-dragaction-dropzone
    @memberof Coral.DragAction#
  */
  Object.defineProperty(Coral.DragAction.prototype, 'dropZone', {
    get: function() {
      return this._dropZone;
    },
    set: function(value) {
      if (Coral.validate.valueMustChange(value, this._dropZone)) {
        // Set new value
        this._dropZone = value;
        this._dropZoneEntered = false;

        if (typeof value === 'string' ||
          value instanceof HTMLElement ||
          Object.prototype.toString.call(value) === '[object NodeList]') {
          this._dropZones = transformToArray(value);
        }
        else {
          this._dropZones = [];
        }
      }
    }
  });

  /**
    The axis to constrain drag movement.

    @name axis
    @type {Coral.DragAction.axis}
    @default Coral.DragAction.axis.FREE
    @htmlattribute coral-dragaction-axis
    @memberof Coral.DragAction#
  */
  Object.defineProperty(Coral.DragAction.prototype, 'axis', {
    get: function() {
      return this._axis;
    },
    set: function(value) {
      var newAxis = Coral.transform.string(value);
      if (Coral.validate.valueMustChange(newAxis, this._axis)) {
        if (Coral.validate.enumeration(axis)(newAxis)) {
          this._axis = newAxis;
        }
        else {
          this._axis = axis.FREE;
        }
      }
    }
  });

  /**
    Whether to scroll the container when the draggable element is moved beyond the viewport.

    @name scroll
    @default false
    @type {Boolean}
    @htmlattribute coral-dragaction-scroll
    @memberof Coral.DragAction#
  */
  Object.defineProperty(Coral.DragAction.prototype, 'scroll', {
    get: function() {
      return this._scroll;
    },
    set: function(value) {
      var newScroll = Coral.transform.boolean(value);
      if (Coral.validate.valueMustChange(newScroll, this._scroll)) {
        this._scroll = newScroll;
      }
    }
  });

  /**
    Whether to constrain the draggable element to its container viewport.

    @name containment
    @default false
    @type {Boolean}
    @htmlattribute coral-dragaction-containment
    @memberof Coral.DragAction#
  */
  Object.defineProperty(Coral.DragAction.prototype, 'containment', {
    get: function() {
      return this._containment;
    },
    set: function(value) {
      var newContainment = Coral.transform.boolean(value);
      if (Coral.validate.valueMustChange(newContainment, this._containment)) {
        this._containment = newContainment;
      }
    }
  });

  /** @private */
  Coral.DragAction.prototype._dragStart = function(event) {
    // Container
    this._container = getViewContainer(this._dragElement);

    // Prevent dragging ghost image
    if (event.target.tagName === 'IMG') {
      event.preventDefault();
    }

    // Prevent touchscreen windows to scroll while dragging
    Coral.events.on('touchmove.CoralDragAction', function(event) {
      event.preventDefault();
    });

    document.body._overflow = getComputedStyle(document.body).overflow;
    document.body.style.overflow = 'hidden';

    if (!this._container.matches('body')) {
      this._container._overflow = getComputedStyle(this._container).overflow;
      this._container.style.overflow = this.scroll ? 'scroll' : 'hidden';
    }
    
    var pagePosition = getPagePosition(event);
    var dragElementBoundingClientRect = this._dragElement.getBoundingClientRect();
    this._dragPosition = getPagePosition(event);
    this._dragPosition.y -= dragElementBoundingClientRect.top + this._scrollingElement.scrollTop;
    this._dragPosition.x -= dragElementBoundingClientRect.left + this._scrollingElement.scrollLeft;
    
    // Handle classes
    document.body.classList.add(CLOSE_HAND_CLASS);
    if (this._handles && this._handles.length) {
      this._handles.forEach(function(handle) {
        handle.classList.remove(OPEN_HAND_CLASS);
      });
    }
    else {
      this._dragElement.classList.remove(OPEN_HAND_CLASS);
    }
    this._dragElement.classList.add(IS_DRAGGING_CLASS);
    
    // Apply relative position by default
    if (window.getComputedStyle(this._dragElement).position === 'static') {
      this._dragElement.style.position = 'relative';
    }

    this._dragEvents.dispatch('coral-dragaction:dragstart', {
      detail: {
        dragElement: this._dragElement,
        pageX: pagePosition.x,
        pageY: pagePosition.y
      }
    });
  };

  /** @private */
  Coral.DragAction.prototype._drag = function(event) {
    if (this._dragElement.classList.contains(IS_DRAGGING_CLASS)) {
      var self = this;
      var pagePosition = getPagePosition(event);
  
      var documentScrollTop = this._scrollingElement.scrollTop;
      var documentScrollLeft = this._scrollingElement.scrollLeft;
      
      var dragElementBoundingClientRect = this._dragElement.getBoundingClientRect();
      var dragElementHeight = dragElementBoundingClientRect.height;
      var dragElementWidth = dragElementBoundingClientRect.width;
      var dragElementPosition = {
        top: dragElementBoundingClientRect.top + documentScrollTop,
        left: dragElementBoundingClientRect.left + documentScrollLeft
      };
      var dragElementComputedStyle = window.getComputedStyle(this._dragElement);
      var dragElementCSSPosition = {
        top: parseFloat(dragElementComputedStyle.top) || 0,
        left: parseFloat(dragElementComputedStyle.left) || 0
      };
      
      var containerBoundingClientRect = this._container.getBoundingClientRect();
      var containerWidth = containerBoundingClientRect.width;
      var containerHeight = containerBoundingClientRect.height;
      var containerPosition = {
        top: containerBoundingClientRect.top + documentScrollTop,
        left: containerBoundingClientRect.left + documentScrollLeft
      };

      self._dragEvents.dispatch('coral-dragaction:drag', {
        detail: {
          dragElement: self._dragElement,
          pageX: pagePosition.x,
          pageY: pagePosition.y
        }
      });

      // Remove selection
      if (document.selection) {
        document.selection.empty();
      }
      else if (window.getSelection) {
        // @polyfill ie
        if (window.getSelection().removeAllRanges) {
          window.getSelection().removeAllRanges();
        }
      }

      // Need to scroll ?
      if (this.scroll) {
        // Scroll element is the document
        if (this._container === document.body) {
          // Scroll to the top
          if (dragElementBoundingClientRect.top < DEFAULT_SCROLL_OFFSET) {
            this._scrollingElement.scrollTop = documentScrollTop - DEFAULT_SCROLL_BY;
          }
          // Scroll to the bottom but don't go further than the maximum scroll position of the document
          else if (dragElementBoundingClientRect.top + dragElementBoundingClientRect.height > window.innerHeight - DEFAULT_SCROLL_OFFSET &&
            dragElementPosition.top + dragElementBoundingClientRect.height + DEFAULT_SCROLL_OFFSET < this._scrollingElement.scrollHeight) {
            this._scrollingElement.scrollTop = documentScrollTop + DEFAULT_SCROLL_BY;
          }
  
          // Scroll to the left
          if (dragElementBoundingClientRect.left < DEFAULT_SCROLL_OFFSET) {
            this._scrollingElement.scrollLeft = documentScrollLeft - DEFAULT_SCROLL_BY;
          }
          // Scroll to the right but don't go further than the maximum scroll position of the document
          else if (dragElementBoundingClientRect.left + dragElementBoundingClientRect.width > window.innerWidth - DEFAULT_SCROLL_OFFSET &&
            dragElementPosition.left + dragElementBoundingClientRect.width + DEFAULT_SCROLL_OFFSET < this._scrollingElement.scrollWidth) {
            this._scrollingElement.scrollLeft = documentScrollLeft + DEFAULT_SCROLL_BY;
          }
        }
        // Scroll element is an element other than the document
        else {
          // Scroll to the top
          if (dragElementBoundingClientRect.top - containerBoundingClientRect.top < DEFAULT_SCROLL_OFFSET) {
            this._container.scrollTop = this._container.scrollTop - DEFAULT_SCROLL_BY;
          }
          // Scroll to the bottom but don't go further than the maximum scroll position of the container
          else if (dragElementBoundingClientRect.top - containerBoundingClientRect.top + dragElementBoundingClientRect.height > containerBoundingClientRect.height - DEFAULT_SCROLL_OFFSET &&
            dragElementBoundingClientRect.top - containerBoundingClientRect.top + dragElementBoundingClientRect.height < containerBoundingClientRect.height) {
            this._container.scrollTop = this._container.scrollTop + DEFAULT_SCROLL_BY;
          }
          
          // Scroll to the left
          if (dragElementBoundingClientRect.left - containerBoundingClientRect.left < DEFAULT_SCROLL_OFFSET) {
            this._container.scrollLeft = this._container.scrollLeft - DEFAULT_SCROLL_BY;
          }
          // Scroll to the bottom but don't go further than the maximum scroll position of the container
          else if (dragElementBoundingClientRect.left - containerBoundingClientRect.left + dragElementBoundingClientRect.width > containerBoundingClientRect.width - DEFAULT_SCROLL_OFFSET &&
            dragElementBoundingClientRect.left - containerBoundingClientRect.left + dragElementBoundingClientRect.width < containerBoundingClientRect.width) {
            this._container.scrollLeft = this._container.scrollLeft + DEFAULT_SCROLL_BY;
          }
        }
      }

      // Set drag element's new position
      var newPosition = {};

      if (this.axis !== 'horizontal') {
        var top = pagePosition.y - this._dragPosition.y;

        // Applying container containment for y movements
        if (this.containment) {
          if (top >= containerPosition.top && top + dragElementHeight <= containerPosition.top + containerHeight) {
            newPosition.top = top;
          }
          else {
            // put the drag element to the container's top
            if (pagePosition.y <= containerPosition.top) {
              newPosition.top = containerPosition.top;
            }
            // put the drag element to the container's bottom
            else if (pagePosition.y >= containerPosition.top + containerHeight) {
              newPosition.top = containerPosition.top + containerHeight - dragElementHeight;
            }
          }
        }
        else {
          newPosition.top = top;
        }
      }
      if (this.axis !== 'vertical') {
        var left = pagePosition.x - this._dragPosition.x;

        // Applying container containment for x movements
        if (this.containment) {
          if (left >= containerPosition.left && left + dragElementWidth <= containerPosition.left + containerWidth) {
            newPosition.left = left;
          }
          else {
            // put the drag element to the container's left
            if (pagePosition.x <= containerPosition.left) {
              newPosition.left = containerPosition.left;
            }
            // put the drag element to the container's right
            else if (pagePosition.x >= containerPosition.left + containerWidth) {
              newPosition.left = containerPosition.left + containerWidth - dragElementWidth;
            }
          }
        }
        else {
          newPosition.left = left;
        }
      }

      // Set the new position
      this._dragElement.style.top = newPosition.top - dragElementPosition.top + dragElementCSSPosition.top + 'px';
      this._dragElement.style.left = newPosition.left - dragElementPosition.left + dragElementCSSPosition.left + 'px';

      // Trigger dropzone related events
      var dropZone = isOverDropZone(self);
      if (dropZone) {
        self._dropElement = dropZone;
        if (!self._dropZoneEntered) {
          self._dropZoneEntered = true;
          self._dragEvents.dispatch('coral-dragaction:dragenter', {
            detail: {
              dragElement: self._dragElement,
              pageX: pagePosition.x,
              pageY: pagePosition.y,
              dropElement: self._dropElement
            }
          });
        }

        self._dragEvents.dispatch('coral-dragaction:dragover', {
          detail: {
            dragElement: self._dragElement,
            pageX: pagePosition.x,
            pageY: pagePosition.y,
            dropElement: self._dropElement
          }
        });
      }
      else {
        if (self._dropZoneEntered) {
          self._dragEvents.dispatch('coral-dragaction:dragleave', {
            detail: {
              dragElement: self._dragElement,
              pageX: pagePosition.x,
              pageY: pagePosition.y,
              dropElement: self._dropElement
            }
          });
          self._dropZoneEntered = false;
        }
      }
    }
  };

  /** @private */
  Coral.DragAction.prototype._dragEnd = function(event) {
    if (this._dragElement.classList.contains(IS_DRAGGING_CLASS)) {
      var pagePosition = getPagePosition(event);

      // Restore overflow
      document.body.style.overflow = document.body._overflow;
      document.body._overflow = undefined;

      if (!this._container.matches('body')) {
        this._container.style.overflow = this._container._overflow;
        this._container._overflow = undefined;
      }

      document.body.classList.remove(CLOSE_HAND_CLASS);
      this._dragElement.classList.remove(IS_DRAGGING_CLASS);
      
      if (this._handles && this._handles.length) {
        this._handles.forEach(function(handle) {
          handle.classList.add(OPEN_HAND_CLASS);
        });
      }
      else {
        this._dragElement.classList.add(OPEN_HAND_CLASS);
      }

      if (this._dropZoneEntered) {
        var dropZone = isOverDropZone(this);
        if (dropZone) {
          this._dropElement = dropZone;
          this._dragEvents.dispatch('coral-dragaction:drop', {
            detail: {
              dragElement: this._dragElement,
              pageX: pagePosition.x,
              pageY: pagePosition.y,
              dropElement: this._dropElement
            }
          });
        }
      }

      this._dragEvents.dispatch('coral-dragaction:dragend', {
        detail: {
          dragElement: this._dragElement,
          pageX: pagePosition.x,
          pageY: pagePosition.y
        }
      });
    }
  };

  /**
    Remove draggable actions

    @function destroy
    @param {Boolean} restorePosition
      Whether to restore the draggable element to its initial position
    @memberof Coral.DragAction
  */
  Coral.DragAction.prototype.destroy = function(restorePosition) {
    // Unbind events and remove classes
    document.body.classList.remove(CLOSE_HAND_CLASS);
    this._dragElement.classList.remove(IS_DRAGGING_CLASS);
    if (this._handles && this._handles.length) {
      this._handles.forEach(function(handle) {
        handle._dragEvents.off('.CoralDragAction');
        handle.classList.remove(OPEN_HAND_CLASS);
      });
    }
    else {
      this._dragEvents.off('.CoralDragAction');
      this._dragElement.classList.remove(OPEN_HAND_CLASS);
    }
    
    Coral.events.off('.CoralDragAction' + this._id);

    // Restore overflow
    if (document.body._overflow) {
      document.body.style.overflow = document.body._overflow;
      document.body._overflow = undefined;
    }

    // Container might not have been initialized
    if (this._container) {
      if (!this._container.matches('body') && this._container._overflow) {
        this._container.style.overflow = this._container._overflow;
        this._container._overflow = undefined;
      }
    }

    // Set to initial position
    if (restorePosition) {
      this._dragElement.style.position = this._initialPosition.position;
      this._dragElement.style.top = this._initialPosition.top;
      this._dragElement.style.left = this._initialPosition.left;
    }

    // Remove reference
    this._dragElement.dragAction = undefined;
  };

  // Exports the axis enumeration
  Coral.DragAction.axis = axis;

  // Apply draggable actions
  document.addEventListener('DOMContentLoaded', function() {
    Array.prototype.forEach.call(document.body.querySelectorAll('[' + DRAG_ACTION_ATTRIBUTE + ']'), function(el) {
      new Coral.DragAction(el);
    });
  });

  /**
    Triggered when the drag element starts to be dragged.

    @event Coral.DragAction#coral-dragaction:dragstart

    @param {HTMLElement} dragElement
      The dragged element
    @param {Number} pageX
      The mouse position relative to the left edge of the document.
    @param {Number} pageY
      The mouse position relative to the top edge of the document.
  */

  /**
    Triggered when the drag element is being dragged.

    @event Coral.DragAction#coral-dragaction:drag

    @param {HTMLElement} dragElement
      The dragged element
    @param {Number} pageX
      The mouse position relative to the left edge of the document.
    @param {Number} pageY
      The mouse position relative to the top edge of the document.
  */

  /**
    Triggered when the drag element stops to be dragged.

    @event Coral.DragAction#coral-dragaction:dragend

    @param {HTMLElement} dragElement
      The dragged element
    @param {Number} pageX
      The mouse position relative to the left edge of the document.
    @param {Number} pageY
      The mouse position relative to the top edge of the document.
  */

  /**
    Triggered when the drag element enters a drop element.

    @event Coral.DragAction#coral-dragaction:dragenter

    @param {HTMLElement} dragElement
      The dragged element
    @param {HTMLElement} dropElement
      The drop element
    @param {Number} pageX
      The mouse position relative to the left edge of the document.
    @param {Number} pageY
      The mouse position relative to the top edge of the document.
  */

  /**
    Triggered when the drag element is over a drop element.

    @event Coral.DragAction#coral-dragaction:dragover

    @param {HTMLElement} dragElement
      The dragged element
    @param {HTMLElement} dropElement
      The drop element
    @param {Number} pageX
      The mouse position relative to the left edge of the document.
    @param {Number} pageY
      The mouse position relative to the top edge of the document.
  */

  /**
    Triggered when the drag element leaves a drop element.

    @event Coral.DragAction#coral-dragaction:dragleave

    @param {HTMLElement} dragElement
      The dragged element
    @param {HTMLElement} dropElement
      The drop element
    @param {Number} pageX
      The mouse position relative to the left edge of the document.
    @param {Number} pageY
      The mouse position relative to the top edge of the document.
  */

  /**
    Triggered when the drag element is dropped on a drop element.

    @event Coral.DragAction#coral-dragaction:drop

    @param {HTMLElement} dragElement
      The dragged element
    @param {HTMLElement} dropElement
      The drop element
    @param {Number} pageX
      The mouse position relative to the left edge of the document.
    @param {Number} pageY
      The mouse position relative to the top edge of the document.
  */
})();

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-dialog"] = {"en-US":{"Close":"Close"},"de-DE":{"Close":"Schließen"},"fr-FR":{"Close":"Fermer"},"it-IT":{"Close":"Chiudi"},"ja-JP":{"Close":"閉じる"},"es-ES":{"Close":"Cerrar"},"ko-KR":{"Close":"닫기"},"zh-CN":{"Close":"关闭"},"zh-TW":{"Close":"關閉"},"pt-BR":{"Close":"Fechar"},"nl-NL":{"Close":"Sluiten"},"da-DK":{"Close":"Luk"},"fi-FI":{"Close":"Sulje"},"nb-NO":{"Close":"Lukk"},"sv-SE":{"Close":"Stäng"},"cs-CZ":{"Close":"Zavřít"},"pl-PL":{"Close":"Zamknij"},"ru-RU":{"Close":"Закрыть"},"tr-TR":{"Close":"Kapat"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Dialog"] = window["Coral"]["templates"]["Dialog"] || {};
window["Coral"]["templates"]["Dialog"]["header"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["icon"] = document.createElement("coral-icon");
  el0.setAttribute("handle", "icon");
  el0.className += " coral3-Dialog-typeIcon";
  el0.setAttribute("size", "S");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["headerContent"] = document.createElement("div");
  el2.setAttribute("handle", "headerContent");
  el2.className += " coral3-Dialog-title coral-Heading coral-Heading--2";
  el2.setAttribute("role", "heading");
  el2.setAttribute("aria-level", "2");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["closeButton"] = document.createElement("button","coral-button");
  el4.setAttribute("handle", "closeButton");
  el4.className += " coral3-Dialog-closeButton";
  el4.setAttribute("type", "button");
  el4.setAttribute("is", "coral-button");
  el4.setAttribute("variant", "minimal");
  el4.setAttribute("icon", "close");
  el4.setAttribute("iconsize", "XS");
  el4.setAttribute("title", Coral["i18n"]["get"]('Close'));
  el4.setAttribute("tabindex", "-1");
  el4.setAttribute("coral-close", "");
  frag.appendChild(el4);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Boolean enumeration for dialog closable state.

    @enum {String}
    @memberof Coral.Dialog
  */
  var closable = {
    /** Show a close button on the dialog and close the dialog when clicked. */
    ON: 'on',
    /** Do not show a close button. Elements with the <code>coral-close</code> attribute will still close the dialog. */
    OFF: 'off'
  };

  /**
    Boolean enumeration for dialog keyboard interaction state.

    @enum {String}
    @memberof Coral.Dialog
  */
  var interaction = {
    /** Keyboard interaction is enabled. */
    ON: 'on',
    /** Keyboard interaction is disabled. */
    OFF: 'off'
  };

  /**
    Dialog variants.

    @enum {String}
    @memberof Coral.Dialog
  */
  var variant = {
    /** A dialog with the default, gray header and no icon. */
    DEFAULT: 'default',
    /** A dialog with a red header and warning icon, indicating that an error has occurred. */
    ERROR: 'error',
    /** A dialog with an orange header and warning icon, notifying the user of something important. */
    WARNING: 'warning',
    /** A dialog with a green header and checkmark icon, indicates to the user that an operation was successful. */
    SUCCESS: 'success',
    /** A dialog with a blue header and question mark icon, provides the user with help. */
    HELP: 'help',
    /** A dialog with a blue header and info icon, informs the user of non-critical information. */
    INFO: 'info'
  };

  /**
    Dialog backdrop types.

    @enum {String}
    @memberof Coral.Dialog
  */
  var backdrop = {
    /** No backdrop. */
    NONE: 'none',
    /** A backdrop that hides the dialog when clicked. */
    MODAL: 'modal',
    /** A backdrop that does not hide the dialog when clicked. */
    STATIC: 'static'
  };

  /**
    Map of variant -> icon class names

    @ignore
  */
  var ICON_CLASSES = {
    'error': 'alert',
    'warning': 'alert',
    'success': 'checkCircle',
    'help': 'helpCircle',
    'info': 'infoCircle'
  };

  // The dialog's base classname
  var CLASSNAME = 'coral3-Dialog';
  // Modifier classnames
  var FULLSCREEN_CLASSNAME = CLASSNAME + '--fullscreen';
  var EMPTY_BACKDROP_CLASSNAME = CLASSNAME + '--backdropNone';

  // A string of all possible variant classnames
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.Dialog# */ {
    /**
      @class Coral.Dialog
      @classdesc A Dialog component
      @extends Coral.Component
      @extends Coral.mixin.overlay
      @htmltag coral-dialog
    */
    name: 'Dialog',
    tagName: 'coral-dialog',
    className: CLASSNAME,

    mixins: [
      Coral.mixin.overlay
    ],

    events: {
      'click [coral-close]': '_handleCloseClick',

      // Since we cover the backdrop with ourself for positioning purposes, this is implemented as a click listener
      // instead of using backdropClickedCallback
      'click': '_handleClick',

      // Handle resize events
      'global:resize': 'center',

      'global:key:escape': '_handleEscape'
    },

    properties: {

      /**
        Whether keyboard interaction is enabled.

        @type {Coral.Dialog.interaction}
        @default Coral.Dialog.interaction.ON
        @memberof Coral.Dialog#
      */
      'interaction': {
        default: interaction.ON,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(interaction)
        ]
      },

      /**
        Whether to trap tabs and keep them within the overlay.

        @type {Coral.mixin.overlay.trapFocus}
        @default Coral.mixin.overlay.trapFocus.ON
        @htmlattribute trapfocus
        @memberof Coral.Dialog#
      */
      'trapFocus': {
        default: Coral.mixin.overlay.trapFocus.ON
      },

      /**
        Whether to return focus to the previously focused element when closed.

        @type {Coral.mixin.overlay.returnFocus}
        @default Coral.mixin.overlay.returnFocus.ON
        @htmlattribute returnfocus
        @memberof Coral.Dialog#
      */
      'returnFocus': {
        default: Coral.mixin.overlay.returnFocus.ON
      },

      /**
        The dialog's header element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Dialog#
      */
      'header': Coral.property.contentZone({
        handle: 'header',
        tagName: 'coral-dialog-header',
        insert: function(header) {
          this._elements.headerContent.appendChild(header);
        },
        set: function(value) {
          // Stop observing the old header and observe the new one
          this._observeHeader();

          // Check if header needs to be hidden
          this._hideHeaderIfEmpty();
        }
      }),

      /**
        The dialog's content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Dialog#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-dialog-content',
        defaultContentZone: true,
        insert: function(content) {
          // The content should always be before footer
          this._elements.contentZoneTarget.insertBefore(content, this.footer);
        }
      }),

      /**
        The dialog's footer element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Dialog#
      */
      'footer': Coral.property.contentZone({
        handle: 'footer',
        tagName: 'coral-dialog-footer',
        insert: function(footer) {
          // The footer should always be after content
          this._elements.contentZoneTarget.appendChild(footer);
        }
      }),

      /**
        The backdrop configuration for this dialog.

        @type {Coral.Dialog.backdrop}
        @default Coral.Dialog.backdrop.MODAL
        @htmlattribute backdrop
        @memberof Coral.Dialog#
      */
      'backdrop': {
        default: backdrop.MODAL,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(backdrop)
        ],
        sync: function() {
          var showBackdrop = (this.backdrop !== backdrop.NONE);

          // We're visible now, so hide or show the modal accordingly
          if (this.open && showBackdrop) {
            this._showBackdrop();
          }

          this.classList.toggle(EMPTY_BACKDROP_CLASSNAME, !showBackdrop);
        }
      },

      /**
        The dialog's variant.

        @type {Coral.Dialog.variant}
        @default Coral.Dialog.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Dialog#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // Remove all variant classes
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant === Coral.Dialog.variant.DEFAULT) {
            this._elements.icon.icon = '';

            // ARIA
            this.setAttribute('role', 'dialog');
          }
          else {
            this._elements.icon.icon = ICON_CLASSES[this.variant];

            // Set new variant class
            // Don't use this._className; use the constant
            // This lets popover get our styles for free
            this.classList.add(CLASSNAME + '--' + this.variant);

            // ARIA
            this.setAttribute('role', 'alertdialog');
          }
        }
      },

      /**
        Whether the dialog should be displayed full screen (without borders or margin).

        @type {Boolean}
        @default false
        @htmlattribute fullscreen
        @htmlattributereflected
        @memberof Coral.Dialog#
      */
      'fullscreen': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          if (value) {
            this.movable = false;
          }
          this._fullscreen = value;
        },
        sync: function() {
          if (this.fullscreen) {
            this.classList.add(FULLSCREEN_CLASSNAME);

            // Remove any positioning that may have been added by centering
            this._elements.wrapper.style.top = '';
            this._elements.wrapper.style.left = '';
            this._elements.wrapper.style.marginLeft = '';
            this._elements.wrapper.style.marginTop = '';

            this._elements.closeButton.iconSize = 'S';
          }
          else {
            this.classList.remove(FULLSCREEN_CLASSNAME);

            this._elements.closeButton.iconSize = 'XS';

            // Recenter the dialog if fullscreen was removed
            this._center();
          }
        }
      },

      // JSDoc inherited
      'open': {
        sync: function() {
          if (this.open) {
            // Ensure we're a child of the body
            // Fake out mixin.overlay's detached/attachedCallback so they don't do anything
            this._open = false;
            if (this.parentNode !== document.body) {
              document.body.insertBefore(this, document.body.lastElementChild);
            }
            this._open = true;

            // Center immediately during sync method. Don't invoke center() directly, as that would wait a frame
            this._center();

            // Show the backdrop, if necessary
            if (this.backdrop !== backdrop.NONE) {
              this._showBackdrop();
            }
          }
        }
      },

      /**
        The dialog's icon.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Dialog#
      */
      'icon': Coral.property.proxy({
        path: '_elements.icon.icon'
      }),

      /**
        Whether the dialog should have a close button.

        @type {Coral.Dialog.closable}
        @default Coral.Dialog.closable.OFF
        @htmlattribute closable
        @htmlattributereflected
        @memberof Coral.Dialog#
      */
      'closable': {
        default: closable.OFF,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(closable)
        ],
        sync: function() {
          this.classList.toggle(this._className + '--closable', this.closable === closable.ON);
          this._elements.closeButton.style.display = this.closable === closable.ON ? '' : 'none';
        }
      },

      /**
        Whether the dialog can moved around by dragging the title.

        @type {Boolean}
        @default false
        @htmlattribute movable
        @htmlattributereflected
        @memberof Coral.Dialog#
      */
      'movable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          if (value) {
            this.fullscreen = false;
          }
          this._movable = value;
        },
        sync: function() {
          var wrapper = this._elements.wrapper;

          if (this.movable) {
            // Allows the dialog to moved outside of the right window side
            wrapper.style.width = wrapper.getBoundingClientRect().width + 'px';

            var dragAction = new Coral.DragAction(wrapper);
            dragAction.handle = this._elements.headerWrapper;
          }
          else {
            // Restore default
            wrapper.style.width = '';

            if (wrapper.dragAction) {
              wrapper.dragAction.destroy();
            }

            // Recenter the dialog once it's not movable anymore
            this._center();
          }
        }
      }
    },

    /** @protected */
    _overlayAnimationTime: Coral.mixin.overlay.FADETIME,

    /** @ignore */
    _initialize: function() {
      // Always execute in the context of the component
      this._center = this._center.bind(this);

      this.style.display = 'none';

      // Listen for mutations
      this._headerObserver = new MutationObserver(this._hideHeaderIfEmpty.bind(this));

      // Watch for changes to the header element's children
      this._observeHeader();
    },

    /** @ignore */
    _observeHeader: function() {
      if (this._headerObserver) {
        this._headerObserver.disconnect();
        this._headerObserver.observe(this._elements.header, {
          childList: true, // Catch changes to childList
          characterData: true, // Catch changes to textContent
          subtree: true // Monitor any child node
        });
      }
    },

    /**
      Hide the header wrapper if the header content zone is empty.
      @ignore
    */
    _hideHeaderIfEmpty: function() {
      var header = this._elements.header;
      var headerContent = this._elements.headerContent;

      // If it's empty and has no non-textnode children, hide the header
      var hiddenValue = header.children.length === 0 || header.textContent.replace(/\s*/g, '') === '';

      if (hiddenValue) {
        headerContent.removeAttribute('role');
        headerContent.removeAttribute('aria-level');
      }
      else {
        headerContent.setAttribute('role', 'heading');
        headerContent.setAttribute('aria-level', '2');
      }
    },

    /** @ignore */
    _handleEscape: function(event) {
      // When escape is pressed, hide ourselves
      if (this.interaction === Coral.Dialog.interaction.ON && this.open && this._isTopOverlay()) {
        this.hide();
      }
    },

    /**
      @ignore
      @todo maybe this should be mixin or something
    */
    _handleCloseClick: function(event) {
      var dismissTarget = event.matchedTarget;
      var dismissValue = dismissTarget.getAttribute('coral-close');
      if (!dismissValue || this.matches(dismissValue)) {
        this.hide();
        event.stopPropagation();
      }
    },

    /** @ignore */
    _handleClick: function(event) {
      // When we're modal, we close when our outer area (over the backdrop) is clicked
      if (event.target === this && this.backdrop === backdrop.MODAL && this._isTopOverlay()) {
        this.hide();
      }
    },

    /** @ignore */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.apply(this, arguments);

      // Center ourself
      if (this.open) {
        this._center();
      }
    },

    /** @ignore */
    _render: function() {
      // Fetch the content zones
      var header = this.querySelector('coral-dialog-header');
      var content = this.querySelector('coral-dialog-content');
      var footer = this.querySelector('coral-dialog-footer');

      // Verify if a content zone is provided
      var contentZoneProvided = content || footer || header;

      // Verify if the internal wrapper exists
      var wrapper = this.querySelector('.coral3-Dialog-wrapper');

      // Case where the dialog was rendered already - cloneNode support
      if (wrapper) {

        // Remove tab captures
        Array.prototype.filter.call(this.children, function(child) {
          return (child.hasAttribute('coral-tabcapture'));
        }).forEach(function(tabCapture) {
          this.removeChild(tabCapture);
        }.bind(this));

        // Assign internal elements
        this._elements.headerWrapper = this.querySelector('.coral3-Dialog-header');
        this._elements.headerContent = this.querySelector('.coral3-Dialog-title');
        this._elements.closeButton = this.querySelector('.coral3-Dialog-closeButton');
        this._elements.icon = this.querySelector('.coral3-Dialog-typeIcon');

        this._elements.wrapper = wrapper;
        // We can assume content zones are created if wrapper is already there
        this._elements.contentZoneTarget = contentZoneProvided.parentNode;
      }
      // Case where the dialog needs to be rendered
      else {
        // Create content zones if not provided
        header = header || document.createElement('coral-dialog-header');
        content = content || document.createElement('coral-dialog-content');
        footer = footer || document.createElement('coral-dialog-footer');

        // Create default wrapper
        wrapper = document.createElement('div');
        wrapper.className = 'coral3-Dialog-wrapper';

        // Create default header wrapper
        var headerFrag = Coral.templates.Dialog.header.call(this._elements);
        var headerWrapper = this._elements.headerWrapper = document.createElement('div');
        headerWrapper.className = 'coral3-Dialog-header';
        headerWrapper.appendChild(headerFrag);

        // Store internal wrapper
        this._elements.wrapper = wrapper;

        // Case where the dialog needs to be rendered and content zones are provided
        if (contentZoneProvided) {
          // Check if user wrapper is provided
          if (contentZoneProvided.parentNode === this) {
            // Content zone target defaults to default wrapper if no user wrapper element is provided
            this._elements.contentZoneTarget = wrapper;
          }
          else {
            // Content zone target defaults to user wrapper element if provided
            this._elements.contentZoneTarget = contentZoneProvided.parentNode;
          }

          // Move everything in the wrapper
          while (this.firstChild) {
            wrapper.appendChild(this.firstChild);
          }

          // Add the dialog header
          this._elements.contentZoneTarget.appendChild(headerWrapper);
        }
        // Case where the dialog needs to be rendered and content zones need to be created
        else {
          // Default content zone target is wrapper
          this._elements.contentZoneTarget = wrapper;

          // Move everything in the "content" content zone
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }

          // Add the content zones in the wrapper
          wrapper.appendChild(headerWrapper);
          wrapper.appendChild(content);
          wrapper.appendChild(footer);
        }

        // Add the wrapper to the dialog
        this.appendChild(wrapper);
      }

      // Assign content zones
      this.header = header;
      this.content = content;
      this.footer = footer;
    },

    /**
      Centers the dialog in the middle of the screen.

      @returns {Coral.Dialog} this, chainable.
    */
    center: function() {
      // We're already centered in fullscreen mode
      if (this.fullscreen) {
        return;
      }

      if (this._centered) {
        // If we've already centered or never centered before, wait a frame
        Coral.commons.nextFrame(this._center);
      }

      // Mark that we're not currently centered
      this._centered = false;

      return this;
    },

    /** @private */
    _center: function() {
      var wrapper = this._elements.wrapper;

      var currentStyle = this.style.display;

      // Set display to block so we can measure
      this.style.display = 'block';

      // Change to absolute so we can calculate correctly. Shove it to the top left so we can calculate width
      // correctly
      wrapper.style.position = 'absolute';
      wrapper.style.left = 0;
      wrapper.style.top = 0;

      // Calculate the size
      var width = wrapper.offsetWidth;
      var height = wrapper.offsetHeight;

      // Only position vertically if we have to use 20px buffers to match the margin from CSS
      if (height < window.innerHeight - 20) {
        // Set position
        wrapper.style.top = '50%';
        wrapper.style.marginTop = -(height / 2) + 'px';
      }
      else {
        // Allow vertical scroll
        wrapper.style.top = '';
        wrapper.style.marginTop = '';
      }

      // Take the whole screen if fullscreen
      if (this.fullscreen) {
        wrapper.style.marginLeft = '';
        wrapper.style.left = '';
      }
      else {
        wrapper.style.marginLeft = -(width / 2) + 'px';
        wrapper.style.left = '50%';
      }

      // Reset display to previous style
      this.style.display = currentStyle;

      // Mark that we're centered
      this._centered = true;
    }
  });

  Coral.register( /** @lends Coral.Dialog.Header */ {
    /**
      @class Coral.Dialog.Header
      @classdesc A Dialog Header component
      @extends Coral.Component
      @htmltag coral-dialog-header
    */
    name: 'Dialog.Header',
    tagName: 'coral-dialog-header'
  });

  Coral.register( /** @lends Coral.Dialog.Footer */ {
    /**
      @class Coral.Dialog.Footer
      @classdesc A Dialog Footer component
      @extends Coral.Component
      @htmltag coral-dialog-footer
    */
    name: 'Dialog.Footer',
    tagName: 'coral-dialog-footer',
    className: 'coral3-Dialog-footer'
  });

  Coral.register( /** @lends Coral.Dialog.Content */ {
    /**
      @class Coral.Dialog.Content
      @classdesc A Dialog Content component
      @extends Coral.Component
      @htmltag coral-dialog-content
    */
    name: 'Dialog.Content',
    tagName: 'coral-dialog-content',
    className: 'coral3-Dialog-content'
  });

  // Expose enums globally
  Coral.Dialog.interaction = interaction;
  Coral.Dialog.variant = variant;
  Coral.Dialog.backdrop = backdrop;
  Coral.Dialog.closable = closable;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var CLASSNAME = 'coral3-Popover';

  /**
    Boolean enumeration for popover closable state.

    @memberof Coral.Popover
    @enum {String}
  */
  var closable = {
    /** Show a close button on the popover and close the popover when clicked. */
    ON: 'on',
    /**
      Do not show a close button. Elements with the <code>coral-close</code> attributes will still close the
      popover.
    */
    OFF: 'off'
  };

  /**
    Popover interaction values.

    @enum {String}
    @memberof Coral.Popover
  */
  var interaction = {
    /** Show when the target is clicked and hide when clicked outside of the target and popover. */
    ON: 'on',
    /** Do not show or hide automatically. */
    OFF: 'off'
  };

  /**
    Popover variants.

    @memberof Coral.Popover
    @enum {String}
  */
  var variant = {
    /** A popover with the default, gray header and no icon. */
    DEFAULT: 'default',
    /** A popover with a red header and warning icon, indicating that an error has occurred. */
    ERROR: 'error',
    /** A popover with an orange header and warning icon, notifying the user of something important. */
    WARNING: 'warning',
    /** A popover with a green header and checkmark icon, indicates to the user that an operation was successful. */
    SUCCESS: 'success',
    /** A popover with a blue header and question mark icon, provides the user with help. */
    HELP: 'help',
    /** A popover with a blue header and info icon, informs the user of non-critical information. */
    INFO: 'info'
  };

  Coral.register( /** @lends Coral.Popover# */ {
    /**
      @class Coral.Popover
      @classdesc A Popover component
      @extends Coral.Component
      @htmltag coral-popover
      @extends Coral.Overlay

      @borrows Coral.mixin.overlay#focusOnShow as Coral.Popover#focusOnShow
      @borrows Coral.mixin.overlay#open as Coral.Popover#open
      @borrows Coral.mixin.overlay#hide as Coral.Popover#hide
      @borrows Coral.mixin.overlay#show as Coral.Popover#show
      @borrows Coral.mixin.overlay#returnFocusTo as Coral.Popover#returnFocusTo
      @borrows Coral.mixin.overlay#event:coral-overlay:beforeopen as Coral.Popover#coral-overlay:beforeopen
      @borrows Coral.mixin.overlay#event:coral-overlay:beforeclose as Coral.Popover#coral-overlay:beforeclose
      @borrows Coral.mixin.overlay#event:coral-overlay:open as Coral.Popover#coral-overlay:open
      @borrows Coral.mixin.overlay#event:coral-overlay:close as Coral.Popover#coral-overlay:close
    */
    name: 'Popover',
    tagName: 'coral-popover',
    className: CLASSNAME,
    extend: Coral.Overlay,

    events: {
      'global:capture:click': '_handleClick',

      'click [coral-close]': '_handleCloseClick'
    },

    properties: {
      /**
        Whether to trap tabs and keep them within the overlay.

        @type {Coral.mixin.overlay.trapFocus}
        @default Coral.mixin.overlay.trapFocus.ON
        @htmlattribute trapfocus
        @memberof Coral.Popover#
      */
      'trapFocus': {
        default: Coral.mixin.overlay.trapFocus.ON
      },

      /**
        Whether to return focus to the previously focused element when closed.

        @type {Coral.mixin.overlay.returnFocus}
        @default Coral.mixin.overlay.returnFocus.ON
        @htmlattribute returnfocus
        @memberof Coral.Popover#
      */
      'returnFocus': {
        default: Coral.mixin.overlay.returnFocus.ON
      },

      // JSDoc inherited
      'focusOnShow': {
        default: Coral.mixin.overlay.focusOnShow.ON
      },

      /**
        The popover's content element.

        @contentzone
        @name content
        @type {HTMLElement}
        @memberof Coral.Popover#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-popover-content',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.contentWrapper.appendChild(content);
        }
      }),

      /**
        The popover's header element.

        @contentzone
        @name header
        @type {HTMLElement}
        @memberof Coral.Popover#
      */
      'header': Coral.property.contentZone({
        handle: 'header',
        tagName: 'coral-popover-header',
        insert: function(header) {
          this._elements.headerContent.appendChild(header);
        },
        set: function(value) {
          // Stop observing the old header and observe the new one
          this._observeHeader();

          // Check if header needs to be hidden
          this._hideHeaderIfEmpty();
        }
      }),

      /**
        The point on the overlay we should anchor from when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.LEFT_CENTER
        @htmlattribute alignmy
        @memberof Coral.Popover#
      */
      'alignMy': {
        default: Coral.Overlay.align.LEFT_CENTER
      },

      /**
        The point on the target we should anchor to when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.RIGHT_CENTER
        @htmlattribute alignat
        @memberof Coral.Overlay#
      */
      'alignAt': {
        default: Coral.Overlay.align.RIGHT_CENTER
      },

      /**
        The placement of the overlay. This property sets {@link Coral.Overlay#alignMy} and {@link Coral.Overlay#alignAt}.

        @type {Coral.Overlay.placement}
        @default Coral.Overlay.placement.RIGHT
        @name placement
        @htmlattribute placement
        @memberof Coral.Popover#
      */

      /**
        The distance the overlay should be from its target.

        @type {Number}
        @default 5
        @htmlattribute offset
        @memberof Coral.Popover#
      */
      'offset': {
        default: 5
      },

      // JSDoc inherited
      'open': {
        sync: function() {
          var target = this._getTarget();
          if (target) {
            if (this.open) {
              // Check if the target already has is-selected
              this._targetWasSelected = target.classList.contains('is-selected');

              // Only bother adding the class if the target doesn't have it
              if (!this._targetWasSelected) {
                // Highlight target
                target.classList.add('is-selected');
              }
            }
            else if (!this._targetWasSelected) {
              // When closed, only remove the class if the target didn't have it before
              target.classList.remove('is-selected');
            }
          }
        }
      },

      /**
        Whether the popover should show itself when the target is interacted with.

        @type {Coral.Popover.interaction}
        @default Coral.Popover.interaction.ON
        @name interaction
        @htmlattribute interaction
        @memberof Coral.Popover#
      */
      'interaction': {
        default: interaction.ON
      },

      /**
        The popover's variant.

        @type {Coral.Dialog.variant}
        @default Coral.Dialog.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Popover#
      */
      // Inherit from Dialog
      'variant': Coral.Dialog.prototype._properties.variant,

      /**
        Whether the popover should have a close button.

        @type {Coral.Popover.closable}
        @default Coral.Popover.closable.OFF
        @htmlattribute closable
        @htmlattributereflected
        @memberof Coral.Popover#
      */
      'closable': {
        default: closable.OFF,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(closable)
        ],
        sync: function() {
          this._elements.closeButton.style.display = this.closable === closable.ON ? '' : 'none';
        }
      },

      /**
        The popover's icon.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Popover#
      */
      'icon': Coral.property.proxy({
        path: '_elements.icon.icon'
      })
    },

    // Use the fade time from overlay
    _overlayAnimationTime: Coral.mixin.overlay.FADETIME,

    /** @ignore */
    _observeHeader: function() {
      if (this._headerObserver) {
        this._headerObserver.disconnect();
        this._headerObserver.observe(this._elements.header, {
          childList: true, // Catch changes to childList
          characterData: true, // Catch changes to textContent
          subtree: true // Monitor any child node
        });
      }
    },

    /**
      Hide the header wrapper if the header content zone is empty.
      @ignore
    */
    _hideHeaderIfEmpty: function() {
      var header = this._elements.header;
      var headerWrapper = this._elements.headerWrapper;
      var headerContent = this._elements.headerContent;

      // If it's empty and has no non-textnode children, hide the header
      var hiddenValue = header.children.length === 0 && header.textContent.replace(/\s*/g, '') === '';

      // Only bother if the hidden status has changed
      if (hiddenValue !== headerWrapper.hidden) {
        headerWrapper.hidden = hiddenValue;

        if (hiddenValue) {
          headerContent.removeAttribute('role');
          headerContent.removeAttribute('aria-level');
        }
        else {
          headerContent.setAttribute('role', 'heading');
          headerContent.setAttribute('aria-level', '2');
        }

        // Reposition as the height has changed
        this.reposition();
      }
    },

    /**
      @ignore
      @todo maybe this should be mixin or something
    */
    _handleCloseClick: function(event) {
      var dismissTarget = event.matchedTarget;
      var dismissValue = dismissTarget.getAttribute('coral-close');
      if (!dismissValue || this.matches(dismissValue)) {
        this.hide();
        event.stopPropagation();
      }
    },

    _handleClick: function(event) {
      if (this.interaction === interaction.OFF) {
        // Since we use delegation, just ignore clicks if interaction is off
        return;
      }

      var eventTarget = event.target;
      var targetEl = this._getTarget();

      var eventIsWithinTarget = targetEl ? targetEl.contains(eventTarget) : false;

      if (eventIsWithinTarget) {
        // When target is clicked

        if (!this.open && !targetEl.disabled) {
          // Open if we're not already open and target element is not disabled
          this.show();
        }
        else {
          this.hide();
        }
      }
      else if (this.open && !this.contains(eventTarget)) {
        // Close if we're open and the click was outside of the target and outside of the popover
        this.hide();
      }
    },

    /** @ignore */
    attachedCallback: function() {
      // Call top level class' attachedCallback
      Coral.Component.prototype.attachedCallback.call(this);

      // @todo CUI-3739 - expose methods on prototype and call from there
      // Re-implmement behavior from Coral.mixin.overlay's attachedCallback
      if (this.open) {
        this._pushOverlay();

        if (this._showBackdropOnAttached) {
          // Show the backdrop again
          this._showBackdrop();
        }

        // @todo CUI-3899 - add this to Coral.Overlay
        // Reposition when attached if open
        this.reposition();
      }
    },

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var frag = document.createDocumentFragment();

      // Create a wrapper for the header
      // This lets us apply the right CSS classes to the outer container
      var headerWrapper = this._elements.headerWrapper = document.createElement('div');
      headerWrapper.className = 'coral3-Dialog-header coral3-Popover-header';

      // Create a wrapper for the content
      // This lets us apply the CSS classes to the outer container, while letting the user freely apply classes to the
      // content zone
      var contentWrapper = this._elements.contentWrapper = document.createElement('div');
      contentWrapper.className = 'coral3-Popover-content';

      // Render the template for the header and move it into the wrapper
      var headerFrag = Coral.templates.Dialog.header.call(this._elements);
      headerWrapper.appendChild(headerFrag);

      // Try to find the header
      var foundHeader = this.querySelector('coral-popover-header');

      // Fetch or create the header, content, and footer sub-components
      var header = foundHeader || document.createElement('coral-popover-header');
      var content = this.querySelector('coral-popover-content') || document.createElement('coral-popover-content');

      this.header = header;
      this.content = content;

      if (!foundHeader) {
        // Hide the wrapper if no header was provided
        headerWrapper.hidden = true;
      }

      // Move the rendered header template into the frag
      frag.appendChild(headerWrapper);

      // Move the content and footer sub-components to the frag
      frag.appendChild(contentWrapper);

      // Finally, move any remaining elements into the content sub-component
      while (this.firstChild) {
        content.appendChild(this.firstChild);
      }

      // Add the frag to the component
      this.appendChild(frag);
    },

    /** @ignore */
    _initialize: function() {
      // ARIA
      this.setAttribute('role', 'dialog');
      this.setAttribute('aria-live', 'assertive'); // This helped annoucements in certian screen readers

      // Listen for mutations
      this._headerObserver = new MutationObserver(this._hideHeaderIfEmpty.bind(this));

      // Watch for changes to the header element's children
      this._observeHeader();
    }
  });

  Coral.register( /** @lends Coral.Popover.Content */ {
    /**
      @class Coral.Popover.Content
      @classdesc A Popover Content component
      @extends Coral.Component
      @htmltag coral-popover-content
    */
    name: 'Popover.Content',
    tagName: 'coral-popover-content'
  });

  Coral.register( /** @lends Coral.Popover.Header */ {
    /**
      @class Coral.Popover.Header
      @classdesc A Popover Header component
      @extends Coral.Dialog.Header
      @htmltag coral-popover-header
    */
    name: 'Popover.Header',
    tagName: 'coral-popover-header'
  });

  Coral.register( /** @lends Coral.Popover.Separator */ {
    /**
      @class Coral.Popover.Separator
      @classdesc A Popover Separator component
      @extends Coral.Component
      @htmltag coral-popover-separator
    */
    name: 'Popover.Separator',
    tagName: 'coral-popover-separator',
    className: 'coral3-Popover-separator'
  });

  Coral.Popover.closable = closable;
  Coral.Popover.interaction = interaction;
  Coral.Popover.variant = variant;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-actionbar"] = {"en-US":{"More":"More"},"de-DE":{"More":"Mehr"},"fr-FR":{"More":"Plus"},"it-IT":{"More":"Altro"},"ja-JP":{"More":"その他"},"es-ES":{"More":"Más"},"ko-KR":{"More":"자세히"},"zh-CN":{"More":"更多"},"zh-TW":{"More":"更多"},"pt-BR":{"More":"Mais"},"nl-NL":{"More":"Meer"},"da-DK":{"More":"Mere"},"fi-FI":{"More":"Lisää"},"nb-NO":{"More":"Mer"},"sv-SE":{"More":"Mer"},"cs-CZ":{"More":"Více"},"pl-PL":{"More":"Więcej"},"ru-RU":{"More":"Дополнительно"},"tr-TR":{"More":"Daha Fazla"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["ActionBar"] = window["Coral"]["templates"]["ActionBar"] || {};
window["Coral"]["templates"]["ActionBar"]["moreButton"] = (function anonymous(data_0
/*``*/) {
  var data = data_0;
  var el0 = this["moreButton"] = document.createElement("button","coral-button");
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("handle", "moreButton");
  el0.setAttribute("type", "button");
  el0.setAttribute("variant", "quiet");
  el0.setAttribute("icon", "more");
  el0.setAttribute("coral-actionbar-more", "");
  el0.setAttribute("aria-expanded", "false");
  el0.setAttribute("aria-haspopup", "true");
  return el0;
});

window["Coral"]["templates"]["ActionBar"]["morePopover"] = (function anonymous(data_0
/*``*/) {
  var data = data_0;
  var el0 = this["popover"] = document.createElement("coral-popover");
  el0.setAttribute("handle", "popover");
  el0.setAttribute("alignmy", "left top");
  el0.setAttribute("alignat", "left bottom");
  el0.setAttribute("coral-actionbar-popover", "");
  return el0;
});

window["Coral"]["templates"]["ActionBar"]["popovercontent"] = (function anonymous(data_0
/*``*/) {
  var data = data_0;
  var el0 = document.createElement("ul");
  el0.className += " coral-List coral-List--minimal";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var iterated_1 = data_0;
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el3 = document.createTextNode("\n    ");
    el0.appendChild(el3);
    var el4 = document.createElement("li");
    el4.className += " coral-List-item";
    var el5 = document.createTextNode("\n      ");
    el4.appendChild(el5);
    el4.appendChild(data_1);
    el0.appendChild(el4);
    var el7 = document.createTextNode("\n  ");
    el0.appendChild(el7);
  }
  var el8 = document.createTextNode("\n");
  el0.appendChild(el8);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ActionBar# */ {
    /**
      @class Coral.ActionBar
      @classdesc An ActionBar component
      @extends Coral.Component
      @htmltag coral-actionbar
    */
    name: 'ActionBar',
    tagName: 'coral-actionbar',
    className: 'coral3-ActionBar',

    events: {
      'key:up': '_onFocusPreviousItem',
      'key:left': '_onFocusPreviousItem',
      'key:down': '_onFocusNextItem',
      'key:right': '_onFocusNextItem',
      'global:resize': '_onResizeWindow'
    },

    properties: {
      /**
        The primary (left) container of the ActionBar.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.ActionBar#
      */
      'primary': Coral.property.contentZone({
        handle: 'primary',
        tagName: 'coral-actionbar-primary',
        defaultContentZone: true,
        insert: function(content) {
          // primary has to be before secondary if available
          this.insertBefore(content, this.secondary);
        }
      }),

      /**
        The secondary (right) container of the ActionBar.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.ActionBar#
      */
      'secondary': Coral.property.contentZone({
        handle: 'secondary',
        tagName: 'coral-actionbar-secondary',
        insert: function(content) {
          this.appendChild(content);
        }
      })
    },

    /** @ignore */
    _render: function() {
      // Cleanup resize helpers object (cloneNode support)
      var resizeHelpers = this.querySelectorAll('object');
      for (var i = 0; i < resizeHelpers.length; ++i) {
        var resizeElement = resizeHelpers[i];
        if (resizeElement.parentNode === this) {
          this.removeChild(resizeElement);
        }
      }

      var primary = this.querySelector('coral-actionbar-primary');
      var secondary = this.querySelector('coral-actionbar-secondary');

      // we need to know if the content zone was provided to stop the voracious behavior
      var primaryProvided = primary !== null;

      // in case they do not exist we create them since every content zone is mandatory
      primary = primary || document.createElement('coral-actionbar-primary');
      secondary = secondary || document.createElement('coral-actionbar-secondary');

      // as a way to transition to the new content zones, we need to provide support for the old container tag. we copy
      // everything from these containers into the corresponding content zones, including the configurations
      var containers = Array.prototype.slice.call(this.getElementsByTagName('coral-actionbar-container'));

      var legacyContainer;
      var targetContainer;
      for (var j = 0, containersCount = containers.length; j < containersCount; j++) {
        legacyContainer = containers[j];

        // move first container content to new primary element
        if (j === 0) {
          targetContainer = primary;
          // overrides the previous configuration as we support older containers
          primaryProvided = true;
        }
        else if (j === 1) {
          targetContainer = secondary;
        }

        // it may happen that more than 2 containers were provided, in such case we simply ignore it
        if (targetContainer) {
          // we need to copy the existing configuration to the new content zone
          if (legacyContainer.hasAttribute('threshold')) {
            targetContainer.setAttribute('threshold', legacyContainer.getAttribute('threshold'));
          }
          if (legacyContainer.hasAttribute('morebuttontext')) {
            targetContainer.setAttribute('morebuttontext', legacyContainer.getAttribute('morebuttontext'));
          }

          // @todo: are we copying the more button?
          while (legacyContainer.firstChild) {
            targetContainer.appendChild(legacyContainer.firstChild);
          }
        }

        this.removeChild(legacyContainer);
      }

      // to prevent the content zone being voracious, we only move the children if primary was not explicitely provided
      if (!primaryProvided) {
        while (this.firstChild) {
          primary.appendChild(this.firstChild);
        }
      }

      // assign the content zones
      this.primary = primary;
      this.secondary = secondary;
    },

    /** @ignore */
    _recalculateLayoutOnMutation: function() {
      // recalculate layout on dom element size change + on dom mutation
      // http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/

      // relayout any time the dom changes
      var self = this;

      self._observer = new MutationObserver(function() {
        self._debounceOnLayout();
      });

      // Watch for changes
      self._observer.observe(self, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    },

    /** @ignore */
    _initialize: function() {
      // Debounce wait time in milliseconds
      this._wait = 50;
      
      // bind this._onLayout so it can be removed again
      this._onLayout = this._onLayout.bind(this);
      this._debounceOnLayout = this._debounceOnLayout.bind(this);

      // @todo: see CUI-3907. This should be Coral.commons.ready
      var self = this;
      Coral.commons.nextFrame(function() {
        //force one layout
        self._onLayout();

        // use the smart strategy instead of re-rendering every frame
        self._recalculateLayoutOnMutation();
      });
    },

    // JSDocs inherited
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.apply(this, arguments);

      var self = this;
      Coral.commons.nextFrame(function() {
        // re-calculate layout on element resize
        // wait one frame to attach resize listeners in order to be sure, that sub components are ready
        Coral.commons.addResizeListener(self, self._debounceOnLayout);
        Coral.commons.addResizeListener(self.primary, self._debounceOnLayout);
        Coral.commons.addResizeListener(self.secondary, self._debounceOnLayout);
      });
    },

    // JSDocs inherited
    detachedCallback: function() {
      Coral.Component.prototype.detachedCallback.apply(this, arguments);

      // remove global resize event listeners
      Coral.commons.removeResizeListener(this, this._debounceOnLayout);
      Coral.commons.removeResizeListener(this.primary, this._debounceOnLayout);
      Coral.commons.removeResizeListener(this.secondary, this._debounceOnLayout);
    },

    /** @ignore */
    _onFocusPreviousItem: function(event) {
      // stops the page from scrolling
      event.preventDefault();

      var previousItem = this._getPreviousSelectableWrappedItem(event.target);
      if (previousItem !== null) {
        previousItem.focus();
      }
    },

    /** @ignore */
    _onFocusNextItem: function(event) {
      // stops the page from scrolling
      event.preventDefault();

      var nextWrappedItem = this._getNextSelectableWrappedItem(event.target);
      if (nextWrappedItem !== null) {
        nextWrappedItem.focus();
      }
    },

    /** @ignore */
    _onResizeWindow: function() {
      // just close all popovers for now when screen is resized
      // there might be more popovers, then the 'more' popovers
      var popovers = this.querySelectorAll('coral-popover');
      for (var i = 0; i < popovers.length; i++) {
        popovers[i].open = false;
      }

      // force a relayout (needed especially if framerate during resize drops e.g.: in FF)
      this._debounceOnLayout();
    },

    /** @ignore */
    _onLayout: function() {
      if (!this.primary || !this.primary._elements.popover || !this.secondary || !this.secondary._elements.popover) {
        // while containers are not cached do nothing
        return;
      }

      if (this.primary._elements.popover.open === true || this.secondary._elements.popover.open === true) {
        // while popovers are open do not relayout
        return;
      }

      var focusedItem = document.activeElement;
      if (!(this !== focusedItem && this.contains(focusedItem))) {
        // focus not on the actionbar => do not bother
        focusedItem = null;
      }

      if (focusedItem &&
        focusedItem.parentNode &&
        focusedItem.parentNode.tagName.toLowerCase() === 'coral-actionbar-item') {
        // focusedItem is wrapped
        focusedItem = focusedItem.parentNode;
      }

      var ERROR_MARGIN = 25;

      var leftItems = this.primary.items.getAll();
      var rightItems = this.secondary.items.getAll().reverse();
      var itemLeft = null;
      var itemRight = null;
      var widthCache = this._newWidthCache();
      var leftMoreButtonWidth = (leftItems.length > 0) ?
        widthCache.getOuterWidth(this.primary._elements.moreButton) : 0;
      var rightMoreButtonWidth = (rightItems.length > 0) ?
        widthCache.getOuterWidth(this.secondary._elements.moreButton) : 0;

      // Make it possible to set left/right padding to the containers
      var borderWidthLeftContainer = this.primary.offsetWidth - this.primary.getBoundingClientRect().width;
      var borderWidthRightContainer = this.secondary.offsetWidth - this.secondary.getBoundingClientRect().width;

      var primaryLeftOffset = this.primary.offsetLeft;
      var secondaryRightOffset = this.offsetWidth - (this.secondary.offsetLeft + this.secondary.offsetWidth);

      var availableWidth = this.offsetWidth - primaryLeftOffset - secondaryRightOffset - leftMoreButtonWidth -
        rightMoreButtonWidth - borderWidthLeftContainer - borderWidthRightContainer - ERROR_MARGIN;
      var currentUsedWidth = 0;
      var leftVisibleItems = 0;
      var rightVisibleItems = 0;
      var moreButtonLeftVisible = false;
      var moreButtonRightVisible = false;
      var showItem = false;
      var itemWidth = 0;

      for (var i = 0; i < leftItems.length || i < rightItems.length; i++) {
        itemLeft = (i < leftItems.length) ? leftItems[i] : null;
        itemRight = (i < rightItems.length) ? rightItems[i] : null;

        // first calculate visibility of left item
        showItem = false;
        if (itemLeft !== null) {

          if (itemLeft.hidden || itemLeft.style.display === 'none') {
            // item is hidden on purpose (we don't use it for layouting but do also not move offscreen) needed as it
            // might already have been moved offscreen before
            this._moveToScreen(itemLeft);
          }
          else {
            // if item is not hidden on purpose (hiding by actionBar due to space problems does not count) => layout
            // element
            if (!moreButtonLeftVisible) {

              if (this.primary.threshold <= 0 || leftVisibleItems < this.primary.threshold) {
                // if threshold is not reached so far
                itemWidth = widthCache.getOuterWidth(itemLeft);

                if (currentUsedWidth + itemWidth < availableWidth) {
                  // if there is still enough space to show another item
                  showItem = true;
                }
                else if (leftVisibleItems === leftItems.length - 1 &&
                  currentUsedWidth + itemWidth < availableWidth + leftMoreButtonWidth
                ) {
                  // if this is the last item and so far there have been no items hidden => don't show more button
                  showItem = true;
                }
              }
            }

            // enable tab for first left item
            this._makeItemTabEnabled(itemLeft, showItem && i === 0);

            if (showItem) {
              leftVisibleItems += 1;
              currentUsedWidth += itemWidth;
              this._moveToScreen(itemLeft);
            }
            else {
              this._hideItem(itemLeft);
              moreButtonLeftVisible = true;
            }

            if (leftVisibleItems === leftItems.length) {
              // left more button not needed => more free space available
              availableWidth += leftMoreButtonWidth;
              moreButtonLeftVisible = false;
            }
          }
        }

        // then calculate visibility of right item
        showItem = false;
        if (itemRight !== null) {
          if (itemRight.hidden || itemRight.style.display === 'none') {
            // item is hidden on purpose (we don't use it for layouting but do also not move offscreen) needed as it
            // might already have been moved offscreen before
            this._moveToScreen(itemRight);
          }
          else {
            // if item is not hidden on purpose (hiding by actionBar due to space problems does not count) => layout
            // element
            if (!moreButtonRightVisible) {

              if (this.secondary.threshold <= 0 || rightVisibleItems < this.secondary.threshold) {
                // if threshold is not reached so far
                itemWidth = widthCache.getOuterWidth(itemRight);

                if (currentUsedWidth + itemWidth < availableWidth) {
                  // if there is still enough space to show another item
                  showItem = true;
                }
                else if (rightVisibleItems === rightItems.length - 1 &&
                  currentUsedWidth + itemWidth < availableWidth + rightMoreButtonWidth
                ) {
                  // if this is the last item and so far there have been no items hidden => don't show more button
                  showItem = true;
                }
              }
            }

            // enable tab for 'first' right item
            this._makeItemTabEnabled(itemRight, showItem && (i === rightItems.length - 1));

            if (showItem) {
              rightVisibleItems += 1;
              currentUsedWidth += itemWidth;
              this._moveToScreen(itemRight);
            }
            else {
              this._hideItem(itemRight);
              moreButtonRightVisible = true;
            }

            if (rightVisibleItems === rightItems.length) {
              // left more button not needed => more free space available
              availableWidth += rightMoreButtonWidth;
              moreButtonRightVisible = false;
            }
          }
        }
      }

      // show or hide more buttons
      this._moveToScreen(this.primary._elements.moreButton, moreButtonLeftVisible);
      this._moveToScreen(this.secondary._elements.moreButton, moreButtonRightVisible);

      // enable tabs on more buttons if needed
      this._makeItemTabEnabled(this.primary._elements.moreButton, leftVisibleItems < 1);
      this._makeItemTabEnabled(this.secondary._elements.moreButton, rightVisibleItems < rightItems.length);

      // we need to check if item has 'hasAttribute' because it is not present on the document
      if (focusedItem && focusedItem.hasAttribute && focusedItem.hasAttribute('coral-actionbar-offscreen')) {
        // if currently an element is focused, that should not be visible => select first selectable element nicer
        // algorithm possible
        var wrappedItem = Coral.ActionBar._getFirstSelectableWrappedItem(this._getAllSelectableItems()[0]);
        if (wrappedItem) {
          wrappedItem.focus();
        }
      }
    },

    /** @ignore */
    _getNextSelectableWrappedItem: function(currentItem) {
      if (currentItem.parentNode.tagName.toLowerCase() === 'coral-actionbar-item') {
        // currentItem is wrapped
        currentItem = currentItem.parentNode;
      }

      var selectableItems = this._getAllSelectableItems(currentItem);
      var index = selectableItems.indexOf(currentItem);

      if (index >= 0 && selectableItems.length > index + 1) {
        //if there is a next selectable element return it
        return Coral.ActionBar._getFirstSelectableWrappedItem(selectableItems[index + 1]);
      }

      return null;
    },

    /** @ignore */
    _getPreviousSelectableWrappedItem: function(currentItem) {
      if (currentItem.parentNode.tagName.toLowerCase() === 'coral-actionbar-item') {
        // currentItem is wrapped
        currentItem = currentItem.parentNode;
      }

      var selectableItems = this._getAllSelectableItems(currentItem);
      var index = selectableItems.indexOf(currentItem);

      if (index > 0) {
        //if there is a previous selectable element return it
        return Coral.ActionBar._getFirstSelectableWrappedItem(selectableItems[index - 1]);
      }

      return null;
    },

    /** @ignore */
    _getAllSelectableItems: function(currentItem) {
      var selectableItems = [];

      if (this.primary._elements.popover.open === true || this.secondary._elements.popover.open === true) {
        // if popover is open only items in popover can be selected
        var popoverItems = (this.primary._elements.popover.open === true) ? this.primary._itemsInPopover :
          this.secondary._itemsInPopover;
        var item = null;
        for (var i = 0; i < popoverItems.length; i++) {
          item = popoverItems[i];
          if (!item.hasAttribute('disabled') &&
            !item.hasAttribute('hidden') &&
            item.style.display !== 'none' &&
            Coral.ActionBar._getFirstSelectableWrappedItem(item)
          ) {
            selectableItems.push(item);
          }
        }
      }
      else {
        // concat selectable items from left side of the bar and right side of the bar
        var leftSelectableItems = this.primary.items._getAllSelectable();
        var rightSelectableItems = this.secondary.items._getAllSelectable();
        if (currentItem) {
          if (leftSelectableItems.indexOf(currentItem) >= 0) {
            selectableItems = leftSelectableItems;
          }
          else if (rightSelectableItems.indexOf(currentItem) >= 0) {
            selectableItems = rightSelectableItems;
          }
        }
        else {
          selectableItems = leftSelectableItems.concat(rightSelectableItems);
        }
      }

      return selectableItems;
    },

    /** @ignore */
    _newWidthCache: function() {
      return {
        _items: [],
        _outerWidth: [],
        getOuterWidth: function(item) {
          var index = this._items.indexOf(item);
          if (index < 0) {
            // if item was not cached in current frame => cache it
            this._items.push(item);

            var width = item.offsetWidth;
            this._outerWidth.push(width);
            index = this._outerWidth.length - 1;
          }

          return this._outerWidth[index];
        }
      };
    },

    /** @ignore */
    _forceWebkitRedraw: function(el) {
      var isWebkit = 'WebkitAppearance' in document.documentElement.style;

      if (isWebkit && el.style.display !== 'none') {
        el.style.display = 'none';

        // no need to store this anywhere, the reference would be enough (just saved to silence jshint)
        this._cachedOffsetHeight = el.offsetHeight;

        el.style.display = '';
      }
    },

    /** @ignore */
    _hideItem: function(item, hide) {
      if (hide === false) {
        this._moveToScreen(item);
      }
      else if (!item.hasAttribute('coral-actionbar-offscreen')) {
        // actually just move element offscreen to be able to measure the size while calculating the layout
        item.setAttribute('coral-actionbar-offscreen', '');
        // if I do not force a browser redraw webkit has layouting problems
        this._forceWebkitRedraw(item);
      }
    },

    /** @ignore */
    _moveToScreen: function(item, show) {
      if (show === false) {
        this._hideItem(item);
      }
      else if (item.hasAttribute('coral-actionbar-offscreen')) {
        // actually just move element onscreen again (see _hideItem)
        item.removeAttribute('coral-actionbar-offscreen');
        // if I do not force a browser redraw webkit has layouting problems
        this._forceWebkitRedraw(item);
      }
    },

    /** @ignore */
    _makeItemTabEnabled: function(item, tabable) {
      // item might be wrapped (for now remove/add tabindex only on the first wrapped item)
      item = Coral.ActionBar._getFirstSelectableWrappedItem(item);

      if (item !== null) {
        if (tabable && item.hasAttribute('tabindex')) {
          item.removeAttribute('tabindex');
        }
        else if (!tabable && !item.hasAttribute('tabindex')) {
          item.setAttribute('tabindex', '-1');
        }
      }
    },
  
    /** @private */
    _debounceOnLayout: function() {
      var self = this;
    
      // Debounce
      if (self._timeout !== null) {
        window.clearTimeout(self._timeout);
      }
    
      self._timeout = window.setTimeout(function() {
          self._timeout = null;
        self._onLayout();
      }, self._wait);
    }
  });

  /** @ignore */
  Coral.ActionBar._getFirstSelectableWrappedItem = function(wrapperItem) {
    // util method to get first selectable item inside a wrapper item
    if (!wrapperItem) {
      return null;
    }

    if (wrapperItem.hasAttribute('coral-actionbar-more')) {
      // more buttons are no 'real' actionbar items => not wrapped
      return wrapperItem;
    }

    var child = null;
    for (var i = 0; i < wrapperItem.children.length; i++) {
      child = wrapperItem.children[i];

      // maybe filter even more elements? (opacity, display='none', position='absolute' ...)
      if (child.offsetParent && child.matches(Coral.commons.FOCUSABLE_ELEMENT_SELECTOR)) {
        return child;
      }
    }

    return null;
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for container position.

    @private
    @enum {String}
    @memberof Coral.ActionBar.Container
  */
  var position = {
    /** Primary (left) ActionBar container */
    PRIMARY: 'primary',
    /** Secondary (right) ActionBar container */
    SECONDARY: 'secondary',
    /** Invalid ActionBar container */
    INVALID: 'invalid'
  };

  Coral.register( /** @lends Coral.ActionBar.Container# */ {
    /**
      @class Coral.ActionBar.Container
      @classdesc An ActionBar component
      @extends Coral.Component
      @htmltag coral-actionbar-container
    */
    name: 'ActionBar.Container',
    tagName: 'coral-actionbar-container',
    className: 'coral3-ActionBar-container',

    _itemsInPopover: [],

    events: {
      'coral-overlay:beforeopen [handle="popover"]': '_beforePopoverOpen',
      'coral-overlay:beforeclose [handle="popover"]': '_beforePopoverClose'
    },

    properties: {

      /**
        The container position inside the actionbar.

        @private
        @type {Coral.ActionBar.Container.position}
        @readonly
        @default Coral.ActionBar.Container.position.INVALID
        @memberof Coral.ActionBar.Container#
      */
      '_position': {
        attribute: null,
        get: function() {

          if (this.parentNode) {
            var containers = this.parentNode.querySelectorAll('coral-actionbar-container');

            if (containers.length > 0 && containers[0] === this) {
              return Coral.ActionBar.Container.position.PRIMARY;
            }
            else if (containers.length > 1 && containers[1] === this) {
              return Coral.ActionBar.Container.position.SECONDARY;
            }
          }

          return Coral.ActionBar.Container.position.INVALID;
        },
        // Read-only
        set: function() {}
      },

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.ActionBar.Container#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new Coral.ActionBar.Container.Collection(this);
          }

          return this._items;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        The amount of items that are maximally visible inside the container. Using a value <= 0 will disable this
        feature and show as many items as possible.

        @type {Number}
        @default -1
        @htmlattribute threshold
        @htmlattributereflected
        @memberof Coral.ActionBar.Container#
      */
      'threshold': {
        default: -1,
        reflectAttribute: true,
        transform: Coral.transform.number
      },

      /**
        If there are more ActionBarItems inside the ActionBar than currently can be shown, then a "more" Button with the
        following text will be rendered (and some ActionBarItems will be hidden inside of a Popover).

        @type {String}
        @default ""
        @htmlattribute morebuttontext
        @memberof Coral.ActionBar.Container#
      */
      'moreButtonText': {
        default: '',
        attribute: 'morebuttontext',
        transform: Coral.transform.string,
        sync: function() {
          if (this._elements.moreButton) {
            // moreButton might not have been created so far
            this._elements.moreButton.label.innerHTML = this.moreButtonText;
            if (this.moreButtonText.trim() === '') {
              this._elements.moreButton.setAttribute('title', Coral.i18n.get('More'));
            }
            else {
              this._elements.moreButton.removeAttribute('title');
            }
          }
        }
      }
    },

    /**
      Called after popover.open is set to true, but before the transition of the popover is done.
      Show elements inside the actionbar, that are hidden due to space problems.
      @ignore
    */
    _beforePopoverOpen: function(event) {
      // there might be popovers in popover => ignore them
      if (event.target !== this._elements.popover) {
        return;
      }

      this._itemsInPopover = this.items._getAllOffScreen();

      if (this._itemsInPopover.length < 1) {
        return;
      }

      // show the current popover (hidden needed to disable fade time of popover)
      this._elements.popover.hidden = false;

      // render popover content
      var popoverContent = this._elements.popover.content;
      popoverContent.innerHTML = '';
      popoverContent.appendChild(Coral.templates.ActionBar.popovercontent(this._itemsInPopover));

      // focus first item (nextFrame needed as popover must be visible and initialized with items)
      var self = this;
      var wrappedItem;
      var loop = true;
      var focusFirstItem = function() {
        wrappedItem = Coral.ActionBar._getFirstSelectableWrappedItem(self._itemsInPopover[0]);
        if (wrappedItem) {
          // focus first item
          wrappedItem.removeAttribute('tabindex');
          wrappedItem.focus();
          return;
        }

        // If the wrappedItem isn't in the DOM and focusable, try one more time.
        if (loop) {
          loop = false;
          Coral.commons.nextFrame(focusFirstItem);
        }
      };

      Coral.commons.nextFrame(focusFirstItem);
    },

    /**
      Called after popover.open is set to false, but before the transition of the popover is done.
      Make items visible again, that now do fit into the actionbar.
      @ignore
    */
    _beforePopoverClose: function(event) {
      // there might be popovers in popover => ignore them
      if (event.target !== this._elements.popover) {
        return;
      }

      var focusedItem = document.activeElement.parentNode;

      // hide the popover(needed to disable fade time of popover)
      this._elements.popover.hidden = true;

      //close any popovers, that might be inside the 'more' popover
      var childPopovers = this._elements.popover.querySelectorAll('coral-popover');
      for (var i = 0; i < childPopovers.length; i++) {
        childPopovers[i].open = false;
      }

      // return all elements from popover
      if (this._position === Coral.ActionBar.Container.position.PRIMARY) {
        this._returnLeftElementsFromPopover();
      }
      else if (this._position === Coral.ActionBar.Container.position.SECONDARY) {
        this._returnRightElementsFromPopover();
      }

      // clear cached items from popover
      this._itemsInPopover = [];

      // we need to check if item has 'hasAttribute' because it is not present on the document
      var isFocusedItemInsideActionBar = (this.parentNode !== focusedItem && this.parentNode.contains(focusedItem));

      var isFocusedItemOffscreen = focusedItem.hasAttribute && focusedItem.hasAttribute('coral-actionbar-offscreen');
      if (isFocusedItemInsideActionBar && isFocusedItemOffscreen) {
        // if currently an element is focused, that should not be visible (or is no actionbar-item) => select 'more'
        // button
        this._elements.moreButton.focus();
      }
    },

    /** @ignore */
    _render: function() {
      // Cleanup resize helpers object (cloneNode support)
      var resizeHelpers = this.querySelectorAll('object');
      for (var i = 0; i < resizeHelpers.length; ++i) {
        var resizeElement = resizeHelpers[i];
        if (resizeElement.parentNode === this) {
          this.removeChild(resizeElement);
        }
      }

      // Cleanup 'More' button
      this._elements.moreButton = this.querySelector('[coral-actionbar-more]');
      if (this._elements.moreButton) {
        this.removeChild(this._elements.moreButton);
      }

      // Cleanup 'More' popover
      this._elements.popover = this.querySelector('[coral-actionbar-popover]');
      if (this._elements.popover) {
        this.removeChild(this._elements.popover);
      }

      // Init 'More' button
      Coral.templates.ActionBar.moreButton.call(this._elements);
      this._elements.moreButton.label.textContent = this.moreButtonText;
      // 'More' button might be moved later in dom when Container is attached to parent
      // @see this.attachedCallback()
      this.appendChild(this._elements.moreButton);

      // Init 'More' popover
      Coral.templates.ActionBar.morePopover.call(this._elements);
      this._elements.popover.target = this._elements.moreButton;

      // Insert popover always as firstChild to ensure element order (cloneNode support)
      this.insertBefore(this._elements.popover, this.firstChild || null);

      console.warn('@deprecated: coral-actionbar-container is deprecated, use coral-actionbar-primary and ' +
        'coral-actionbar-secondary instead');
    },

    /** @ignore */
    _returnLeftElementsFromPopover: function() {
      var item = null;
      var wrappedItem = null;

      for (var i = 0; i < this._itemsInPopover.length; i++) {
        item = this._itemsInPopover[i];

        // remove tabindex again
        wrappedItem = Coral.ActionBar._getFirstSelectableWrappedItem(item);
        if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
          wrappedItem.setAttribute('tabindex', -1);
        }

        // 'insertBefore' with an undefined "before" argument fails on IE9
        this.insertBefore(item, this._elements.moreButton || null);
      }
    },

    /** @ignore */
    _returnRightElementsFromPopover: function() {
      var item = null;
      var wrappedItem = null;

      for (var i = this._itemsInPopover.length - 1; i >= 0; i--) {
        item = this._itemsInPopover[i];

        // remove tabindex again
        wrappedItem = Coral.ActionBar._getFirstSelectableWrappedItem(item);
        if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
          wrappedItem.setAttribute('tabindex', -1);
        }

        // 'insertBefore' with an undefined "before" argument fails on IE9
        this.insertBefore(item, this.firstChild.nextSibling || null);
      }
    },

    /** @ignore */
    _attachMoreButtonToContainer: function() {
      if (this.parentNode && this.parentNode.secondary === this) {
        // 'insertBefore' with an undefined "before" argument fails on IE9.
        this.insertBefore(this._elements.moreButton, this.firstChild || null);
      }
      else {
        // add the button to the left/primary contentzone
        this.appendChild(this._elements.moreButton);
      }
    },

    // JSDocs inherited
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.apply(this, arguments);
      // we need to wait if the component is not ready
      if (!this.parentNode._componentReady) {
        var self = this;
        Coral.commons.ready(this, function() {
          self._attachMoreButtonToContainer();
        });
      }
      else {
        this._attachMoreButtonToContainer();
      }
    }
  });

  // exports the enumeration
  Coral.ActionBar.Container.position = position;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var properties = {
    /**
      The Collection Interface that allows interacting with the items that the component contains. See
      {@link Coral.Collection} for more details.

      @type {Coral.Collection}
      @readonly
      @memberof Coral.mixin.actionBarContainer
    */
    'items': {
      get: function() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new Coral.ActionBar.Container.Collection(this);
        }

        return this._items;
      },
      set: function() {
        // Read-only
      }
    },

    /**
      The amount of items that are maximally visible inside the container. Using a value <= 0 will disable this
      feature and show as many items as possible.

      @type {Number}
      @default -1
      @htmlattribute threshold
      @htmlattributereflected
      @memberof Coral.mixin.actionBarContainer
    */
    'threshold': {
      default: -1,
      reflectAttribute: true,
      transform: Coral.transform.number
    },

    /**
      If there are more ActionBarItems inside the ActionBar than currently can be shown, then a "more" Button with the
      following text will be rendered (and some ActionBarItems will be hidden inside of a Popover).

      @type {String}
      @default ""
      @htmlattribute morebuttontext
      @memberof Coral.mixin.actionBarContainer
    */
    'moreButtonText': {
      default: '',
      attribute: 'morebuttontext',
      transform: Coral.transform.string,
      sync: function() {
        if (this._elements.moreButton) {
          // moreButton might not have been created so far
          this._elements.moreButton.label.innerHTML = this.moreButtonText;
          if (this.moreButtonText.trim() === '') {
            this._elements.moreButton.setAttribute('title', Coral.i18n.get('More'));
          }
          else {
            this._elements.moreButton.removeAttribute('title');
          }
        }
      }
    }
  };

  // Events to add
  var events = {
    'coral-overlay:beforeopen [handle="popover"]': '_onOverlayBeforeOpen',
    'coral-overlay:beforeclose [handle="popover"]': '_onOverlayBeforeClose'
  };

  // Methods to add
  var methods = {

    /**
      Called after popover.open is set to true, but before the transition of the popover is done. Show elements inside
      the actionbar, that are hidden due to space problems.

      @ignore
    */
    _onOverlayBeforeOpen: function(event) {
      // there might be popovers in popover => ignore them
      if (event.target !== this._elements.popover) {
        return;
      }

      this._itemsInPopover = this.items._getAllOffScreen();

      if (this._itemsInPopover.length < 1) {
        return;
      }

      // show the current popover (hidden needed to disable fade time of popover)
      this._elements.popover.hidden = false;

      // render popover content
      var popoverContent = this._elements.popover.content;
      popoverContent.innerHTML = '';
      popoverContent.appendChild(Coral.templates.ActionBar.popovercontent(this._itemsInPopover));

      // focus first item (nextFrame needed as popover must be visible and initialized with items)
      var self = this;
      var wrappedItem;
      var loop = true;
      var focusFirstItem = function() {
        wrappedItem = Coral.ActionBar._getFirstSelectableWrappedItem(self._itemsInPopover[0]);
        if (wrappedItem) {
          // focus first item
          wrappedItem.removeAttribute('tabindex');
          wrappedItem.focus();
          return;
        }

        // If the wrappedItem isn't in the DOM and focusable, try one more time.
        if (loop) {
          loop = false;
          Coral.commons.nextFrame(focusFirstItem);
        }
      };

      Coral.commons.nextFrame(focusFirstItem);
    },

    /**
      Called after popover.open is set to false, but before the transition of the popover is done.
      Make items visible again, that now do fit into the actionbar.
      @ignore
    */
    _onOverlayBeforeClose: function(event) {
      // there might be popovers in popover => ignore them
      if (event.target !== this._elements.popover) {
        return;
      }

      var focusedItem = document.activeElement.parentNode;

      // hide the popover(needed to disable fade time of popover)
      this._elements.popover.hidden = true;

      //close any popovers, that might be inside the 'more' popover
      var childPopovers = this._elements.popover.querySelectorAll('coral-popover');
      for (var i = 0; i < childPopovers.length; i++) {
        childPopovers[i].open = false;
      }

      // return all elements from popover
      this._returnElementsFromPopover();

      // clear cached items from popover
      this._itemsInPopover = [];

      // we need to check if item has 'hasAttribute' because it is not present on the document
      var isFocusedItemInsideActionBar = this.parentNode.contains(focusedItem);
      var isFocusedItemOffscreen = focusedItem.hasAttribute && focusedItem.hasAttribute('coral-actionbar-offscreen');
      if (isFocusedItemInsideActionBar && isFocusedItemOffscreen) {
        // if currently an element is focused, that should not be visible (or is no actionbar-item) => select 'more'
        // button
        this._elements.moreButton.focus();
      }
    },

    /** @ignore */
    _render: function() {
      // Cleanup resize helpers object (cloneNode support)
      var resizeHelpers = this.querySelectorAll('object');
      for (var i = 0; i < resizeHelpers.length; ++i) {
        var resizeElement = resizeHelpers[i];
        if (resizeElement.parentNode === this) {
          this.removeChild(resizeElement);
        }
      }

      // Cleanup 'More' button
      this._elements.moreButton = this.querySelector('[coral-actionbar-more]');
      if (this._elements.moreButton) {
        this.removeChild(this._elements.moreButton);
      }

      // Cleanup 'More' popover
      this._elements.popover = this.querySelector('[coral-actionbar-popover]');
      if (this._elements.popover) {
        this.removeChild(this._elements.popover);
      }

      // Init 'More' button
      Coral.templates.ActionBar.moreButton.call(this._elements);
      this._elements.moreButton.label.textContent = this.moreButtonText;
      // 'More' button might be moved later in dom when Container is attached to parent
      // @see this.attachedCallback()
      this.appendChild(this._elements.moreButton);

      // Init 'More' popover
      Coral.templates.ActionBar.morePopover.call(this._elements);
      this._elements.popover.target = this._elements.moreButton;

      // Insert popover always as firstChild to ensure element order (cloneNode support)
      this.insertBefore(this._elements.popover, this.firstChild || null);
    }
  };

  /**
    Configure a component to have the basic properties and methods that are expected from an action bar.

    @mixin
    @private
  */
  Coral.mixin.actionBarContainer = function(prototype, options) {
    // Add methods
    Coral.commons.augment(prototype, methods, function(objectMethod, mixinMethod, propName) {
      return Coral.commons.callAll(mixinMethod, objectMethod);
    });

    // Define events, letting the object override the mixin
    prototype._events = Coral.commons.augment({}, prototype._events, events);

    // Augment property descriptors
    Coral.register.augmentProperties(options.properties, properties);
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ActionBar.Primary# */ {
    /**
     @class Coral.ActionBar.Primary
     @classdesc An ActionBar Primary Container
     @extends Coral.Component
     @htmltag coral-actionbar-primary
     */
    name: 'ActionBar.Primary',
    tagName: 'coral-actionbar-primary',
    className: 'coral3-ActionBar-primary',

    mixins: [
      Coral.mixin.actionBarContainer
    ],

    _itemsInPopover: [],

    /** @ignore */
    _returnElementsFromPopover: function() {
      var item = null;
      var wrappedItem = null;

      for (var i = 0; i < this._itemsInPopover.length; i++) {
        item = this._itemsInPopover[i];

        // remove tabindex again
        wrappedItem = Coral.ActionBar._getFirstSelectableWrappedItem(item);
        if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
          wrappedItem.setAttribute('tabindex', -1);
        }

        // 'insertBefore' with an undefined "before" argument fails on IE9
        this.insertBefore(item, this._elements.moreButton || null);
      }
    },

    /** @ignore */
    _attachMoreButtonToContainer: function() {
      // add the button to the left/primary contentzone
      this.appendChild(this._elements.moreButton);
    },

    // JSDocs inherited
    attachedCallback: function() {
      var self = this;
      Coral.Component.prototype.attachedCallback.apply(this, arguments);
      // we need to make sure the more button is the last item
      Coral.commons.ready(this, function() {
        self._attachMoreButtonToContainer();
      });
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ActionBar.Secondary# */ {
    /**
      @class Coral.ActionBar.Secondary
      @classdesc An ActionBar Secondary Container
      @extends Coral.Component
      @htmltag coral-actionbar-secondary
    */
    name: 'ActionBar.Secondary',
    tagName: 'coral-actionbar-secondary',
    className: 'coral3-ActionBar-secondary',

    mixins: [
      Coral.mixin.actionBarContainer
    ],

    _itemsInPopover: [],

    /** @ignore */
    _returnElementsFromPopover: function() {
      var item = null;
      var wrappedItem = null;

      for (var i = this._itemsInPopover.length - 1; i >= 0; i--) {
        item = this._itemsInPopover[i];

        // remove tabindex again
        wrappedItem = Coral.ActionBar._getFirstSelectableWrappedItem(item);
        if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
          wrappedItem.setAttribute('tabindex', -1);
        }

        // 'insertBefore' with an undefined "before" argument fails on IE9
        this.insertBefore(item, this.firstChild.nextSibling || null);
      }
    },

    /** @ignore */
    _attachMoreButtonToContainer: function() {
      // 'insertBefore' with an undefined "before" argument fails on IE9.
      this.insertBefore(this._elements.moreButton, this.firstChild || null);
    },

    // JSDocs inherited
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.apply(this, arguments);
      // we need to wait if the component is not ready

      // we need to make sure the more button is the first item
      this._attachMoreButtonToContainer();
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    The default Collection as used by Coral.ActionBar.Container .

    @param host {HTMLElement}
    The element that hosts the collection

    @constructor
    @ignore
  */
  var Collection = function(host) {
    this._host = host;
  };

  // Assigns the prototype to get access to the Collection signature methods:
  Collection.prototype = Object.create(Coral.Collection.prototype);

  Collection.prototype.add = function(item, before) {
    // in the left actionBar container always insert elements before the 'more' button in right actionBar always append
    // at the end
    if (!before && this._host.tagName === 'CORAL-ACTIONBAR-PRIMARY') {
      before = this._host.lastChild;
    }

    if (!(item instanceof HTMLElement)) {
      // Creates a new item and initializes its values:
      var config = item;

      item = document.createElement('coral-actionbar-item');

      // applies quietly the settings
      item.set(config, true);
    }

    // 'insertBefore' with an undefined "before" argument fails on IE9.
    this._host.insertBefore(item, before || null);

    return item;
  };

  Collection.prototype.clear = function() {
    var items = this.getAll();

    var removed = [];

    for (var i = items.length - 1; i > -1; i--) {
      removed.push(this.remove(items[i]));
    }

    this._host._itemsInPopover = [];

    return removed;
  };

  Collection.prototype.getAll = function() {
    var childItems = Array.prototype.filter.call(this._host.children, function(child) {
      return child.tagName === ('CORAL-ACTIONBAR-ITEM');
    });

    // add items in popovers
    return childItems.concat(this._host._itemsInPopover);
  };

  Collection.prototype._getAllSelectable = function() {
    var selectableItems = [];

    var child = null;
    for (var i = 0; i < this._host.children.length; i++) {
      child = this._host.children[i];
      if (
        !child.hasAttribute('disabled') &&
        !child.hasAttribute('hidden') &&
        !child.hasAttribute('coral-actionbar-offscreen') &&
        child !== this._host._elements.popover &&
        Coral.ActionBar._getFirstSelectableWrappedItem(child)
      ) {
        selectableItems.push(child);
      }
    }

    return selectableItems;
  };

  Collection.prototype._getAllOffScreen = function() {
    return Array.prototype.filter.call(this._host.children, function(child) {
      return child.tagName === 'CORAL-ACTIONBAR-ITEM' && child.hasAttribute('CORAL-ACTIONBAR-OFFSCREEN');
    });
  };

  // this class is not public
  Coral.ActionBar.Container.Collection = Collection;
})();

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ActionBar.Item# */ {
    /**
      An ActionBar Item should simply wrap arbitrary other items

      @class Coral.ActionBar.Item
      @classdesc An ActionBar item
      @extends Coral.Component
      @htmltag coral-actionbar-item
    */
    name: 'ActionBar.Item',
    tagName: 'coral-actionbar-item',
    className: 'coral3-ActionBar-item',

    properties: {
      /**
        Item content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.ActionBar.Item#
      */
      'content': {
        contentZone: true,
        get: function() {
          return this;
        },
        set: function() {}
      }
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Alert"] = window["Coral"]["templates"]["Alert"] || {};
window["Coral"]["templates"]["Alert"]["icon"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["icon"] = document.createElement("coral-icon");
  el0.className += " coral3-Alert-typeIcon";
  el0.setAttribute("size", "XS");
  el0.setAttribute("handle", "icon");
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // A map of types to icon names
  var iconMap = {
    'success': 'checkCircle',
    'info': 'infoCircle',
    'error': 'alert',
    'warning': 'alert',
    'help': 'helpCircle'
  };

  /**
    Enumeration representing alert variants.

    @memberof Coral.Alert
    @enum {String}
  */
  var variant = {
    /** An alert with a red header and warning icon, indicating that an error has occurred. */
    ERROR: 'error',
    /** An alert with an orange header and warning icon, notifying the user of something important. */
    WARNING: 'warning',
    /** An alert with a green header and checkmark icon, indicates to the user that an operation was successful. */
    SUCCESS: 'success',
    /** An alert with a blue header and question mark icon, provides the user with help. */
    HELP: 'help',
    /** An alert with a blue header and info icon, informs the user of non-critical information. */
    INFO: 'info'
  };

  /**
    Enumeration representing alert sizes.

    @memberof Coral.Alert
    @enum {String}
  */
  var size = {
    /** A small alert, usually employed for single line alerts without headers. */
    SMALL: 'S',
    /** A large alert, usually employed for multi-line alerts with headers. */
    LARGE: 'L'
  };

  var CLASSNAME = 'coral3-Alert';

  // size mapping
  var SIZE_CLASSES = {
    'S': 'small',
    'L': 'large'
  };

  // An array of all possible variant classnames
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }
  // An array of all possible size classnames
  var ALL_SIZE_CLASSES = [];
  for (var sizeValue in size) {
    ALL_SIZE_CLASSES.push(CLASSNAME + '--' + SIZE_CLASSES[size[sizeValue]]);
  }

  Coral.register( /** @lends Coral.Alert# */ {
    /**
      @class Coral.Alert
      @classdesc An Alert component
      @extends Coral.Component
      @htmltag coral-alert
    */
    name: 'Alert',
    tagName: 'coral-alert',
    className: CLASSNAME,

    events: {
      'click [coral-close]': '_onCloseClick'
    },

    properties: {

      /**
        The alert variant style to use.

        @type {Coral.Alert.variant}
        @default Coral.Alert.variant.INFO
        @htmlattribute variant
        @htmlattributereflected
        @memberof Coral.Alert#
      */
      'variant': {
        default: variant.INFO,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        set: function(value) {
          this._variant = value;
          this._elements.icon.icon = iconMap[this.variant];
        },
        sync: function() {
          // Remove all variant classes
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          // Set new variant class
          // Don't use this._className; use the constant
          // This lets popover get our styles for free
          this.classList.add(CLASSNAME + '--' + this.variant);
          // Set the role attribute to alert or status depending on
          // the variant so that the element turns into a live region
          this.setAttribute('role',
            (this.variant === variant.ERROR || this.variant === variant.WARNING) ? 'alert' : 'status');
        }
      },

      /**
        The size of the alert. It accepts both lower and upper case sizes.

        @type {Coral.Alert.size}
        @default Coral.Alert.size.SMALL
        @htmlattribute size
        @htmlattributereflected
        @memberof Coral.Alert#
      */
      'size': {
        default: size.SMALL,
        reflectAttribute: true,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        sync: function() {
          // Remove all variant classes and adds the new one
          this.classList.remove.apply(this.classList, ALL_SIZE_CLASSES);
          this.classList.add(CLASSNAME + '--' + SIZE_CLASSES[this.size]);
        }
      },

      /**
        The alert header element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Alert#
      */
      'header': Coral.property.contentZone({
        handle: 'header',
        tagName: 'coral-alert-header',
        insert: function(header) {
          // After the icon
          this.insertBefore(header, this._elements.icon.nextElementSibling);
        }
      }),

      /**
        The alert content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Alert#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-alert-content',
        defaultContentZone: true,
        insert : function(content) {
          // After the header
          this.insertBefore(content, this.header.nextElementSibling);
        }
      }),

      /**
        The alert footer element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Alert#
      */
      'footer': Coral.property.contentZone({
        handle: 'footer',
        tagName: 'coral-alert-footer',
        insert : function(footer) {
          // After the content
          this.insertBefore(footer, this.content.nextElementSibling);
        }
      })
    },

    _templateHandleNames: ['icon'],

    /** @private */
    _render: function() {
      // Fetch or create the header and content footer sub-components
      var header = this.querySelector('coral-alert-header') ||
        document.createElement('coral-alert-header');
      var content = this.querySelector('coral-alert-content');
      var footer = this.querySelector('coral-alert-footer') ||
        document.createElement('coral-alert-footer');

      // when the content zone was not created, we need to make sure that everything is added inside it as a content
      if (content === null) {
        content = document.createElement('coral-alert-content');
        while (this.firstChild) {
          var child = this.firstChild;
          if (child.nodeType === Node.TEXT_NODE ||
            this._templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the content
            content.appendChild(child);
          }
          else {
            // Remove anything else element
            this.removeChild(child);
          }
        }
      }

      var icon = this.querySelector('coral-icon');
      if (icon === null) {
        // Create the icon and add the reference to _elements
        this.appendChild(Coral.templates.Alert.icon.call(this._elements));
      }
      else {
        // Add the reference to _elements
        this._elements.icon = icon;
      }

      // Assign the content zones so the insert functions will be called
      this.header = header;
      this.content = content;
      this.footer = footer;
    },

    /**
      @ignore
      @todo maybe this should be mixin or something
    */
    _onCloseClick: function(event) {
      var dismissTarget = event.matchedTarget;
      var dismissValue = dismissTarget.getAttribute('coral-close');
      if (!dismissValue || this.matches(dismissValue)) {
        this.hide();
        event.stopPropagation();
      }
    }
  });

  Coral.register( /** @lends Coral.Alert.Header# */ {
    /**
      @class Coral.Alert.Header
      @classdesc The Alert header content component
      @htmltag coral-alert-header
      @extends Coral.Component
    */
    name: 'Alert.Header',
    tagName: 'coral-alert-header',
    className: CLASSNAME + '-header'
  });

  Coral.register( /** @lends Coral.Alert.Content# */ {
    /**
      @class Coral.Alert.Content
      @classdesc The Alert content component
      @htmltag coral-alert-content
      @extends Coral.Component
    */
    name: 'Alert.Content',
    tagName: 'coral-alert-content',
    className: CLASSNAME + '-content'
  });

  Coral.register( /** @lends Coral.Alert.Footer# */ {
    /**
      @class Coral.Alert.Footer
      @classdesc The Alert footer content component
      @htmltag coral-alert-footer
      @extends Coral.Component
    */
    name: 'Alert.Footer',
    tagName: 'coral-alert-footer',
    className: CLASSNAME + '-footer'
  });

  // Exports the enums globally
  Coral.Alert.size = size;
  Coral.Alert.variant = variant;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["List"] = window["Coral"]["templates"]["List"] || {};
window["Coral"]["templates"]["List"]["item"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["icon"] = document.createElement("coral-icon");
  el0.setAttribute("size", "S");
  el0.className += " coral3-BasicList-item-icon";
  el0.setAttribute("handle", "icon");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["outerContainer"] = document.createElement("div");
  el2.className += " coral3-BasicList-item-outerContainer";
  el2.setAttribute("handle", "outerContainer");
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["contentContainer"] = document.createElement("div");
  el4.className += " coral3-BasicList-item-contentContainer";
  el4.setAttribute("handle", "contentContainer");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el2.appendChild(el5);
  frag.appendChild(el2);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Boolean enumeration for List keyboard interaction state.

    @enum {String}
    @memberof Coral.List#
  */
  var interaction = {
    /** Keyboard interaction is enabled. */
    ON: 'on',
    /** Keyboard interaction is disabled. */
    OFF: 'off'
  };

  Coral.register( /** @lends Coral.List */ {
    /**
      @class Coral.List
      @classdesc A list of interactive items
      @extends Coral.Component
      @htmltag coral-list
    */
    name: 'List',
    tagName: 'coral-list',
    className: 'coral3-BasicList',
    itemTagName: 'coral-list-item',

    events: {
      'capture:mouseenter [coral-list-item]': '_onItemMouseEnter',
      'key:down [coral-list-item]': '_focusNextItem',
      'key:right [coral-list-item]': '_focusNextItem',
      'key:left [coral-list-item]': '_focusPreviousItem',
      'key:up [coral-list-item]': '_focusPreviousItem',
      'key:pageup [coral-list-item]': '_focusPreviousItem',
      'key:pagedown [coral-list-item]': '_focusNextItem',
      'key:home [coral-list-item]': '_focusFirstItem',
      'key:end [coral-list-item]': '_focusLastItem'
    },

    properties: {
      /**
        The item collection.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.List#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new Coral.Collection({
              itemTagName: this.itemTagName,
              itemBaseTagName: this.itemBaseTagName,
              itemSelector: '[coral-list-item]',
              host: this
            });
          }

          return this._items;
        },
        set: function() {}
      },

      /**
        Whether interaction with the component is enabled.

        @type {Coral.List.interaction}
        @default Coral.List.interaction.ON
        @htmlattribute interaction
        @memberof Coral.List#
      */
      'interaction': {
        default: interaction.ON,
        attribute: 'interaction',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(interaction)
        ]
      }
    },

    focus: function() {
      if (!this.contains(document.activeElement)) {
        var items = this._getSelectableItems();
        if (items.length > 0) {
          items[0].focus();
        }
      }
    },

    /** @private */
    _onItemMouseEnter: function(event) {
      // Do not try to focus on disabled items
      if (!event.matchedTarget.hasAttribute('disabled') && this.interaction === Coral.List.interaction.ON) {
        event.matchedTarget.focus();
      }
    },

    /**
      Returns true if the event is at the matched target.

      @todo this should be moved to Coral.Component
      @private
    */
    _eventIsAtTarget: function(event) {
      var target = event.target;
      var listItem = event.matchedTarget;

      var isAtTarget = (target === listItem);

      if (isAtTarget) {
        // Don't let arrow keys etc scroll the page
        event.preventDefault();
        event.stopPropagation();
      }

      return isAtTarget;
    },

    /** @private */
    _focusFirstItem: function() {
      if (this.interaction === Coral.List.interaction.OFF || !this._eventIsAtTarget(event)) {
        return;
      }

      var items = this._getSelectableItems();
      items[0].focus();
    },

    /** @private */
    _focusLastItem: function() {
      if (this.interaction === Coral.List.interaction.OFF || !this._eventIsAtTarget(event)) {
        return;
      }

      var items = this._getSelectableItems();
      items[items.length - 1].focus();
    },

    /** @private */
    _focusNextItem: function(event) {
      if (this.interaction === Coral.List.interaction.OFF || !this._eventIsAtTarget(event)) {
        return;
      }

      var target = event.matchedTarget;
      var items = this._getSelectableItems();
      var index = items.indexOf(target);

      if (index === -1) {
        // Invalid state
        return;
      }

      if (index < items.length - 1) {
        items[index + 1].focus();
      }
      else {
        items[0].focus();
      }
    },

    /** @private */
    _focusPreviousItem: function(event) {
      if (this.interaction === Coral.List.interaction.OFF || !this._eventIsAtTarget(event)) {
        return;
      }

      var target = event.matchedTarget;
      var items = this._getSelectableItems();
      var index = items.indexOf(target);

      if (index === -1) {
        // Invalid state
        return;
      }

      if (index > 0) {
        items[index - 1].focus();
      }
      else {
        items[items.length - 1].focus();
      }
    },

    /** @private */
    _getSelectableItems: function() {
      return this.items.getAll().filter(function(item) {
        return !item.hasAttribute('hidden') && !item.hasAttribute('disabled') && item.offsetParent !== null &&
          (item.offsetWidth > 0 || item.offsetHeight > 0 );
      });
    }
  });

  Coral.register( /** @lends Coral.List.Item */ {
    /**
      @class Coral.List.Item
      @classdesc A list item
      @extends Coral.Component
      @htmltag coral-list-item
    */
    name: 'List.Item',
    tagName: 'coral-list-item',
    className: 'coral3-BasicList-item',

    properties: {
      /**
        The content of the help item.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.List.Item#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-list-item-content',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.contentContainer.appendChild(content);
        }
      }),

      /**
        Whether this item is disabled.

        @default false
        @type {Boolean}
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.AnchorList.Item#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          if (this.disabled) {
            this.setAttribute('aria-disabled', 'true');
          }
          else {
            this.removeAttribute('aria-disabled');
          }
        }
      },

      /**
        The icon to display.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Button#

        @see {@link Coral.Icon}
      */
      'icon': {
        default: '',
        validate: [], // Don't do validation so setter runs
        get: function() {
          return this._elements.icon.icon;
        },
        set: function(value) {
          this._elements.icon.icon = value;

          // Hide if no icon
          this._elements.icon.hidden = this._elements.icon.icon === '';
        }
      }
    },

    /** @ignore */
    _render: function() {

      // Create a temporary fragment
      var fragment = document.createDocumentFragment();

      // Render the template
      fragment.appendChild(Coral.templates.List.item.call(this._elements));

      // Fetch or create the content content zone element
      var content = this.querySelector('coral-list-item-content') || document.createElement('coral-list-item-content');

      // Cleanup template elements (supporting cloneNode)
      Array.prototype.filter.call(this.children, function(child) {
        return (child.hasAttribute('handle'));
      }).forEach(function(handleItem) {
        this.removeChild(handleItem);
      }.bind(this));

      // Move any remaining elements into the content sub-component
      while (this.firstChild) {
        content.appendChild(this.firstChild);
      }

      // Assign the content zones, moving them into place in the process
      this.content = content;

      // Add the frag to the component
      this.appendChild(fragment);
    },

    /** @ignore */
    _initialize: function() {
      // The attribute that makes different types of list items co-exist
      // This is also used for event delegation
      this.setAttribute('coral-list-item', '');
    }
  });

  Coral.register( /** @lends Coral.List.Item.Content */ {
    /**
      @class Coral.List.Item.Content
      @classdesc The content of a list item
      @extends Coral.Component
      @htmltag coral-list-item-content
    */
    name: 'List.Item.Content',
    tagName: 'coral-list-item-content',
    className: 'coral3-BasicList-item-content'
  });

  // exposes the enum globally
  Coral.List.interaction = interaction;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.AnchorList */ {
    /**
      @class Coral.AnchorList
      @classdesc A list of interactive anchors
      @extends Coral.List
      @htmltag coral-anchorlist
    */
    name: 'AnchorList',
    tagName: 'coral-anchorlist',
    className: 'coral3-BasicList coral3-AnchorList',

    extend: Coral.List,
    itemTagName: 'coral-anchorlist-item',
    itemBaseTagName: 'a'
  });

  Coral.register( /** @lends Coral.AnchorList.Item */ {
    /**
      @class Coral.AnchorList.Item
      @classdesc An anchor list item
      @extends HTMLAnchorElement
      @extends Coral.List.Item
      @htmltag coral-anchorlist-item
    */
    name: 'AnchorList.Item',
    tagName: 'coral-anchorlist-item',
    baseTagName: 'a',
    className: 'coral3-BasicList-item coral3-AnchorList-item',

    extend: Coral.List.Item,

    events: {
      'click': '_onClick'
    },

    properties: {
      // JSDoc inherited
      'disabled': {
        sync: function(disabled) {
          if (this.disabled) {
            // It's not tabbable anymore
            this.tabIndex = -1;
          }
          else {
            // Now it's tabbable
            this.tabIndex = 0;
          }
        }
      }
    },

    /** @private */
    _onClick: function(event) {
      // Support disabled property
      if (this.disabled) {
        event.preventDefault();
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ButtonList */ {
    /**
      @class Coral.ButtonList
      @classdesc A list of interactive buttons
      @extends Coral.List
      @htmltag coral-buttonlist
    */
    name: 'ButtonList',
    tagName: 'coral-buttonlist',
    className: 'coral3-BasicList coral3-ButtonList',

    extend: Coral.List,
    itemTagName: 'coral-buttonlist-item',
    itemBaseTagName: 'button'
  });

  Coral.register( /** @lends Coral.ButtonList.Item */ {
    /**
      @class Coral.ButtonList.Item
      @classdesc An button list item
      @extends HTMLButtonElement
      @extends Coral.BaseList.Item
      @htmltag coral-buttonlist-item
    */
    name: 'ButtonList.Item',
    tagName: 'coral-buttonlist-item',
    baseTagName: 'button',
    className: 'coral3-BasicList-item coral3-ButtonList-item',

    extend: Coral.List.Item,

    properties: {
      // Don't try to define disabled as HTMLButtonElement already does
      'disabled' : null
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-taglist"] = {"en-US":{"Remove":"Remove"},"fr-FR":{"Remove":"Supprimer"},"de-DE":{"Remove":"Entfernen"},"it-IT":{"Remove":"Rimuovi"},"es-ES":{"Remove":"Eliminar"},"pt-BR":{"Remove":"Remover"},"ja-JP":{"Remove":"削除"},"ko-KR":{"Remove":"제거"},"zh-CN":{"Remove":"删除"},"zh-TW":{"Remove":"移除"},"nl-NL":{"Remove":"Verwijderen"},"da-DK":{"Remove":"Fjern"},"fi-FI":{"Remove":"Poista"},"nb-NO":{"Remove":"Fjern"},"sv-SE":{"Remove":"Ta bort"},"cs-CZ":{"Remove":"Odebrat"},"pl-PL":{"Remove":"Usuń"},"ru-RU":{"Remove":"Удалить"},"tr-TR":{"Remove":"Kaldır"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["TagList"] = window["Coral"]["templates"]["TagList"] || {};
window["Coral"]["templates"]["TagList"]["input"] = (function anonymous(data_0
/*``*/) {
  var data = data_0;
  var el0 = this["input"] = document.createElement("input");
  el0.setAttribute("handle", "input");
  el0.setAttribute("type", "hidden");
  el0.setAttribute("name", "");
  el0.setAttribute("value", "");
  return el0;
});

window["Coral"]["templates"]["TagList"]["tag"] = (function anonymous(data_0
/*``*/) {
  var data = data_0;
  var el0 = this["button"] = document.createElement("button","coral-button");
  el0.setAttribute("handle", "button");
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("type", "button");
  el0.setAttribute("variant", "minimal");
  el0.setAttribute("icon", "close");
  el0.setAttribute("iconSize", "XS");
  el0.className += " coral3-Tag-removeButton";
  el0.setAttribute("title", Coral["i18n"]["get"]('Remove'));
  el0.setAttribute("tabindex", "-1");
  el0.setAttribute("coral-close", "");
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var CLASSNAME = 'coral3-Tag';

  /**
    Enum for tag size values.

    @enum {String}
    @memberof Coral.Tag
  */
  var size = {
    /** A default tag (non-interactive), height 20px without closable button. */
    SMALL: 'S',
    /** A default tag (non-interactive), height 28px without closable button. */
    MEDIUM: 'M',
    /** A default tag (interactive), height 32px without closable button. */
    LARGE: 'L'
  };

  /**
    Color of the tag. By default they are semi-transparent unless otherwise stated.

    @enum {String}
    @memberof Coral.Tag
  */
  var color = {
    DEFAULT: '',
    GREY: 'grey',
    BLUE: 'blue',
    LIGHT_BLUE: 'lightblue',
    PERIWINKLE: 'periwinkle',
    PLUM: 'plum',
    FUCHSIA: 'fuchsia',
    MAGENTA: 'magenta',
    RED: 'red',
    ORANGE: 'orange',
    TANGERINE: 'tangerine',
    YELLOW: 'yellow',
    CHARTREUSE: 'chartreuse',
    GREEN: 'green',
    KELLY_GREEN: 'kellygreen',
    SEA_FOAM: 'seafoam',
    CYAN: 'cyan'
  };

  // size mappings
  var SIZE_CLASSES = {
    'S': 'small',
    'M': 'medium',
    'L': 'large'
  };

  // builds a string containing all possible size classnames. this will be used to remove classnames when the size
  // changes
  var ALL_SIZE_CLASSES = [];
  for (var sizeValue in size) {
    ALL_SIZE_CLASSES.push(CLASSNAME + '--' + SIZE_CLASSES[size[sizeValue]]);
  }

  // builds a string containing all possible color classnames. this will be used to remove classnames when the color
  // changes
  var ALL_COLOR_CLASSES = [];
  for (var colorValue in color) {
    ALL_COLOR_CLASSES.push(CLASSNAME + '--' + color[colorValue]);
  }

  var quietTagClass = CLASSNAME + '--quiet';
  var multilineTagClass = CLASSNAME + '--multiline';

  // Store coordinates of a mouse down event to compare against mouseup coordinates.
  var bullseye = null;

  // Utility method to detect center point of an element.
  function getOffsetCenter(element) {
    var rect = element.getBoundingClientRect();
    var body = document.body;
    var documentElement = document.documentElement;
    var scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;
    var clientTop = documentElement.clientTop || body.clientTop || 0;
    var clientLeft = documentElement.clientLeft || body.clientLeft || 0;
    var x = rect.left + rect.width / 2 + scrollLeft - clientLeft;
    var y = rect.top + rect.height / 2 + scrollTop - clientTop;
    return {
      x: Math.round(x),
      y: Math.round(y)
    };
  }

  Coral.register( /** @lends Coral.Tag# */ {

    /**
      @class Coral.Tag
      @classdesc A Tag component
      @extends Coral.Component
      @htmltag coral-tag
    */
    name: 'Tag',
    tagName: 'coral-tag',
    className: CLASSNAME,

    events: {
      'click': '_onClick',
      'key:backspace': '_onRemoveButtonClick',
      'key:delete': '_onRemoveButtonClick',
      'key:space': '_onRemoveButtonClick',
      'mousedown': '_onMouseDown'
    },

    properties: {
      /**
        The tag's label element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Tag#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-tag-label',
        defaultContentZone: true,
        insert: function(label) {
          this.appendChild(label);
        },
        sync: function() {
          this._updateAriaLabel();
        }
      }),

      /**
        Whether this component can be closed.

        @type {Boolean}
        @default false
        @htmlattribute closable
        @htmlattributereflected
        @memberof Coral.Tag#
      */
      'closable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          // Insert the button if it was not added to the DOM
          if (this.closable && !this.contains(this._elements.button)) {
            this.insertBefore(this._elements.button, this.firstChild);
          }
          this._elements.button.hidden = !this.closable;
          this._updateAriaLabel();
        }
      },

      /**
        Value of the tag. If not explicitly set, the value of <code>Node.textContent</code> is returned.

        @type {String}
        @default ""
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.Tag#
      */
      'value': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        trigger: 'coral-tag:_valuechanged',
        get: function() {
          // keep spaces to only 1 max and trim to mimic native select option behavior
          return typeof this._value === 'undefined' ? this.textContent.replace(/\s{2,}/g, ' ').trim() : this._value;
        }
      },

      /**
        A quiet tag to differentiate it from default tag.

        @type {Boolean}
        @default false
        @htmlattribute quiet
        @htmlattributereflected
        @memberof Coral.Tag#
      */
      'quiet': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(quietTagClass, this.quiet);
        }
      },

      /**
        A multiline tag for block-level layout with multiline text.

        @type {Boolean}
        @default false
        @htmlattribute multiline
        @htmlattributereflected
        @memberof Coral.Tag#
      */
      'multiline': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(multilineTagClass, this.multiline);
        }
      },

      /**
        The tag's size.

        @type {Coral.Tag.size}
        @default Coral.Tag.size.LARGE
        @htmlattribute size
        @memberof Coral.Tag#
      */
      'size': {
        default: size.LARGE,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_SIZE_CLASSES);
          this.classList.add(this._className + '--' + SIZE_CLASSES[this.size]);
        }
      },

      /**
        The tags's color.

        @type {Coral.Tag.color}
        @default Coral.Tag.color.DEFAULT
        @htmlattribute color
        @memberof Coral.Tag#
      */
      'color': {
        default: color.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(color)
        ],
        sync: function() {
          // removes every existing color
          this.classList.remove.apply(this.classList, ALL_COLOR_CLASSES);

          if (this.color !== Coral.Tag.color.DEFAULT) {
            this.classList.add(this._className + '--' + this.color);
          }
        }
      }
    },

    /** @private */
    _onRemoveButtonClick: function(event) {
      event.preventDefault();
      if (this.closable) {
        event.stopPropagation();
        this.focus();

        this.trigger('coral-tag:_buttonclicked');
        this.remove();
      }
    },

    /** @private */
    _onClick: function(event) {
      if (this._elements.button.disabled) {
        return;
      }

      // If the click event originated from a screen reader's event sequence or the remove button, trigger the removal
      // of the tag.
      if (event.target === this._elements.button ||
          this._elements.button.contains(event.target) ||
          bullseye !== null ||
          /* Detects virtual cursor or Narrator on Windows */
          (event.clientX <= 0 && event.clientY <= 0)) {
        this._onRemoveButtonClick(event);
        bullseye = null;
      }
    },

    /** @private */
    _onMouseDown: function(event) {
      // Determine the center point of the event target
      var offsetCenter = getOffsetCenter(event.target);
      // This Tag will be the event.target when mousedown originates from a screen reader.
      if (event.target === this &&
          Math.abs(event.pageX - offsetCenter.x) < 2 &&
          Math.abs(event.pageY - offsetCenter.y) < 2) {
        // If click is close enough to the center, store the coordinates.
        bullseye = {
          x: event.pageX,
          y: event.pageY
        };
      }
      else {
        bullseye = null;
      }
      Coral.events.on('mouseup', this._onMouseUp);
    },

    /** @private */
    _onMouseUp: function(event) {
      // If stored bullseye coordinates don't match mouse up event coordinates,
      // don't store them any more.
      if (bullseye !== null && (event.pageX !== bullseye.x || event.pageY !== bullseye.y)) {
        bullseye = null;
      }
      Coral.events.off('mouseup', this._onMouseUp);
    },

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var fragment = document.createDocumentFragment();

      // Create or fetch the label element.
      var label = this.querySelector('coral-tag-label') || document.createElement('coral-tag-label');

      // Remove it so we can process children
      if (label.parentNode) {
        this.removeChild(label);
      }

      // Process remaining elements as necessary
      while (this.firstChild) {
        var child = this.firstChild;
        // Only works if the template element has a handle attribute
        if (child.hasAttribute && child.hasAttribute('handle') || child.nodeType === Node.COMMENT_NODE) {
          // Store the button
          if (child.hasAttribute && child.getAttribute('handle') === 'button') {
            this._elements.button = child;
          }
          fragment.appendChild(child);
        }
        else {
          // Move anything else into the label
          label.appendChild(child);
        }
      }

      if (!this._elements.button) {
        // Render the button template but insert it only if 'closable' is true
        Coral.templates.TagList.tag.call(this._elements);
      }
      
      // Make sure to disable the button when rendered
      if (this.hasAttribute('disabled')) {
        this._elements.button.disabled = true;
      }

      // Add the frag to the component
      this.appendChild(fragment);

      // Assign the content zones, moving them into place in the process
      this.label = label;
    },

    /**
      Updates the aria-label property from the button and label elements.

      @memberof Coral.Tag#
      @ignore
    */
    _updateAriaLabel: function() {
      var button = this._elements.button;
      var label = this._elements.label;

      // In the edge case that this is a Tag without a TagList,
      // just treat the Tag as a container element without special labelling.
      if (this.getAttribute('role') !== 'option') {
        button.removeAttribute('aria-hidden');
        label.removeAttribute('aria-hidden');
        return;
      }

      var labelText = [];

      var buttonAriaLabel = button.getAttribute('title');
      var labelTextContent = label.textContent;

      if (button.parentElement) {
        if (!label.parentElement || labelTextContent !== buttonAriaLabel) {
          if (!button.hidden) {
            labelText.push(buttonAriaLabel);
          }
          button.setAttribute('aria-hidden', 'true');
        }
      }

      if (label.parentElement) {
        if (!button.parentElement || buttonAriaLabel !== labelTextContent) {
          labelText.push(labelTextContent);
          label.setAttribute('aria-hidden', 'true');
        }
      }

      if (labelText.length) {
        this.setAttribute('aria-label', labelText.join(' '));
      } else {
        this.removeAttribute('aria-label');
      }
    }

    /**
      Triggered when the close button is clicked.

      @event Coral.Tag#coral-tag:_buttonclicked

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when the value is changed.

      @event Coral.Tag#coral-tag:_valuechanged

      @param {Object} event Event object
      @private
     */
  });

  /**
    @class Coral.Tag.Label
    @classdesc A Tag Label component
    @extends Coral.Component
    @htmltag coral-tag-label
  */
  Coral.Tag.Label = function() {
    return document.createElement('coral-tag-label');
  };

  // exports the enumerations
  Coral.Tag.size = size;
  Coral.Tag.color = color;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Collection
  var itemTagName = 'coral-tag';

  Coral.register( /** @lends Coral.TagList# */ {

    /**
      @class Coral.TagList
      @classdesc A TagList component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-taglist
    */
    name: 'TagList',
    tagName: 'coral-taglist',
    className: 'coral3-TagList',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'capture:focus coral-tag': '_onItemFocus',
      'capture:blur coral-tag': '_onItemBlur',
      'key:right coral-tag': '_onNextItemFocus',
      'key:down coral-tag': '_onNextItemFocus',
      'key:pagedown coral-tag': '_onNextItemFocus',
      'key:left coral-tag': '_onPreviousItemFocus',
      'key:up coral-tag': '_onPreviousItemFocus',
      'key:pageup coral-tag': '_onPreviousItemFocus',
      'key:home coral-tag': '_onFirstItemFocus',
      'key:end coral-tag': '_onLastItemFocus',

      // Private
      'coral-tag:_buttonclicked': '_onTagButtonClicked',
      'coral-tag:_valuechanged': '_onTagValueChanged'
    },

    properties: {
      // JSDoc inherited
      'disabled': {
        set: function(value) {
          this._disabled = value;
          
          var self = this;
          self.classList.toggle('is-disabled', self.disabled);
          self.setAttribute('aria-disabled', self.disabled);

          self.items.getAll().forEach(function(tag) {
            tag[self.disabled ? 'setAttribute': 'removeAttribute']('disabled', '');
            
            var input = tag._input;
            if (input) {
              input.disabled = self.disabled;
            }
            
            if (tag._elements) {
              tag._elements.button.disabled = self.disabled;
            }
            
            if (self.disabled) {
              tag.removeAttribute('tabindex');
            } else {
              tag.setAttribute('tabindex', 0);
            }
          });
        }
      },

      // JSDoc inherited
      'readOnly': {
        set: function(value) {
          this._readOnly = value;
          
          var self = this;
          self.removeAttribute('aria-readonly');
          self.items.getAll().forEach(function(tag) {
            tag.closable = !self.readOnly;
          });
        }
      },

      // JSDoc inherited
      'value': {
        transform: Coral.transform.string,
        validate: [
          function(newValue, oldValue) {
            // In case there's an item with empty string value
            return newValue !== oldValue || oldValue === '' && this.items.length;
          }
        ],
        get: function() {
          var all = this.items.getAll();
          if (all.length) {
            return all[0].value;
          }
          else {
            return '';
          }
        },
        set: function(value) {
          if (typeof this.value !== 'undefined') {
            this.items.clear();

            if (value) {
              var item = new Coral.Tag().set({
                'label': {
                  // @todo this allows HTML, should it be textContent?
                  innerHTML: value
                },
                'value': value
              });

              // Don't wait for the mutation observer to kick in
              this._attachInputToItem(item, true);

              this.items.add(item);
            }
          }
        }
      },

      /**
        Changing the values will redefine the component's items.

        @type {Array.<String>}
        @memberof Coral.TagList#
        @fires Coral.mixin.formField#change
      */
      'values': {
        get: function() {
          return this.items.getAll().map(function(tag) {
            return tag.value;
          });
        },
        set: function(values) {
          var self = this;
          self.items.clear();

          values.forEach(function(value) {
            var item = new Coral.Tag().set({
              'label': {
                // @todo this allows HTML, should it be textContent?
                innerHTML: value
              },
              'value': value
            });

            // Don't wait for the mutation observer to kick in
            self._attachInputToItem(item, true);

            self.items.add(item);
          });
        }
      },

      /**
        The Collection Interface that allows interacting with the Coral.Tag items that the component contains.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.TagList#
      */
      'items': {
        set: function() {},
        get: function() {
          // just init on demand
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemTagName: itemTagName
            });
          }
          return this._items;
        }
      },

      // JSDoc inherited
      'name': {
        transform: Coral.transform.string,
        get: function() {
          return this._name;
        },
        set: function(value) {
          this._name = value;
          this.items.getAll().forEach(function(tag) {
            var input = tag._input;
            if (input) {
              input.setAttribute('name', value);
            }
          });
        }
      }
    },

    // JSDoc inherited
    _getLabellableElement: function() {
      return this;
    },

    /** @private */
    _attachInputToItem: function(item, preAttachInput) {
      if (!item._input) {
        var input = item.querySelector('input[handle=input]') || Coral.templates.TagList.input.call(item._elements);
        input.disabled = this.disabled;
        input.name = this.name;
        input.value = item.value;
        item.appendChild(input);

        // Pre-attach the input to ensure the correct values are sent on form submission
        if (preAttachInput) {
          item._preAttachedInput = input;
        }
        else {
          item._input = input;
        }
      }
      // Switch internal pre-attached input
      else if (item._preAttachedInput) {
        item._input = item._preAttachedInput;
        item._preAttachedInput = undefined;
      }
    },

    /** @private */
    _onItemAttached: function(attachedItem) {
      var items = this.items.getAll();

      // if the item already has an input, it means that it was already initialized
      if (attachedItem._input) {
        return;
      }

      // Prevents to add duplicates based on the tag value
      var duplicate = items.some(function(tag) {
        return (tag.value === attachedItem.value && tag !== attachedItem);
      });

      if (duplicate) {
        attachedItem.remove();
        return;
      }

      // create corresponding input field
      this._attachInputToItem(attachedItem);

      // adds the role to support accesibility
      attachedItem.setAttribute('role', 'option');
      attachedItem.setAttribute('aria-selected', false);
      attachedItem.setAttribute('tabindex', '-1');
      attachedItem.closable = !this.readOnly;

      // add tabindex to first item if none existing
      if (!this.querySelector(itemTagName + '[tabindex="0"]')) {
        var first = items[0];
        if (first) {
          first.setAttribute('tabindex', '0');
        }
      }

      // triggers the Coral.Collection event
      this.trigger('coral-collection:add', {
        item: attachedItem
      });
    },

    /** @private */
    _onItemDetached: function(detachedItem) {
      // Cleans the tag from TagList specific values
      detachedItem._input = undefined;
      detachedItem._preAttachedInput = undefined;
      detachedItem.removeAttribute('role');
      detachedItem.removeAttribute('aria-selected');
      detachedItem.removeAttribute('tabindex');

      if (this._itemToFocusAfterDelete) {
        this._itemToFocusAfterDelete.focus();
      }

      // triggers the Coral.Collection event
      this.trigger('coral-collection:remove', {
        item: detachedItem
      });
    },

    /** @private */
    _onItemFocus: function(event) {
      if (!this.disabled) {
        this.setAttribute('aria-live', 'polite');

        var tag = event.matchedTarget;
        tag.setAttribute('aria-selected', true);

        // add tabindex to first item and remove from previous focused item
        this.items.getAll().forEach(function(item) {
          if (item !== tag) {
            item.setAttribute('tabindex', '-1');
          }
        });
        tag.setAttribute('tabindex', '0');

        this._setItemToFocusOnDelete(tag);
      }
    },

    /** @private */
    _onItemBlur: function(event) {
      if (!this.disabled) {
        this.setAttribute('aria-live', 'off');

        var tag = event.matchedTarget;
        tag.setAttribute('aria-selected', false);

        this._setItemToFocusOnDelete(tag);
      }
    },

    /** @private */
    _onSiblingItemFocus: function(event, sibling) {
      if (!this.disabled) {
        event.preventDefault();

        var item = event.target[sibling];
        while (item) {
          if (item.tagName.toLowerCase() === itemTagName && !item.hidden) {
            item.focus();
            break;
          }
          else {
            item = item[sibling];
          }
        }
      }
    },

    /** @private */
    _onNextItemFocus: function(event) {
      this._onSiblingItemFocus(event, 'nextElementSibling');
    },

    /** @private */
    _onPreviousItemFocus: function(event) {
      this._onSiblingItemFocus(event, 'previousElementSibling');
    },

    /** @private */
    _onFirstItemFocus: function(event) {
      event.preventDefault();
      var length = this.items.length;
      if (length > 0) {
        this.items.getAll()[0].focus();
      }
    },

    /** @private */
    _onLastItemFocus: function(event) {
      event.preventDefault();
      var length = this.items.length;
      if (length > 0) {
        this.items.getAll()[length - 1].focus();
      }
    },

    /** @private */
    _onTagButtonClicked: function(event) {
      event.stopImmediatePropagation();

      // As the button was just clicked and the tag is not removed so far we need to wait a frame to trigger a "change"
      // event
      Coral.commons.nextFrame(function() {
        // A tag was removed due to user interaction
        this.trigger('change');
      }.bind(this));
    },

    /** @private */
    _onTagValueChanged: function(event) {
      event.stopImmediatePropagation();

      var tag = event.target;
      var input = tag._input;
      if (input) {
        input.value = tag.value;
      }
    },

    /** @private */
    _setItemToFocusOnDelete: function(tag) {
      var self = this;
      var itemToFocusAfterDelete = tag.nextElementSibling;

      // Next item will be focusable if the focused tag is removed
      while (itemToFocusAfterDelete) {
        if (itemToFocusAfterDelete.tagName.toLowerCase() === itemTagName && !itemToFocusAfterDelete.hidden) {
          this._itemToFocusAfterDelete = itemToFocusAfterDelete;
          return;
        }
        else {
          itemToFocusAfterDelete = itemToFocusAfterDelete.nextElementSibling;
        }
      }

      itemToFocusAfterDelete = tag.previousElementSibling;
      // Previous item will be focusable if the focused tag is removed
      while (itemToFocusAfterDelete) {
        if (itemToFocusAfterDelete.tagName.toLowerCase() === itemTagName && !itemToFocusAfterDelete.hidden) {
          this._itemToFocusAfterDelete = itemToFocusAfterDelete;
          break;
        }
        else {
          itemToFocusAfterDelete = itemToFocusAfterDelete.previousElementSibling;
        }
      }

      Coral.commons.nextFrame(function() {
        if (tag.parentElement !== null && !self.contains(document.activeElement)) {
          itemToFocusAfterDelete = undefined;
        }
      });
    },

    // JSDoc inherited
    reset: function() {
      this.values = this._initialValues;
    },

    /** @ignore */
    _initialize: function() {
      this._itemToFocusAfterDelete = null;

      // adds the role to support accessibility
      this.setAttribute('role', 'listbox');

      this.setAttribute('aria-live', 'off');
      this.setAttribute('aria-atomic', 'false');
      this.setAttribute('aria-relevant', 'additions');

      // Replacement for coral-tag attached callbacks and detached callbacks
      this._observer = new MutationObserver(function(mutations) {
        var tagList = this;

        mutations.forEach(function(mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];

            // Upgrading the element to guarantee custom elements properties and methods are available.
            // Upgrading is not needed for Chrome as it is already upgraded during parsing but doing it is harmless.
            // Non custom-elements will be ignored.
            window.CustomElements.upgrade(addedNode);

            if (addedNode instanceof Coral.Tag) {
              tagList._onItemAttached(addedNode);
            }
          }

          for (var k = 0; k < mutation.removedNodes.length; k++) {
            var removedNode = mutation.removedNodes[k];
            if (removedNode instanceof Coral.Tag) {
              tagList._onItemDetached(removedNode);
            }
          }
        });
      }.bind(this));

      this._observer.observe(this, {
        childList: true
      });

      // Make sure tags are ready before manipulating them
      Coral.commons.ready(this, function(tagList) {
        // Prepare all items
        tagList.items.getAll().forEach(function(item) {
          tagList._onItemAttached(item);
        });

        // Since tagList can have multiple values, we have to store them all to be able to reset them
        tagList._initialValues = tagList.values;
      });
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-autocomplete"] = {"en-US":{"No matching results&period;":"No matching results.","Show suggestion":"Show suggestion","Show {0} suggestions":"Show {0} suggestions","Show suggestions":"Show suggestions"},"de-DE":{"No matching results&period;":"Keine passenden Ergebnisse.","Show suggestion":"Vorschlag anzeigen","Show {0} suggestions":"{0} Vorschläge anzeigen","Show suggestions":"Vorschläge anzeigen"},"es-ES":{"No matching results&period;":"No hay resultados coincidentes.","Show suggestion":"Mostrar sugerencia","Show {0} suggestions":"Mostrar {0} sugerencias","Show suggestions":"Mostrar sugerencias"},"ko-KR":{"No matching results&period;":"일치하는 결과가 없습니다.","Show suggestion":"제안 사항 표시","Show {0} suggestions":"{0}제안 사항 표시","Show suggestions":"제안 사항 표시"},"fr-FR":{"No matching results&period;":"Aucun résultat correspondant.","Show suggestion":"Afficher la suggestion","Show {0} suggestions":"Afficher {0} suggestions","Show suggestions":"Afficher les suggestions"},"ja-JP":{"No matching results&period;":"一致する結果がありません。","Show suggestion":"入力候補を表示","Show {0} suggestions":"{0}入力候補を表示","Show suggestions":"入力候補を表示"},"zh-CN":{"No matching results&period;":"无匹配的结果。","Show suggestion":"显示建议","Show {0} suggestions":"显示 {0} 个建议","Show suggestions":"显示建议"},"zh-TW":{"No matching results&period;":"沒有相符的結果。","Show suggestion":"顯示建議","Show {0} suggestions":"顯示 {0} 個建議","Show suggestions":"顯示建議"},"pt-BR":{"No matching results&period;":"Nenhum resultado correspondente.","Show suggestion":"Mostrar sugestão","Show {0} suggestions":"Mostrar {0} sugestões","Show suggestions":"Mostrar sugestões"},"it-IT":{"No matching results&period;":"Nessun risultato corrispondente.","Show suggestion":"Mostra suggerimento","Show {0} suggestions":"Mostra {0} suggerimenti","Show suggestions":"Mostra suggerimenti"},"nl-NL":{"No matching results&period;":"Geen overeenkomende resultaten.","Show suggestion":"Voorstel tonen","Show {0} suggestions":"{0} voorstellen tonen","Show suggestions":"Voorstellen tonen"},"da-DK":{"No matching results&period;":"Ingen matchende resultater.","Show suggestion":"Vis forslag","Show {0} suggestions":"Vis  {0} forslag","Show suggestions":"Vis forslag"},"fi-FI":{"No matching results&period;":"Vastaavia tuloksia ei ole.","Show suggestion":"Näytä ehdotus","Show {0} suggestions":"Näytä {0} ehdotusta","Show suggestions":"Näytä ehdotukset"},"nb-NO":{"No matching results&period;":"Ingen tilsvarende resultater.","Show suggestion":"Vis forslag","Show {0} suggestions":"Vis {0} forslag","Show suggestions":"Vis forslag"},"sv-SE":{"No matching results&period;":"Inga matchande resultat.","Show suggestion":"Visa förslag","Show {0} suggestions":"Visa {0} förslag","Show suggestions":"Visa förslag"},"cs-CZ":{"No matching results&period;":"Neodpovídají žádné výsledky.","Show suggestion":"Zobrazit doporučení","Show {0} suggestions":"Zobrazit následující počet návrhů: {0}","Show suggestions":"Zobrazit doporučení"},"pl-PL":{"No matching results&period;":"Brak pasujących wyników.","Show suggestion":"Pokaż sugestię","Show {0} suggestions":"Wyświetl {0} sugestii","Show suggestions":"Pokaż sugestie"},"ru-RU":{"No matching results&period;":"Нет соответствующих результатов.","Show suggestion":"Показать предложение","Show {0} suggestions":"Показать предложения ({0})","Show suggestions":"Показать предложения"},"tr-TR":{"No matching results&period;":"Eşleşen sonuç yok.","Show suggestion":"Öneriyi göster","Show {0} suggestions":"{0} önerilerini göster","Show suggestions":"Önerileri göster"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Autocomplete"] = window["Coral"]["templates"]["Autocomplete"] || {};
window["Coral"]["templates"]["Autocomplete"]["base"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["field"] = document.createElement("input");
  el0.setAttribute("type", "hidden");
  el0.setAttribute("handle", "field");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["inputGroup"] = document.createElement("div");
  el2.className += " coral-InputGroup coral-InputGroup--block coral3-Autocomplete-inputGroup";
  el2.setAttribute("handle", "inputGroup");
  el2.setAttribute("role", "presentation");
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["label"] = document.createElement("div");
  el4.className += " coral-InputGroup-input coral-DecoratedTextfield";
  el4.setAttribute("handle", "label");
  el4.setAttribute("role", "presentation");
  var el5 = document.createTextNode("\n    ");
  el4.appendChild(el5);
  var el6 = this["icon"] = document.createElement("coral-icon");
  el6.setAttribute("size", "XS");
  el6.className += " coral-DecoratedTextfield-icon coral3-Autocomplete-icon";
  el6.setAttribute("handle", "icon");
  el4.appendChild(el6);
  var el7 = document.createTextNode("\n    ");
  el4.appendChild(el7);
  var el8 = this["input"] = document.createElement("input","coral-textfield");
  el8.className += " coral-DecoratedTextfield-input coral3-Autocomplete-input";
  el8.setAttribute("type", "text");
  el8.setAttribute("autocomplete", "off");
  el8.setAttribute("handle", "input");
  el8.setAttribute("role", "textbox");
  el8.setAttribute("is", "coral-textfield");
  el4.appendChild(el8);
  var el9 = document.createTextNode("\n  ");
  el4.appendChild(el9);
  el2.appendChild(el4);
  var el10 = document.createTextNode("\n  ");
  el2.appendChild(el10);
  var el11 = document.createElement("span");
  el11.className += " coral-InputGroup-button";
  el11.setAttribute("role", "presentation");
  var el12 = document.createTextNode("\n    ");
  el11.appendChild(el12);
  var el13 = this["trigger"] = document.createElement("button","coral-button");
  el13.setAttribute("tabindex", "-1");
  el13.setAttribute("is", "coral-button");
  el13.setAttribute("type", "button");
  el13.setAttribute("icon", "chevronDown");
  el13.setAttribute("iconsize", "XS");
  el13.setAttribute("handle", "trigger");
  el13.className += " coral3-Autocomplete-trigger";
  el13.setAttribute("aria-label", Coral["i18n"]["get"]('Show suggestions'));
  el13.setAttribute("title", Coral["i18n"]["get"]('Show suggestions'));
  el11.appendChild(el13);
  var el14 = document.createTextNode("\n  ");
  el11.appendChild(el14);
  el2.appendChild(el11);
  var el15 = document.createTextNode("\n");
  el2.appendChild(el15);
  frag.appendChild(el2);
  var el16 = document.createTextNode("\n");
  frag.appendChild(el16);
  var el17 = this["overlay"] = document.createElement("coral-overlay");
  el17.className += " coral3-Autocomplete-overlay";
  el17.setAttribute("returnfocus", "off");
  el17.setAttribute("alignmy", "left top");
  el17.setAttribute("alignat", "left bottom");
  el17.setAttribute("target", "_prev");
  el17.setAttribute("handle", "overlay");
  el17.setAttribute("role", "presentation");
  var el18 = document.createTextNode("\n  ");
  el17.appendChild(el18);
  var el19 = this["selectList"] = document.createElement("coral-buttonlist");
  el19.id = Coral["commons"]["getUID"]();
  el19.className += " coral3-Autocomplete-selectList";
  el19.setAttribute("handle", "selectList");
  el19.setAttribute("role", "listbox");
  el19.setAttribute("interaction", "off");
  el17.appendChild(el19);
  var el20 = document.createTextNode("\n");
  el17.appendChild(el20);
  frag.appendChild(el17);
  var el21 = document.createTextNode("\n");
  frag.appendChild(el21);
  var el22 = this["tagList"] = document.createElement("coral-taglist");
  el22.className += " coral3-Autocomplete-tagList";
  el22.setAttribute("handle", "tagList");
  frag.appendChild(el22);
  return frag;
});

window["Coral"]["templates"]["Autocomplete"]["loadIndicator"] = (function anonymous(data_0
/*``*/) {
    var data = data_0;
    var el0 = document.createElement("div");
    el0.className += " coral3-Autocomplete-loading";
    el0.setAttribute("role", "progressbar");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-wait");
    el2.setAttribute("centered", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    The distance, in pixels, from the bottom of the List at which we assume the user has scrolled
    to the bottom of the list.
    @type {Number}
    @ignore
   */
  var SCROLL_BOTTOM_THRESHOLD = 50;

  /**
    The number of milliseconds for which scroll events should be debounced.
    @type {Number}
    @ignore
  */
  var SCROLL_DEBOUNCE = 100;

  // @temp - Enable debug messages when writing tests
  var DEBUG = 0;

  var AutocompleteCollection = function(options) {
    Coral.Collection.call(this, arguments);
    this._host = options.host;
  };

  AutocompleteCollection.prototype = Object.create(Coral.Collection.prototype);

  AutocompleteCollection.prototype.add = function(item, insertBefore) {
    if (!(item instanceof HTMLElement)) {
      // Create an instance of an item from the object
      item = new Coral.Autocomplete.Item().set(item, true);
    }

    // 'insertBefore' with an undefined "before" argument fails on IE9.
    this._host.insertBefore(item, insertBefore || null);
    return item;
  };

  AutocompleteCollection.prototype.getAll = function() {
    return Array.prototype.slice.call(this._host.querySelectorAll('coral-autocomplete-item'));
  };

  /**
    Enumeration of match values.

    @enum {String}
    @memberof Coral.Autocomplete
  */
  var match = {
    /** Include only matches that start with the user provided value. */
    STARTSWITH: 'startswith',
    /** Include only matches that contain the user provided value. */
    CONTAINS: 'contains'
  };

  var matchValidator = Coral.validate.enumeration(match);

  Coral.register( /** @lends Coral.Autocomplete# */ {
    /**
      @class Coral.Autocomplete
      @extends Coral.Component
      @extends Coral.mixin.formField
      @classdesc An autocomplete component.
      @htmltag coral-autocomplete
    */
    name: 'Autocomplete',
    tagName: 'coral-autocomplete',
    className: 'coral3-Autocomplete',

    mixins: [
      Coral.mixin.formField
    ],

    properties: {
      /**
        The item collection.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Autocomplete#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new AutocompleteCollection({
              itemTagName: 'coral-autocomplete-item',
              itemSelector: 'coral-autocomplete-item',
              host: this
            });
          }

          return this._items;
        },
        set: function() {}
      },

      // JSDoc inherited
      'name': {
        set: function(name) {
          this._name = name;

          // Set/remove the name from the appropriate fields
          this._setName();
        },
        get: function() {
          return this._name;
        }
      },

      /**
        The current value, as submitted during form submission.
        When {@link Coral.Autocomplete#multiple} is <code>true</code>, the first selected value will be returned.

        @type {String}
        @default ""
        @htmlattribute value
        @memberof Coral.Autocomplete#
      */
      'value': {
        override: true,
        transform: function(value) {
          // Convert to an string if empty
          if (value === undefined || value === null) {
            value = '';
          }

          return value;
        },
        set: function(value) {
          // Store in values array
          // Let validation run as part of values' setter
          this.values = [value];
        },
        get: function() {
          // Get the first value (or empty string)
          var values = this.values;
          return values && values.length > 0 ? values[0] : '';
        }
      },

      /**
        The current values, as submitted during form submission.
        When {@link Coral.Autocomplete#multiple} is <code>false</code>, this will be an array of length 1.

        @type {Array.<String>}
        @memberof Coral.Autocomplete#
      */
      'values': {
        // No default, otherwise setter is invoked
        validate: [
          Coral.validate.valueMustChange,
          function(values) {
            return Array.isArray(values);
          }
        ],
        set: function(values) {
          if (values === undefined || values === null) {
            values = [];
          }

          var i;
          var value;
          var selectedValues = [];
          if (this.forceSelection) { // Valid values only
            // Add each valid value
            for (i = 0; i < values.length; i++) {
              value = values[i];
              if (this._optionsMap[value] !== undefined) {
                selectedValues.push(value);
              }
            }
          }
          else { // Any value goes
            for (i = 0; i < values.length; i++) {
              value = values[i];
              selectedValues.push(value);
            }
          }

          if (this.multiple) {
            // Remove existing tags, DOM selection, etc
            // This is a full override
            this._clearValues();

            // Add each tag
            for (i = 0; i < selectedValues.length; i++) {
              value = selectedValues[i];

              // Ensure the item is selected if it's present in the DOM
              // This keeps the DOM in sync with the JS API and prevents bugs like CUI-5681
              this._selectItem(value);

              // Add the value to the tag list
              this._addValue(value, null, true);
            }
          }
          else {
            // Set value
            this._values = selectedValues.length > 0 ? [selectedValues[0]] : [];
            this._reflectCurrentValue();
          }
        },
        get: function() {
          return this._values;
        }
      },

      /**
        Indicates if the autocomplete is a single or multiple mode. In multiple mode, the user can select multiple
        values.

        @type {Boolean}
        @default false
        @htmlattribute multiple
        @htmlattributereflected
        @memberof Coral.Autocomplete#
      */
      'multiple': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(multiple) {
          this._multiple = multiple;

          this._setName();

          if (multiple) {
            this._elements.tagList.hidden = false;
          }
          else {
            this._elements.tagList.hidden = true;
            this._elements.tagList.items.clear();
          }
        },
        get: function() {
          return this._multiple;
        },
        sync: function() {},
        alsoSync: 'labelledBy'
      },

      /**
        Amount of time, in milliseconds, to wait after typing a character before the suggestion is shown.

        @type {Number}
        @default 200
        @htmlattribute delay
        @htmlattributereflected
        @memberof Coral.Autocomplete#
      */
      'delay': {
        default: 200,
        reflectAttribute: true,
        transform: Coral.transform.number,
        validate: function(newVal, oldVal) {
          return typeof newVal === 'number' && newVal >= 0;
        }
      },

      /**
        Set to <code>true</code> to restrict the selected value to one of the given options from the suggestions.
        When set to <code>false</code>, users can enter anything.

        <strong>NOTE:</strong> This API is under review and may be removed or changed in a subsequent release.
        @ignore

        @type {Boolean}
        @default false
        @htmlattribute forceselection
        @htmlattributereflected
        @memberof Coral.Autocomplete#
      */
      'forceSelection': {
        default: false,
        attribute: 'forceselection',
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(forceSelection) {
          if (this.forceSelection && !forceSelection) {
            // @todo invalidate if incorrect

            if (DEBUG) {
              console.warn('Coral.Autocomplete: Should check for invalid state');
            }
          }
          this._forceSelection = forceSelection;
        },
        get: function() {
          return this._forceSelection;
        }
      },

      /**
        A hint to the user of what can be entered.

        @type {String}
        @default ""
        @htmlattribute placeholder
        @htmlattributereflected
        @memberof Coral.Autocomplete#
      */
      'placeholder': {
        default: '',
        reflectAttribute: true,
        set: function(placeholder) {
          // Set attribute as the placeholder property is not available in IE9
          this._elements.input.setAttribute('placeholder', placeholder);
        },
        get: function() {
          return this._elements.input.getAttribute('placeholder');
        }
      },

      /**
        Max length for the Input field

        @type {Long}
        @htmlattribute maxlength
        @htmlattributereflected
        @memberof Coral.Autocomplete#
      */
      'maxLength' : {
        attribute: 'maxlength',
        reflectAttribute: true,
        set: function(value) {
          this._elements.input.maxLength = value;
        },
        get: function() {
          return this._elements.input.maxLength;
        }
      },


      /**
        The icon of the autocomplete.

        @type {String}
        @default ""
        @htmlattribute icon
        @htmlattributereflected
        @memberof Coral.Autocomplete#
      */
      'icon': {
        default: '',
        validate: [], // Let Icon handle this
        reflectAttribute: true,
        set: function(icon) {
          this._elements.icon.icon = icon;

          // Hide if no icon provided
          this._elements.icon.hidden = !this._elements.icon.icon;
        },
        get: function() {
          return this._elements.icon.icon;
        }
      },

      /**
        The match mode.

        @type {String}
        @default Coral.Autocomplete.match.CONTAINS
        @htmlattribute match
        @memberof Coral.Autocomplete#
      */
      'match': {
        default: match.CONTAINS,
        validate: function(value) {
          // Strings must match the enumeration
          if (typeof value === 'string') {
            return matchValidator(value);
          }

          return typeof value === 'function';
        },
        set: function(value) {
          if (value === match.STARTSWITH) {
            this._matchFunction = this._optionStartsWithValue;
          }
          else if (value === match.CONTAINS) {
            this._matchFunction = this._optionContainsValue;
          }
          else if (typeof value === 'function') {
            this._matchFunction = value;
          }

          // Store raw value for getter
          this._match = value;
        }
      },

      // JSDoc inherited
      'invalid': {
        sync: function() {
          // Add to outer component
          this.classList.toggle('is-invalid', this.invalid);
          this._elements.input.classList.toggle('is-invalid', this.invalid);
        }
      },

      // JSDoc inherited
      'disabled': {
        set: function(value) {
          this._disabled = value;
          
          this._elements.input.disabled = this.disabled;
          this._elements.trigger.disabled = this.disabled || this.readOnly;
          this._elements.tagList.disabled = this.disabled || this.readOnly;
        }
      },

      // JSDoc inherited
      'readOnly': {
        set: function(value) {
          this._readOnly = value;
          
          this._elements.input.readOnly = this.readOnly;
          this._elements.trigger.disabled = this.readOnly || this.disabled;
        }
      },

      // JSDoc inherited
      'required': {
        set: function(value) {
          this._required = value;
          
          this._elements.input.required = this.required;
        }
      },

      // JSDoc inherited
      'labelledBy': {
        sync: function() {
          if (this.labelledBy && this.multiple) {
            this._elements.tagList.setAttribute('aria-labelledby', this.labelledBy);
          }
          else {
            this._elements.tagList.removeAttribute('aria-labelledby');
          }
        }
      },

      /**
        Indicates that the component is currently loading remote data. This will set the wait indicator inside the list.

        @type {Boolean}
        @default false
        @htmlattribute loading
        @memberof Coral.Autocomplete#
      */
      'loading': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          this._loading = value;

          var loadIndicator = this._elements.loadIndicator;

          if (this.loading) {
            // if it does not exist we create it
            if (!loadIndicator) {
              loadIndicator = this._elements.loadIndicator = Coral.templates.Autocomplete.loadIndicator().firstChild;
            }

            var overlay = this._elements.overlay;

            // we decide first if we need to scroll to the bottom since adding the load will change the dimentions
            var scrollToBottom = overlay.scrollTop >= overlay.scrollHeight - overlay.clientHeight;

            // inserts the item at the end
            this._elements.overlay.appendChild(loadIndicator);

            // we make the load indicator visible
            if (scrollToBottom) {
              overlay.scrollTop = overlay.scrollHeight;
            }
          }
          else {
            if (loadIndicator && loadIndicator.parentNode) {
              this._elements.overlay.removeChild(loadIndicator);
            }
          }
        }
      }
    },

    events: {

      // ARIA Autocomplete role keyboard interaction
      // http://www.w3.org/TR/wai-aria-practices/#autocomplete
      'key:up [handle="input"]': '_handleInputUpKeypress',
      'key:alt+up [handle="input"]': '_handleInputUpKeypress',
      'key:down [handle="input"]': '_handleInputDownKeypress',
      'key:alt+down [handle="input"]': '_handleInputDownKeypress',
      'key:tab [handle="input"]': '_handleInputTabKeypress',
      'key:shift+tab [handle="input"]': '_handleListFocusShift',
      'capture:change [handle="input"]': '_handleInput',
      'input [handle="input"]': '_handleInputEvent',

      // Manually listen to keydown event due to CUI-3973
      'keydown': '_handleInputKeypressEnter',

      // Interaction
      'click [handle="trigger"]': '_handleTriggerClick',
      'mousedown [handle="trigger"]': '_handleTriggerMousedown',
      'key:escape': '_hideSuggestionsAndFocus',
      'key:shift+tab [is="coral-buttonlist-item"]': '_handleListFocusShift',

      // Focus
      'capture:blur': '_handleFocusOut',
      'capture:focus [handle="inputGroup"]': '_handleInputGroupFocusIn',
      'capture:blur [handle="inputGroup"]': '_handleInputGroupFocusOut',

      // Taglist
      'coral-collection:remove [handle="tagList"]': '_handleTagRemoved',
      'change [handle="tagList"]': '_preventTagListChangeEvent',

      // SelectList
      'key:enter button[is="coral-buttonlist-item"]': '_handleSelect', // Needed for ButtonList
      'click button[is="coral-buttonlist-item"]': '_handleSelect',
      'capture:scroll [handle="overlay"]': '_onScroll',
      'capture:mousewheel [handle="overlay"]' : '_onMouseWheel',
      'mousedown button[is="coral-buttonlist-item"]': '_handleSelect',
      'capture:mouseenter [is="coral-buttonlist-item"]': '_handleListItemFocus',

      // Overlay
      'coral-overlay:positioned': '_handleOverlayPositioned',

      // Items
      'coralui-autocomplete-item:_valuechanged': '_handleItemValueChange',
      'coralui-autocomplete-item:_selectedchanged': '_handleItemSelectedChange',
      'coralui-autocomplete-item:_contentchanged': '_handleItemContentChange'
    },

    /** @private */
    _render: function() {
      // Create a temporary fragment
      var frag = document.createDocumentFragment();

      // Render the template
      frag.appendChild(Coral.templates.Autocomplete.base.call(this._elements));

      // Clean up
      while (this.firstChild) {
        var child = this.firstChild;
        // Only works if all root template elements have a handle attribute
        if (child.nodeType === Node.TEXT_NODE || (child.hasAttribute && !child.hasAttribute('handle'))) {
          // Add non-template elements to the content
          frag.appendChild(child);
        }
        else {
          // Remove anything else
          this.removeChild(child);
        }
      }

      // Append the fragment to the component
      this.appendChild(frag);

      // Container role per ARIA Autocomplete
      this.setAttribute('role', 'presentation');

      // Input attributes per ARIA Autocomplete
      this._elements.input.setAttribute('role', 'combobox');
      this._elements.input.setAttribute('aria-autocomplete', 'list');
      this._elements.input.setAttribute('aria-haspopup', 'true');
      this._elements.input.setAttribute('aria-controls', this._elements.selectList.id);

      // Trigger button attributes per ARIA Autocomplete
      this._elements.trigger.setAttribute('aria-haspopup', 'true');
      this._elements.trigger.setAttribute('aria-controls', this._elements.selectList.id);

      // A map of values to tags
      this._tagMap = {};

      // A list of selected values
      this._values = [];

      // A list of options objects
      this._options = [];

      // A map of option values to their content
      this._optionsMap = {};

      // Bind the debounced scroll method
      this._handleScrollBottom = this._handleScrollBottom.bind(this);

      // Listen for mutations
      this._observer = new MutationObserver(this._handleMutation.bind(this));
      this._startObserving();

      // Set the state from the DOM when initialized
      this._setStateFromDOM();
    },

    /** @private */
    _initialize: function() {
      // save initial selection (used for reset)
      this._initialSelectedValues = this.values.slice(0);
    },

    // JSDocs inherited from coralui-mixin-formfield
    reset: function() {
      // reset the values to the initial values
      this.values = this._initialSelectedValues;
    },

    /** @ignore */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      // Set the state from the DOM when attached
      // Selected and value change events won't bubble when not in the DOM
      // As such, we'll need to make sure we're in sync when we get put in the DOM
      this._setStateFromDOM();
    },

    /** @private */
    _startObserving: function() {
      this._observer.observe(this, {
        // Only watch the childList
        // Items will tell us if selected/value/content changes
        childList: true
      });
    },

    /**
      Stop watching for mutations. This should be done before manually updating observed properties.

      @protected
    */
    _stopObserving: function() {
      this._observer.disconnect();
    },

    /**
      Set the name accordingly for multiple/single mode so the form submits contain only the right fields.

      @protected
    */
    _setName: function() {
      if (this.multiple) {
        this._elements.tagList.name = this.name;
        this._elements.field.name = '';
      }
      else {
        this._elements.field.name = this.name;
        this._elements.tagList.name = '';
      }
    },

    // Override to do nothing
    _onInputChange: function(event) {
      // stops the current event
      event.stopPropagation();

      if (!this.multiple) {

        var inputText = this._elements.input.value.toLowerCase();

        if (this.forceSelection || inputText === '') {
          // We need a way to deselect item in single selection mode
          // 1) by using an empty string if this.forceSelection === false
          // 2) by using an invalid string if this.forceSelection === true
          var items = this.items.getAll();
          for (var i = 0; i < items.length; i++) {
            if (items[i].value.toLowerCase() !== inputText) {
              items[i].selected = false;
            }
          }
        }
      }
    },

    /**
      Handle mutations to children and childList. This is used to keep the options in sync with DOM changes.

      @private
    */
    _handleMutation: function(mutations) {
      for (var i = 0; i < mutations.length; i++) {
        var mutation = mutations[i];
        var target = mutation.target;

        if (mutation.type === 'childList' && target === this) {
          this._setStateFromDOM();
          return;
        }
      }
    },

    /**
      Update the option set and selected options from the DOM.

      @private
    */
    _setStateFromDOM: function() {
      this._createOptionsFromDOM();
      this._setSelectedFromDOM();
    },

    /**
      Create the set of options from nodes in the DOM.

      @private
    */
    _createOptionsFromDOM: function() {
      // Reset options array and value to content map
      this._options.length = 0;
      this._optionsMap = {};

      var items = this.querySelectorAll('coral-autocomplete-item');
      for (var i = 0; i < items.length; i++) {
        var itemEl = items[i];
        // Don't use properties as children may not be initialized yet
        var itemObj = {
          value: itemEl.getAttribute('value'),
          icon: itemEl.getAttribute('icon'),
          disabled: itemEl.hasAttribute('disabled'),
          content: itemEl.innerHTML
        };
        this._options.push(itemObj);
        this._optionsMap[itemObj.value] = itemObj;
      }

      // @todo update value in hidden field if changed value = old value?
    },

    /** @private */
    _setInputValues: function(value, content) {
      this._elements.field.value = value;

      // Set text into input if in "multiple selection mode" or in "single selection mode and content is not empty"
      // otherwise keep the current text for us (should be marked red)
      if (this.multiple || content !== '') {
        this._elements.input.value = content.trim();
      }
    },

    /** @private */
    _reflectCurrentValue: function() {
      // Use empty string if no values
      var value = this._values.length > 0 ? this._values[0] : '';

      // Reflect the value in the field for form submit
      this._elements.field.value = value;

      var content = '';
      if (value !== '') {
        // Find the object with the corresponding content
        var itemObj = this._optionsMap[value];

        if (itemObj) {
          // Reflect the content in the input
          content = itemObj.content;
        }
        else {
          // Just use the provided value
          content = value;
        }
      }

      this._setInputValues(value, content);
    },

    /**
      Update the option set and selected options from the DOM
      @ignore
    */
    _setSelectedFromDOM: function() {
      var selectedItems = this.querySelectorAll('coral-autocomplete-item[selected]');
      if (selectedItems.length) {
        // Use this.hasAttribute('multiple') instead of this.multiple here, as this method is called from _render and element might not be ready
        if (this.hasAttribute('multiple')) {
          // Remove current tags
          this._resetValues();

          // Add new ones
          for (var i = 0; i < selectedItems.length; i++) {
            var value = selectedItems[i].getAttribute('value');
            var content = selectedItems[i].innerHTML;
            this._addValue(value, content, true);
          }
        }
        else {
          // Select last
          var last = selectedItems[selectedItems.length - 1];

          // Deselect others
          this._deselectExcept(last, selectedItems);

          // Set value from the attribute
          // We don't want to use the property as the sub-component may not have been upgraded yet
          this.value = last.getAttribute('value');
        }
      }
      else {
        // Use this.hasAttribute('multiple') instead of this.multiple here, as this method is called from _render and element might not be ready
        if (this.hasAttribute('multiple')) {
          this._resetValues();
        }
        else {
          this.value = '';
        }
      }
    },

    /**
      De-select every item except the provided item.

      @param {HTMLElement} exceptItem
        The item not to select
      @param {Array.<HTMLElement>} [items]
        The set of items to consider when deselecting. If not provided, the current set of selected items is used.

      @private
    */
    _deselectExcept: function(exceptItem, items) {
      var selectedItems = items || this.querySelectorAll('coral-autocomplete-item[selected]');

      // Deselect others
      this._stopObserving();
      for (var i = 0; i < selectedItems.length; i++) {
        if (selectedItems[i] !== exceptItem) {
          selectedItems[i].removeAttribute('selected');
        }
      }
      this._startObserving();
    },

    /**
      Add a tag to the taglist.

      @private
    */
    _addValue: function(value, content, asHTML) {
      if (!content) {
        // Find the content
        var itemObj = this._optionsMap[value];
        if (itemObj) {
          content = itemObj.content;
        }
        else {
          // Just use the value
          content = value;

          if (DEBUG) {
            console.warn('Coral.Autocomplete: Did not have content for value %s', value);
          }
        }
      }

      // Add to selected values
      var index = this._values.indexOf(value);
      if (index === -1) {
        this._values.push(value);
      }
      else {
        if (DEBUG) {
          console.warn('Coral.Autocomplete: Tried to add value that was already present');
        }
      }

      var labelContent = {};
      if (asHTML) {
        labelContent.innerHTML = content;
      }
      else {
        labelContent.textContent = content;
      }

      // Create a new tag
      var tag = new Coral.Tag().set({
        label: labelContent,
        value: value
      });

      // Add to map
      this._tagMap[value] = tag;

      // Add to taglist
      this._elements.tagList.items.add(tag);

      // make sure to remove text from input box (to easily choose next item)
      this._setInputValues('', '');
    },

    /**
      Remove a tag from the taglist.

      @private
    */
    _removeValue: function(value) {
      // Remove from selected values
      var index = this._values.indexOf(value);
      if (index === -1) {
        if (DEBUG) {
          console.warn('Coral.Autocomplete: Tried to remove tag that is not in values');
        }
        // Get out if we don't have the value
        return;
      }
      else {
        this._values.splice(index, 1);
      }

      // Select autocomplete item
      var item = this.querySelector('coral-autocomplete-item[value=' + JSON.stringify(value) + ']');

      if (item) {
        if (item.hasAttribute('selected')) {
          this._stopObserving();
          item.removeAttribute('selected');
          this._startObserving();
        }
      }
      else {
        if (DEBUG) {
          console.warn('Coral.Autocomplete: Tried to remove value without corresponding item');
        }
      }

      // Look up the tag by value
      var tag = this._tagMap[value];

      if (tag) {
        // Remove from map
        this._tagMap[value] = null;

        // Remove from taglist
        this._elements.tagList.items.remove(tag);
      }

      if (index !== -1) {
        // Emit the change event when a value is removed but only after a user interaction
        this.trigger('change');
      }
    },

    /**
      Remove all tags from the taglist.

      @private
    */
    _clearValues: function() {
      this._resetValues();

      // Deselect items
      this._stopObserving();
      var items = this.querySelectorAll('coral-autocomplete-item[selected]');
      for (var i = 0; i < items.length; i++) {
        items[i].removeAttribute('selected');
      }
      this._startObserving();
    },

    /**
      Reset values without affecting the DOM.

      @private
    */
    _resetValues: function() {
      // Reset values
      this._values = [];

      // Drop references to tags
      this._tagMap = {};

      // Clear taglist
      this._elements.tagList.items.clear();
    },

    /** @private */
    _focusNextItem: function() {
      // Display focus on next item in the selectList
      var selectList = this._elements.selectList;
      var currentItem = selectList.querySelector('.is-focused');
      var input = this._elements.input;
      var items = selectList._getSelectableItems();
      var index;
      var item;
      var self = this;
      if (currentItem) {
        index = items.indexOf(currentItem);
        if (index < items.length - 1) {
          item = items[index + 1];
        }
      }
      else if (items && items.length > 0) {
        item = items[0];
      }
      Coral.commons.nextFrame(function() {
        if (item) {
          if (currentItem) {
            currentItem.classList.remove('is-focused');
          }
          self._scrollItemIntoView(item);
          item.classList.add('is-focused');
          input.setAttribute('aria-activedescendant', item.id);
        }
        if (!selectList.querySelector('.is-focused')) {
          input.removeAttribute('aria-activedescendant');
        }
      });
    },

    /** @private */
    _focusPreviousItem: function() {
      // Display focus on previous item in the selectList
      var selectList = this._elements.selectList;
      var currentItem = selectList.querySelector('.is-focused');
      var input = this._elements.input;
      var items = selectList._getSelectableItems();
      var index;
      var item;
      var self = this;
      if (currentItem) {
        index = items.indexOf(currentItem);
        if (index > 0) {
          item = items[index - 1];
        }
        currentItem.classList.remove('is-focused');
      }
      else if (items && items.length > 0) {
        item = items[items.length - 1];
      }
      Coral.commons.nextFrame(function() {
        if (item) {
          self._scrollItemIntoView(item);
          item.classList.add('is-focused');
          input.setAttribute('aria-activedescendant', item.id);
        }
        if (!selectList.querySelector('.is-focused')) {
          input.removeAttribute('aria-activedescendant');
        }
      });
    },

    /** @private */
    _showSuggestions: function() {
      // Get value from the input
      var inputValue = this._elements.input.value;

      // Since we're showing fresh suggestions, clear the existing suggestions
      this.clearSuggestions();

      // Trigger an event
      var event = this.trigger('coral-autocomplete:showsuggestions', {
        // Pass user input
        value: inputValue,
        start: 0 // Started at zero here, always
      });

      // Flag to indicate that the private method is called before public showSuggestions method
      this._showSuggestionsCalled = true;

      if (event.defaultPrevented) {
        // Set loading mode
        this.loading = true;

        // Show the menu
        this.showSuggestions();
      }
      else {
        // Show suggestions that match in the DOM
        this.addSuggestions(this._getMatches(inputValue.toLowerCase().trim(), this._optionContainsValue));
        this.showSuggestions();
      }
    },

    /** @private */
    _onScroll: function() {
      clearTimeout(this._scrollTimeout);
      this._scrollTimeout = setTimeout(this._handleScrollBottom, SCROLL_DEBOUNCE);
    },

    /** @private */
    _onMouseWheel: function(event) {
      var overlay = this._elements.overlay;
      // If scrolling with mouse wheel and if it has hit the top or bottom boundary
      // `SCROLL_BOTTOM_THRESHOLD` is ignored when hitting scroll bottom to allow debounced loading
      if ((event.deltaY < 0 && overlay.scrollTop === 0) || (event.deltaY > 0 && overlay.scrollTop >= overlay.scrollHeight - overlay.clientHeight)) {
        event.preventDefault();
      }
    },

    /** @private */
    _handleScrollBottom: function() {
      var overlay = this._elements.overlay;
      var selectList = this._elements.selectList;

      if (overlay.scrollTop >= overlay.scrollHeight - overlay.clientHeight - SCROLL_BOTTOM_THRESHOLD) {
        var inputValue = this._elements.input.value;

        // Do not clear the suggestions here, instead we'll expect them to append

        // Trigger an event
        var event = this.trigger('coral-autocomplete:showsuggestions', {
          // Pass user input
          value: inputValue,
          start: selectList.items.length
        });

        if (event.defaultPrevented) {
          // Set loading mode
          this.loading = true;
        }
      }
    },

    /** @private */
    _handleFocusOut: function(event) {
      var self = this;
      var selectList = this._elements.selectList;
      var target = event.target;
      var inputBlur = target === this._elements.input;

      if (this._blurTimeout) {
        clearTimeout(this._blurTimeout);
      }

      // This is to hack around the fact that you cannot determine which element gets focus in a blur event
      // Firefox doesn't support focusout/focusin, so we're left doing awful things
      this._blurTimeout = setTimeout(function() {
        var relatedTarget = document.activeElement;
        var focusOutside = !self.contains(relatedTarget);

        // If focus has moved out of the autocomplete, it's an input event
        if (inputBlur && focusOutside && !self.multiple) {
          self._handleInput(event);
        }
        else if (
          // Nothing was focused
          !relatedTarget ||
          (
            (inputBlur || relatedTarget !== document.body) &&
            // Focus is now outside of the autocomplete component
            focusOutside ||
            // Focus has shifted from the selectList to another element inside of the autocomplete component
            selectList.contains(target) && !selectList.contains(relatedTarget)
          )
        ) {
          self.hideSuggestions();
        }
      }, 0);
    },

    /** @private */
    _handleInputGroupFocusIn: function() {
      this.classList.add('is-focused');
    },

    /** @private */
    _handleInputGroupFocusOut: function(event) {
      this.classList.remove('is-focused');
    },

    /** @private */
    _handleOverlayPositioned: function(event) {
      // We'll remove these classes when closed
      if (event.detail.vertical === 'top') {
        this.classList.remove('is-openAbove');
        this.classList.add('is-openBelow');
      }
      else {
        this.classList.remove('is-openBelow');
        this.classList.add('is-openAbove');
      }
    },

    /** @private */
    _handleListFocusShift: function(event) {
      if (this._elements.overlay.open) {
        // Stop focus shift
        event.preventDefault();
        event.stopImmediatePropagation();

        this._hideSuggestionsAndFocus();
      }
    },

    /** @private */
    _hideSuggestionsAndFocus: function(event) {
      // Hide the menu and focus on the input
      this.hideSuggestions();
      this._elements.input.focus();
    },

    /** @private */
    _handleTriggerClick: function() {
      if (this._elements.overlay.open) {
        this._hideSuggestionsAndFocus();
      }
      else {
        // Focus on the input so down arrow works as expected
        // Per @mijordan
        this._showSuggestions();
        this._elements.input.focus();
      }
    },

    /** @private */
    _handleTriggerMousedown: function() {
      this._elements.trigger.focus();
    },

    /** @private */
    _handleListItemFocus: function(event) {
      var item = event.matchedTarget;
      var selectList = this._elements.selectList;
      var currentItem = selectList.querySelector('.is-focused');
      var input = this._elements.input;
      if (currentItem) {
        currentItem.classList.remove('is-focused');
        input.removeAttribute('aria-activedescendant');
      }
      if (!item.disabled) {
        this._scrollItemIntoView(item);
        item.classList.add('is-focused');
        input.setAttribute('aria-activedescendant', item.id);
      }
    },

    /** @private */
    _scrollItemIntoView: function(item) {
      var itemRect = item.getBoundingClientRect();
      var overlayRect = this._elements.overlay.getBoundingClientRect();
      if (itemRect.top < overlayRect.top) {
        item.scrollIntoView();
      }
      else if (itemRect.bottom > overlayRect.bottom + 1) {
        item.scrollIntoView(false);
      }
    },

    /** @private */
    _getMatches: function(value, optionMatchesValue) {
      optionMatchesValue = optionMatchesValue || this._matchFunction;

      var matches = [];

      for (var i = 0; i < this._options.length; i++) {
        if (optionMatchesValue(this._options[i], value)) {
          matches.push(this._options[i]);
        }
      }

      if (!matches.length) {
        // If there are no matches in _options,
        // Check for matches in list, which could have been added after mounting the element
        var buttons = this._elements.selectList.items.getAll();
        for (i = 0 ; i < buttons.length ; i++) {
          var option = {
            value : buttons[i].value,
            content : buttons[i].textContent.trim()
          };
          if (optionMatchesValue(option, value)) {
            matches.push(option);
          }
        }
      }

      return matches;
    },

    /** @private */
    _handleInputKeypressEnter: function(event) {
      if (event.which === 13) { // Sigh, CUI-3973 Hitting enter quickly after typing causes form to submit
        this._handleInput(event);
      }
    },

    /** @private */
    _handleInputEvent: function(e) {
      // Any input makes this valid again
      this.invalid = false;

      if (this.delay) {
        // Wait until the use has stopped typing for delay milliseconds before getting suggestions
        clearTimeout(this.timeout);
        this.timeout = setTimeout(this._showSuggestions.bind(this), this.delay);
      } else {
        // Immediately get suggestions
        this._showSuggestions();
      }
    },

    /** @private */
    _handleInput: function(event) {
      var focusedItemValue;

      // Stop the event
      event.preventDefault();

      // If a selectList item has focus, set the input value to the value of the selected item.
      if (this._elements.overlay.open && this._elements.input.getAttribute('aria-activedescendant')) {
        var focusedItem = this._elements.selectList.querySelector('.is-focused');
        if (focusedItem) {
          // Use the text content value of the item for comparison
          focusedItemValue = focusedItem.textContent.trim();
        }
      }

      var value = focusedItemValue || this._elements.input.value;

      var isChange = false;

      // Get all exact matches
      var exactMatches = this._getMatches(value, this._optionEqualsValue); // Find exact matches

      if (exactMatches.length) {
        // Find perfect case sensitive match else defaults to first one
        var exactMatch = exactMatches.filter(function(option) {
          return option.content === value;
        })[0] || exactMatches[0];

        isChange = this.value !== exactMatch.value;

        // Select the matched item
        this._selectItem(exactMatch.value, exactMatch.content, false);

        if (this.multiple) {
          if (value.trim()) {
            // Add tag for non-empty values
            this._addValue(exactMatch.value, exactMatch.content, false);
          }
        }
        else {
          // Set value
          this.value = exactMatch.value;
        }

        // value can't be invalid as an exact match is selected
        if (this.forceSelection) {
          this.invalid = false;
        }

        // Hide the suggestions so the result can be seen
        this.hideSuggestions();

        // Emit the change event when a selection is made from an exact match
        if (isChange === true) {
          this.trigger('change');
        }
      }
      else {
        if (this.forceSelection) {
          // Invalid
          if (this.multiple) {
            this.invalid = value !== '' || ((this.values.length === 1 && this.values[0] === '') || this.values.length === 0);
          }
          else {
            this.invalid = true;
          }
        // Leave suggestions open if nothing matches
        }
        else {
          // DO NOT select the corresponding item, as this would add an item
          // This would result in adding items that match what the user typed, resulting in selections
          // this._selectItem(value);

          isChange = this.value !== value;

          if (this.multiple) {
            if (value.trim()) {
              // Add tag for non-empty values
              this._addValue(value, null, false);
            }
          }
          else {
            // Set value
            this.value = value;
          }

          // Hide the suggestions so the result can be seen
          this.hideSuggestions();

          // Emit the change event when arbitrary data is entered
          if (isChange === true) {
            this.trigger('change');
          }
        }
      }

      this._updateButtonAccessibilityLabel();
    },

    /**
      This ensures the collection API is up to date with selected items, even if they come from suggestions.

      @private
    */
    _selectItem: function(value, content, asHTML) {
      // Don't get caught up with internal changes
      this._stopObserving();

      // Select autocomplete item if it's there
      var item = this.querySelector('coral-autocomplete-item[value=' + JSON.stringify(value) + ']');
      if (item) {
        // Select the existing item
        item.setAttribute('selected', '');
      }
      else {
        var labelContent = {};
        content = typeof content === 'undefined' ? value : content;
        if (asHTML) {
          labelContent.innerHTML = content;
        }
        else {
          labelContent.textContent = content;
        }

        // Add a new, selected item
        this.items.add(new Coral.Autocomplete.Item().set({
          value: value,
          content: labelContent,
          selected: true
        }));
      }

      // Resume watching for changes
      this._startObserving();
    },

    /** @private */
    _handleInputUpKeypress: function(event) {
      // Stop any consequences of pressing the key
      event.preventDefault();

      if (this._elements.overlay.open) {
        if (event.altKey) {
          this.hideSuggestions();
        }
        else {
          this._focusPreviousItem();
        }
      }
      else {
        // Show the menu and do not focus on the first item
        // Implements behavior of http://www.w3.org/TR/wai-aria-practices/#autocomplete
        this._showSuggestions();
      }
    },

    /** @private */
    _handleInputDownKeypress: function(event) {
      // Stop any consequences of pressing the key
      event.preventDefault();

      if (this._elements.overlay.open) {
        this._focusNextItem();
      }
      else {
        // Show the menu and do not focus on the first item
        // Implements behavior of http://www.w3.org/TR/wai-aria-practices/#autocomplete
        this._showSuggestions();
      }
    },

    /** @private */
    _handleInputTabKeypress: function(event) {
      // if the select list is open and a list item has focus, prevent default to trap focus.
      if (this._elements.overlay.open && this._elements.input.getAttribute('aria-activedescendant')) {
        event.preventDefault();
      }
    },

    /**
      Handle selections in the selectList.

      @ignore
    */
    _handleSelect: function(event) {
      var selectListItem = event.matchedTarget;

      if (!selectListItem || selectListItem.disabled) {
        // @todo it doesn't seem like this should ever happen, but it does
        return;
      }

      // Select the corresponding item, or add one if it doesn't exist
      this._selectItem(selectListItem.value, selectListItem.content.innerHTML, true);

      if (!this.multiple) {
        this.value = selectListItem.value;

        // Make sure the value is changed
        // The setter won't run if we set the same value again
        // This forces the DOM to update
        this._setInputValues(this.value, selectListItem.content.textContent, false);
      }
      else {
        // Add to values
        this._addValue(selectListItem.value, selectListItem.content.innerHTML, true);
      }

      // Focus on the input element
      // We have to wait a frame here because the item steals focus when selected
      var self = this;
      Coral.commons.nextFrame(function() {
        self._elements.input.focus();
      });

      // Hide the options when option is selected in all cases
      this.hideSuggestions();

      // Emit the change event when a selection is made
      this.trigger('change');
    },

    /**
      Don't let the internal change event bubble and confuse users

      @ignore
    */
    _preventTagListChangeEvent: function(event) {
      event.stopImmediatePropagation();
    },

    /**
      Handle tags that are removed by the user.

      @ignore
    */
    _handleTagRemoved: function(event) {
      // Get the tag from the event
      var tagValue = event.detail.item.value;

      // Remove from values only if there is no other tags with the same value are attached (as this component constantly adds and removes tags)
      // this._elements.tagList.values does not seem to work so iterate over the tags to check values
      var removeValue = true;
      var tags = this._elements.tagList.items.getAll();
      for (var i = 0; i < tags.length; i++) {
        if (tags[i].value === tagValue) {
          removeValue = false;
          break;
        }
      }
      if (removeValue) {
        this._removeValue(tagValue);
      }

      // If all tags were removed, return focus to the input
      if ((this.values.length === 1 && this.values[0] === '') || this.values.length === 0) {
        this._elements.input.focus();
      }

      this._updateButtonAccessibilityLabel();
    },

    /**
      Handles value changes on a child item.

      @private
    */
    _handleItemValueChange: function(event) {
      // stop event propogation
      event.stopImmediatePropagation();

      // Update option map from scratch
      // @todo use attributeOldValue mutationobserver option and update map instead of re-creating
      this._createOptionsFromDOM();
    },

    /**
      Handles content changes on a child item.

      @private
    */
    _handleItemContentChange: function(event) {
      // stop event propogation
      event.stopImmediatePropagation();

      // Update option map from scratch with new content
      this._createOptionsFromDOM();
    },

    /**
      Handles selected changes on a child item.

      @private
    */
    _handleItemSelectedChange: function(event) {
      // stop event propogation
      event.stopImmediatePropagation();

      var target = event.target;
      var selected = target.hasAttribute('selected');
      if (this.multiple) {
        this[selected ? '_addValue' : '_removeValue'](target.value, target.content.innerHTML, true);
      }
      else {
        if (selected) {
          // Set the input text accordingly
          this._elements.input.value = target.content.textContent.replace(/\s{2,}/g, ' ').trim();
          // Set the value accordingly
          this.value = target.value;
          this.invalid = false; // value can't be invalid as an item is selected

          // Deselect the other elements if selected programatically changed
          this._deselectExcept(target);
        }
        else {
          // Remove values if deselected
          // Only do this if we're the current value
          // If the selected item was changed, this.value will be different
          if (this.value === target.value) {
            this.value = '';

            // CUI-5533 Since checks inside of _handleInput will assume the value hasn't change,
            // We need to trigger here
            this.trigger('change');
          }
        }
      }
    },

    /**
      Clears the current selected value or items.
    */
    clear: function() {
      this.value = '';
      this._elements.input.clear();
      if (this.multiple) {
        this._clearValues();
      }
    },

    /**
      Clear the list of suggestions.
    */
    clearSuggestions: function() {
      this._elements.selectList.items.clear();
      this._updateButtonAccessibilityLabel();
    },

    /**
      Add the provided list of suggestions and clear loading status.

      @param {Array.<Coral.Autocomplete~suggestion>} suggestions
        The list of suggestions to show.
      @param {Boolean} clear
        If true, existing suggestions will be cleared.
    */
    addSuggestions: function(suggestions, clear) {
      // Disable loading mode
      this.loading = false;

      if (clear) {
        // Remove existing selectList items
        this.clearSuggestions();
      }

      // Add items to the selectlist
      for (var i = 0; i < suggestions.length; i++) {
        var value = suggestions[i].value;
        var content = suggestions[i].content;
        var icon = suggestions[i].icon;
        var disabled = !!suggestions[i].disabled;

        // Only add the item if it's not a selected value or we're in single mode
        if (!this.multiple || this.values.indexOf(value) === -1) {
          this._elements.selectList.items.add({
            value: value,
            type: 'button',
            icon: icon,
            disabled: disabled,
            id: Coral.commons.getUID(),
            tabIndex: -1,
            content: {
              innerHTML: content
            }
          });
          this._elements.selectList.items.last().setAttribute('role', 'option');
        }
      }

      if (!suggestions.length && !this._elements.selectList.items.length) {
        // Show "no results" when no suggestions are found at all
        this._elements.selectList.items.add({
          type: 'button',
          content: {
            innerHTML: '<em>' + Coral.i18n.get('No matching results.') + '</em>'
          },
          disabled: true
        });
        this._elements.selectList.items.last().setAttribute('role', 'status');
        this._elements.selectList.items.last().setAttribute('aria-live', 'polite');
        this._elements.input.removeAttribute('aria-activedescendant');
        this._updateButtonAccessibilityLabel();
      }
      else {
        this._updateButtonAccessibilityLabel(this._elements.selectList.items.length);
      }

      // Reset height
      this._elements.selectList.style.height = '';

      // Measure actual height
      var style = window.getComputedStyle(this._elements.selectList);
      var height = parseInt(style.height, 10);
      var maxHeight = parseInt(style.maxHeight, 10);

      if (height < maxHeight) {
        // Make it scrollable
        this._elements.selectList.style.height = height - 1 + 'px';
      }
    },

    /**
      Shows the suggestion UI.
    */
    showSuggestions: function() {
      if (!this._showSuggestionsCalled) {
        this._showSuggestions();
      }
      else {
        this._showSuggestionsCalled = false;
      }

      // @todo make sure this doesn't cause recalculate
      this._elements.overlay.style.minWidth = this.offsetWidth + 'px';

      if (this._elements.overlay.open) {
        // Reposition as the length of the list may have changed
        this._elements.overlay.reposition();
      }
      else {
        // Just show
        this._elements.overlay.open = true;
      }

      this.setAttribute('aria-expanded', 'true');
      this.classList.add('is-open');
    },

    /**
      Hides the suggestion UI.
    */
    hideSuggestions: function() {
      this._elements.overlay.open = false;

      this.setAttribute('aria-expanded', 'false');
      this.classList.remove('is-open', 'is-openBelow', 'is-openAbove');
      this._elements.input.removeAttribute('aria-activedescendant');

      // Don't let the suggestions show
      clearTimeout(this.timeout);

      // Trigger an event
      this.trigger('coral-autocomplete:hidesuggestions');
    },

    /**
      Check if the given option partially matches the given value.

      @param {HTMLElement} option
        The option to test
      @param {String} value
        The value to test

      @returns {Boolean} true if the value matches, false if not.

      @protected
    */
    _optionContainsValue: function(option, value) {
      value = (typeof value === 'string' ? value : '').toLowerCase();
      return option.content.toLowerCase().indexOf(value) !== -1;
    },

    /**
      Check if the given option starts with the given value.

      @param {HTMLElement} option
        The option to test
      @param {String} value
        The value to test

      @returns {Boolean} true if the value matches, false if not.

      @protected
    */
    _optionStartsWithValue: function(option, value) {
      value = (typeof value === 'string' ? value : '').toLowerCase();
      return option.content.toLowerCase().trim().indexOf(value) === 0;
    },

    /**
      Check if the given option exactly matches the given value.

      @param {HTMLElement} option
        The option to test
      @param {String} value
        The value to test

      @returns {Boolean} true if the value matches, false if not.

      @protected
    */
    _optionEqualsValue: function(option, value) {
      value = (typeof value === 'string' ? value : '').toLowerCase();
      return option.content.toLowerCase().trim() === value;
    },

    /**
      Updates label on toggle button to communicate number of suggestions in list.

      @param {Number} num
        The number of suggestions available
      @private
    */
    _updateButtonAccessibilityLabel: function(num) {
      var str = Coral.i18n.get('Show suggestions');

      if (num === 1) {
        str = Coral.i18n.get('Show suggestion');
      }
      else if (num > 1) {
        str = Coral.i18n.get('Show {0} suggestions', num);
      }

      this._elements.trigger.setAttribute('aria-label', str);
      this._elements.trigger.setAttribute('title', str);
    }

    /**
      Triggered before suggestions are determined and displayed.

      @event Coral.Autocomplete#coral-autocomplete:showsuggestions

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.value
        The user-provided input value.
      @param {HTMLElement} event.detail.start
        The count of existing suggestions, the index from which new suggestions should start at.
      @param {Function} event.preventDefault
        When called, prevent search for suggestions in existing items and show a loading indicator.
        Suggestions can be manually added by calling {@link Coral.Autocomplete#showSuggestions}.
    */
  });

  Coral.register( /** @lends Coral.Autocomplete.Item# */ {
    /**
      @class Coral.Autocomplete.Item
      @extends Coral.Component
      @classdesc An autocomplete item.
      @htmltag coral-autocomplete-item
    */
    name: 'Autocomplete.Item',
    tagName: 'coral-autocomplete-item',

    properties: {
      /**
        Value of the item. <code>textContent</code> is used if not provided.

        @type {String}
        @default ""
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.Autocomplete.Item#
      */
      'value': {
        reflectAttribute: true,
        trigger: 'coralui-autocomplete-item:_valuechanged',
        transform: Coral.transform.string,
        get: function() {
          // keep spaces to only 1 max and trim to mimic native select option behavior
          return typeof this._value === 'undefined' ? this.textContent.replace(/\s{2,}/g, ' ').trim() : this._value;
        }
      },

      /**
        The content zone element of the item.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Autocomplete.Item#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      },

      /**
        Whether this item is selected.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Autocomplete.Item#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coralui-autocomplete-item:_selectedchanged'
      },

      /**
        Whether this item is disabled.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.Autocomplete.Item#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr
      }
    },

    /** @ignore */
    _initialize: function() {
      this._observer = new MutationObserver(this._handleMutation.bind(this));
      this._observer.observe(this, {
        characterData: true,
        childList: true,
        subtree: true
      });
    },

    /** @private */
    _handleMutation: function(mutations) {
      this.trigger('coralui-autocomplete-item:_contentchanged', {
        content: this.textContent
      });
    }
  });

  // Expose enums
  Coral.Autocomplete.match = match;

  /**
    A suggestion object.

    @typedef {Object} Coral.Autocomplete~suggestion

    @property {String} value
      The form submission value to use when this suggestion is selected.
    @property {String} [content=value]
      The content to disable in the suggestion dropdown.
  */
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-calendar"] = {"en-US":{"Previous":"Previous","Next":"Next","Today, {0} selected/[translation hint:date]":"Today, {0} selected","Today, {0}/[translation hint:date]":"Today, {0}","{0} selected/[translation hint:date]":"{0} selected"},"fr-FR":{"Previous":"Précédent","Next":"Suivant","Today, {0} selected/[translation hint:date]":"Aujourd’hui, sélection de {0}","Today, {0}/[translation hint:date]":"Aujourd’hui, {0}","{0} selected/[translation hint:date]":"Sélection de {0}"},"de-DE":{"Previous":"Zurück","Next":"Weiter","Today, {0} selected/[translation hint:date]":"Heute, {0} ausgewählt","Today, {0}/[translation hint:date]":"Heute, {0}","{0} selected/[translation hint:date]":"{0} ausgewählt"},"it-IT":{"Previous":"Precedente","Next":"Successivo","Today, {0} selected/[translation hint:date]":"Oggi, {0} selezionati","Today, {0}/[translation hint:date]":"Oggi, {0}","{0} selected/[translation hint:date]":"{0} selezionati"},"es-ES":{"Previous":"Anterior","Next":"Siguiente","Today, {0} selected/[translation hint:date]":"Hoy, {0} seleccionados","Today, {0}/[translation hint:date]":"Hoy, {0}","{0} selected/[translation hint:date]":"{0} seleccionados"},"pt-BR":{"Previous":"Anterior","Next":"Próximo","Today, {0} selected/[translation hint:date]":"Hoje, {0} selecionados","Today, {0}/[translation hint:date]":"Hoje, {0}","{0} selected/[translation hint:date]":"{0} selecionados"},"ja-JP":{"Previous":"前へ","Next":"次へ","Today, {0} selected/[translation hint:date]":"今日、{0} が選択されました","Today, {0}/[translation hint:date]":"今日、{0}","{0} selected/[translation hint:date]":"{0} が選択されました"},"ko-KR":{"Previous":"이전으로","Next":"다음","Today, {0} selected/[translation hint:date]":"현재 {0}이(가) 선택됨","Today, {0}/[translation hint:date]":"현재 {0}","{0} selected/[translation hint:date]":"{0}이(가) 선택됨"},"zh-CN":{"Previous":"上一步","Next":"下一步","Today, {0} selected/[translation hint:date]":"已选定今天 {0}","Today, {0}/[translation hint:date]":"今天 {0}","{0} selected/[translation hint:date]":"已选定 {0}"},"zh-TW":{"Previous":"上一頁","Next":"下一頁","Today, {0} selected/[translation hint:date]":"今天，已選取 {0}","Today, {0}/[translation hint:date]":"今天，{0}","{0} selected/[translation hint:date]":"已選取 {0} "},"nl-NL":{"Previous":"Vorige","Next":"Volgende","Today, {0} selected/[translation hint:date]":"Vandaag {0} geselecteerd","Today, {0}/[translation hint:date]":"Vandaag {0} ","{0} selected/[translation hint:date]":"{0} geselecteerd"},"da-DK":{"Previous":"Foregående","Next":"Næste","Today, {0} selected/[translation hint:date]":"I dag, {0} valgt","Today, {0}/[translation hint:date]":"I dag, {0} ","{0} selected/[translation hint:date]":"{0} valgt"},"fi-FI":{"Previous":"Edellinen","Next":"Seuraava","Today, {0} selected/[translation hint:date]":"Tänään, {0} valittu","Today, {0}/[translation hint:date]":"Tänään, {0}","{0} selected/[translation hint:date]":"{0} valittu"},"nb-NO":{"Previous":"Forrige","Next":"Neste","Today, {0} selected/[translation hint:date]":"I dag, {0} valgt","Today, {0}/[translation hint:date]":"I dag, {0}","{0} selected/[translation hint:date]":"{0} valgt"},"sv-SE":{"Previous":"Föregående","Next":"Nästa","Today, {0} selected/[translation hint:date]":"Idag, {0} vald","Today, {0}/[translation hint:date]":"Idag, {0}","{0} selected/[translation hint:date]":"{0} vald"},"cs-CZ":{"Previous":"Předchozí","Next":"Další","Today, {0} selected/[translation hint:date]":"Dnes je vybráno: {0}","Today, {0}/[translation hint:date]":"Dnes, {0}","{0} selected/[translation hint:date]":"Vybráno: {0}"},"pl-PL":{"Previous":"Wstecz","Next":"Dalej","Today, {0} selected/[translation hint:date]":"Dziś, wybrano {0}","Today, {0}/[translation hint:date]":"Dziś, {0}","{0} selected/[translation hint:date]":"wybrano {0}"},"ru-RU":{"Previous":"Предыдущий","Next":"Следующий","Today, {0} selected/[translation hint:date]":"Сегодня, {0}, выбрано","Today, {0}/[translation hint:date]":"Сегодня, {0}","{0} selected/[translation hint:date]":"{0} выбрано"},"tr-TR":{"Previous":"Önceki","Next":"İleri","Today, {0} selected/[translation hint:date]":"Bugün, {0} seçildi","Today, {0}/[translation hint:date]":"Bugün, {0}","{0} selected/[translation hint:date]":"{0} seçildi"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Calendar"] = window["Coral"]["templates"]["Calendar"] || {};
window["Coral"]["templates"]["Calendar"]["calendar"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["input"] = document.createElement("input");
  el0.setAttribute("handle", "input");
  el0.setAttribute("type", "hidden");
  el0.setAttribute("name", "");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral3-Calendar-calendarHeader";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["heading"] = document.createElement("div");
  el4.setAttribute("handle", "heading");
  el4.className += " coral-Heading coral-Heading--2";
  el4.id = Coral["commons"]["getUID"]();
  el4.setAttribute("role", "heading");
  el4.setAttribute("aria-live", "assertive");
  el4.setAttribute("aria-atomic", "true");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el2.appendChild(el5);
  var el6 = this["prev"] = document.createElement("button","coral-button");
  el6.setAttribute("type", "button");
  el6.setAttribute("handle", "prev");
  el6.className += " coral3-Calendar-prevMonth";
  el6.setAttribute("is", "coral-button");
  el6.setAttribute("variant", "minimal");
  el6.setAttribute("icon", "chevronLeft");
  el6.setAttribute("iconsize", "XS");
  el6.setAttribute("aria-label", Coral["i18n"]["get"]('Previous'));
  el6.setAttribute("title", Coral["i18n"]["get"]('Previous'));
  el2.appendChild(el6);
  var el7 = document.createTextNode("\n  ");
  el2.appendChild(el7);
  var el8 = this["next"] = document.createElement("button","coral-button");
  el8.setAttribute("type", "button");
  el8.setAttribute("handle", "next");
  el8.className += " coral3-Calendar-nextMonth";
  el8.setAttribute("is", "coral-button");
  el8.setAttribute("variant", "minimal");
  el8.setAttribute("icon", "chevronRight");
  el8.setAttribute("iconsize", "XS");
  el8.setAttribute("aria-label", Coral["i18n"]["get"]('Next'));
  el8.setAttribute("title", Coral["i18n"]["get"]('Next'));
  el2.appendChild(el8);
  var el9 = document.createTextNode("\n");
  el2.appendChild(el9);
  frag.appendChild(el2);
  var el10 = document.createTextNode("\n");
  frag.appendChild(el10);
  var el11 = this["body"] = document.createElement("div");
  el11.className += " coral3-Calendar-calendarBody";
  el11.setAttribute("handle", "body");
  el11.setAttribute("role", "grid");
  el11.setAttribute("tabindex", "0");
  el11.setAttribute("aria-readonly", "true");
  frag.appendChild(el11);
  return frag;
});

window["Coral"]["templates"]["Calendar"]["container"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["container"] = document.createElement("div");
  el0.className += " coral3-DatePicker-calendarSlidingContainer";
  el0.setAttribute("handle", "container");
  el0.setAttribute("style", "width: "+data_0["width"]+"px; height: "+data_0["height"]+"px;");
  return el0;
});

window["Coral"]["templates"]["Calendar"]["table"] = (function anonymous(data_0
/**/) {
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  var el0 = this["table"] = document.createElement("table");
  el0.setAttribute("handle", "table");
  el0.setAttribute("role", "presentation");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("thead");
  el2.setAttribute("role", "presentation");
  var el3 = document.createTextNode("\n    ");
  el2.appendChild(el3);
  var el4 = document.createElement("tr");
  el4.setAttribute("role", "row");
  var el5 = document.createTextNode("\n      ");
  el4.appendChild(el5);
  var iterated_1 = data_0["dayNames"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el7 = document.createTextNode("\n        ");
    el4.appendChild(el7);
    var el8 = document.createElement("th");
    el8.setAttribute("role", "columnheader");
    el8.setAttribute("scope", "col");
    var el9 = document.createTextNode("\n          ");
    el8.appendChild(el9);
    var el10 = document.createElement("abbr");
    el10.className += " coral3-Calendar-dayOfWeek";
    el10.setAttribute("title", data_1["dayFullName"]);
    el10.textContent = data_1["dayAbbr"];
    el8.appendChild(el10);
    var el11 = document.createTextNode("\n        ");
    el8.appendChild(el11);
    el4.appendChild(el8);
    var el12 = document.createTextNode("\n      ");
    el4.appendChild(el12);
  }
  var el13 = document.createTextNode("\n    ");
  el4.appendChild(el13);
  el2.appendChild(el4);
  var el14 = document.createTextNode("\n  ");
  el2.appendChild(el14);
  el0.appendChild(el2);
  var el15 = document.createTextNode("\n  ");
  el0.appendChild(el15);
  var el16 = document.createElement("tbody");
  el16.setAttribute("role", "presentation");
  var el17 = document.createTextNode("\n    ");
  el16.appendChild(el17);
  var iterated_1 = data_0["weeks"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el19 = document.createTextNode("\n      ");
    el16.appendChild(el19);
    var el20 = document.createElement("tr");
    el20.setAttribute("role", "row");
    var el21 = document.createTextNode("\n        ");
    el20.appendChild(el21);
    var iterated_2 = data_1;
    for (var i2 = 0, ni2 = iterated_2.length; i2 < ni2; i2++) {
      var data_2 = data = iterated_2[i2];
      var el23 = document.createTextNode("\n          ");
      el20.appendChild(el23);
      data = data_2;
      
            var calendarTitle;
            var calendarDate = data.dateLabel + ', ' + data.formattedDate;
            if (data.isToday) {
              if (data.ariaSelected) {
                calendarTitle = Coral.i18n.get('Today, {0} selected', calendarDate, 'date');
              }
              else {
                calendarTitle = Coral.i18n.get('Today, {0}', calendarDate, 'date');
              }
            }
            else {
              if (data.ariaSelected) {
                calendarTitle = Coral.i18n.get('{0} selected', calendarDate, 'date');
              }
              else {
                calendarTitle = calendarTitle = calendarDate;
              }
            }
          
      data_2 = data;
      var el25 = document.createTextNode("\n          ");
      el20.appendChild(el25);
      var el26 = document.createElement("td");
      el26.setAttribute("role", "gridcell");
      el26.id = Coral["commons"]["getUID"]()+"-row"+i1+"-col"+i2;
      el26.className += " "+data_2["cssClass"];
      el26.setAttribute("aria-selected", data_2["ariaSelected"]);
      if (data_2["isDisabled"]) {
      el26.setAttribute("aria-disabled", "true");
      }
      if (data_2["ariaInvalid"]) {
      el26.setAttribute("aria-invalid", "true");
      }
      if (data_2["formattedDate"]) {
      el26.setAttribute("title", calendarTitle);
      }
      var el27 = document.createTextNode("\n            ");
      el26.appendChild(el27);
      if (data_2["dateAttr"]) {
        var el29 = document.createTextNode("\n                ");
        el26.appendChild(el29);
        var el30 = document.createElement("a");
        el30.setAttribute("role", "presentation");
        el30.className += " coral3-Calendar-date";
        el30.setAttribute("data-date", data_2["dateAttr"]);
        el30.textContent = data_2["dateText"];
        el26.appendChild(el30);
        var el31 = document.createTextNode("\n              ");
        el26.appendChild(el31);
      }
      else {
        var el32 = document.createTextNode("\n                ");
        el26.appendChild(el32);
        var el33 = document.createElement("span");
        el33.setAttribute("role", "presentation");
        el33.className += " coral3-Calendar-secondaryDate";
        el33.textContent = data_2["dateText"];
        el26.appendChild(el33);
        var el34 = document.createTextNode("\n            ");
        el26.appendChild(el34);
      }
      var el35 = document.createTextNode("\n          ");
      el26.appendChild(el35);
      el20.appendChild(el26);
      var el36 = document.createTextNode("\n        ");
      el20.appendChild(el36);
    }
    var el37 = document.createTextNode("\n      ");
    el20.appendChild(el37);
    el16.appendChild(el20);
    var el38 = document.createTextNode("\n    ");
    el16.appendChild(el38);
  }
  var el39 = document.createTextNode("\n  ");
  el16.appendChild(el39);
  el0.appendChild(el16);
  var el40 = document.createTextNode("\n  ");
  el0.appendChild(el40);
  var el41 = document.createElement("caption");
  el41.className += " u-coral-screenReaderOnly";
  el41.setAttribute("aria-live", "assertive");
  el41.setAttribute("aria-atomic", "true");
  el0.appendChild(el41);
  var el42 = document.createTextNode("\n");
  el0.appendChild(el42);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /** @ignore */
  function isDateInRange(date, startDate, endDate) {
    if (startDate === null && endDate === null) {
      return true;
    }
    else if (startDate === null) {
      return date <= endDate;
    }
    else if (endDate === null) {
      return date >= startDate;
    }
    else {
      return startDate <= date && date <= endDate;
    }
  }

  /** @ignore */
  function toMoment(value, format) {
    if (value === 'today') {
      return moment().startOf('day');
    }
    else if (moment.isMoment(value)) {
      return value.isValid() ? value.clone() : null;
    }
    else {
      // if the value provided is a date it does not make sense to provide a format to parse the date
      var result = moment(value, value instanceof Date ? null : format);
      return result.isValid() ? result : null;
    }
  }

  /** @ignore */
  function noop() {
  }

  /** @ignore */
  function validateAsChangedAndValidMoment(newValue, oldValue) {
    // if the value is undefined we change it to null since moment considers both to be different
    newValue = newValue || null;
    oldValue = oldValue || null;

    if (newValue !== oldValue && !moment(newValue).isSame(oldValue, 'day')) {
      return newValue === null || newValue.isValid();
    }

    return false;
  }

  /**
    Slides in new month tables, slides out old tables, and then cleans up the leftovers when it is done.

    @ignore
  */
  function TableAnimator(host) {
    this.host = host;

    this._addContainerIfNotPresent = function(width, height) {
      if (!this.container) {
        // Get a fresh container for the animation:
        Coral.templates.Calendar.container.call(
          this,
          {
            width: width,
            height: height
          }
        );
        this.host.appendChild(this.container);
      }
    };

    this._removeContainerIfEmpty = function() {
      if (this.container && this.container.children.length === 0) {
        this.host.removeChild(this.container);
        this.container = null;
      }
    };

    this.slide = function(newTable, direction) {
      var replace = direction === undefined;
      var isLeft = direction === 'left';

      var oldTable = this.oldTable;

      // Should the replace flag be raised, or no old table be present, then do a non-transitioned (re)place and exit
      if (replace || !oldTable) {
        if (oldTable) {
          oldTable.parentNode.removeChild(oldTable);
        }
        this.host.insertBefore(newTable, this.host.firstChild);
        this.oldTable = newTable;
        return;
      }

      var boundingClientRect = oldTable.getBoundingClientRect();
      var width = boundingClientRect.width;
      var height = boundingClientRect.height;
      this._addContainerIfNotPresent(width, height);

      // Add both the old and the new table to the container:
      this.container.appendChild(oldTable);
      this.container.appendChild(newTable);

      // Set the existing table to start from being in full view, and mark it to transition on `left` changing
      oldTable.classList.add('coral3-Calendar-table--transit');

      Coral.commons.transitionEnd(oldTable, function() {
        oldTable.parentNode.removeChild(oldTable);
        this._removeContainerIfEmpty();
      }.bind(this));

      // Set the new table to start out of view (either left or right depending on the direction of the slide), and mark
      // it to transition on `left` changing
      newTable.classList.add('coral3-Calendar-table--transit');
      newTable.style.left = (isLeft ? width : -width) + 'px';

      // When the transition is done, have the transition class lifted
      Coral.commons.transitionEnd(newTable, function() {
        newTable.classList.remove('coral3-Calendar-table--transit');
        this.host.appendChild(newTable);
        this._removeContainerIfEmpty();
      }.bind(this));

      // Force a redraw by querying the browser for its offsetWidth. Without this, the re-positioning code later on
      // would not lead to a transition. Note that there's no significance to the resulting value being assigned to
      // 'height' -- this is merely so to keep jshint from complaining
      height = this.container.offsetWidth;

      // Set the `left` positions to transition to:
      oldTable.style.left = (isLeft ? -width : width) + 'px';
      newTable.style.left = 0;

      this.oldTable = newTable;
    };
  }

  /** @ignore */
  var ARRAYOF6 = [0, 0, 0, 0, 0, 0];

  /** @ignore */
  var ARRAYOF7 = [0, 0, 0, 0, 0, 0, 0];

  /** @ignore */
  var INTERNAL_FORMAT = 'YYYY-MM-DD';

  /** @ignore */
  var timeUnit = {
    'YEAR': 'year',
    'MONTH': 'month',
    'WEEK': 'week',
    'DAY': 'day'
  };

  Coral.register( /** @lends Coral.Calendar# */ {
    /**
      @class Coral.Calendar
      @classdesc A Calendar component. Please note that for the <code>next</code> and <code>previous</code> month
      buttons to show properly, the embedding document is required to have <code><meta charset="utf-8"></code> set in
      its <code><head></code> tag.
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-calendar
    */
    name: 'Calendar',
    tagName: 'coral-calendar',
    className: 'coral3-Calendar',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'click .coral3-Calendar-nextMonth,.coral3-Calendar-prevMonth': '_onNextOrPreviousMonthClick',
      'click .coral3-Calendar-calendarBody .coral3-Calendar-date': '_onDayClick',
      'mousedown .coral3-Calendar-calendarBody .coral3-Calendar-date': '_onDayMouseDown',
      'key:up .coral3-Calendar-calendarBody': '_onUpKey',
      'key:right .coral3-Calendar-calendarBody': '_onRightKey',
      'key:down .coral3-Calendar-calendarBody': '_onDownKey',
      'key:left .coral3-Calendar-calendarBody': '_onLeftKey',
      'key:home .coral3-Calendar-calendarBody': '_onHomeOrEndKey',
      'key:end .coral3-Calendar-calendarBody': '_onHomeOrEndKey',
      'key:pageup': '_onPageUpKey',
      'key:pagedown': '_onPageDownKey',

      'key:meta+pageup': '_onCtrlPageUpKey', // On OSX we use Command+Page Up
      'key:meta+pagedown': '_onCtrlPageDownKey', // On OSX we use Command+Page Down
      'key:ctrl+pageup': '_onCtrlPageUpKey', // On Windows, we use CTRL+Page Up
      'key:ctrl+pagedown': '_onCtrlPageDownKey', // On Windows, we use CTRL+Page Down

      'key:enter .coral3-Calendar-calendarBody': '_onEnterKey',
      'key:space .coral3-Calendar-calendarBody': '_onEnterKey'
    },

    properties: {

      /**
        Defines the start day for the week, 0 = Sunday, 1 = Monday etc., as depicted on the calendar days grid.

        @type {Number}
        @default 0
        @htmlattribute startday
        @memberof Coral.Calendar#
      */
      'startDay': {
        default: typeof moment !== 'undefined' ? (typeof moment.localeData().firstDayOfWeek !== 'undefined' ? moment.localeData(Coral.i18n.locale).firstDayOfWeek() : 0) : 0,
        attribute: 'startday',
        transform: Coral.transform.number,
        validate: [
          Coral.validate.valueMustChange,
          function(value) {
            return value >= 0 && value < 7;
          }
        ],
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },

      /**
        The format used to display the current month and year. See http://momentjs.com/docs/#/displaying/ for valid
        format string options.

        @type {String}
        @default "MMMM YYYY"
        @htmlattribute headerformat
        @memberof Coral.Calendar#
      */
      'headerFormat': {
        default: 'MMMM YYYY',
        attribute: 'headerformat',
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },

      /**
        The minimal selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD' formatted.

        @type {String|Date}
        @default null
        @htmlattribute min
        @memberof Coral.Calendar#
      */
      'min': {
        default: null,
        transform: function(value) {
          return toMoment(value, this.valueFormat);
        },
        validate: validateAsChangedAndValidMoment,
        get: function() {
          return this._min ? this._min.toDate() : null;
        },
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },

      /**
        The max selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD'
        formatted.

        @type {String|Date}
        @default null
        @htmlattribute max
        @memberof Coral.Calendar#
      */
      'max': {
        default: null,
        transform: function(value) {
          return toMoment(value, this.valueFormat);
        },
        validate: validateAsChangedAndValidMoment,
        get: function() {
          return this._max ? this._max.toDate() : null;
        },
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },

      /**
        The format to use on expressing the selected date as a string on the <code>value</code> attribute. See
        http://momentjs.com/docs/#/displaying/ for valid format string options.

        @type {String}
        @default "YYYY-MM-DD"
        @htmlattribute valueformat
        @htmlattributereflected
        @memberof Coral.Calendar#
      */
      'valueFormat': {
        default: 'YYYY-MM-DD',
        attribute: 'valueformat',
        reflectAttribute: true,
        set: function(value) {
          this._valueFormat = value;
          this._elements.input.value = this.value;
        }
      },

      /**
        The current value. When set to 'today', the value is coerced into the clients local date expressed as string
        formatted in accordance to the set <code>valueFormat</code>.

        @type {String}
        @default ""
        @fires Coral.mixin.formField#change
        @htmlattribute value
        @memberof Coral.Calendar#
      */
      'value': {
        transform: function(value) {
          return toMoment(value, this.valueFormat);
        },
        validate: function(newVal, oldVal) {
          return validateAsChangedAndValidMoment(newVal, this._value);
        },
        get: function() {
          return this._value ? this._value.format(this.valueFormat) : '';
        },
        set: function(value) {
          this._value = value;
          this._elements.input.value = this.value;

          // resets the view cursor, so the selected month will be in view
          this._cursor = null;

          this._queueSync('_renderCalendarFlag', 'required');
        }
      },

      /**
        The value returned, or set, as a Date. If the value is '' it will return <code>null</code>.

        @type {Date}
        @default null
        @memberof Coral.Calendar#
      */
      'valueAsDate': {
        attribute: null,
        transform: function(value) {
          return (value instanceof Date) ? moment(value) : '';
        },
        get: function() {
          return this._value ? this._value.toDate() : null;
        },
        set: function(value) {
          this.value = value;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this.classList.toggle('is-required', this.required && this._value === null);
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this._elements.prev.disabled = this.disabled;
          this._elements.next.disabled = this.disabled;
          this._elements.body.setAttribute('aria-disabled', this.disabled);
          this._elements.body[this.disabled ? 'removeAttribute' : 'setAttribute']('tabindex', '0');
        },
        // Have the view reflect the disabled state change (in disabled state, all day buttons become span's
        alsoSync: ['_renderCalendarFlag']
      },

      // JSDoc inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
        },
        // If the selected date is on display, the view needs to reflect it being invalid
        alsoSync: ['_renderCalendarFlag']
      },

      /**
        Internal property that other properties use via `alsoSync` to schedule a calendar redraw. It makes sure that
        `_renderCalendar` is invoked only once per frame as a result of `alsoSync` invoking `Component._queueSync` that
        removes duplicate entries for the given property (`_renderCalendarFlag` in this case), maintaining only the last
        one added.

        @ignore
      */
      '_renderCalendarFlag': {
        attribute: null,
        sync: function() {
          this._renderCalendar();
        }
      }
    },

    /**
      sets focus to appropriate descendant
    */
    focus: function() {
      if (!this.contains(document.activeElement) && !this.disabled) {
        this._setActiveDescendant();
        this._elements.body.focus();
      }
    },

    /** @ignore */
    _render: function() {
      // Clean Up (cloneNode support)
      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.appendChild(Coral.templates.Calendar.calendar.call(this._elements));
    },

    /** @ignore */
    _initialize: function() {
      // Internal keeper of the month that is currently on display.
      this._cursor = null;

      // Internal keeper for the id of the currently focused date cell or the cell that would receive focus when the
      // calendar body receives focus.
      this._activeDescendant = null;
      this._animator = new TableAnimator(this._elements.body);
      this.setAttribute('role', 'region');
    },

    /** @ignore */
    _renderCalendar: function(slide) {
      var cursor = this._requireCursor();
      var displayYear = cursor.year();
      var displayMonth = cursor.month();
      var self = this;
      var oldTable = this._animator.oldTable;

      this._elements.heading.innerHTML = moment([displayYear, displayMonth, 1]).format(this.headerFormat);

      var newTable = this._renderTable(displayYear, displayMonth + 1);

      if (oldTable) {
        Coral.commons.transitionEnd(newTable, function() {
          Coral.commons.nextFrame(function() {
            self._setActiveDescendant();
          });
        });
      }

      this._animator.slide(newTable, slide);

      var el = this._elements.body.querySelector('.is-selected');
      var selectedId = el ? el.id : null;

      // This will be overwritten later if there is any other function setting the attribute
      this._activeDescendant = selectedId;

      this._setActiveDescendant();
    },

    /**
      Returns <code>true</code> if moment specified is before <code>min</code>.

      @param {moment} currentMoment
        A moment to test.
      @returns {Boolean}
        <code>true</code> if moment specified is before <code>min</code>

      @ignore
    */
    _isBeforeMin: function(currentMoment) {
      var min = this.min ? moment(this.min) : null;
      return min && currentMoment.isBefore(min);
    },

    /**
      Returns <code>true</code> if moment specified is after <code>max</code>.

      @param {moment} currentMoment
        A moment to test.
      @returns {Boolean}
        <code>true</code> if moment specified is after <code>max</code>

      @ignore
    */
    _isAfterMax: function(currentMoment) {
      var max = this.max ? moment(this.max) : null;
      return max && currentMoment.isAfter(max);
    },

    /**
      Returns <code>true</code> if moment specified is greater than or equal to <code>min</code> and less than or equal to <code>max</code>.

      @param {moment} currentMoment
        A moment to test.
      @returns {Boolean}
        <code>true</code> if moment specified falls within <code>min</code>/<code>max</code> date range.

      @ignore
    */
    _isInRange: function(currentMoment) {
      return !(this._isBeforeMin(currentMoment) || this._isAfterMax(currentMoment));
    },

    /**
      Updates the aria-activedescendant property for the calendar grid to communicate the currently focused date, or the
      date that should get focus when the grid receives focus, to assistive technology.

      @ignore
    */
    _setActiveDescendant: function() {
      var el;

      if (!this._activeDescendant || !this._elements.body.querySelector('#' + this._activeDescendant + ' [data-date]')) {
        this._activeDescendant = null;
        el = this._elements.body.querySelector('.is-selected');
        var selectedId = el ? el.id : null;
        el = this._elements.body.querySelector('.is-today');
        var todayId = el ? el.id : null;

        this._activeDescendant = selectedId || todayId;

        if (!this._activeDescendant ||
          !this._elements.body.querySelector('#' + this._activeDescendant + ' [data-date]')
        ) {
          var currentMoment = this._value;

          if (currentMoment) {
            var dates = this._elements.body.querySelectorAll('[data-date]');
            if (dates.length) {
              if (this._isBeforeMin(currentMoment)) {
                el = dates[0];
              }
              else if (this._isAfterMax(currentMoment)) {
                el = dates[dates.length - 1];
              }
            }
          }

          if (el) {
            this._activeDescendant = el.parentElement.id;
          }
        }
      }

      el = this._elements.body.querySelector('.is-focused');
      if (el) {
        el.classList.remove('is-focused');
      }

      this._elements.body.setAttribute('aria-activedescendant', this._activeDescendant);

      this._updateTableCaption();

      if (!this._activeDescendant) {
        return;
      }

      el = document.getElementById(this._activeDescendant);
      if (el) {
        el.classList.add('is-focused');
      }
    },

    /**
      Updates the table caption which serves as a live region to announce the currently focused date to assistive
      technology, improving compatibility across operating systems, browsers and screen readers.

      @ignore
     */
    _updateTableCaption: function() {
      var self = this;
      var caption = self._elements.body.querySelector('caption');

      if (!caption) {
        return;
      }

      if (caption.firstChild) {
        caption.removeChild(caption.firstChild);
      }
      if (this._activeDescendant) {
        var activeDescendant = this._elements.body.querySelector('#' + this._activeDescendant);
        var captionText = document.createTextNode(activeDescendant.getAttribute('title'));
        caption.appendChild(captionText);
      }
    },

    /** @ignore */
    _renderTable: function(year, month) {
      var firstDate = moment([year, month - 1, 1]);
      var monthStartsAt = (firstDate.day() - this.startDay) % 7;
      var dateLocal = this._value ? this._value.clone().startOf('day') : null;

      if (monthStartsAt < 0) {
        monthStartsAt += 7;
      }

      var data = {

        dayNames: ARRAYOF7.map(
          function(_, index, days) {
            var dayMoment = moment().day((index + this.startDay) % 7);
            var dayDetail = {
              dayAbbr: dayMoment.format('dd'),
              dayFullName: dayMoment.format('dddd')
            };
            return dayDetail;
          },
          this),

        weeks: ARRAYOF6.map(
          function(_, weekIndex) {
            return ARRAYOF7.map(
              function(_, dayIndex) {
                var result = {};
                var cssClass = this.disabled ? ['is-disabled'] : [];
                var ariaSelected = false;
                var ariaInvalid = false;
                var day = (weekIndex * 7 + dayIndex) - monthStartsAt;
                var cursor = moment([year, month - 1]);
                // we use add() since 'day' could be a negative value
                cursor.add(day, 'days');

                var isCurrentMonth = (cursor.month() + 1) === parseFloat(month);
                var dayOfWeek = moment().day((dayIndex + this.startDay) % 7).format('dddd');
                var isToday = cursor.isSame(moment(), 'day');

                var cursorLocal = cursor.clone().startOf('day');

                if (isToday) {
                  cssClass.push('is-today');
                }

                if (dateLocal && cursorLocal.isSame(dateLocal, 'day')) {
                  ariaSelected = true;
                  cssClass.push('is-selected');
                  if (this.invalid) {
                    ariaInvalid = true;
                    cssClass.push('is-invalid');
                  }
                }

                if (isCurrentMonth) {
                  cssClass.push('is-currentMonth');
                  if (!this.disabled && isDateInRange(cursor, this.min, this.max)) {
                    result.dateAttr = cursorLocal.local().format(INTERNAL_FORMAT);
                    result.weekIndex = cursor.week();
                    result.formattedDate = cursor.format('LL');
                  }
                }

                result.isDisabled = this.disabled || !result.dateAttr;
                result.dateText = cursor.date();
                result.cssClass = cssClass.join(' ');
                result.isToday = isToday;
                result.ariaSelected = ariaSelected;
                result.ariaInvalid = ariaInvalid;
                result.dateLabel = dayOfWeek;
                result.weekIndex = cursor.week();

                return result;
              },
              this
            );
          },
          this)
      };

      var handles = {};
      Coral.templates.Calendar.table.call(handles, data);

      return handles.table;
    },

    /** @ignore */
    _requireCursor: function() {
      var cursor = this._cursor;
      if (!cursor || !cursor.isValid()) {
        // When its unknown what month we should be showing, use the set date. If that is not available, use 'today'
        cursor = (this._value ? this._value.clone().startOf('day') : moment()).startOf('month');
        this._cursor = cursor;
      }

      return cursor;
    },

    /**
      Navigate to previous or next timeUnit interval.

      @param {String} unit
        Year, Month, Week, Day
      @param {Boolean} isNext
        Whether to navigate forward or backward.

      @private
     */
    _gotoPreviousOrNextTimeUnit: function(unit, isNext) {
      var direction = isNext ? 'left' : 'right';
      var operator = isNext ? 'add' : 'subtract';
      var el = this._elements.body.querySelector('td.is-focused .coral3-Calendar-date');
      var currentActive;
      var currentMoment;
      var newMoment;
      var difference;

      if (unit !== timeUnit.MONTH && el) {
        currentActive = el.dataset.date;
        currentMoment = moment(currentActive);
        newMoment = currentMoment[operator](1, unit);

        // make sure new moment is in range before transitioning
        if (this._isInRange(newMoment)) {
          difference = Math.abs(moment(currentActive).diff(newMoment, 'days'));
          this._getToNewMoment(null, direction, operator, difference);
          this._setActiveDescendant();
        }
      }
      else {
        this._requireCursor();

        // if cursor is out of range
        if (!this._isInRange(this._cursor)) {

          // advance to closest value in range
          if (this._isBeforeMin(this._cursor)) {
            newMoment = this.min;
          }
          else if (this._isAfterMax(this._cursor)) {
            newMoment = this.max;
          }
          newMoment = moment(newMoment);
          difference = Math.abs(this._cursor.diff(newMoment, 'days'));
          this._getToNewMoment(null, direction, operator, difference);
          this._setActiveDescendant();
          return;
        }

        this._cursor[operator](1, unit);
        this._renderCalendar(direction);
      }
    },

    /**
      Checks if the Calendar is valid or not. This is done by checking that the current value is between the
      provided <code>min</code> and <code>max</code> values. This check is only performed on user interaction.
      @ignore
    */
    _validateCalendar: function() {
      this.invalid = !(this._value === null || isDateInRange(this._value, this.min, this.max));
    },

    /** @ignore */
    _onNextOrPreviousMonthClick: function(event) {
      event.preventDefault();

      this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, this._elements.next === event.matchedTarget);
      event.matchedTarget.focus();
      this._validateCalendar();
    },

    /** @ignore */
    _getToNewMoment: function(event, direction, operator, difference) {
      var el = this._elements.body.querySelector('td.is-focused .coral3-Calendar-date');
      var currentActive;

      if (el) {
        currentActive = el.dataset.date;
      }
      else {
        this._requireCursor();
        currentActive = this._cursor.local().format(INTERNAL_FORMAT);
      }

      var currentMoment = moment(currentActive);
      var currentMonth = currentMoment.month();
      var currentYear = currentMoment.year();
      var newMoment = currentMoment[operator](difference, 'days');
      var newMonth = newMoment.month();
      var newYear = newMoment.year();
      var newMomentValue = newMoment.local().format(INTERNAL_FORMAT);

      if (newMonth !== currentMonth) {
        this._requireCursor();
        this._cursor[operator](1, 'months');
        this._renderCalendar(direction);
      }
      else if (newMonth === currentMonth && newYear !== currentYear) {
        this._requireCursor();
        this._cursor[operator](1, 'years');
        this._renderCalendar(direction);
      }

      var dateQuery = '.coral3-Calendar-date[data-date^=' + JSON.stringify(newMomentValue) + ']';
      var newDescendant = this._elements.body.querySelector(dateQuery);
      if (newDescendant) {
        var newDescendantId = newDescendant.parentNode.getAttribute('id');
        this._activeDescendant = newDescendantId;
      }
    },

    /** @ignore */
    _onDayMouseDown: function(event) {
      this._activeDescendant = event.target.parentNode.id;
      this._setActiveDescendant();
      this._elements.body.focus();
      this._validateCalendar();
    },

    /** @ignore */
    _onDayClick: function(event) {
      event.preventDefault();

      this._elements.body.focus();

      var date = moment(event.target.dataset.date, INTERNAL_FORMAT);
      var dateLocal;

      // Carry over any user set time info
      if (this._value) {
        dateLocal = this._value.clone();
      }

      // Set attribute so a change event will be triggered if the user has selected a different date
      if (validateAsChangedAndValidMoment(date, dateLocal)) {
        this.value = date.local();
        this.trigger('change');
      }

      this._validateCalendar();
    },

    /** @ignore */
    _onEnterKey: function(event) {
      event.preventDefault();

      var el = this._elements.body.querySelector('td.is-focused .coral3-Calendar-date');

      if (el) {
        el.click();
      }

      this._validateCalendar();
    },

    /** @ignore */
    _onUpKey: function(event) {
      event.preventDefault();

      this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, false);
      this._validateCalendar();
    },

    /** @ignore */
    _onDownKey: function(event) {
      event.preventDefault();

      this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, true);
      this._validateCalendar();
    },

    /** @ignore */
    _onRightKey: function(event) {
      event.preventDefault();

      this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, true);
      this._validateCalendar();
    },

    /** @ignore */
    _onLeftKey: function(event) {
      event.preventDefault();

      this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, false);
      this._validateCalendar();
    },

    /** @ignore */
    _onHomeOrEndKey: function(event) {
      event.preventDefault();
      var isHome = event.keyCode === Coral.Keys.keyToCode('home');
      var direction = '';
      var operator = isHome ? 'subtract' : 'add';
      var el = this._elements.body.querySelector('td.is-focused .coral3-Calendar-date');

      if (el) {
        var currentActive = el.dataset.date;
        var currentMoment = moment(currentActive);
        var difference = isHome ? currentMoment.date() - 1 : currentMoment.daysInMonth() - currentMoment.date();
        this._getToNewMoment(event, direction, operator, difference);
        this._setActiveDescendant();
      }

      this._validateCalendar();
    },

    /** @ignore */
    _onPageDownKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, true);
      this._validateCalendar();
    },

    /** @ignore */
    _onPageUpKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, false);
      this._validateCalendar();
    },

    /** @ignore */
    _onCtrlPageDownKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, true);
      this._validateCalendar();
    },

    /** @ignore */
    _onCtrlPageUpKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, false);
      this._validateCalendar();
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for Card variant values.

    @enum {String}
    @memberof Coral.Card
  */
  var variant = {
    /** Default card variant that shows the asset, overlay and content in their default positions. */
    DEFAULT: 'default',
    /** Condensed card variant where the overlay is hidden and the content is shown over the image. */
    CONDENSED: 'condensed',
    /** Condensed card variant where the overlay is hidden and the content is shown over the image with a dark style. */
    INVERTED: 'inverted',
    /** Card variant where only the asset is shown. */
    ASSET: 'asset'
  };

  // the card's base classname
  var CLASSNAME = 'coral3-Card';

  // builds a string containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.Card# */ {
    /**
      @class Coral.Card
      @classdesc A Card component
      @extends Coral.Component
      @htmltag coral-card
    */
    name: 'Card',
    tagName: 'coral-card',
    className: CLASSNAME,

    events: {
      'capture:load coral-card-asset img': '_onLoad'
    },

    properties: {

      /**
        The Asset of the card.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card#
      */
      'asset': Coral.property.contentZone({
        handle: 'asset',
        tagName: 'coral-card-asset',
        insert: function(asset) {
          this.insertBefore(asset, this.info || this._elements.wrapper || null);
        }
      }),

      /**
        Hints the height of the asset that is going to be loaded. This prepares the size so that when the image is
        loaded no reflow is triggered. Both <code>assetHeight</code> and <code>assetWidth</code> need to be specified
        for this feature to take effect.

        @type {String}
        @default ""
        @htmlattribute assetheight
        @memberof Coral.Card#
      */
      'assetHeight': {
        default: '',
        attribute: 'assetheight',
        transform: Coral.transform.number,
        sync: function() {
          // both hint dimensions need to be set in order to use this feature
          if (!this._loaded && this._elements.asset && this.assetWidth && this.assetHeight) {
            // gets the width without the border of the card
            var clientRect = this.getBoundingClientRect();
            var width = clientRect.right - clientRect.left;
            // calculates the image ratio used to resize the height
            var ratio = width / this.assetWidth;

            // the image is considered "low resolution"
            // @todo: check this after removal of lowResolution
            if (ratio > 1) {
              // 32 = $card-asset-lowResolution-padding * 2
              this._elements.asset.style.height = (this.assetHeight + 32) + 'px';
            }
            else {
              // for non-low resolution images, condensed and inverted cards do not require the height to be set
              if (this.variant !== Coral.Card.variant.CONDENSED &&
                this.variant !== Coral.Card.variant.INVERTED) {
                this._elements.asset.style.height = (ratio * this.assetHeight) + 'px';
              }
            }
          }
        }
      },

      /**
        Hints the width of the asset that is going to be loaded. This prepares the size so that when the image is
        loaded no reflow is triggered. Both <code>assetHeight</code> and <code>assetWidth</code> need to be specified
        for this feature to take effect.

        @type {String}
        @default ""
        @htmlattribute assetwidth
        @memberof Coral.Card#
      */
      'assetWidth': {
        default: '',
        attribute: 'assetwidth',
        transform: Coral.transform.number
      },

      /**
        @type {String}
        @default ""
        @htmlattribute colorhint
        @memberof Coral.Card#
      */
      'colorHint': {
        attribute: 'colorhint',
        validate: [
          Coral.validate.valueMustChange,
          function(newValue) {
            // tests if the given value is a hex color
            return (/^#[0-9A-F]{6}$/i).test(newValue);
          }
        ],
        sync: function() {
          // if the image is already loaded we do not add the color hint to the asset
          if (!this._loaded) {
            this._elements.asset.style['background-color'] = this.colorHint;
          }
        }
      },

      /**
        The Content of the card.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-card-content',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.wrapper.insertBefore(content, this.overlay || null);
        }
      }),

      /**
        The information area of the card, which is placed over all the content. It is typically used for alerts.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card#
      */
      'info': Coral.property.contentZone({
        handle: 'info',
        tagName: 'coral-card-info',
        insert: function(info) {
          this.appendChild(info);
        }
      }),

      /**
        Fixes the width of the card. By default cards will take the width of their containers allowing them to interact
        nicely with grids. Whenever they are used standalone fixing the width might be desired.

        @type {Boolean}
        @default false
        @htmlattribute fixedwidth
        @htmlattributereflected
        @memberof Coral.Card#
      */
      'fixedWidth': {
        default: false,
        attribute: 'fixedwidth',
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(this._className + '--fixedWidth', this.fixedWidth);
        }
      },

      /**
        The Overlay of the card.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card#
      */
      'overlay': Coral.property.contentZone({
        handle: 'overlay',
        tagName: 'coral-card-overlay',
        insert: function(overlay) {
          this._elements.wrapper.appendChild(overlay);
        }
      }),

      /**
        Whether the card is stacked or not. This is used to represent several assets grouped together.

        @type {Boolean}
        @default false
        @htmlattribute stacked
        @htmlattributereflected
        @memberof Coral.Card#
      */
      'stacked': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(this._className + '--stacked', this.stacked);
        }
      },

      /**
        The card's variant. It determines which sections of the Card and in which position they are shown.

        @type {Coral.Card.variant}
        @default Coral.Card.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Card#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== Coral.Card.variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }
        },
        alsoSync: 'assetHeight'
      }
    },

    /** @ignore */
    _onLoad: function(event) {
      // @todo fix me for multiple images
      // sets the image as loaded
      this._loaded = true;

      // removes the height style since the asset has been completely loaded
      this._elements.asset.style.height = '';

      // enables the transition
      event.target.classList.remove('is-loading');
    },

    /** @ignore */
    _render: function() {

      // queries all the content zones
      var asset = this.querySelector('coral-card-asset') || document.createElement('coral-card-asset');
      var info = this.querySelector('coral-card-info');
      var overlay = this.querySelector('coral-card-overlay');
      var content = this.querySelector('coral-card-content');

      var wrapper = this._elements.wrapper = document.createElement('div');
      wrapper.className = 'coral3-Card-wrapper';

      // prepares images to be loaded nicely
      var images = asset.querySelectorAll('img');
      var imagesCount = images.length;
      for (var i = 0; i < imagesCount; i++) {
        var image = images[i];
        if (!image.complete) {
          image.classList.add('is-loading');
        }
      }

      if (content === null) {
        content = document.createElement('coral-card-content');
        // moves everything into the main content zone
        while (this.firstChild) {
          // removes the empty spaces
          if (this.firstChild.nodeType === Node.TEXT_NODE && this.firstChild.textContent.trim() === '') {
            this.removeChild(this.firstChild);
          }
          // otherwise it gets added to the main content zone
          else {
            content.appendChild(this.firstChild);
          }
        }
      }
      // Assign the content zones so the insert functions will be called

      // moves the overlay and content to the wrapper since it helps providing the appropiate positioning
      if (overlay) {
        this.overlay = overlay;
      }

      this.content = content;

      if (info) {
        this.info = info;
      }

      this.appendChild(wrapper);

      // The 'asset' setter knows to insert the element just before the wrapper node.
      this.asset = asset;
    }
  });

  // exports the enumeration
  Coral.Card.variant = variant;

  /**
    @class Coral.Card.Asset
    @classdesc The Card Asset
    @htmltag coral-card-asset
    @extends HTMLElement
  */
  Coral.Card.Asset = function() {
    return document.createElement('coral-card-asset');
  };

  /**
    @class Coral.Card.Overlay
    @classdesc The Card Overlay
    @htmltag coral-card-overlay
    @extends HTMLElement
  */
  Coral.Card.Overlay = function() {
    return document.createElement('coral-card-overlay');
  };

  /**
    @class Coral.Card.Info
    @classdesc The Card Info
    @htmltag coral-card-info
    @extends HTMLElement
  */
  Coral.Card.Info = function() {
    return document.createElement('coral-card-info');
  };

  /**
    @class Coral.Card.Content
    @classdesc The Card Content
    @htmltag coral-card-content
    @extends HTMLElement
  */
  Coral.Card.Content = function() {
    return document.createElement('coral-card-content');
  };

  /**
    @class Coral.Card.PropertyList
    @classdesc The Card PropertyList component
    @htmltag coral-card-propertylist
    @extends HTMLElement
  */
  Coral.Card.PropertyList = function() {
    return document.createElement('coral-card-propertylist');
  };

  Coral.register( /** @lends Coral.Card.Property# */ {
    /**
      @class Coral.Card.Property
      @classdesc The Card Property
      @htmltag coral-card-property
      @extends Coral.Component
    */
    name: 'Card.Property',
    tagName: 'coral-card-property',
    className: 'coral3-Card-property',

    properties: {
      /**
        The property's content zone

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card.Property#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-card-property-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        Specifies the icon name used inside the property. See {@link Coral.Icon} for valid icon names.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Card.Property#

        @see {@link Coral.Icon}
      */
      'icon': {
        get: function() {
          return this._elements.icon.icon;
        },
        set: function(value) {
          this._elements.icon.icon = value;
        },
        sync: function() {
          // removes the icon element from the DOM since there is no valid icon. this causes the content to have the
          // correct styling
          if (this.icon === '') {
            this._elements.icon.remove();
          }
          else {
            if (!this._elements.icon.parentNode) {
              this.insertBefore(this._elements.icon, this.firstChild);
            }
          }
        }
      }
    },

    /** @ignore */
    _render: function() {
      // creates the icon. it is not added to the DOM
      this._elements.icon = document.createElement('coral-icon');
      this._elements.icon.size = Coral.Icon.size.EXTRA_SMALL;
      this._elements.icon.className += ' coral3-Card-property-icon';

      // Fetch or create the content zone
      var content = this.querySelector('coral-card-property-content');

      if (content === null) {
        content = document.createElement('coral-card-property-content');
        // Move any remaining elements into the content sub-component
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      // Assign the content zone so the insert function will be called
      this.content = content;
    }
  });

  /**
    @class Coral.Card.Property.Content
    @classdesc A Card Property Content component
    @htmltag coral-card-property-content
    @extends HTMLElement
  */
  Coral.Card.Property.Content = function() {
    return document.createElement('coral-card-property-content');
  };

  Coral.register( /** @lends Coral.Card.Title */ {
    /**
      @class Coral.Card.Title
      @classdesc A Card Title component
      @extends Coral.Component
      @htmltag coral-card-title
    */
    name: 'Card.Title',
    tagName: 'coral-card-title',
    className: 'coral3-Card-title',

    properties: {
      /**
        The title's content zone.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card.Title#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      }
    }
  });
  
  Coral.register( /** @lends Coral.Card.Subtitle */ {
    /**
     @class Coral.Card.Subtitle
     @classdesc A Card Subtitle component
     @extends Coral.Component
     @htmltag coral-card-subtitle
     */
    name: 'Card.Subtitle',
    tagName: 'coral-card-subtitle',
    className: 'coral3-Card-subtitle',
    
    properties: {
      /**
       The subtitle's content zone.
       
       @type {HTMLElement}
       @contentzone
       @memberof Coral.Card.Subtitle#
       */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      }
    }
  });

  Coral.register( /** @lends Coral.Card.Context */ {
    /**
      @class Coral.Card.Context
      @classdesc A Card Context component
      @extends Coral.Component
      @htmltag coral-card-context
    */
    name: 'Card.Context',
    tagName: 'coral-card-context',
    className: 'coral3-Card-context',

    properties: {
      /**
        The context's content zone.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card.Context#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      }
    }
  });

  Coral.register( /** @lends Coral.Card.Description */ {
    /**
      @class Coral.Card.Description
      @classdesc A Card Description component
      @extends Coral.Component
      @htmltag coral-card-description
    */
    name: 'Card.Description',
    tagName: 'coral-card-description',
    className: 'coral3-Card-description',

    properties: {
      /**
        The description's content zone.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Card.Description#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enumeration representing the possible targets for the CharacterCount.

    @enum {String}
    @memberof Coral.CharacterCount
  */
  var target = {
    /** Relates the CharacterCount to the previous sibling. */
    PREVIOUS: '_prev',
    /** Relates the CharacterCount to the next sibling. */
    NEXT: '_next'
  };

  Coral.register( /** @lends Coral.CharacterCount */ {
    /**
      @class Coral.CharacterCount
      @classdesc A character counter component
      @extends Coral.Component
      @htmltag coral-charactercount
    */
    name: 'CharacterCount',
    tagName: 'coral-charactercount',
    className: 'coral3-CharacterCount',

    properties: {
      /**
        The target Textfield or Textarea for this component. It accepts values from {@link Coral.CharacterCount.target},
        as well as any DOM element or CSS selector.

        @type {Coral.CharacterCount.target|HTMLElement|String}
        @default Coral.CharacterCount.target.PREVIOUS
        @htmlattribute target
        @memberof Coral.CharacterCount#
      */
      'target': {
        default: target.PREVIOUS,
        validate: function(value) {
          return typeof value === 'string' || value instanceof Node;
        },
        set: function(value) {
          this._target = value;

          // Remove previous event listener
          if (this._targetEl) {
            this._targetEl.removeEventListener('input', this._refreshCharCount.bind(this));
          }

          // Get the target DOM element
          if (value === target.NEXT) {
            this._targetEl = this.nextElementSibling;
          }
          else if (value === target.PREVIOUS) {
            this._targetEl = this.previousElementSibling;
          }
          else if (typeof value === 'string') {
            this._targetEl = document.querySelector(value);
          }
          else {
            this._targetEl = value;
          }

          if (this._targetEl) {
            this._targetEl.addEventListener('input', this._refreshCharCount.bind(this));

            // Try to get maxlength from target element
            if (this._targetEl.getAttribute('maxlength')) {
              this.maxLength = this._targetEl.getAttribute('maxlength');
            }
          }
        }
      },

      /**
        Maximum character length for the TextField/TextArea (will be read from target field markup if able).

        @type {Number}
        @default null
        @htmlattribute maxlength
        @htmlattributereflected
        @memberof Coral.CharacterCount#
      */
      'maxLength': {
        default: null,
        attribute: 'maxlength',
        reflectAttribute: true,
        transform: Coral.transform.number,
        sync: function() {
          this._refreshCharCount();
        }
      }
    },

    /** @ignore */
    _getCharCount: function() {
      var elementLength = this._targetEl ? this._targetEl.value.length : 0;
      return this._maxLength ? (this._maxLength - elementLength) : elementLength;
    },

    /** @ignore */
    _refreshCharCount: function() {
      var currentCount = this._getCharCount();
      this.innerHTML = currentCount;
      var isMaxExceeded = currentCount < 0;
      if (this._targetEl) {
        this._targetEl.classList.toggle('is-invalid', isMaxExceeded);
        this.classList.toggle('is-invalid', isMaxExceeded);
      }
    }
  });

  // Expose enums globally
  Coral.CharacterCount.target = target;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["SelectList"] = window["Coral"]["templates"]["SelectList"] || {};
window["Coral"]["templates"]["SelectList"]["loadIndicator"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["loadIndicator"] = document.createElement("div");
  el0.setAttribute("handle", "loadIndicator");
  el0.className += " coral3-SelectList-loading";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("coral-wait");
  el2.setAttribute("centered", "");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var KEYPRESS_TIMEOUT_DURATION = 1000;

  /**
    The distance, in pixels, from the bottom of the SelectList at which we trigger a scrollbottom event. For example, a
    value of 50 would indicate a scrollbottom event should be triggered when the user scrolls to within 50 pixels of the
    bottom.

    @type {Number}
    @ignore
   */
  var SCROLL_BOTTOM_THRESHOLD = 50;

  /**
    The number of milliseconds for which scroll events should be debounced.

    @type {Number}
    @ignore
  */
  var SCROLL_DEBOUNCE = 100;

  /** @ignore */
  var ITEM_TAG_NAME = 'coral-selectlist-item';

  /** @ignore */
  var GROUP_TAG_NAME = 'coral-selectlist-group';

  var SelectListCollection = function(host, itemTagName) {
    this._host = host;
    this._itemTagName = itemTagName;
  };

  SelectListCollection.prototype = Object.create(Coral.Collection.prototype);

  SelectListCollection.prototype.add = function(item, before) {
    if (!(item instanceof HTMLElement)) {
      // creates a new item and initializes its values
      var itemObject = item;
      item = document.createElement(this._itemTagName);
      item.set(itemObject, true);
    }

    return this._host.insertBefore(item, before || null);
  };

  SelectListCollection.prototype.getAll = function() {
    this._host.id = this._host.id || Coral.commons.getUID();
    return Array.prototype.slice.call(this._host.getElementsByTagName(this._itemTagName));
  };

  Coral.register( /** @lends Coral.SelectList# */ {
    /**
      @class Coral.SelectList
      @classdesc A SelectList component
      @extends Coral.Component
      @mixes Coral.mixin.selectionList
      @borrows Coral.mixin.selectionList#multiple as Coral.SelectList#multiple
      @borrows Coral.mixin.selectionList#selectedItem as Coral.SelectList#selectedItem
      @borrows Coral.mixin.selectionList#selectedItems as Coral.SelectList#selectedItems
      @borrows Coral.mixin.selectionList#items as Coral.SelectList#items
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:add as Coral.SelectList#coral-collection:add
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:remove as Coral.SelectList#coral-collection:remove

      @htmltag coral-selectlist
    */
    // Based on ARIA standard http://www.w3.org/WAI/PF/aria/roles#listbox
    name: 'SelectList',
    tagName: 'coral-selectlist',
    className: 'coral3-SelectList',

    mixins: [
      Coral.mixin.selectionList({
        role: 'listbox',
        itemTagName: ITEM_TAG_NAME
      })
    ],

    events: {
      'scroll': '_onScroll',
      'capture:focus': '_onFocus',
      'capture:blur': '_onBlur',

      'click coral-selectlist-item': '_onItemClick',

      'capture:mouseenter coral-selectlist-item': '_onItemMouseEnter',
      'capture:mouseleave coral-selectlist-item': '_onItemMouseLeave',

      'key:space coral-selectlist-item': '_onToggleItemKey',
      'key:return coral-selectlist-item': '_onToggleItemKey',
      'key:pageup coral-selectlist-item': '_focusPreviousItem',
      'key:left coral-selectlist-item': '_focusPreviousItem',
      'key:up coral-selectlist-item': '_focusPreviousItem',
      'key:pagedown coral-selectlist-item': '_focusNextItem',
      'key:right coral-selectlist-item': '_focusNextItem',
      'key:down coral-selectlist-item': '_focusNextItem',
      'key:home coral-selectlist-item': '_onHomeKey',
      'key:end coral-selectlist-item': '_onEndKey',
      'keypress coral-selectlist-item': '_onKeyPress'
    },

    properties: {
      /**
        The Collection Interface that allows interacting with the {@link Coral.SelectList.Group} elements that the
        SelectList contains. This includes items nested inside groups. To manage items contained within a specific
        group, see {@link Coral.SelectList.Group#items}.

        See {@link Coral.Collection} for more details regarding collection APIs.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.SelectList#
      */
      'groups': {
        set: function() {},
        get: function() {
          if (!this._groups) {
            this._groups = new SelectListCollection(this, GROUP_TAG_NAME);
          }
          return this._groups;
        }
      },

      /**
        Whether items are being loaded for the SelectList. Toggling this merely shows or hides a loading indicator.

        @default false
        @type {Boolean}
        @htmlattribute loading
        @htmlattributereflected
        @memberof Coral.SelectList#
      */
      'loading': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          this._loading = value;

          var loadIndicator = this._elements.loadIndicator;

          if (this.loading) {
            // if it does not exist we create it
            if (!loadIndicator) {
              loadIndicator = Coral.templates.SelectList.loadIndicator.call(this._elements);
            }

            // we decide first if we need to scroll to the bottom since adding the load will change the dimentions
            var scrollToBottom = this.scrollTop >= this.scrollHeight - this.clientHeight;

            // inserts the item at the end
            this.appendChild(loadIndicator);

            // we make the load indicator visible
            if (scrollToBottom) {
              this.scrollTop = this.scrollHeight;
            }
          }
          else {
            if (loadIndicator && loadIndicator.parentNode) {
              this.removeChild(loadIndicator);
            }
          }
        }
      },

      /** @private **/
      '_tabTarget': {
        default: null,
        sync: function() {
          var value = this._tabTarget;
          var items = this.items.getAll();

          // Set all but the current set _tabTarget to not be a tab target:
          items.forEach(function(item) {
            item._isTabTarget = item === value;
          });
        }
      }
    },

    /** @private */
    _onItemMouseEnter: function(event) {
      if (event.target.disabled) {
        return;
      }

      // if the component already has the focus, we can change the activeElement.
      if (this.classList.contains('is-focused')) {
        this._focusItem(event.target);
      }
      // since we cannot give focus to the item, we mark it as highlighted
      else {
        event.target.classList.add('is-highlighted');
      }
    },

    /** @private */
    _onItemMouseLeave: function(event) {
      event.target.classList.remove('is-highlighted');
    },

    /** @private */
    _onFocus: function(event) {
      this.classList.add('is-focused');
    },

    /** @private */
    _onBlur: function(event) {
      // required otherwise the latest item that had the focus would get it again instead of the selected item
      this._resetTabTarget();
      this.classList.remove('is-focused');
    },

    /** @private */
    _onItemClick: function(event) {
      var item = event.matchedTarget;
      if (item) {
        event.preventDefault();
        event.stopPropagation();

        // stores the value to be able to determine if something changed
        var oldSelectedValue = item.selected;

        this._selectItem(item);
        this._focusItem(item);

        // since we need to know that the user interacted with the list, we need to trigger an event to indicate that
        // interaction ocurred even though the selection is the same.
        if (oldSelectedValue === item.selected) {
          this.trigger('coral-selectlist:change', {
            oldSelection: this._getSelection(),
            selection: this._getSelection()
          });
        }
      }
    },

    /** @private */
    _focusItem: function(item) {
      if (item) {
        item.focus();
      }

      this._tabTarget = item;
    },

    /** @private */
    _onToggleItemKey: function(event) {
      event.preventDefault();
      event.stopPropagation();

      var item = event.target;

      // stores the value to be able to determine if something changed
      var oldSelectedValue = item.selected;

      this._selectItem(item);
      this._focusItem(item);

      // since we need to know that the user interacted with the list, we need to trigger an event to indicate that
      // interaction ocurred even though the selection is the same.
      if (oldSelectedValue === item.selected) {
        this.trigger('coral-selectlist:change', {
          oldSelection: this._getSelection(),
          selection: this._getSelection()
        });
      }
    },

    /** @private */
    _focusPreviousItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getPreviousSelectable(event.target));
    },

    /** @private */
    _focusNextItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getNextSelectable(event.target));
    },

    /** @private */
    _onHomeKey: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getFirstSelectable());
    },

    /** @private */
    _onEndKey: function(event) {
      event.preventDefault();
      event.stopPropagation();
      this._focusItem(this.items.getLastSelectable());
    },

    _keypressTimeoutID: null,
    _keypressSearchString: '',

    /**
      Handles keypress event for alphanumeric search.

      @param {KeyboardEvent} event
        The keyboard event.
      @private
     */
    _onKeyPress: function(event) {
      var self = this;
      // The string entered when the key was pressed
      var newString = String.fromCharCode(event.which);

      // Clear the timeout before the _keypressSearchString is cleared
      clearTimeout(this._keypressTimeoutID);

      // If the character entered does not match the last character entered, append it to the _keypressSearchString
      if (newString !== this._keypressSearchString) {
        this._keypressSearchString += newString;
      }

      // Set a timeout so that _keypressSearchString is cleared after 1 second
      this._keypressTimeoutID = setTimeout(function() {
        self._keypressSearchString = '';
      }, KEYPRESS_TIMEOUT_DURATION);

      // Search within selectable items
      var selectableItems = this.items._getSelectableItems();

      // Remember the index of the focused item within the array of selectable items
      var currentIndex = selectableItems.indexOf(this._tabTarget);

      this._keypressSearchString = this._keypressSearchString.trim().toLowerCase();

      var start;
      // If the currentIndex is -1, meaning no item has focus, start from the beginning
      if (currentIndex === -1) {
        start = 0;
      }
      else if (this._keypressSearchString.length === 1) {
        // Otherwise, if there is only one character to compare, start comparing from the next item after the currently
        // focused item. This allows us to iterate through items beginning with the same character
        start = currentIndex + 1;
      }
      else {
        start = currentIndex;
      }

      var newFocusItem;
      var comparison;
      var item;

      // Compare _keypressSearchString against item text until a match is found
      for (var i = start; i < selectableItems.length; i++) {
        item = selectableItems[i];
        comparison = item.textContent.trim().toLowerCase();
        if (comparison.indexOf(this._keypressSearchString) === 0) {
          newFocusItem = item;
          break;
        }
      }

      // If no match is found, continue searching for a match starting from the top
      if (!newFocusItem) {
        for (var j = 0; j < start; j++) {
          item = selectableItems[j];
          comparison = item.textContent.trim().toLowerCase();
          if (comparison.indexOf(this._keypressSearchString) === 0) {
            newFocusItem = item;
            break;
          }
        }
      }

      // If a match has been found, focus the matched item
      if (newFocusItem !== undefined) {
        this._focusItem(newFocusItem);
      }
    },

    /**
      Invocation of any of the 4 mixin.selectionList handlers referenced below may result in the internal '_tabTarget'
      property changing. Note that these are not overrides, but additions, invoked via 'Coral.commons.callAll'.

      @private
    */
    _onItemSelected: function() {
      this._resetTabTarget();
    },

    /** @private **/
    _onItemDeselected: function() {
      this._resetTabTarget();
    },

    /** @private **/
    _onItemAttached: function() {
      this._resetTabTarget();
    },

    /** @private **/
    _onItemDetached: function() {
      this._resetTabTarget();
    },

    /**
      Determine what item should get focus (if any) when the user tries to tab into the SelectList. This should be the
      first selected item, or the first selectable item otherwise. When neither is available, it cannot be tabbed into
      the SelectList.

      @private
    */
    _resetTabTarget: function() {
      if (!this._resetTabTargetScheduled) {
        this._resetTabTargetScheduled = true;

        Coral.commons.nextFrame(function() {
          this._resetTabTargetScheduled = false;

          // since hidden items cannot have focus, we need to make sure the tabTarget is not hidden
          var selectedItems = this.items._getNonNestedItems().filter(function(item) {
            return item.hasAttribute('selected') && !item.hasAttribute('disabled') && !item.hasAttribute('hidden');
          });
          this._tabTarget = selectedItems.length ? selectedItems[0] : this.items.getFirstSelectable();
        }.bind(this));
      }
    },

    /** @private */
    _onScroll: function() {
      clearTimeout(this._scrollTimeout);
      this._scrollTimeout = setTimeout(this._onDebouncedScroll, SCROLL_DEBOUNCE);
    },

    /**
      @fires Coral.SelectList#coral-selectlist:scrollbottom

      @private
    */
    _onDebouncedScroll: function() {
      if (this.scrollTop >= this.scrollHeight - this.clientHeight - SCROLL_BOTTOM_THRESHOLD) {
        this.trigger('coral-selectlist:scrollbottom');
      }
    },

    /** @private */
    _initialize: function() {
      // we correctly bind the scroll event
      this._onDebouncedScroll = this._onDebouncedScroll.bind(this);
    },

    /**
      Handles component focus.

      @ignore
    */
    focus: function() {
      // avoids moving the focus once it is already inside the component
      if (!this.contains(document.activeElement)) {
        this._resetTabTarget();
        this._focusItem(this._tabTarget);
      }
    }

    /**
      Triggered when the user scrolls to near the bottom of the list. This can be useful for when additional items can
      be loaded asynchronously (i.e., infinite scrolling).

      @event Coral.SelectList#coral-selectlist:scrollbottom

      @param {Object} event
        Event object.
    */

    /**
      Triggered when the selection changes or the user interacts with the list. For example, if something is already
      selected and the user clicks on it again, even it it does not cause the selection to change, a
      <code>coral-selectlist:change</code> event will be triggered so that components can identify that the user
      interacted with the SelectList.

      @event Coral.SelectList#coral-selectlist:change

      @param {Object} event
        Event object.
      @param {Object} event.detail
        Detail object.
      @param {HTMLElement|Array.<HTMLElement>} event.detail.oldSelection
        The old item selection. When {@link Coral.SelectList#multiple}, it includes an Array.
      @param {HTMLElement|Array.<HTMLElement>} event.detail.selection
        The item selection. When {@link Coral.SelectList#multiple}, it includes an Array.
    */
  });

  Coral.register( /** @lends Coral.SelectList.Item# */ {
    /**
      @class Coral.SelectList.Item
      @classdesc A SelectList.Item component
      @extends Coral.Component
      @mixes Coral.mixin.selectionList.Item
      @borrows Coral.mixin.selectionList.Item#disabled as Coral.SelectList.Item#disabled
      @borrows Coral.mixin.selectionList.Item#selected as Coral.SelectList.Item#selected
      @htmltag coral-selectlist-item
    */
    name: 'SelectList.Item',
    tagName: ITEM_TAG_NAME,
    className: 'coral3-SelectList-item',

    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-selectlist',
        role: 'option'
      })
    ],

    events: {
      'focus': '_onFocus',
      'blur': '_onBlur'
    },

    properties: {

      /**
        Value of the item. If not explicitly set, the value of <code>Node.textContent</code> is returned.

        @type {String}
        @default ""
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.SelectList.Item#
      */
      'value': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        get: function() {
          return typeof this._value === 'undefined' ? this.textContent : this._value;
        }
      },

      /**
        The content element for the item.

        @type {HTMLElement}
        @contentzone
        @readonly
        @memberof Coral.SelectList.Item#
       */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      },

      /** @private **/
      '_isTabTarget': {
        default: false,
        sync: function() {
          this.setAttribute('tabindex', this.__isTabTarget ? 0 : -1);
        }
      }
    },

    /** @private */
    _onFocus: function(event) {
      this.classList.add('is-highlighted');
    },

    /** @private */
    _onBlur: function(event) {
      this.classList.remove('is-highlighted');
    }
  });

  Coral.register( /** @lends Coral.SelectList.Group# */ {
    /**
      @class Coral.SelectList.Group
      @classdesc A SelectList.Group component
      @extends Coral.Component
      @htmltag coral-selectlist-group
    */
    name: 'SelectList.Group',
    tagName: GROUP_TAG_NAME,
    className: 'coral3-SelectList-group',

    properties: {
      /**
        The label of the group. It reflects the <code>label</code> attribute to the DOM.

        @type {String}
        @default ""
        @htmlattribute label
        @htmlattributereflected
        @memberof Coral.SelectList.Group#
      */
      'label': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        sync: function() {
          this.setAttribute('aria-label', this.label);
        }
      },

      /**
        The Collection Interface that allows interacting with the {@link Coral.SelectList.Item}
        elements that the group contains.

        See {@link Coral.Collection} for more details regarding collection APIs.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.SelectList.Group#
      */
      'items': {
        set: function() {},
        get: function() {
          if (!this._groups) {
            this._groups = new SelectListCollection(this, ITEM_TAG_NAME);
          }
          return this._groups;
        }
      }
    },

    /** @private */
    _initialize: function() {
      this.setAttribute('role', 'group');
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-select"] = {"en-US":{"Select":"Select"},"fr-FR":{"Select":"Sélectionner"},"de-DE":{"Select":"Auswählen"},"it-IT":{"Select":"Seleziona"},"es-ES":{"Select":"Seleccionar"},"pt-BR":{"Select":"Selecionar"},"ja-JP":{"Select":"選択"},"ko-KR":{"Select":"선택"},"zh-CN":{"Select":"选择"},"zh-TW":{"Select":"選取"},"nl-NL":{"Select":"Selecteren"},"da-DK":{"Select":"Vælg"},"fi-FI":{"Select":"Valitse"},"nb-NO":{"Select":"Velg"},"sv-SE":{"Select":"Välj"},"cs-CZ":{"Select":"Vybrat"},"pl-PL":{"Select":"Wybierz"},"ru-RU":{"Select":"Выберите"},"tr-TR":{"Select":"Seç"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Select"] = window["Coral"]["templates"]["Select"] || {};
window["Coral"]["templates"]["Select"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  
  var buttonId = Coral.commons.getUID();
  var listId = Coral.commons.getUID();

  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["button"] = document.createElement("button","coral-button");
  el2.setAttribute("handle", "button");
  el2.setAttribute("type", "button");
  el2.setAttribute("is", "coral-button");
  el2.setAttribute("block", "");
  el2.setAttribute("role", "combobox");
  el2.setAttribute("aria-expanded", "false");
  el2.setAttribute("aria-haspopup", "true");
  el2.id = buttonId;
  el2.setAttribute("aria-controls", listId);
  el2.setAttribute("aria-owns", listId);
  el2.className += " coral3-Select-button";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["icon"] = document.createElement("coral-icon");
  el4.setAttribute("handle", "icon");
  el4.setAttribute("icon", "chevronDown");
  el4.setAttribute("size", "xs");
  el4.className += " coral3-Select-openIcon";
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el2.appendChild(el5);
  var el6 = this["label"] = document.createElement("span");
  el6.setAttribute("handle", "label");
  el6.className += " coral3-Select-label";
  el6.setAttribute("role", "textbox");
  el6.setAttribute("aria-readonly", "true");
  el6.textContent = "​";
  el2.appendChild(el6);
  var el7 = document.createTextNode("\n");
  el2.appendChild(el7);
  frag.appendChild(el2);
  var el8 = document.createTextNode("\n");
  frag.appendChild(el8);
  var el9 = this["overlay"] = document.createElement("coral-overlay");
  el9.setAttribute("handle", "overlay");
  el9.className += " coral3-Select-overlay";
  el9.setAttribute("trapfocus", "on");
  el9.setAttribute("focusonshow", "on");
  el9.setAttribute("target", "#"+buttonId);
  el9.setAttribute("role", "presentation");
  el9.setAttribute("offset", "-1");
  el9.setAttribute("alignmy", "left top");
  el9.setAttribute("alignat", "left bottom");
  var el10 = document.createTextNode("\n  ");
  el9.appendChild(el10);
  var el11 = this["list"] = document.createElement("coral-selectlist");
  el11.setAttribute("handle", "list");
  el11.className += " coral3-Select-selectList";
  el11.setAttribute("role", "listbox");
  el11.id = listId;
  el9.appendChild(el11);
  var el12 = document.createTextNode("\n");
  el9.appendChild(el12);
  frag.appendChild(el9);
  var el13 = document.createTextNode("\n");
  frag.appendChild(el13);
  var el14 = this["input"] = document.createElement("input");
  el14.setAttribute("handle", "input");
  el14.setAttribute("type", "hidden");
  frag.appendChild(el14);
  var el15 = document.createTextNode("\n");
  frag.appendChild(el15);
  var el16 = this["nativeSelect"] = document.createElement("select");
  el16.setAttribute("handle", "nativeSelect");
  el16.className += " coral3-Select-select";
  el16.setAttribute("tabindex", "-1");
  frag.appendChild(el16);
  var el17 = document.createTextNode("\n");
  frag.appendChild(el17);
  var el18 = this["taglist"] = document.createElement("coral-taglist");
  el18.setAttribute("handle", "taglist");
  el18.className += " coral3-Select-tagList";
  frag.appendChild(el18);
  var el19 = document.createTextNode("\n");
  frag.appendChild(el19);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for Select variant values.

    @enum {String}
    @memberof Coral.Select
  */
  var variant = {
    /** A default, gray Select. */
    DEFAULT: 'default',
    /** A Select with no border or background. */
    QUIET: 'quiet'
  };

  /**
    Offset used to separate the overlay from the button based on the variant.

    @private
  */
  var overlayOffset = {
    'default': -1,
    'quiet': 4
  };

  var CLASSNAME = 'coral3-Select';

  // builds a string containing all possible variant classnames. This will be used to remove
  // classnames when the variant changes.
  var ALL_VARIANT_CLASSES = [];
  for (var variantKey in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantKey]);
  }

  // used in 'auto' mode to determine if the client is on mobile.
  var IS_MOBILE_DEVICE = navigator.userAgent.match(/iPhone|iPad|iPod|Android/i) !== null;

  /**
    Extracts the value from the item in case no explicit value was provided.

    @param {HTMLElement} item
      the item whose value will be extracted.

    @returns {String} the value that will be submitted for this item.

    @private
  */
  var itemValueFromDOM = function(item) {
    var attr = item.getAttribute('value');
    // checking explicitely for null allows to differenciate between non set values and empty strings
    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };

  /**
    Calculates the difference between two given arrays. It returns the items that are in a that are not in b.

    @param {Array.<String>} a
    @param {Array.<String>} b

    @returns {Array.<String>}
      the difference between the arrays.
  */
  var arrayDiff = function(a, b) {
    return a.filter(function(item) {
      return !b.some(function(item2) {
          return item === item2;
        });
    });
  };

  Coral.register( /** @lends Coral.Select# */ {
    /**
      @class Coral.Select
      @classdesc A Select component
      @extends Coral.Component
      @extends Coral.mixin.formField

      @htmltag coral-select
    */
    // Based on ARIA standard http://www.w3.org/TR/wai-aria/roles#select
    name: 'Select',
    tagName: 'coral-select',
    className: CLASSNAME,
    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'coral-collection:add coral-taglist': '_onInternalEvent',
      'coral-collection:add coral-selectlist': '_onSelectListItemAdd',

      'coral-collection:remove coral-taglist': '_onInternalEvent',
      'coral-collection:remove coral-selectlist': '_onInternalEvent',

      // item events
      'coral-select-item:_valuechanged coral-select-item': '_onItemValueChange',
      'coral-select-item:_contentchanged coral-select-item': '_onItemContentChange',
      'coral-select-item:_disabledchanged coral-select-item': '_onItemDisabledChange',
      'coral-select-item:_selectedchanged coral-select-item': '_onItemSelectedChange',

      'coral-selectlist:change': '_onSelectListChange',
      'coral-selectlist:scrollbottom': '_onSelectListScrollBottom',

      'change coral-taglist': '_onTagListChange',
      'change select': '_onNativeSelectChange',
      'click select': '_onNativeSelectClick',
      // selector required since tags also have .coral3-Select-button
      'click > .coral3-Select-button': '_onButtonClick',

      'key:space > .coral3-Select-button': '_onSpaceKey',
      'key:down > .coral3-Select-button': '_onSpaceKey',
      'key:tab coral-selectlist-item': '_onTabKey',
      'key:tab+shift coral-selectlist-item': '_onTabKey',

      'coral-overlay:close': '_onOverlayToggle',
      'coral-overlay:open': '_onOverlayToggle',
      'coral-overlay:positioned': '_onOverlayPositioned',
      'coral-overlay:beforeopen': '_onInternalEvent',
      'coral-overlay:beforeclose': '_onInternalEvent',

      'global:click': '_onGlobalClick',
      'global:touchstart': '_onGlobalClick'
    },

    properties: {
      /**
        The item collection.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Select#
      */
      'items': {
        get: function() {
          // we do lazy initialization of the collection
          if (!this._items) {
            this._items = new Coral.SelectableCollection({
              host: this,
              itemTagName: 'coral-select-item',
              onItemAdded: this._onItemAdded,
              onItemRemoved: this._onItemRemoved,
              onCollectionChange: this._onCollectionChange
            });
          }
          return this._items;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Indicates whether the select accepts multiple selected values.

        @type {Boolean}
        @default false
        @htmlattribute multiple
        @htmlattributereflected
        @memberof Coral.Select#
      */
      'multiple': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          this._multiple = value;

          // taglist should not be in DOM if multiple === false
          if (!value) {
            this.removeChild(this._elements.taglist);
          }
          else {
            this.appendChild(this._elements.taglist);
          }

          // we need to remove and re-add the native select to loose the selection
          if (this._nativeInput) {
            this.removeChild(this._elements.nativeSelect);
          }
          this._elements.nativeSelect.multiple = value;
          this._elements.nativeSelect.selectedIndex = -1;
          if (this._nativeInput) {
            if (value) {
              this.insertBefore(this._elements.nativeSelect, this._elements.taglist);
            }
            else {
              this.appendChild(this._elements.nativeSelect);
            }
          }

          this._elements.list.multiple = value;

          // sets the correct name for value submission
          this._setName(this.name);

          // we need to make sure the selection is valid
          this._setStateFromDOM();

          // everytime multiple changes, the state of the selectlist and taglist need to be updated
          this.items.getAll().forEach(function(item) {
            // if _elements is not available it means the item is not yet initialized. in this case, we can ignore
            // it and rely on the normal initialization
            if (item._elements) {
              if (this.multiple && item.hasAttribute('selected')) {
                if (item._elements.selectListItem) {
                  item._elements.selectListItem.setAttribute('hidden', '');
                }
                this._addTagToTagList(item);
              }
              else {
                if (item._elements.selectListItem) {
                  item._elements.selectListItem.removeAttribute('hidden');
                }
                // taglist is never used for multiple = false
                this._removeTagFromTagList(item);

                // when multiple = false and the item is selected, the value needs to be updated in the input
                if (item.hasAttribute('selected')) {
                  this._elements.input.value = itemValueFromDOM(item);
                }
              }
            }
          }, this);
        }
      },

      /**
        Contains a hint to the user of what can be selected in the component. If no placeholder is provided, the first
        option will be displayed in the component.

        @type {String}
        @default ""
        @htmlattribute placeholder
        @htmlattributereflected
        @memberof Coral.Select#
      */
      // p = placeholder, m = multiple, se = selected
      // case 1:  p +  m +  se = p
      // case 2:  p +  m + !se = p
      // case 3: !p + !m +  se = se
      // case 4: !p + !m + !se = firstSelectable (native behavior)
      // case 5:  p + !m +  se = se
      // case 6:  p + !m + !se = p
      // case 7: !p +  m +  se = 'Select'
      // case 8: !p +  m + !se = 'Select'
      'placeholder': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string,
        alsoSync: 'selectedItem',
        sync: function() {
          // case 1:  p +  m +  se = p
          // case 2:  p +  m + !se = p
          // case 6:  p + !m + !se = p
          if (this.placeholder && (this.multiple || !this.selectedItem)) {
            this._elements.button.classList.add('is-placeholder');
            this._elements.label.textContent = this.placeholder;
          }
          // case 7: !p +  m +  se = 'Select'
          // case 8: !p +  m + !se = 'Select'
          else if (this.multiple) {
            this._elements.button.classList.add('is-placeholder');
            this._elements.label.textContent = Coral.i18n.get('Select');
          }
          // case 4: !p + !m + !se = firstSelectable (native behavior)
          else if (!this.selectedItem) {
            // we clean the value because there is no selected item
            this._elements.input.value = '';

            // gets the first candidate for selection
            var placeholderItem = this.items._getFirstSelectable();
            this._elements.button.classList.remove('is-placeholder');

            if (placeholderItem) {
              // selects using the attribute in case the item is not yet initialized
              placeholderItem.setAttribute('selected', '');
              this._elements.label.innerHTML = placeholderItem.innerHTML;
            }
            else {
              // label must be cleared when there is no placeholder and no item to select
              this._elements.label.textContent = '';
            }
          }
        }
      },

      // JSDocs inherited
      'name': {
        get: function() {
          return this.multiple ? this._elements.taglist.name : this._elements.input.name;
        },
        set: function(value) {
          this._setName(value);
        }
      },

      // JSDocs inherited
      'value': {
        get: function() {
          // we leverage the internal elements to know the value, this way we are always sure that the server submission
          // will be correct
          return this.multiple ? this._elements.taglist.value : this._elements.input.value;
        },
        set: function(value) {
          // we rely on the the values property to handle this correctly
          this.values = [value];
        }
      },

      /**
        The current selected values, as submitted during form submission. When {@link Coral.Select#multiple} is
        <code>false</code>, this will be an array of length 1.

        @type {Array.<String>}
        @memberof Coral.Select#
      */
      'values': {
        attribute: null,
        validate: [
          Coral.validate.valueMustChange,
          function(values) {
            return Array.isArray(values);
          }
        ],
        get: function() {
          if (this.multiple) {
            return this._elements.taglist.values;
          }
          else {
            // if there is a selection, we return whatever value it has assigned
            return this.selectedItem ? [this._elements.input.value] : [];
          }
        },
        set: function(values) {
          // when multiple = false, we explicitely ignore the other values and just set the first one
          if (!this.multiple && values.length > 1) {
            values = [values[0]];
          }

          // gets all the items
          var items = this.items.getAll();

          var itemValue;
          // if multiple, we need to explicitely set the selection state of every item
          if (this.multiple) {
            items.forEach(function(item) {
              // we use DOM API instead of properties in case the item is not yet initialized
              itemValue = itemValueFromDOM(item);
              // if the value is located inside the values array, then we set the item as selected
              item[values.indexOf(itemValue) !== -1 ? 'setAttribute' : 'removeAttribute']('selected', '');
            });
          }
          // if single selection, we find the first item that matches the value and deselect everything else. in case,
          // no item matches the value, we may need to find a selection candidate
          else {
            var targetItem;
            // since multiple = false, there is only 1 value value
            var value = values[0] || '';

            items.forEach(function(item) {
              // small optimization to avoid calculating the value from every item
              if (!targetItem) {
                itemValue = itemValueFromDOM(item);

                if (itemValue === value) {
                  // selecting the item will cause the taglist or input to be updated
                  item.setAttribute('selected', '');
                  // we store the first ocurrence, afterwards we deselect all items
                  targetItem = item;

                  // since we found our target item, we continue to avoid removing the selected attribute
                  return;
                }
              }

              // every-non targetItem must be deselected
              item.removeAttribute('selected');
            });

            // if no targetItem was found, _setStateFromDOM will make sure that the state is valid
            if (!targetItem) {
              this._setStateFromDOM();
            }
          }
        }
      },

      // JSDocs inherited
      'required': {
        sync: function() {
          this._elements.input.required = this.required;
          this._elements.taglist.required = this.required;
        }
      },

      // JSDocs inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
        }
      },

      // JSDocs inherited
      'disabled': {
        sync: function() {
          this._elements.button.disabled = this.disabled || this.readOnly;
          this._elements.input.disabled = this.disabled || this.readOnly;
          this._elements.taglist.disabled = this.disabled || this.readOnly;
        }
      },

      // JSDocs inherited
      'readOnly': {
        sync: function() {
          this._elements.button.disabled = this.readOnly || this.disabled;
          this._elements.input.readOnly = this.readOnly || this.disabled;
          this._elements.taglist.readOnly = this.readOnly || this.disabled;
        }
      },

      // JSDocs inherited
      'labelledBy': {
        sync: function() {
          if (this.labelledBy) {
            this._elements.nativeSelect.setAttribute('aria-labelledby', this.labelledBy);
          }
          else {
            this._elements.nativeSelect.removeAttribute('aria-labelledby');
          }
          this._elements.taglist.labelledBy = this.labelledBy;
        }
      },

      /**
        Returns the first selected item in the Select. The value <code>null</code> is returned if no element is
        selected.

        @type {?HTMLElement}
        @readonly
        @memberof Coral.Select#
      */
      'selectedItem': {
        get: function() {
          return this.multiple ? this.items._getFirstSelected() : this.items._getLastSelected();
        },
        set: function() {
          // Read-only
        },
        alsoSync: 'placeholder',
        sync: function() {
          // case 3: !p + !m +  se = se
          // case 5:  p + !m +  se = se
          if (this.selectedItem && !this.multiple) {
            this._elements.button.classList.remove('is-placeholder');
            this._elements.label.innerHTML = this.selectedItem.innerHTML;
          }
        }
      },

      /**
        Returns an Array containing the set selected items.

        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.Select#
      */
      'selectedItems': {
        get: function() {
          if (this.multiple) {
            return this.items._getAllSelected();
          }
          else {
            var item = this.selectedItem;
            return item ? [item] : [];
          }
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Indicates that the Select is currently loading remote data. This will set the wait indicator inside the list.

        @type {Boolean}
        @default false
        @htmlattribute loading
        @memberof Coral.Select#
      */
      'loading': {
        get: function() {
          return this._elements.list.loading;
        },
        set: function(value) {
          this._elements.list.loading = value;
        }
      },

      /**
        The Select's variant.

        @type {Coral.Select.variant}
        @default Coral.Select.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Select#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        set: function(value) {
          this._variant = value;

          // we need to handle the default value of the button because it is not 'default'. this is done in the set
          // since the button will have its own sync
          this._elements.button.variant = value === variant.DEFAULT ?
            Coral.Button.variant.DEFAULT :
            Coral.Button.variant.QUIET;
        },
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== Coral.Select.variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }

          // sets the separation of the overlay from the button based on the variant
          this._elements.overlay.offset = overlayOffset[this.variant];
        }
      }
    },

    /** @ignore */
    _setName: function(value) {
      if (this.multiple) {
        this._elements.input.name = '';
        this._elements.taglist.name = value;
      }
      else {
        this._elements.taglist.name = '';
        this._elements.input.name = value;
      }
    },

    /**
      @param {Boolean} [checkAvailableSpace=false]
        If <code>true</code>, the event is triggered based on the available space.

      @private
    */
    _showOptions: function(checkAvailableSpace) {
      if (checkAvailableSpace) {
        // threshold in pixels
        var ITEM_SIZE_THRESHOLD = 30;

        var scrollHeight = this._elements.list.scrollHeight;
        var viewportHeight = this._elements.list.clientHeight;
        var scrollTop = this._elements.list.scrollTop;
        // we should not do this, but it increases performance since we do not need to find the item
        var loadIndicator = this._elements.list._elements.loadIndicator;

        // we remove the size of the load indicator
        if (loadIndicator && loadIndicator.parentNode) {
          var outerHeight = function(el) {
            var height = el.offsetHeight;
            var style = getComputedStyle(el);

            height += parseInt(style.marginTop) + parseInt(style.marginBottom);
            return height;
          };

          scrollHeight -= outerHeight(loadIndicator);
        }

        // if we are not close to the bottom scroll, we cancel triggering the event
        if (scrollTop + viewportHeight < scrollHeight - ITEM_SIZE_THRESHOLD) {
          return;
        }
      }

      // we do not show the list with native
      if (!this._useNativeInput) {
        // Show the overlay
        this._elements.overlay.open = true;
      }

      // Trigger an event
      // @todo: maybe we should only trigger this event when the button is toggled and we have space for more items
      var event = this.trigger('coral-select:showitems', {
        // amount of items in the select
        start: this.items.length
      });

      // while using native there is no need to show the loading
      if (!this._useNativeInput) {
        // if the default is prevented, we should the loading indicator
        this._elements.list.loading = event.defaultPrevented;
      }
    },

    /** @private */
    _hideOptions: function() {
      this._elements.overlay.open = false;

      this.trigger('coral-select:hideitems');
    },

    /** @ignore */
    _onGlobalClick: function(event) {
      if (!this._elements.overlay.open) {
        return;
      }

      var eventTargetWithinOverlayTarget = this._elements.button.contains(event.target);
      var eventTargetWithinItself = this._elements.overlay.contains(event.target);
      if (!eventTargetWithinOverlayTarget && !eventTargetWithinItself) {
        this._hideOptions();
      }
    },

    /** @private */
    _onSelectListItemAdd: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      // When items have been added, we are no longer loading
      this.loading = false;

      // Reset height
      this._elements.list.style.height = '';

      // Measure actual height
      var style = window.getComputedStyle(this._elements.list);
      var height = parseInt(style.height, 10);
      var maxHeight = parseInt(style.maxHeight, 10);

      if (height < maxHeight) {
        // Make it scrollable
        this._elements.list.style.height = height - 1 + 'px';
      }
    },

    /** @private */
    _onInternalEvent: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();
    },

    /** @ignore */
    _onItemAdded: function(item) {
      var selectListItemParent = this._elements.list;

      var selectListItem = item._elements.selectListItem || new Coral.SelectList.Item();

      // @todo: Make sure it is added at the right index.
      selectListItemParent.appendChild(selectListItem);

      selectListItem.set({
        value: item.value,
        content: {
          innerHTML: item.content.innerHTML
        },
        disabled: item.disabled,
        selected: item.selected
      }, true);

      var nativeOption = item._elements.nativeOption || new Option();

      // @todo: make sure it is added at the right index.
      this._elements.nativeSelect.appendChild(nativeOption);

      // Need to store the initially selected values in the native select so that it can be reset
      if (this._initialValues.indexOf(item.value) !== -1) {
        nativeOption.setAttribute('selected', 'selected');
      }

      nativeOption.selected = item.selected;
      nativeOption.value = item.value;
      nativeOption.disabled = item.disabled;
      nativeOption.innerHTML = item.content.innerHTML;

      if (this.multiple) {
        // in case it was selected before it was added
        if (item.selected) {
          selectListItem.hidden = true;
          this._addTagToTagList(item);
        }
      }
      else {
        // Make sure the input value is set to the selected item
        if (item.selected) {
          this._elements.input.value = item.value;
        }
      }

      item._elements.selectListItem = selectListItem;
      item._elements.nativeOption = nativeOption;

      selectListItem._elements.selectItem = item;
      nativeOption._selectItem = item;
    },

    /** @private */
    _onItemRemoved: function(item) {
      if (item._elements && item._elements.selectListItem) {
        item._elements.selectListItem.remove();
        item._elements.selectListItem._elements.selectItem = undefined;
        item._elements.selectListItem = undefined;
      }

      if (item._elements && item._elements.nativeOption) {
        this._elements.nativeSelect.removeChild(item._elements.nativeOption);
        item._elements.nativeOption._selectItem = undefined;
        item._elements.nativeOption = undefined;
      }

      this._removeTagFromTagList(item, true);
    },

    /** @private */
    _onItemSelected: function(item) {
      // in case the component is not in the DOM or the internals have not been created we force it
      if (!item._elements.selectListItem || !item._elements.selectListItem.parentNode) {
        this._onItemAdded(item);
      }

      item._elements.selectListItem.selected = true;
      item._elements.nativeOption.selected = true;

      if (this.multiple) {
        this._addTagToTagList(item);
        // we need to hide the item from further selections
        // @todo: what happens when ALL items have been selected
        //  1. a message is disabled (i18n?)
        //  2. we don't try to open the selectlist (native behavior).
        item._elements.selectListItem.hidden = true;
      }
      else {
        this._elements.input.value = item.value;
      }
    },

    /** @private */
    _onItemDeselected: function(item) {
      // in case the component is not in the DOM or the internals have not been created we force it
      if (!item._elements.selectListItem || !item._elements.selectListItem.parentNode) {
        this._onItemAdded(item);
      }

      item._elements.selectListItem.selected = false;
      item._elements.nativeOption.selected = false;

      // the hidden items need to be reinstated
      if (this.multiple) {
        // we use the internal reference to remove the related tag from the taglist
        this._removeTagFromTagList(item);
        item._elements.selectListItem.hidden = false;
      }
    },

    /**
      Detects when something inside the select list changes.

      @private
    */
    _onSelectListChange: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
      // a change event
      if (this._bulkSelectionChange) {
        return;
      }

      var oldSelection = event.detail.oldSelection || [];
      oldSelection = !Array.isArray(oldSelection) ? [oldSelection] : oldSelection;

      var selection = event.detail.selection || [];
      selection = !Array.isArray(selection) ? [selection] : selection;

      // if the arrays are the same, there is no point in calculating the selection changes
      if (event.detail.oldSelection !== event.detail.selection) {
        this._bulkSelectionChange = true;

        // we deselect first the ones that have to go
        var diff = arrayDiff(oldSelection, selection);
        diff.forEach(function(listItem) {
          // selectlist will report on removed items
          if (listItem._elements.selectItem) {
            listItem._elements.selectItem.removeAttribute('selected');
          }
        });

        // we only sync the items that changed
        var newSelection = arrayDiff(selection, oldSelection);
        newSelection.forEach(function(listItem) {
          if (listItem._elements.selectItem) {
            listItem._elements.selectItem.setAttribute('selected', '');
          }
        });

        this._bulkSelectionChange = false;

        // hides the list since something was selected. if the overlay was open, it means there was user interaction so
        // the necessary events need to be triggered
        if (this._elements.overlay.open) {
          // closes and triggers the hideitems event
          this._hideOptions();

          // if there is a change in the selection, we trigger a change event
          if (newSelection.length) {
            this.trigger('change');
          }
        }
      }
      // in case they are the same, we just need to trigger the hideitems event when appropiate, and that is when the
      // overlay was previously open
      else if (this._elements.overlay.open) {
        // closes and triggers the hideitems event
        this._hideOptions();
      }
    },

    /** @private */
    _onTagListChange: function(event) {
      // cancels the change event from the taglist
      event.stopImmediatePropagation();

      // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
      // a change event
      if (this._bulkSelectionChange) {
        return;
      }

      this._bulkSelectionChange = true;

      var values = event.target.values;
      // we use the selected items, because they are the only possible items that may change
      var itemValue;
      this.items._getAllSelected().forEach(function(item) {
        // we use DOM API instead of properties in case the item is not yet initialized
        itemValue = itemValueFromDOM(item);
        // if the item is inside the values array, then it has to be selected
        item[values.indexOf(itemValue) !== -1 ? 'setAttribute' : 'removeAttribute']('selected', '');
      });

      this._bulkSelectionChange = false;

      // if the taglist is empty, we should return the focus to the button
      if (!values.length) {
        this._elements.button.focus();
      }

      // reparents the change event with the select as the target
      this.trigger('change');
    },

    /** @private */
    _addTagToTagList: function(item) {
      // we prepare the tag
      item._elements.tag = item._elements.tag || new Coral.Tag();
      item._elements.tag.set({
        value: item.value,
        multiline: true,
        label: {
          innerHTML: item.content.innerHTML
        }
      }, true);

      // we add the new tag at the end
      this._elements.taglist.items.add(item._elements.tag);
    },

    /** @private */
    _removeTagFromTagList: function(item, destroy) {
      if (item._elements && item._elements.tag) {
        item._elements.tag.remove();
        // we only remove the reference if destroy is passed, this allow us to recycle the tags when possible
        item._elements.tag = destroy ? undefined : item._elements.tag;
      }
    },

    /** @private */
    _onSelectListScrollBottom: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      if (this._elements.overlay.open) {
        // Checking if the overlay is open guards against debounced scroll events being handled after an overlay has
        // already been closed (e.g. clicking the last element in a selectlist always reopened the overlay emediately
        // after closing)

        // triggers the corresponding event
        // since we got the the event from select list we need to trigger the event
        this._showOptions();
      }
    },

    /** @private */
    _onButtonClick: function(event) {
      event.preventDefault();

      if (this.disabled) {
        return;
      }

      // if native is required, we do not need to do anything
      if (!this._useNativeInput) {
        // @todo: this was removed cause otherwise the coral-select:showitems event is never triggered.
        // if this is a multiselect and all items are selected, there should be nothing in the list to focus so do
        // nothing.
        // if (this.multiple && this.selectedItems.length === this.items.length) {
        //   return;
        // }

        // Toggle openness
        if (this._elements.overlay.open) {
          this._hideOptions();
        }
        else {
          // event should be triggered based on the contents
          this._showOptions(true);
        }
      }
    },

    /** @private */
    _onNativeSelectClick: function(event) {
      this._showOptions(false);
    },

    /** @private */
    _onSpaceKey: function(event) {
      if (this.disabled) {
        return;
      }

      event.preventDefault();

      if (this._useNativeInput) {
        // we try to open the native select
        this._elements.nativeSelect.dispatchEvent(new MouseEvent('mousedown'));
      }
      else {
        if (!this._elements.overlay.open || event.keyCode === Coral.Keys.keyToCode('space')) {
          this._elements.button.click();
        }
      }
    },

    /**
      Prevents tab key default handling on selectList Items.

      @private
    */
    _onTabKey: function(event) {
      event.preventDefault();
    },

    /** @private */
    _onOverlayToggle: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      this._elements.button.classList.toggle('is-selected', event.target.open);

      // @a11y
      this._elements.button.setAttribute('aria-expanded', event.target.open);

      if (!event.target.open) {
        this.classList.remove.apply(this.classList, ['is-openAbove', 'is-openBelow']);
      }
    },

    /** @private */
    _onOverlayPositioned: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      this.classList.add(event.detail.vertical === 'top' ? 'is-openBelow' : 'is-openAbove');
      this._elements.overlay.style.minWidth = this.offsetWidth + 'px';
    },

    // @todo: while the select is multiple, if everything is deselected no change event will be triggered.
    _onNativeSelectChange: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
      // a change event
      if (this._bulkSelectionChange) {
        return;
      }

      this._bulkSelectionChange = true;
      // extracts the native options for the selected items. We use the selected options, instead of the complete
      // options to make the diff since it will normally be a smaller set
      var oldSelectedOptions = this.selectedItems.map(function(element) {
        return element._elements.nativeOption;
      });

      // we convert the HTMLCollection to an array
      var selectedOptions = Array.prototype.slice.call(event.target.querySelectorAll(':checked'));

      var diff = arrayDiff(oldSelectedOptions, selectedOptions);
      diff.forEach(function(item) {
        item._selectItem.selected = false;
      });

      // we only sync the items that changed
      var newSelection = arrayDiff(selectedOptions, oldSelectedOptions);
      newSelection.forEach(function(item) {
        item._selectItem.selected = true;
      });

      this._bulkSelectionChange = false;

      // since multiple keeps the select open, we cannot return the focus to the button otherwise the user cannot
      // continue selecting values
      if (!this.multiple) {
        // returns the focus to the button, otherwise the select will keep it
        this._elements.button.focus();
        // since selecting an item closes the native select, we need to trigger an event
        this.trigger('coral-select:hideitems');
      }

      // if the native change event was triggered, then it means there is some new value
      this.trigger('change');
    },

    /**
      This handles content change of coral-select-item and updates its associatives.

      @private
    */
    _onItemContentChange: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      var item = event.target;
      if (item._elements.selectListItem && item._elements.selectListItem.content) {
        item._elements.selectListItem.content.innerHTML = item.content.innerHTML;
      }

      if (item._elements.nativeOption) {
        item._elements.nativeOption.innerHTML = item.content.innerHTML;
      }

      if (item._elements.tag && item._elements.tag.label) {
        item._elements.tag.label.innerHTML = item.content.innerHTML;
      }

      // since the content changed, we need to sync the placeholder in case it was the selected item
      this._queueSync('placeholder', 'selectedItem');
    },

    /**
      This handles value change of coral-select-item and updates its associatives.

      @private
    */
    _onItemValueChange: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      var item = event.target;
      if (item._elements.selectListItem) {
        item._elements.selectListItem.value = item.value;
      }

      if (item._elements.nativeOption) {
        item._elements.nativeOption.value = item.value;
      }

      if (item._elements.tag) {
        item._elements.tag.value = item.value;
      }
    },

    /**
      This handles disabled change of coral-select-item and updates its associatives.

      @private
    */
    _onItemDisabledChange: function(event) {
      // stops propagation cause the event is internal to the component
      event.stopImmediatePropagation();

      var item = event.target;
      if (item._elements.selectListItem) {
        item._elements.selectListItem.disabled = item.disabled;
      }

      if (item._elements.nativeOption) {
        item._elements.nativeOption.disabled = item.disabled;
      }
    },

    /**
      Handles selecting multiple items. Selection could result a single or multiple selected items.

      @private
    */
    _onItemSelectedChange: function(event) {
      // we stop propagation since it is a private event
      event.stopImmediatePropagation();

      // the item that was selected
      var item = event.target;

      // setting this to true will ignore any changes from the selectlist al
      this._bulkSelectionChange = true;

      // when the item is selected, we need to enforce the selection mode
      if (item.selected) {
        this._onItemSelected(item);

        // enforces the selection mode
        if (!this.multiple) {
          this.items._deselectAllExcept(item);
        }
      }
      else {
        this._onItemDeselected(item);
      }

      this._bulkSelectionChange = false;

      // since there is a change in selection, we need to update the placeholder
      this._updateLabel();
    },

    // JSDocs inherited from coralui-mixin-formfield
    clear: function() {
      this.value = '';
    },

    /**
      Focuses the component.

      @ignore
    */
    focus: function() {
      if (!this.contains(document.activeElement)) {
        this._elements.button.focus();
      }
    },

    // JSDocs inherited from coralui-mixin-formfield
    reset: function() {
      // reset the values to the initial values
      this.values = this._initialValues;
    },

    /** @private */
    attachedCallback: function() {
      // we explicitly do not call the super to avoid triggering coral-component:attached
      this._delegateGlobalEvents();
    },

    /** @private */
    detachedCallback: function() {
      // we explicitly do not call the super to avoid triggering coral-component:detached
      this._undelegateGlobalEvents();
    },

    /**
      In case an item from the initial selection is removed, we need to remove it from the initial values.

      @private
    */
    _validateInitialState: function(nodes) {
      var item;
      var value;
      var index;

      // we iterate over all the nodes, checking if they matched the initial value
      for (var i = 0, nodeCount = nodes.length; i < nodeCount; i++) {
        // since we are not sure if the item has been upgraded, we try first the attribute, otherwise we extract the
        // value from the textContent
        item = nodes[i];

        value = itemValueFromDOM(item);
        index = this._initialValues.indexOf(item.value);

        if (index !== -1) {
          this._initialValues.splice(index, 1);
        }
      }
    },

    /** @private */
    _onCollectionChange: function(addedNodes, removedNodes) {
      // we make sure that items that were part of the initial selection are removed from the internal representation
      this._validateInitialState(removedNodes);
      // makes sure that the selection state matches the multiple variable
      this._setStateFromDOM();
    },

    /**
      Updates the label to reflect the current state. The label needs to be updated when the placeholder changes and
      when the selection changes.

      @private
    */
    _updateLabel: function() {
      this._queueSync('placeholder', 'selectedItem');
    },

    /**
      Handles the selection state.

      @ignore
    */
    _setStateFromDOM: function() {
      // if it is not multiple, we need to be sure only one item is selected
      if (!this.multiple) {
        // makes sure that only one is selected
        this.items._deselectAllExceptLast();

        // we execute _getFirstSelected instead of _getSelected because it is faster
        var selectedItem = this.items._getFirstSelected();

        // case 1. there is a selected item, so no further change is required
        // case 2. no selected item and no placeholder. an item will be automatically selected
        // case 3. no selected item and a placehoder. we just make sure the value is really empty
        if (!selectedItem) {
          // we clean the value because there is no selected item
          this._elements.input.value = '';

          // when there is no placeholder, we need to force a selection to behave like the native select
          if (this.placeholder === '') {
            // gets the first candidate for selection
            var selectable = this.items._getFirstSelectable();

            if (selectable) {
              // selects using the attribute in case the item is not yet initialized
              selectable.setAttribute('selected', '');
              // we set the value explicitely, so we do not need to wait for the MO
              this._elements.input.value = itemValueFromDOM(selectable);
            }
          }
        }
      }

      // handles the initial item in the select
      this._updateLabel();
    },

    /** @ignore */
    _initialize: function() {
      // we only have AUTO mode.
      this._useNativeInput = IS_MOBILE_DEVICE;
      this.classList.toggle('coral3-Select--native', this._useNativeInput);

      if (!this._useNativeInput && this.contains(this._elements.nativeSelect)) {
       this.removeChild(this._elements.nativeSelect);
      }

      // default value of inner flag to process events
      this._bulkSelectionChange = false;

      // handles the initial selection
      this._setStateFromDOM();

      Coral.commons.ready(this._elements.taglist, function(taglist) {
        // since reseting a form will call the reset on every component, we need to kill the behavior of the taglist
        // otherwise the state will not be accurate
        taglist.reset = function() {};
      });

      this._initialValues = [];
      // we need to keep a state of the initial items to be able to reset the component. values is not reliable during
      // initialization since items are not yet initialized
      this.selectedItems.forEach(function(item) {
        // we use DOM API instead of properties in case the item is not yet initialized
        this._initialValues.push(itemValueFromDOM(item));
      }, this);

      // initializes the collection to detect automatically the items
      this.items._startHandlingItems();
    },

    /** @ignore */
    _render: function() {
      // Cleanup template elements (supporting cloneNode)
      var templateElements = this.querySelectorAll('[handle]');
      for (var i = 0; i < templateElements.length; ++i) {
        var currentElement = templateElements[i];
        if (currentElement.parentNode === this) {
          this.removeChild(currentElement);
        }
      }

      // Render the main template
      this.insertBefore(Coral.templates.Select.base.call(this._elements), this.firstChild || null);

      // Constrains the size of the list to 6 items
      this._elements.list.style.maxHeight = 42 * 6 + 'px';

      // handles the focus allocation every time the overlay closes
      this._elements.overlay.returnFocusTo(this._elements.button);
    }

    /**
      Triggered when the select could accept external data to be loaded by the user. If <code>preventDefault()</code> is
      called, then a loading indicator will be shown. {@link Coral.Select#loading} should be set to false to indicate
      that the data has been successfully loaded.

      @event Coral.Select#coral-select:showitems

      @param {Object} event
        Event object.
      @param {Object} event.detail
        Detail object.
      @param {Number} event.detail.start
        The count of existing items, which is the index where new items should start.
    */

    /**
      Triggered when the select hides the UI used to select items. This is typipically used to cancel a load request
      because the items will not be shown anymore.

      @event Coral.Select#coral-select:hideitems
      @param {Object} event
        Event object.
    */
  });

  // Exports the variants enumeration.
  Coral.Select.variant = variant;

  Coral.register( /** @lends Coral.Select.Item# */ {
    /**
      @class Coral.Select.Item
      @classdesc A Select.Item component
      @extends Coral.Component
      @htmltag coral-select-item
    */
    name: 'Select.Item',
    tagName: 'coral-select-item',

    properties: {

      /**
        Item content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Select.Item#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      },

      /**
        Whether this item is disabled. When set to <code>true</code>, this will prevent every user interaction with the
        item. If disabled is set to <code>true</code> for a selected item it will be deselected.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.Select.Item#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-select-item:_disabledchanged'
      },

      /**
        Whether the item is selected. Selected cannot be set to <code>true</code> if the item is disabled.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Select.Item#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-select-item:_selectedchanged'
      },

      /**
        Value of the item. If not explicitly set, the value of <code>Node.textContent</code> is returned.

        @type {String}
        @default ""
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.Select.Item#
      */
      'value': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        trigger: 'coral-select-item:_valuechanged',
        get: function() {
          // keep spaces to only 1 max and trim to mimic native select option behavior
          return typeof this._value === 'undefined' ? this.textContent.replace(/\s{2,}/g, ' ').trim() : this._value;
        }
      }
    },

    /** @private */
    attachedCallback: function() {
      // we explicitly do not call the super to avoid triggering coral-component:attached
    },

    /** @private */
    detachedCallback: function() {
      // we explicitly do not call the super to avoid triggering coral-component:detached
    },

    /** @ignore */
    _initialize: function() {
      this._observer = new MutationObserver(this._handleMutation.bind(this));
      this._observer.observe(this, {
        characterData: true,
        childList: true,
        subtree: true
      });
    },

    /** @private */
    _handleMutation: function(mutations) {
      this.trigger('coral-select-item:_contentchanged', {
        content: this.textContent
      });
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-clock"] = {"en-US":{"am":"am","pm":"pm","Hours":"Hours","Minutes":"Minutes","AM/PM":"AM/PM"},"de-DE":{"am":"vormittags","pm":"nachmittags","Hours":"Stunden","Minutes":"Minuten","AM/PM":"AM/PM"},"fr-FR":{"am":"matin","pm":"après-midi","Hours":"Heures","Minutes":"Minutes","AM/PM":"AM/PM"},"ja-JP":{"am":"午前","pm":"午後","Hours":"時間","Minutes":"分","AM/PM":"午前 / 午後"},"es-ES":{"am":"a. m.","pm":"p. m.","Hours":"Horas","Minutes":"Minutos","AM/PM":"a. m./p. m."},"ko-KR":{"am":"오전","pm":"오후","Hours":"시간","Minutes":"분","AM/PM":"오전/오후"},"zh-CN":{"am":"上午","pm":"下午","Hours":"小时","Minutes":"分钟","AM/PM":"上午/下午"},"zh-TW":{"am":"上午","pm":"下午","Hours":"小時","Minutes":"分鐘","AM/PM":"上午/下午"},"pt-BR":{"am":"am","pm":"pm","Hours":"Horas","Minutes":"Minutos","AM/PM":"AM/PM"},"it-IT":{"am":"am","pm":"pm","Hours":"Ore","Minutes":"Minuti","AM/PM":"AM/PM"},"nl-NL":{"am":"am","pm":"pm","Hours":"Uren","Minutes":"Minuten","AM/PM":"AM/PM"},"da-DK":{"am":"am","pm":"pm","Hours":"Timer","Minutes":"Minutter","AM/PM":"AM/PM"},"fi-FI":{"am":"ap.","pm":"ip.","Hours":"Tunnit","Minutes":"Minuutit","AM/PM":"ap./ip."},"nb-NO":{"am":"am","pm":"pm","Hours":"Timer","Minutes":"Minutter","AM/PM":"AM/PM"},"sv-SE":{"am":"am","pm":"pm","Hours":"Timmar","Minutes":"Minuter","AM/PM":"AM/PM"},"cs-CZ":{"am":"am","pm":"pm","Hours":"hodin","Minutes":"minut","AM/PM":"AM/PM"},"pl-PL":{"am":"przed południem","pm":"po południu","Hours":"Godz.","Minutes":"Min","AM/PM":"Przed południem / Po południu"},"ru-RU":{"am":"дп","pm":"пп","Hours":"ч.","Minutes":"мин.","AM/PM":"ДП/ПП"},"tr-TR":{"am":"öö","pm":"ös","Hours":"Saat","Minutes":"Dakika","AM/PM":"ÖÖ/ÖS"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Clock"] = window["Coral"]["templates"]["Clock"] || {};
window["Coral"]["templates"]["Clock"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  
  var amPmId = Coral.commons.getUID();

  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["input"] = document.createElement("input");
  el2.setAttribute("type", "hidden");
  el2.setAttribute("name", "");
  el2.setAttribute("handle", "input");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["valueAsText"] = document.createElement("time");
  el4.setAttribute("handle", "valueAsText");
  el4.id = Coral["commons"]["getUID"]();
  el4.setAttribute("hidden", "");
  frag.appendChild(el4);
  var el5 = document.createTextNode("\n");
  frag.appendChild(el5);
  var el6 = this["hours"] = document.createElement("input","coral-textfield");
  el6.setAttribute("is", "coral-textfield");
  el6.setAttribute("type", "number");
  el6.setAttribute("min", "0");
  el6.setAttribute("max", "23");
  el6.className += " coral3-Clock-hour";
  el6.setAttribute("handle", "hours");
  el6.setAttribute("aria-label", Coral["i18n"]["get"]('Hours'));
  frag.appendChild(el6);
  var el7 = document.createTextNode("\n");
  frag.appendChild(el7);
  var el8 = document.createElement("span");
  el8.className += " coral3-Clock-divider";
  el8.textContent = ":";
  frag.appendChild(el8);
  var el9 = document.createTextNode("\n");
  frag.appendChild(el9);
  var el10 = this["minutes"] = document.createElement("input","coral-textfield");
  el10.setAttribute("is", "coral-textfield");
  el10.setAttribute("type", "number");
  el10.setAttribute("min", "0");
  el10.setAttribute("max", "59");
  el10.className += " coral3-Clock-minute";
  el10.setAttribute("handle", "minutes");
  el10.setAttribute("aria-label", Coral["i18n"]["get"]('Minutes'));
  frag.appendChild(el10);
  var el11 = document.createTextNode("\n");
  frag.appendChild(el11);
  var el12 = this["period"] = document.createElement("coral-select");
  el12.setAttribute("handle", "period");
  el12.className += " coral3-Clock-period";
  el12.setAttribute("hidden", "");
  el12.setAttribute("labelledby", amPmId);
  var el13 = document.createTextNode("\n  ");
  el12.appendChild(el13);
  var el14 = document.createElement("span");
  el14.className += " u-coral-screenReaderOnly";
  el14.id = amPmId;
  el14.setAttribute("hidden", "");
  el14.textContent = Coral["i18n"]["get"]('AM/PM');
  el12.appendChild(el14);
  var el15 = document.createTextNode("\n  ");
  el12.appendChild(el15);
  var el16 = document.createElement("coral-select-item");
  el16.setAttribute("value", "am");
  el12.appendChild(el16);
  var el17 = document.createTextNode("\n  ");
  el12.appendChild(el17);
  var el18 = document.createElement("coral-select-item");
  el18.setAttribute("value", "pm");
  el12.appendChild(el18);
  var el19 = document.createTextNode("\n");
  el12.appendChild(el19);
  frag.appendChild(el12);
  var el20 = document.createTextNode("\n");
  frag.appendChild(el20);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Default for display and value format
  var DEFAULT_HOUR_FORMAT = 'HH';
  var DEFAULT_MINUTE_FORMAT = 'mm';
  var DEFAULT_TIME_FORMAT = DEFAULT_HOUR_FORMAT + ':' + DEFAULT_MINUTE_FORMAT;

  // Used to extract the time format from a date format
  var AUTHORIZED_TOKENS = '(A|a|H{1,2}|h{1,2}|k{1,2}|m{1,2})';
  var TIME_REG_EXP = new RegExp(AUTHORIZED_TOKENS + '.*' + AUTHORIZED_TOKENS + '|' + AUTHORIZED_TOKENS);
  var HOUR_REG_EXP = new RegExp('h{1,2}|H{1,2}|k{1,2}');
  var MIN_REG_EXP = new RegExp('m{1,2}');

  /**
    Enum for Clock variant values.

    @enum {String}
    @memberof Coral.Clock
  */
  var variant = {
    /** A default, gray Clock. */
    DEFAULT: 'default',
    /** A Clock with no border or background. */
    QUIET: 'quiet'
  };

  var CLASSNAME = 'coral3-Clock';

  // builds an array containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.Clock# */ {
    /**
      @class Coral.Clock
      @classdesc A component that allows for selecting a time.
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-clock
    */
    name: 'Clock',
    tagName: 'coral-clock',
    className: CLASSNAME,

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'change [handle="period"]': '_onPeriodChange'
    },

    properties: {
      /**
        The format used to display the selected time to the user. If the user manually types a time, this format
        will be used to parse the value. See http://momentjs.com/docs/#/displaying/ for valid format string
        options.

        @type {String}
        @default "HH:mm"
        @htmlattribute displayformat
        @memberof Coral.Clock#
      */
      'displayFormat': {
        default: DEFAULT_TIME_FORMAT,
        attribute: 'displayformat',
        transform: function(value) {
          return this._extractTimeFormat(Coral.transform.string(value).trim(), TIME_REG_EXP, DEFAULT_TIME_FORMAT);
        },
        sync: function() {
          this._syncDisplay();
        }
      },

      /**
        The format to use on expressing the time as a string on the <code>value</code> attribute. The value
        will be sent to the server using this format. If an empty string is provided, then the default value per type
        will be used. See http://momentjs.com/docs/#/displaying/ for valid format string options.

        @type {String}
        @default "HH:mm"
        @htmlattribute valueformat
        @memberof Coral.Clock#
      */
      'valueFormat': {
        default: DEFAULT_TIME_FORMAT,
        attribute: 'valueformat',
        transform: function(value) {
          return this._extractTimeFormat(Coral.transform.string(value).trim(), TIME_REG_EXP, DEFAULT_TIME_FORMAT);
        },
        set: function(value) {
          this._valueFormat = value;
          this._elements.input.value = this.value;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          this._elements.hours.disabled = this.disabled;
          this._elements.minutes.disabled = this.disabled;
          // stops the form submission
          this._elements.input.disabled = this.disabled;
        }
      },

      // JSDoc inherited
      'invalid': {
        sync: function() {
          this._elements.hours.invalid = this.invalid;
          this._elements.minutes.invalid = this.invalid;
        }
      },

      // JSDoc inherited
      'readOnly': {
        sync: function() {
          this._elements.hours.readOnly = this.readOnly;
          this._elements.minutes.readOnly = this.readOnly;
          this._elements.input.readOnly = this.readOnly;
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this._elements.hours.required = this.required;
          this._elements.minutes.required = this.required;
          this._elements.input.required = this.required;
        }
      },

      // JSDoc inherited
      'value': {
        validate: function(newValue, oldValue) {
          return typeof newValue === 'string';
        },
        get: function() {
          return this._getValueAsString(this._value, this.valueFormat);
        },
        set: function(value) {
          // we do strict conversion of the values
          var time = moment(value, this.valueFormat, true);
          this._value = time.isValid() ? time : '';
          this._elements.input.value = this.value;

          this._syncValueAsText();
        },
        sync: function() {
          this._syncDisplay();
        }
      },

      // JSDoc inherited
      labelledBy: {
        get: function() {

          // Get current aria-labelledby attribute on the labellable element.
          var labelledBy = this._getLabellableElement().getAttribute('aria-labelledby');

          // If a labelledBy attribute has been defined,
          if (labelledBy) {

            // and strip the valueAsText element id from the end of the aria-labelledby string.
            labelledBy = labelledBy.replace(this._elements.valueAsText.id, '').trim();

            // If the resulting labelledBy string is empty, return null.
            if (!labelledBy.length) {
              labelledBy = null;
            }
          }
          return labelledBy;
        },
        sync: function() {
          // The specified labelledBy property.
          var labelledBy = this.labelledBy;

          // An array of element ids to label control, the last being the valueAsText element id.
          var ids = [this._elements.valueAsText.id];

          // If a labelledBy property exists,
          if (labelledBy) {
            // prepend the labelledBy value to the ids array
            ids.unshift(labelledBy);

            // Keep labelledBy property and labelledby attribute in sync.
            if (this.getAttribute('labelledby') !== labelledBy) {
              this.setAttribute('labelledby', labelledBy);
            }
          }
          else {

            // labelledBy property is null, remove the labelledby attribute.
            this.removeAttribute('labelledby');
          }

          // Set aria-labelledby attribute on the labellable element joining ids array into space-delimited list of ids.
          this._getLabellableElement().setAttribute('aria-labelledby', ids.join(' '));
        }
      },

      /**
        The current value as a Date. If the value is "" or an invalid date, <code>null</code> will be returned.

        @type {Date}
        @default null
        @memberof Coral.Clock#
      */
      'valueAsDate': {
        attribute: null,
        transform: function(value) {
          return (value instanceof Date) ? moment(value).format(this.valueFormat) : '';
        },
        get: function() {
          return this._value ? new Date(this._value.toDate().getTime()) : null;
        },
        set: function(value) {
          this.value = value;
        }
      },
      /**
        The clock's variant.

        @type {Coral.Clock.variant}
        @default Coral.Clock.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Clock#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        set: function(value) {
          this._variant = value;

          // passes down the variant to the underlying components
          this._elements.hours.variant = value;
          this._elements.minutes.variant = value;
          this._elements.period.variant = value;
        },
        sync: function() {
          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== Coral.Clock.variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }
        }
      }
    },

    /**
      sets focus to appropriate descendant
    */
    focus: function() {
      if (!this.contains(document.activeElement)) {
        this._elements.hours.focus();
      }
    },

    /**
      Ignore the date part and use the time part only

      @private
    */
    _extractTimeFormat: function(format, regExp, defaultFormat) {
      var match = regExp.exec(format);
      return match && match.length && match[0] !== '' ? match[0] : defaultFormat;
    },

    /**
      Sync time display based on the format

      @private
    */
    _syncDisplay: function() {
      var hourFormat = this._extractTimeFormat(this.displayFormat, HOUR_REG_EXP, DEFAULT_HOUR_FORMAT);
      var minuteFormat = this._extractTimeFormat(this.displayFormat, MIN_REG_EXP, DEFAULT_MINUTE_FORMAT);

      this._elements.hours.placeholder = hourFormat;
      this._elements.minutes.placeholder = minuteFormat;

      this._elements.hours.value = this._getValueAsString(this._value, hourFormat);
      this._elements.minutes.value = this._getValueAsString(this._value, minuteFormat);

      this._syncPeriod();

      this._syncValueAsText();
    },

    /**
      Sync period selector based on the format

      @private
    */
    _syncPeriod: function() {
      Coral.commons.ready(this._elements.period, function(period) {
        var time = this._value;
        var am = Coral.i18n.get('am');
        var pm = Coral.i18n.get('pm');
        var items = period.items.getAll();

        if (time && time.isValid()) {
          if (time.hours() < 12) {
            period.value = 'am';
          }
          else {
            period.value = 'pm';
          }
        }

        // Check for am/pm
        if (this.displayFormat.indexOf('a') !== -1) {
          items[0].textContent = am;
          items[1].textContent = pm;
          this._togglePeriod(true);
        }
        else if (this.displayFormat.indexOf('A') !== -1) {
          items[0].textContent = am.toUpperCase();
          items[1].textContent = pm.toUpperCase();
          this._togglePeriod(true);
        }
        else {
          this._togglePeriod(false);
        }
      }.bind(this));
    },

    /** @private */
    _togglePeriod: function(show) {
      this._elements.period.hidden = !show;
    },

    /** @private */
    _onPeriodChange: function(event) {
      // stops the event from leaving the component
      event.stopImmediatePropagation();

      var time = this._value;
      var period = this._elements.period;

      // we check if a change event needs to be triggered since it was produced via user interaction
      if (time && time.isValid()) {
        if (this.displayFormat.indexOf('h') !== -1) {
          if (period.value === 'am') {
            time.subtract(12, 'h');
          }
          else {
            time.add(12, 'h');
          }
        }

        this.value = time.format(this.valueFormat);
        this.trigger('change');
      }
    },

    _syncValueAsText: function() {
      this._elements.valueAsText.textContent = this._getValueAsString(this._value, this.displayFormat);

      if (!this.getAttribute('aria-labelledby')) {
        this._queueSync('labelledBy');
      }
    },

    /**
      Kills the internal _onInputChange from formMixin because it does not check the target.

      @private
    */
    _onInputChange: function(event) {
      // stops the event from leaving the component
      event.stopImmediatePropagation();

      var newTime = moment();
      var oldTime = this._value;

      var hours = parseInt(this._elements.hours.value, 10);
      var minutes = parseInt(this._elements.minutes.value, 10);

      if (window.isNaN(hours) || window.isNaN(minutes)) {
        newTime = '';
      }
      else {
        if (!this._elements.period.hidden &&
          this.displayFormat.indexOf('h') !== -1 &&
          this._elements.period.value === 'pm') {
          hours += 12;
        }

        newTime.hours(hours);
        newTime.minutes(minutes);
      }

      // we check if a change event needs to be triggered since it was produced via user interaction
      if (newTime && newTime.isValid()) {
        // @polyfill ie
        this.invalid = false;

        if (!newTime.isSame(oldTime, 'hour') || !newTime.isSame(oldTime, 'minute')) {
          this.value = newTime.format(this.valueFormat);
          this.trigger('change');
        }
      }
      else {
        // @polyfill ie
        this.invalid = true;
        // does not sync the inputs so allow the user to continue typing the date
        this._value = '';

        if (newTime !== oldTime) {
          this.trigger('change');
        }
      }
    },

    /**
      Modified the label target to be the clock itself and not the first input. This is used by the
      <code>Coral.mixin.formField</code> to be able to properly label the component.

      @private
    */
    _getLabellableElement: function() {
      return this;
    },

    /**
      Helper class that converts the internal moment value into a String using the provided date format. If the value is
      invalid, empty string will be returned.

      @param {?Moment} value
        The value representing the date. It has to be a moment object or <code>null</code>
      @param {String} format
        The Date format to be used.

      @returns {String} a String representing the value in the given format.

      @ignore
    */
    _getValueAsString: function(value, format) {
      return value && value.isValid() ? value.format(format) : '';
    },

    /** @ignore */
    _initialize: function() {
      this.setAttribute('role', 'group');
    },

    /** @ignore */
    _render: function() {
      // clean up to be able to clone it
      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }

      this.appendChild(Coral.templates.Clock.base.call(this._elements));
    }
  });

  // exports the variant enumeration
  Coral.Clock.variant = variant;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /** @ignore */
  var placement = Coral.Overlay.placement;

  var arrowMap = {
    'left': 'Right',
    'right': 'Left',
    'top': 'Down',
    'bottom': 'Up'
  };

  var CLASSNAME = 'coral3-Tooltip';

  // This is in JS as we're setting this to induce wrapping before collision calculations
  var TOOLTIP_ARROW_SIZE = 12;

  /**
    Tooltip variants.

    @enum {String}
    @memberof Coral.Tooltip
  */
  var variant = {
    /** A blue tooltip that informs the user of non-critical information. */
    INFO: 'info',
    /** A red tooltip that indicates an error has occurred. */
    ERROR: 'error',
    /** An orange tooltip that notifies the user of something important. */
    WARNING: 'warning',
    /** A green tooltip that indicates an operation was successful. */
    SUCCESS: 'success',
    /** A dark gray tooltip that provides additional information for a chart item. */
    INSPECT: 'inspect'
  };

  /**
    Tooltip interaction values.

    @enum {String}
    @memberof Coral.Tooltip
  */
  var interaction = {
    /** Show when the target is hovered or focused and hide when the mouse is moved out or focus is lost. */
    ON: 'on',
    /** Do not show or hide automatically. */
    OFF: 'off'
  };

  // A string of all possible variant classnames
  var ALL_VARIANT_CLASSES = [];
  for (var variantName in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantName]);
  }

  // A string of all position placement classnames
  var ALL_PLACEMENT_CLASSES = [];

  // A map of lowercase directions to their corresponding classname
  var placementClassMap = {};
  for (var key in placement) {
    var direction = placement[key];

    var placementClass = CLASSNAME + '--arrow' + arrowMap[direction];

    // Store in map
    placementClassMap[direction] = placementClass;

    // Store in list
    ALL_PLACEMENT_CLASSES.push(placementClass);
  }

  Coral.register( /** @lends Coral.Tooltip# */ {
    /**
      @class Coral.Tooltip
      @classdesc A Tooltip component
      @extends Coral.Component
      @htmltag coral-tooltip
      @extends Coral.Overlay

      @borrows Coral.mixin.overlay#focusOnShow as Coral.Tooltip#focusOnShow
      @borrows Coral.mixin.overlay#open as Coral.Tooltip#open
      @borrows Coral.mixin.overlay#returnFocus as Coral.Tooltip#returnFocus
      @borrows Coral.mixin.overlay#trapFocus as Coral.Tooltip#trapFocus
      @borrows Coral.mixin.overlay#show as Coral.Tooltip#show
      @borrows Coral.mixin.overlay#hide as Coral.Tooltip#hide
      @borrows Coral.mixin.overlay#returnFocusTo as Coral.Tooltip#returnFocusTo
      @borrows Coral.mixin.overlay#event:coral-overlay:beforeopen as Coral.Tooltip#coral-overlay:beforeopen
      @borrows Coral.mixin.overlay#event:coral-overlay:beforeclose as Coral.Tooltip#coral-overlay:beforeclose
      @borrows Coral.mixin.overlay#event:coral-overlay:open as Coral.Tooltip#coral-overlay:open
      @borrows Coral.mixin.overlay#event:coral-overlay:close as Coral.Tooltip#coral-overlay:close
    */
    name: 'Tooltip',
    tagName: 'coral-tooltip',
    className: CLASSNAME,
    extend: Coral.Overlay,

    /** @protected */
    _overlayAnimationTime: Coral.mixin.overlay.FADETIME,

    properties: {
      /**
        The variant of tooltip.

        @type {Coral.Tooltip.variant}
        @default Coral.Tooltip.variant.INFO
        @htmlattribute variant
        @htmlattributereflected
        @memberof Coral.Tooltip#
      */
      'variant': {
        default: variant.INFO,
        reflectAttribute: true,
        validate: Coral.validate.enumeration(variant),
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);
          this.classList.add(this._className + '--' + this.variant);
        }
      },

      /**
        The amount of time in miliseconds to wait before showing the tooltip when the target is interacted with.

        @type {Number}
        @default 500
        @htmlattribute delay
        @memberof Coral.Tooltip#
      */
      'delay': {
        default: 500,
        transform: Coral.transform.number
      },

      /**
        The Tooltip content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Tooltip#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-tooltip-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        The point on the overlay we should anchor from when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.LEFT_CENTER
        @htmlattribute alignmy
        @memberof Coral.Tooltip#
      */
      'alignMy': {
        default: Coral.Overlay.align.LEFT_CENTER
      },

      /**
        The point on the target we should anchor to when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.RIGHT_CENTER
        @htmlattribute alignat
        @memberof Coral.Tooltip#
      */
      'alignAt': {
        default: Coral.Overlay.align.RIGHT_CENTER
      },

      /**
        Whether to focus the tooltip when opened or not. By default Tooltips do not require the focus to be changed,
        but in case some content needs to be focused, setting focusOnShow="on" would handle this. It also accepts an
        instance of HTMLElement or a selector like ':first-child' or 'button:last-of-type'. If the selector returns
        multiple elements, it will focus the first element inside the overlay that matches the selector.

        @type {Coral.mixin.overlay.focusOnShow|HTMLElement|String}
        @default Coral.mixin.overlay.focusOnShow.ON
        @htmlattribute focusonshow
        @memberof Coral.Tooltip#
      */
      'focusOnShow': {
        default: Coral.mixin.overlay.focusOnShow.OFF
      },

      /**
        The placement of the overlay. This property sets {@link Coral.Tooltip#alignMy} and
        {@link Coral.Tooltip#alignAt}.

        @type {Coral.Overlay.placement}
        @default Coral.Overlay.placement.RIGHT
        @name placement
        @htmlattribute placement
        @memberof Coral.Tooltip#
      */

      /**
        The distance the overlay should be from its target.

        @type {Number}
        @default 5
        @htmlattribute offset
        @memberof Coral.Tooltip#
      */
      'offset': {
        default: TOOLTIP_ARROW_SIZE
      },

      // JSDoc inherited
      'open': {
        sync: function() {
          if (!this.open) {
            // Stop previous show operations from happening
            this._cancelShow();
          }
        }
      },

      // JSDoc inherited
      'target': {
        set: function(value) {
          if (this.interaction === interaction.ON) {
            // Add listeners to the target
            var target = this._getTarget(value);
            this._addTargetListeners(target);
          }
        }
      },

      /**
        Whether the tooltip should show itself when the target is interacted with.

        @type {Coral.Tooltip.interaction}
        @default Coral.Tooltip.interaction.ON
        @name interaction
        @htmlattribute interaction
        @memberof Coral.Tooltip#
      */
      'interaction': {
        default: interaction.ON,
        set: function(value) {
          var target = this._getTarget();

          if (target) {
            if (value === interaction.ON) {
              this._addTargetListeners(target);
            }
            else {
              this._removeTargetListeners(target);
            }
          }

          this._interaction = value;
        }
      }
    },

    /** @ignore */
    _render: function() {
      this._id = Coral.commons.getUID();

      var content = this.querySelector('coral-tooltip-content');

      if (content === null) {
        content = document.createElement('coral-tooltip-content');
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      // Assign the content zone so the insert function will be called
      this.content = content;
    },

    /** @ignore */
    _initialize: function() {
      // Let the tooltip be focusable
      // We'll marshall focus around when its focused
      this.tabIndex = -1;

      // ARIA
      this.setAttribute('role', 'tooltip');
    },

    /** @ignore */
    _applyPosition: function(position, feedback) {
      var top = position.top;
      var left = position.left;

      if (feedback.horizontal === 'left') {
        this._setArrowClass(Coral.Overlay.placement.LEFT);
      }
      else if (feedback.horizontal === 'right') {
        this._setArrowClass(Coral.Overlay.placement.RIGHT);
      }
      else if (feedback.vertical === 'bottom') {
        this._setArrowClass(Coral.Overlay.placement.BOTTOM);
      }
      else if (feedback.vertical === 'top') {
        this._setArrowClass(Coral.Overlay.placement.TOP);
      }

      this.style.top = top + 'px';
      this.style.left = left + 'px';
    },

    _setArrowClass: function(arrowPlacement) {
      this.classList.remove.apply(this.classList, ALL_PLACEMENT_CLASSES);
      this.classList.add(placementClassMap[arrowPlacement]);
    },

    /** @ignore */
    _handleFocus: function() {
      // Don't hide
      this._cancelHide();

      // Focus on the first focusable element
      Array.prototype.some.call(this.querySelectorAll(Coral.commons.FOCUSABLE_ELEMENT_SELECTOR), function(el) {
        if (el.offsetParent !== null) {
          el.focus();
          return true;
        }
      });
    },

    /** @ignore */
    _handleFocusOut: function() {
      var tooltip = this;

      // The item that should have focus will get it on the next frame
      Coral.commons.nextFrame(function() {
        var targetIsFocused = document.activeElement === tooltip._getTarget();
        var tooltipIsFocused = tooltip.contains(document.activeElement);
        if (!targetIsFocused && !tooltipIsFocused) {
          tooltip._cancelShow();
          tooltip.open = false;
        }
      });
    },

    /** @ignore */
    _cancelShow: function() {
      clearTimeout(this._showTimeout);
    },

    /** @ignore */
    _cancelHide: function() {
      clearTimeout(this._hideTimeout);
    },

    /** @ignore */
    _startHide: function() {
      if (this.delay === 0) {
        // Hide immediately
        this._handleFocusOut();
      }
      else {
        var tooltip = this;
        this._hideTimeout = setTimeout(function() {
          tooltip._handleFocusOut();
        }, this.delay);
      }
    },

    /** @ignore */
    _addTargetListeners: function(target) {
      if (!target) {
        return;
      }

      // Make sure we don't add listeners twice to the same element for this particular tooltip
      if (target['_hasCoralTooltipListeners' + this._id]) {
        return;
      }
      target['_hasCoralTooltipListeners' + this._id] = true;

      // Remove listeners from the old target
      if (this._oldTarget) {
        var oldTarget = this._getTarget(this._oldTarget);
        if (oldTarget) {
          this._removeTargetListeners(oldTarget);
        }
      }

      // Store the current target value
      this._oldTarget = target;

      var tooltip = this;
      // Use Vent to bind events on the target
      this._targetEvents = new window.Vent(target);

      this._targetEvents.on('mouseenter.CoralTooltip' + this._id + ' focusin.CoralTooltip' + this._id, function(event) {
        // Don't let the tooltip hide
        tooltip._cancelHide();

        if (!tooltip.open) {
          tooltip._cancelShow();

          if (tooltip.delay === 0) {
            // Show immediately
            tooltip.show();
          }
          else {
            tooltip._showTimeout = setTimeout(function() {
              tooltip.show();
            }, tooltip.delay);
          }
        }
      });

      this._targetEvents.on('mouseleave.CoralTooltip' + this._id, function(event) {
        if (tooltip.interaction === interaction.ON) {
          tooltip._startHide();
        }
      });

      this._targetEvents.on('focusout.CoralTooltip' + this._id, function(event) {
        if (tooltip.interaction === interaction.ON) {
          tooltip._handleFocusOut();
        }
      });
    },

    /** @ignore */
    _removeTargetListeners: function(target) {
      // Remove listeners for this tooltip and mark that the element doesn't have them
      // Use the ID so we can support multiple tooltips on the same element
      if (this._targetEvents) {
        this._targetEvents.off('.CoralTooltip' + this._id);
      }
      target['_hasCoralTooltipListeners' + this._id] = false;
    }
  });

  Coral.register( /** @lends Coral.Tooltip.Content# */ {
    /**
      @class Coral.Tooltip.Content
      @classdesc The Tooltip content component
      @htmltag coral-tooltip-content
      @extends Coral.Component
    */
    name: 'Tooltip.Content',
    tagName: 'coral-tooltip-content'
  });

  // Expose enums globally
  Coral.Tooltip.variant = variant;

}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Slider"] = window["Coral"]["templates"]["Slider"] || {};
window["Coral"]["templates"]["Slider"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  data.uid = Coral.commons.getUID();
  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral3-Slider-bar";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["fillHandle"] = document.createElement("div");
  el4.setAttribute("handle", "fillHandle");
  el4.className += " coral3-Slider-fill is-hidden";
  el4.setAttribute("role", "presentation");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el2.appendChild(el5);
  frag.appendChild(el2);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = this["leftHandle"] = document.createElement("div");
  el7.setAttribute("handle", "leftHandle");
  el7.className += " coral3-Slider-handle";
  var el8 = document.createTextNode("\n  ");
  el7.appendChild(el8);
  var el9 = this["leftInput"] = document.createElement("input");
  el9.setAttribute("handle", "leftInput");
  el9.setAttribute("type", "range");
  el9.id = data_0["uid"];
  el9.className += " coral3-Slider-input";
  el7.appendChild(el9);
  var el10 = document.createTextNode("\n  ");
  el7.appendChild(el10);
  var el11 = document.createElement("coral-tooltip");
  el11.setAttribute("variant", "inspect");
  el11.id = data_0["uid"]+"-tooltip";
  el11.setAttribute("for", data_0["uid"]);
  el11.setAttribute("interaction", "off");
  el7.appendChild(el11);
  var el12 = document.createTextNode("\n");
  el7.appendChild(el12);
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["Slider"]["range"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  
  data.uidMin = Coral.commons.getUID();
  data.uidMax = Coral.commons.getUID();

  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral3-Slider-bar";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["fillHandle"] = document.createElement("div");
  el4.setAttribute("handle", "fillHandle");
  el4.className += " coral3-Slider-fill is-hidden";
  el4.setAttribute("role", "presentation");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el2.appendChild(el5);
  frag.appendChild(el2);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = this["leftHandle"] = document.createElement("div");
  el7.setAttribute("handle", "leftHandle");
  el7.className += " coral3-Slider-handle";
  var el8 = document.createTextNode("\n  ");
  el7.appendChild(el8);
  var el9 = this["leftLabel"] = document.createElement("label");
  el9.setAttribute("handle", "leftLabel");
  el9.className += " u-coral-screenReaderOnly";
  el9.id = data_0["uidMin"]+"-label";
  el9.setAttribute("for", data_0["uidMin"]);
  el9.setAttribute("aria-hidden", "true");
  el9.textContent = "Minimum";
  el7.appendChild(el9);
  var el10 = document.createTextNode("\n  ");
  el7.appendChild(el10);
  var el11 = this["leftInput"] = document.createElement("input");
  el11.setAttribute("handle", "leftInput");
  el11.setAttribute("type", "range");
  el11.id = data_0["uidMin"];
  el11.className += " coral3-Slider-input";
  el7.appendChild(el11);
  var el12 = document.createTextNode("\n  ");
  el7.appendChild(el12);
  var el13 = document.createElement("coral-tooltip");
  el13.setAttribute("variant", "inspect");
  el13.id = data_0["uidMin"]+"-tooltip";
  el13.setAttribute("for", data_0["uidMin"]);
  el13.setAttribute("interaction", "off");
  el7.appendChild(el13);
  var el14 = document.createTextNode("\n");
  el7.appendChild(el14);
  frag.appendChild(el7);
  var el15 = document.createTextNode("\n");
  frag.appendChild(el15);
  var el16 = this["rightHandle"] = document.createElement("div");
  el16.setAttribute("handle", "rightHandle");
  el16.className += " coral3-Slider-handle";
  var el17 = document.createTextNode("\n  ");
  el16.appendChild(el17);
  var el18 = this["rightLabel"] = document.createElement("label");
  el18.setAttribute("handle", "rightLabel");
  el18.className += " u-coral-screenReaderOnly";
  el18.id = data_0["uidMax"]+"-label";
  el18.setAttribute("for", data_0["uidMax"]);
  el18.setAttribute("aria-hidden", "true");
  el18.textContent = "Maximum";
  el16.appendChild(el18);
  var el19 = document.createTextNode("\n  ");
  el16.appendChild(el19);
  var el20 = this["rightInput"] = document.createElement("input");
  el20.setAttribute("handle", "rightInput");
  el20.setAttribute("type", "range");
  el20.id = data_0["uidMax"];
  el20.className += " coral3-Slider-input";
  el16.appendChild(el20);
  var el21 = document.createTextNode("\n  ");
  el16.appendChild(el21);
  var el22 = document.createElement("coral-tooltip");
  el22.setAttribute("variant", "inspect");
  el22.id = data_0["uidMax"]+"-tooltip";
  el22.setAttribute("for", data_0["uidMax"]);
  el22.setAttribute("interaction", "off");
  el16.appendChild(el22);
  var el23 = document.createTextNode("\n");
  el16.appendChild(el23);
  frag.appendChild(el16);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var CLASSNAME = 'coral3-Slider';

  var CLASSNAME_HANDLE = 'coral3-Slider-handle';

  var CLASSNAME_INPUT = 'coral3-Slider-input';

  var TAG_NAME_ITEM = 'coral-slider-item';

  /**
    Slider orientations.

    @enum {String}
    @memberof Coral.Slider
  */
  var orientation = {
    /** Horizontal slider. */
    HORIZONTAL: 'horizontal',
    /** Vertical slider. */
    VERTICAL: 'vertical'
  };

  //collection
  var SliderCollection = function(slider) {
    this._slider = slider;
  };

  // assigns the prototype to get access to the Collection signature methods
  SliderCollection.prototype = Object.create(Coral.Collection.prototype);

  SliderCollection.prototype.add = function(item, before) {
    var config;

    if (!(item instanceof HTMLElement)) {
      // creates a new item and initializes its values
      config = item;
      item = document.createElement(TAG_NAME_ITEM);
    }

    this._slider.insertBefore(item, before);

    // This needs to come after the DOM insertion since we have a requirement that
    // TabPanel.Item#selected cannot be set to true until after the TabPanel.Item has been added
    // to a TabPanel.
    if (config) {
      item.set(config, true);
    }

    return item;
  };

  SliderCollection.prototype.getAll = function() {
    return Array.prototype.slice.call(this._slider.getElementsByTagName(TAG_NAME_ITEM));
  };

  Coral.register( /** @lends Coral.Slider# */ {
    /**
      @class Coral.Slider
      @classdesc A Slider component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-slider
    */
    // Based on ARIA standard http://www.w3.org/WAI/PF/aria/roles#slider
    name: 'Slider',
    tagName: 'coral-slider',
    className: CLASSNAME,

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'key:up .coral3-Slider-handle': '_handleKey',
      'key:right .coral3-Slider-handle': '_handleKey',
      'key:down .coral3-Slider-handle': '_handleKey',
      'key:left .coral3-Slider-handle': '_handleKey',
      'key:pageUp .coral3-Slider-handle': '_handleKey',
      'key:pageDown .coral3-Slider-handle': '_handleKey',
      'key:home .coral3-Slider-handle': '_handleKey',
      'key:end .coral3-Slider-handle': '_handleKey',

      'capture:mouseenter .coral3-Slider-handle': '_onMouseEnter',
      'capture:mouseleave .coral3-Slider-handle': '_onMouseLeave',

      'input': '_onInputChangeHandler',

      'touchstart': '_onMouseDown',
      'mousedown': '_onMouseDown',

      'capture:focus': '_focus',
      'capture:blur': '_blur'
    },

    properties: {
      /**
        Increment value of one step.

        @type {Number}
        @default 1
        @htmlattribute step
        @htmlattributereflected
        @memberof Coral.Slider#
      */
      'step': {
        default: 1,
        reflectAttribute: true,
        transform: Coral.transform.number,
        validate: [
          Coral.validate.valueMustChange,
          function(newValue, oldValue) {
            // step value has to be a positive number
            return newValue !== null && newValue > 0;
          }
        ],
        sync: function() {
          var self = this;
          self._elements.inputs.forEach(function(input) {
            input.setAttribute('step', self.step);
            input.setAttribute('aria-valuestep', self.step);
          });
        }
      },

      /**
        The minimum value.

        @type {Number}
        @default 1
        @htmlattribute min
        @htmlattributereflected
        @memberof Coral.Slider#
      */
      'min': {
        default: 1,
        reflectAttribute: true,
        transform: Coral.transform.number,
        sync: function() {
          var self = this;
          self.setAttribute('aria-valuemin', self.min);
  
          self._elements.inputs.forEach(function(input) {
            input.setAttribute('min', self.min);
            input.setAttribute('aria-valuemin', self.min);
          });
        }
      },

      /**
        The maximum value.

        @type {Number}
        @default 100
        @htmlattribute max
        @htmlattributereflected
        @memberof Coral.Slider#
      */
      'max': {
        default: 100,
        reflectAttribute: true,
        transform: Coral.transform.number,
        sync: function() {
          var self = this;
          self._elements.inputs.forEach(function(input) {
            input.setAttribute('max', self.max);
            input.setAttribute('aria-valuemax', self.max);
          });
        }
      },

      /**
        Display tooltips for the slider value.

        @type {Boolean}
        @default false
        @htmlattribute tooltips
        @htmlattributereflected
        @memberof Coral.Slider#
      */
      'tooltips': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {}
      },

      /**
        Orientation of the slider, which can be VERTICAL or HORIZONTAL.

        @type {Coral.Slider.orientation}
        @default Coral.Slider.orientation.HORIZONTAL
        @htmlattribute orientation
        @memberof Coral.Slider#
      */
      'orientation': {
        default: orientation.HORIZONTAL,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(orientation)
        ],
        sync: function() {
          var self = this;
          var isVertical = self.orientation === orientation.VERTICAL;
  
          self.classList.toggle(CLASSNAME + '--vertical', isVertical);
          self.setAttribute('aria-orientation', self.orientation);
          self._elements.inputs.forEach(function(input) {
            input.setAttribute('aria-orientation', self.orientation);
          });
  
          self._moveHandles();
        }
      },

      /**
        The current value of the slider.

        @type {String}
        @default {@link Coral.Slider#min}
        @htmlattribute value
        @memberof Coral.Slider#
        @fires Coral.mixin.formField#change
      */
      'value': {
        default: function() {
          return String(this.min);
        },
        alsoSync: ['filled'],
        transform: Coral.transform.number,
        get: function() {
          return this._elements.inputs[0].value;
        },
        set: function(value) {
          // setting the value should always set the first value
          if (this._elements.handles.length === 1) {

            var input = this._elements.inputs[0];

            value = this._snapValueToStep(value, this.min, this.max, this.step);

            input.value = value;
            input.setAttribute('aria-valuenow', value);
            input.setAttribute('aria-valuetext', this._getLabel(value));

            this._moveHandles();

            // in order to keep the reset value in sync, we need to handle the "value" attribute of the inner input
            var valueAttribute = this.getAttribute('value');
            input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
          }
        },
        // No-op is required so we can use alsoSync
        sync: function() {}
      },

      /**
        The value returned as a Number. Value is <code>NaN</code> if conversion to Number is not possible.

        @type {Number}
        @default NaN
        @memberof Coral.Slider#
      */
      'valueAsNumber': {
        attribute: null,
        transform: Coral.transform.float,
        get: function() {
          return parseFloat(this.value);
        },
        set: function(value) {
          this.value = value;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.inputs[0].name;
        },
        set: function(name) {
          this._elements.inputs.forEach(function(input) {
            input.name = name;
          });
        }
      },

      /**
        @ignore
      */
      '_values': {
        attribute: null,
        default: function() {
          return [this.min, this.max];
        },
        get: function() {
          var ret = [];

          this._elements.inputs.forEach(function(input) {
            ret.push(String(parseInt(input.value, 10)));
          });

          return ret;
        },
        set: function(values) {
          var self = this;
          if (values && values.length === self._elements.handles.length) {
            self._elements.inputs.forEach(function(input, i) {
              var value = values[i] = self._snapValueToStep(values[i], self.min, self.max, self.step);

              input.value = value;
              input.setAttribute('aria-valuenow', value);
              input.setAttribute('aria-valuetext', self._getLabel(value));
            });
  
            self._moveHandles();
          }
        },
        // No-op is required so we can alsoSync
        sync: function() {},
        alsoSync: ['filled']
      },

      /**
        Fill a value or value range using a highlight color.

        @type {Boolean}
        @default false
        @htmlattribute filled
        @htmlattributereflected
        @memberof Coral.Slider#
      */
      'filled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          if (this.filled) {
            this._updateFill();
          }
          this._elements.fillHandle.classList.toggle('is-hidden', !this.filled);
        }
      },

      /**
        Whether this field is disabled or not. This value is reflected as an attribute in the DOM. Implementers should
        additionally set 'aria-disabled' to improve accessibility of the component.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.Slider#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          var self = this;
          self.setAttribute('aria-disabled', self.disabled);
          self._elements.inputs.forEach(function(input, i) {
            input[self.disabled ? 'setAttribute' : 'removeAttribute']('disabled', '');
            self._elements.handles[i].setAttribute('aria-disabled', self.disabled);
          });
        }
      },

      // JSDoc inherited
      'labelledBy': {
        override: true,
        attribute: 'labelledby',
        transform: Coral.transform.string,
        get: function() {
          if (this._elements.handles.length === 1) {
            return this._elements.inputs[0].getAttribute('aria-labelledby');
          }
          else {
            return this.getAttribute('aria-labelledby');
          }
        },
        set: function(value) {
          var self = this;
          var label;

          if (!value) { // removing the labels
            self._updateForAttributes(self.labelledBy, self._elements.inputs[0].id, true);
            self.removeAttribute('aria-labelledby');
  
            self._elements.handles.forEach(function(handle, i) {
              handle.removeAttribute('aria-labelledby');
              self._elements.inputs[i].removeAttribute('aria-labelledby');
            });

            return;
          }

          // adding labels
          if (self._elements.handles.length === 1) {
            self._elements.handles[0].setAttribute('aria-labelledby', value);
            self._elements.inputs[0].setAttribute('aria-labelledby', value);
          }
          else {
            self.setAttribute('aria-labelledby', value);
  
            self._elements.handles.forEach(function(handle, i) {
              label = value + ' ' + handle.querySelector('label').id;

              handle.setAttribute('aria-labelledby', label);
              self._elements.inputs[i].setAttribute('aria-labelledby', label);
            });
          }
          self._updateForAttributes(value, self._elements.inputs[0].id);
        }
      },

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Slider#
      */
      'items': {
        set: function() {},
        get: function() {
          // just init on demand
          if (!this._items) {
            this._items = new SliderCollection(this);
          }

          return this._items;
        }
      }
    },

    /**
      handles any mousedown/touchstart on the whole slider
      @private
    */
    _onMouseDown: function(event) {
      // do not accept right mouse button clicks
      if (event instanceof MouseEvent) {
        if ((event.which || event.button) !== 1) {
          return;
        }
      }

      event.preventDefault();

      this._currentHandle = event.target.closest('.' + CLASSNAME_HANDLE);

      // If no handle was touched:
      // the closest handle needs to jump to the closest valid position
      if (!this._currentHandle) {
        var p = this._getPoint(event);
        var val = this._getValueFromCoord(p.pageX, p.pageY, true);

        this._currentHandle = this._findNearestHandle(p.pageX, p.pageY);
        this._updateValue(this._currentHandle, val);
        this._setHandleFocus(this._currentHandle);
      }

      this._currentHandle.classList.add('is-dragged');
      document.body.classList.add('u-coral-closedHand');

      if (this.tooltips) {
        var idx = this._elements.handles.indexOf(this._currentHandle);

        this._openTooltip(this._currentHandle, this._getLabel(this._values[idx]));
      }

      this._draggingHandler = this._handleDragging.bind(this);
      this._mouseUpHandler = this._mouseUp.bind(this);

      Coral.events.on('mousemove', this._draggingHandler);
      Coral.events.on('mouseup', this._mouseUpHandler);

      Coral.events.on('touchmove', this._draggingHandler);
      Coral.events.on('touchend', this._mouseUpHandler);
      Coral.events.on('touchcancel', this._mouseUpHandler);

      this._setHandleFocus(this._currentHandle);
    },

    /**
      @private
      @return {Object} which contains the real coordinates
    */
    _getPoint: function(event) {
      return event.changedTouches && event.changedTouches.length > 0 ?
        event.changedTouches[0] :
        event.touches && event.touches.length > 0 ?
          event.touches[0] :
          event;
    },

    /**
      will set the focus either on the handle element
      or its input if range is supported

      @protected
    */
    _setHandleFocus: function(handle) {
      handle.querySelector('.' + CLASSNAME_INPUT).focus();
    },

    /**
      Handles keyboard interaction with the handlers.
      In case input[type=range] is supported, the focus
      will be on the input and keyboard handling will happen natively

      @private
    */
    _handleKey: function(event) {
      event.preventDefault();

      this._focus(event);

      var handle = event.matchedTarget;
      var idx = this._elements.handles.indexOf(handle);
      var v = parseInt(this._values[idx], 10);

      if (event.keyCode === Coral.Keys.keyToCode('up') ||
        event.keyCode === Coral.Keys.keyToCode('right') ||
        event.keyCode === Coral.Keys.keyToCode('pageUp')) { // increase
        v += this.step;

      }
      else if (event.keyCode === Coral.Keys.keyToCode('down') ||
        event.keyCode === Coral.Keys.keyToCode('left') ||
        event.keyCode === Coral.Keys.keyToCode('pageDown')) { // decrease
        v -= this.step;

      }
      else if (event.keyCode === Coral.Keys.keyToCode('home')) { // min
        v = this.min;

      }
      else if (event.keyCode === Coral.Keys.keyToCode('end')) { // max
        v = this.max;
      }

      this._updateValue(handle, v);
    },

    /**
      Finds the nearest handle based on X/Y coordinates

      @private
    */
    _findNearestHandle: function(mouseX, mouseY) {
      var closestDistance = Infinity, // Incredible large start value
        closestHandle;

      function calculateDistance(elem, mouseX, mouseY) {
        var box = elem.getBoundingClientRect(),
          top = box.top + window.pageYOffset,
          left = box.left + window.pageXOffset;

        return Math.floor(
          Math.sqrt(Math.pow(mouseX - (left + (box.width / 2)), 2) +
            Math.pow(mouseY - (top + (box.height / 2)), 2))
        );
      }

      // Find the nearest handle
      this._elements.handles.forEach(function(handle) {
        var distance = calculateDistance(handle, mouseX, mouseY);

        if (distance < closestDistance) {
          closestDistance = distance;
          closestHandle = handle;
        }
      });

      return closestHandle;
    },

    /**
      Moves the handles to right position
      based on the data in this._values

      @private
    */
    _moveHandles: function() {
      var self = this;

      function calculatePercent(value) {
        return (value - self.min) / (self.max - self.min) * 100;
      }

      // Set the handle position as a percentage based on the stored values
      self._elements.handles.forEach(function(handle, index) {
        var percent = calculatePercent(self._values[index]);

        if (self.orientation === orientation.VERTICAL) {
          handle.style.bottom = percent + '%';
          handle.style.left = '';
        }
        else { // Horizontal
          handle.style.left = percent + '%';
          handle.style.bottom = '';
        }
  
        self._updateTooltip(handle, self._getLabel(self._values[index]));
      });
    },

    /**
      Handles "onchange" events from the input.
      This is only neede in case of IE10 which doesn't handle "oninput event".
      In that case, the _onInputChangeHandler will be called from this handler.

      @private
     */
    _onInputChange: function(event) {
      if (typeof (event.target.oninput) === 'undefined') {
        this._onInputChangeHandler(event);
      }
    },

    /**
      Handles "oninput" events from the input.
      This makes ensures native inputs like
      - direct keyboard interaction with input[type=range]
      - accessibility features with input[type=range]

      Note we are not using the "_onInputChange" directly because Firefox
      will trigger the "change" event only after the focus has been lost.

      @private
     */
    _onInputChangeHandler: function(event) {
      // stops the current event
      event.stopPropagation();

      var handle = event.target.closest('.' + CLASSNAME_HANDLE);

      if (event.target === document.activeElement) {
        this._focus(event);
      }

      this._updateValue(handle, event.target.value, true);
    },

    /**
      Handles "focusin" event from  either an input or its handle.

      @private
     */
    _focus: function(event) {
      var self = this,
        // Depending on support for input[type=range],
        // the event.target could be either the handle or its child input.
        // Use closest() to locate the actual handle.
        handle = event.target.closest('.' + CLASSNAME_HANDLE),
        index = this._elements.handles.indexOf(handle);
      
      this.classList.add('is-focused');
      handle.classList.add('is-focused');

      if (this.tooltips) {
        this._openTooltip(handle, self._getLabel(self._values[index]));
      }

      var eventHandler = function(event) {
        if (!self.contains(event.target)) {
          return;
        }
        event.target.blur();
      };
      
      Coral.events.on('touchstart.CoralSlider', eventHandler);
      Coral.events.on('mousedown.CoralSlider', eventHandler);
    },

    /**
      Handles "focusout" event from  either an input or its handle.

      @private
    */
    _blur: function(event) {
      // Depending on support for input[type=range],
      // the event.target could be either the handle or its child input.
      // Use closest() to locate the actual handle.
      var handle = event.target.closest('.' + CLASSNAME_HANDLE);

      this.classList.remove('is-focused');
      handle.classList.remove('is-focused');

      if (this.tooltips) {
        this._closeTooltip(handle);
      }

      Coral.events.off('.CoralSlider');
    },

    /**
      handles mousemove/touchmove after a succesful start on an handle

      @private
    */
    _handleDragging: function(event) {
      var p = this._getPoint(event);

      this._updateValue(this._currentHandle, this._getValueFromCoord(p.pageX, p.pageY));

      event.preventDefault();
    },

    /**
      updates the value for a handle
      @param handle
      @param val
      @param {Boolean} forceEvent
        Always triggers the event. If <code>true</code> the change event will be triggered without checking if the value really changed. This is useful if we are called from something like the _onInputChange where new value has already been updated AND we are certain the change event should be triggered without checking.
      @protected
    */
    _updateValue: function(handle, val, forceEvent) {
      // this is prepared to work for multiple handles
      var idx = this._elements.handles.indexOf(handle);
      var values = this._values;

      values[idx] = val;

      var oldval = this._values;
      this.set('_values', values);
      var newval = this._values;

      if (forceEvent || oldval.join(':') !== newval.join(':')) {
        this.trigger('change');
      }
    },

    /**
      @private
    */
    _getValueFromCoord: function(posX, posY, restrictBounds) {
      var self = this;
      var percent;
      var boundingClientRect = self.getBoundingClientRect();

      if (self.orientation === orientation.VERTICAL) {
        var elementHeight = boundingClientRect.height;
        percent = ((boundingClientRect.top + elementHeight) - posY) / elementHeight;
      }
      else {
        var elementWidth = boundingClientRect.width;
        percent = ((posX - boundingClientRect.left) / elementWidth);
      }

      // if the bounds are retricted, as with _handleClick, we shouldn't change the value.
      if (restrictBounds && (percent < 0 || percent > 1)) {
        return NaN;
      }

      var rawValue = self.min * 1 + ((self.max - self.min) * percent);

      // Snap value to nearest step
      return this._snapValueToStep(rawValue, self.min, self.max, self.step);
    },

    /**
      @private
    */
    _snapValueToStep: function(rawValue, min, max, step) {
      step = parseFloat(step);
      var remainder = ((rawValue - min) % step), snappedValue,
        floatString = step.toString().replace(/^(?:\d+)(?:\.(\d+))?$/g, '$1'),
        precision = floatString.length;

      if (Math.abs(remainder) * 2 >= step) {
        snappedValue = (rawValue - Math.abs(remainder)) + step;
      }
      else {
        snappedValue = rawValue - remainder;
      }

      if (snappedValue < min) {
        snappedValue = min;
      }
      else if (snappedValue > max) {
        snappedValue = min + Math.floor((max - min) / step) * step;
      }

      // correct floating point behavior by rounding to step precision
      if (precision > 0) {
        snappedValue = parseFloat(snappedValue.toFixed(precision));
      }

      return snappedValue;
    },

    /**
     *
     * @private
     */
    _onMouseEnter: function(event) {
      var handle = event.matchedTarget,
        index = this._elements.handles.indexOf(handle);

      if (this.tooltips) {
        this._openTooltip(handle, this._getLabel(this._values[index]));
      }
    },

    /**
     *
     * @private
     */
    _onMouseLeave: function(event) {
      var handle = event.matchedTarget;

      // in case the user drags the handle
      // we do not close the tooltip
      if (this.tooltips && !handle.classList.contains('is-dragged')) {
        this._closeTooltip(handle);
      }
    },

    /**
      end operation of a dragging flow
      @private
    */
    _mouseUp: function() {
      this._currentHandle.classList.remove('is-dragged');
      document.body.classList.remove('u-coral-closedHand');

      this._closeTooltip(this._currentHandle);

      Coral.events.off('mousemove', this._draggingHandler);
      Coral.events.off('touchmove', this._draggingHandler);
      Coral.events.off('mouseup', this._mouseUpHandler);
      Coral.events.off('touchend', this._mouseUpHandler);
      Coral.events.off('touchcancel', this._mouseUpHandler);

      this._currentHandle = null;
      this._draggingHandler = null;
      this._mouseUpHandler = null;
    },

    /**
      called when it is necessary to update the fill
      @protected
     */
    _updateFill: function() {
      var percent = ((this._values[0] - this.min) / (this.max - this.min)) * 100;

      if (this.orientation === orientation.VERTICAL) {
        this._elements.fillHandle.style.height = percent + '%';
      }
      else {
        this._elements.fillHandle.style.width = percent + '%';
      }
    },

    /**
      Opens the tooltip of a handle
      @protected
    */
    _openTooltip: function(handle, value) {
      var _tooltip = handle.querySelector('coral-tooltip'),
        placement = this.orientation === orientation.VERTICAL ?
          Coral.Overlay.placement.RIGHT :
          Coral.Overlay.placement.TOP;

      _tooltip.set({
        content: {
          textContent: value
        },
        target: handle,
        placement: placement
      });

      _tooltip.open = true;
    },

    /**
      Updates the tooltip of a handle
      @protected
    */
    _updateTooltip: function(handle, value) {
      var _tooltip = handle.querySelector('coral-tooltip');

      _tooltip.content.textContent = value;
    },

    /**
      Closes the tooltip of a handle
      @protected
    */
    _closeTooltip: function(handle) {
      var _tooltip = handle.querySelector('coral-tooltip');
      if (_tooltip) {
        _tooltip.open = false;
      }
    },

    /**
      Gets the label for a passed value.

      @param value
      @return {String|Number} the known label from the item or the value itself
      @protected
    */
    _getLabel: function(value) {
      var items = this.items.getAll();
      var item;

      for (var i = 0; i < items.length; i++) {
        if (Coral.transform.number(items[i].value) === Coral.transform.number(value)) {
          item = items[i];
          break;
        }
      }

      // Use the innerHTML of the item if one was found
      return item ? item.content.innerHTML : value;
    },

    /**
      @protected
    */
    _renderTemplate: function() {
      var frag;

      frag = Coral.templates.Slider.base.call(this._elements);
      this.appendChild(frag);
    },

    /**
      @private
    */
    _render: function() {
      var self = this;
      self._renderTemplate();
  
      self._elements.handles = Array.prototype.slice.call(self.querySelectorAll('.' + CLASSNAME_HANDLE));
      self._elements.inputs = Array.prototype.slice.call(self.querySelectorAll('.' + CLASSNAME_INPUT));
  
      self.setAttribute('role', 'presentation');
    }
  });

  Coral.Slider.orientation = orientation;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var CLASSNAME = 'coral3-Slider-item';

  Coral.register( /** @lends Coral.Slider.Item# */ {
    /**
      @class Coral.Slider.Item
      @classdesc A Slider.Item component
      @extends Coral.Component
      @htmltag coral-slider-item
    */
    name: 'Slider.Item',
    tagName: 'coral-slider-item',
    className: CLASSNAME,

    properties: {

      /**
        The slider's item value.
        This should contain a number formatted as a string (e.g.: "10") or an empty string.

        @type {String}
        @default ""
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.Slider.Item#
      */
      'value': {
        reflectAttribute: true,
        transform: Coral.transform.string
      },

      /**
        The content zone element of the item.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Select.Item#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var CLASSNAME = 'coral3-Slider';

  Coral.register( /** @lends Coral.RangedSlider# */ {
    /**
      @class Coral.RangedSlider
      @classdesc A RangedSlider component
      @extends Coral.Slider
      @htmltag coral-rangedslider
    */
    name: 'RangedSlider',
    tagName: 'coral-rangedslider',
    className: CLASSNAME,
    extend: Coral.Slider,

    properties: {
      /**
        Value property does nothing on a RangedSlider.

        @ignore
        @name value
        @memberof Coral.RangedSlider#
      */

      /**
        Ranged sliders are always filled.

        @type {Boolean}
        @default true
        @override
        @htmlattribute filled
        @htmlattributereflected
        @readonly
        @memberof Coral.RangedSlider#
      */
      'filled': {
        // changes the default to true
        default: true,
        set: function(value) {
          // filled is always true
          this._filled = true;
        }
      },

      // JSDoc inherited
      'value': Coral.property.proxy({
        path: 'startValue'
      }),

      /**
        The starting value of the range.

        @type {String}
        @default {@link Coral.RangedSlider#min}
        @fires Coral.mixin.formField#change
        @memberof Coral.RangedSlider#
        @htmlattribute startValue
        @htmlattributereflected
      */
      'startValue': {
        attribute: 'startvalue',
        transform: Coral.transform.string,
        set: function(value) {

          // Snap value to step
          var valueNumber = Coral.transform.number(value);
          valueNumber = this._snapValueToStep(valueNumber, this.min, this.max, this.step);
          value = String(valueNumber);

          var values = this.values;
          values[0] = value;
          this.values = values;

          // in order to keep the reset value in sync, we need to handle the "startvalue" attribute of the inner input
          var input = this._elements.inputs[0];
          var valueAttribute = this.getAttribute('startvalue') || this.getAttribute('value');
          input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
        },
        get: function() {
          return this.values[0];
        }
      },

      /**
        The ending value of the range.

        @type {String}
        @default {@link Coral.RangedSlider#max}
        @fires Coral.mixin.formField#change
        @memberof Coral.RangedSlider#
        @htmlattribute endValue
        @htmlattributereflected
      */
      'endValue': {
        attribute: 'endvalue',
        transform: Coral.transform.string,
        set: function(value) {

          // Snap value to step
          var valueNumber = Coral.transform.number(value);
          valueNumber = this._snapValueToStep(valueNumber, this.min, this.max, this.step);
          value = String(valueNumber);

          var values = this.values;
          values[1] = value;
          this.values = values;

          // in order to keep the reset value in sync, we need to handle the "endvalue" attribute of the inner input
          var input = this._elements.inputs[1];
          var valueAttribute = this.getAttribute('endvalue');
          input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
        },
        get: function() {
          return this.values[1];
        }
      },

      /**
        The current values of the ranged slider.

        @type {Array.<String>}
        @default [{@link Coral.RangedSlider#startValue},{@link Coral.RangedSlider#endValue}]
        @fires Coral.mixin.formField#change
        @memberof Coral.RangedSlider#
      */
      'values': Coral.property.proxy({
        path: '_values'
      })
    },

    // JSDocs inherited from coralui-mixin-formfield
    clear: function() {
      this.startValue = this.min;
      this.endValue = this.max;
    },

    reset: function() {
      // since the 'value' property is not reflected, form components use it to restore the initial value. When a
      // component has support for values, this method needs to be overwritten

      var initialStartValue = this.getAttribute('startvalue') || this.getAttribute('value');
      var initialEndValue = this.getAttribute('endvalue');

      this.startValue = Coral.transform.string(initialStartValue);
      this.endValue = Coral.transform.string(initialEndValue);
    },

    /**
      @private
    */
    _getHighestValue: function() {
      return Math.max.apply(null, this.values);
    },

    /**
      @private
    */
    _getLowestValue: function() {
      return Math.min.apply(null, this.values);
    },

    /**
      @override
    */
    _updateValue: function(handle, val) {
      var idx = this._elements.handles.indexOf(handle);

      if (idx === 0) {
        if (val > parseFloat(this.values[1])) {
          val = this.values[1];
        }
        this._elements.rightInput.min = val;
        this._elements.rightHandle.setAttribute('aria-valuemin', val);
      }
      else {
        if (val < parseFloat(this.values[0])) {
          val = this.values[0];
        }
        this._elements.leftInput.max = val;
        this._elements.leftHandle.setAttribute('aria-valuemax', val);
      }

      var resValue = [this.values[0], this.values[1]];
      resValue[idx] = val;

      var oldval = this.get('values');
      this.set('values', resValue);
      var newval = this.get('values');

      if (oldval.join(':') !== newval.join(':')) {
        this.trigger('change');
      }
    },

    /**
      @override
    */
    _updateFill: function() {
      var deltaMaxMinBase = 100 / (this.max - this.min);
      var percent = (this._getLowestValue() - this.min) * deltaMaxMinBase;
      var percentDiff = (this._getHighestValue() - this.min) * deltaMaxMinBase - percent;

      if (this.orientation === Coral.Slider.orientation.VERTICAL) {
        this._elements.fillHandle.style.bottom = percent + '%';
        this._elements.fillHandle.style.height = percentDiff + '%';
      }
      else { // Horizontal
        this._elements.fillHandle.style.left = percent + '%';
        this._elements.fillHandle.style.width = percentDiff + '%';
      }
    },

    /**
      @override
    */
    _renderTemplate: function() {
      var frag = Coral.templates.Slider.range.call(this._elements);

      this.appendChild(frag);
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-colorinput"] = {"en-US":{"Swatches":"Swatches","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Color Picker","unset":"Not set","checked":"Checked","{value}, Color":"{value}, Color","Color not set":"Color not set"},"fr-FR":{"Swatches":"Échantillons","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Sélecteur de couleurs","unset":"Non défini","checked":"Activé","{value}, Color":"{value}, Couleur","Color not set":"Couleur non défini"},"de-DE":{"Swatches":"Muster","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Farbauswahl","unset":"Nicht gesetzt","checked":"Aktiviert","{value}, Color":"{value}, Farbe","Color not set":"Farbe nicht gesetzt"},"it-IT":{"Swatches":"Campioni","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Selettore colori","unset":"Non impostato","checked":"Selezionato","{value}, Color":"{value}, Colore","Color not set":"Colore non impostato"},"es-ES":{"Swatches":"Muestras","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Selector de colores","unset":"No establecido","checked":"Activado","{value}, Color":"{value}, Color","Color not set":"Color no establecido"},"pt-BR":{"Swatches":"Amostras","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Seletor de cores","unset":"Não definida","checked":"Selecionado","{value}, Color":"{value}, Cor","Color not set":"Cor não definida"},"ja-JP":{"Swatches":"スウォッチ","R":"R","G":"G","B":"B","A":"A","HEX":"16 進","Color Picker":"カラー ピッカー","unset":"設定解除","checked":"選択","{value}, Color":"{value}, カラー","Color not set":"色が設定されていません"},"ko-KR":{"Swatches":"견본","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"색 선택","unset":"설정 해제","checked":"선택됨","{value}, Color":"{value}, 색","Color not set":"색상이 설정되지 않았습니다."},"zh-CN":{"Swatches":"色板","R":"R","G":"G","B":"B","A":"A","HEX":"十六进制","Color Picker":"颜色选取器","unset":"取消设置","checked":"已选中","{value}, Color":"{value}, 颜色","Color not set":"颜色未设定"},"zh-TW":{"Swatches":"色票","R":"R","G":"G","B":"B","A":"A","HEX":"十六進位","Color Picker":"色彩選擇器","unset":"取消設定","checked":"已檢查","{value}, Color":"{value}, 色彩","Color not set":"顏色未設定"},"nl-NL":{"Swatches":"Stalen","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Kleurenkiezer","unset":"Niet ingesteld","checked":"Geselecteerd","{value}, Color":"{value}, Kleur","Color not set":"Kleur niet ingesteld"},"da-DK":{"Swatches":"Farveprøver","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Farvevælger","unset":"annuller indstilling","checked":"kontrolleret","{value}, Color":"{value}, Farve","Color not set":"Farve ikke indstillet"},"fi-FI":{"Swatches":"Värimallit","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Värimuokkain","unset":"poista asetus","checked":"valittu","{value}, Color":"{value}, väri","Color not set":"Väriä ei ole asetettu."},"nb-NO":{"Swatches":"Fargekart","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Fargevelger","unset":"fjern","checked":"avmerket","{value}, Color":"{value}, farge","Color not set":"Farge ikke angitt"},"sv-SE":{"Swatches":"Färgrutor","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Färgväljaren","unset":"ställ tillbaka","checked":"kontrollerade","{value}, Color":"{value}, Färg","Color not set":"Färg inte inställd"},"cs-CZ":{"Swatches":"Vzorníky","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Výběr barvy","unset":"nenastaveno","checked":"zkontrolováno","{value}, Color":"{value}, Barva","Color not set":"Barva není nastavena"},"pl-PL":{"Swatches":"Próbki","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Próbnik kolorów","unset":"usuń ustawienie","checked":"sprawdzono","{value}, Color":"{value}, kolor","Color not set":"Nie ustawiono koloru"},"ru-RU":{"Swatches":"Цветовые образцы","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Палитра цветов","unset":"не задано","checked":"проверено","{value}, Color":"{value}, цвет","Color not set":"Цвет не задан"},"tr-TR":{"Swatches":"Renk Örnekleri","R":"R","G":"G","B":"B","A":"A","HEX":"HEX","Color Picker":"Renk Seçici","unset":"ayarı kaldır","checked":"denetlendi","{value}, Color":"{value}, Renk","Color not set":"Renk ayarlanmadı"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["ColorInput"] = window["Coral"]["templates"]["ColorInput"] || {};
window["Coral"]["templates"]["ColorInput"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  var uid = Coral.commons.getUID();
  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["input"] = document.createElement("input","coral-textfield");
  el2.setAttribute("handle", "input");
  el2.setAttribute("is", "coral-textfield");
  el2.className += " coral3-ColorInput-input";
  el2.setAttribute("type", "text");
  el2.setAttribute("value", "");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = document.createElement("div");
  el4.className += " coral3-ColorInput-buttonWrapper";
  el4.setAttribute("role", "presentation");
  var el5 = document.createTextNode("\n  ");
  el4.appendChild(el5);
  var el6 = this["colorPreview"] = document.createElement("button","coral-button");
  el6.setAttribute("handle", "colorPreview");
  el6.setAttribute("is", "coral-button");
  el6.setAttribute("variant", "default");
  el6.className += " coral3-ColorInput-button coral3-ColorInput-preview";
  el6.setAttribute("type", "button");
  el6.setAttribute("aria-haspopup", "true");
  el6.setAttribute("aria-expanded", "false");
  el6.setAttribute("aria-controls", uid);
  var el7 = document.createTextNode("\n    ");
  el6.appendChild(el7);
  var el8 = document.createElement("coral-button-label");
  el8.id = uid+"-coral-button-label";
  el8.className += " u-coral-screenReaderOnly";
  el8.textContent = Coral["i18n"]["get"]('Color Picker');
  el6.appendChild(el8);
  var el9 = document.createTextNode("\n  ");
  el6.appendChild(el9);
  el4.appendChild(el6);
  var el10 = document.createTextNode("\n");
  el4.appendChild(el10);
  frag.appendChild(el4);
  var el11 = document.createTextNode("\n");
  frag.appendChild(el11);
  var el12 = this["overlay"] = document.createElement("coral-overlay");
  el12.setAttribute("role", "dialog");
  el12.setAttribute("focusonshow", "on");
  el12.setAttribute("trapfocus", "on");
  el12.setAttribute("handle", "overlay");
  el12.setAttribute("alignmy", "right top");
  el12.setAttribute("alignat", "right bottom");
  el12.setAttribute("collision", "fit");
  el12.setAttribute("offset", "5");
  el12.id = uid;
  el12.setAttribute("aria-label", Coral["i18n"]["get"]('Color Picker'));
  frag.appendChild(el12);
  return frag;
});

window["Coral"]["templates"]["ColorInput"]["colorProperties"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  var uid = Coral.commons.getUID();
  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral3-ColorInput-propertiesSubview";
  el2.setAttribute("role", "group");
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = document.createElement("div");
  el4.className += " coral3-ColorInput-previewView";
  el4.setAttribute("role", "presentation");
  var el5 = document.createTextNode("\n    ");
  el4.appendChild(el5);
  var el6 = document.createElement("div");
  el6.className += " coral3-ColorInput-preview-container";
  el6.setAttribute("role", "presentation");
  var el7 = document.createTextNode("\n      ");
  el6.appendChild(el7);
  var el8 = this["colorPreview2"] = document.createElement("button","coral-button");
  el8.setAttribute("is", "coral-button");
  el8.setAttribute("handle", "colorPreview2");
  el8.className += " coral3-ColorInput-preview";
  el8.setAttribute("type", "button");
  el8.setAttribute("aria-pressed", "false");
  el6.appendChild(el8);
  var el9 = document.createTextNode("\n    ");
  el6.appendChild(el9);
  el4.appendChild(el6);
  var el10 = document.createTextNode("\n    ");
  el4.appendChild(el10);
  var el11 = document.createElement("div");
  el11.className += " coral3-ColorInput-editHex";
  el11.setAttribute("role", "presentation");
  var el12 = document.createTextNode("\n      ");
  el11.appendChild(el12);
  var el13 = document.createElement("label");
  var el14 = document.createTextNode("\n        ");
  el13.appendChild(el14);
  var el15 = document.createElement("span");
  el15.textContent = "#";
  el13.appendChild(el15);
  var el16 = document.createTextNode("\n        ");
  el13.appendChild(el16);
  var el17 = this["hexInput"] = document.createElement("input","coral-textfield");
  el17.setAttribute("type", "text");
  el17.setAttribute("handle", "hexInput");
  el17.setAttribute("is", "coral-textfield");
  el17.setAttribute("aria-label", Coral["i18n"]["get"]('HEX'));
  el17.setAttribute("placeholder", Coral["i18n"]["get"]('HEX'));
  el17.setAttribute("maxlength", "6");
  el17.setAttribute("value", "");
  el17.setAttribute("variant", "quiet");
  el13.appendChild(el17);
  var el18 = document.createTextNode("\n      ");
  el13.appendChild(el18);
  el11.appendChild(el13);
  var el19 = document.createTextNode("\n    ");
  el11.appendChild(el19);
  el4.appendChild(el11);
  var el20 = document.createTextNode("\n  ");
  el4.appendChild(el20);
  el2.appendChild(el4);
  var el21 = document.createTextNode("\n  ");
  el2.appendChild(el21);
  var el22 = document.createElement("div");
  el22.className += " coral3-ColorInput-rgbaView coral3-ColorInput-editRgba";
  el22.setAttribute("role", "presentation");
  var el23 = document.createTextNode("\n    ");
  el22.appendChild(el23);
  var el24 = document.createElement("div");
  el24.setAttribute("role", "group");
  el24.setAttribute("labelledby", uid+"-r");
  var el25 = document.createTextNode("\n      ");
  el24.appendChild(el25);
  var el26 = document.createElement("label");
  el26.id = uid+"-r";
  el26.textContent = Coral["i18n"]["get"]('R');
  el24.appendChild(el26);
  var el27 = document.createTextNode("\n      ");
  el24.appendChild(el27);
  var el28 = this["redSlider"] = document.createElement("coral-colorinput-slider");
  el28.setAttribute("labelledby", uid+"-r");
  el28.setAttribute("handle", "redSlider");
  el28.setAttribute("min", "0");
  el28.setAttribute("max", "255");
  el28.setAttribute("value", "0");
  el28.setAttribute("gradient", "#000000 #FF0000");
  el24.appendChild(el28);
  var el29 = document.createTextNode("\n      ");
  el24.appendChild(el29);
  var el30 = this["redInput"] = document.createElement("input","coral-textfield");
  el30.setAttribute("labelledby", uid+"-r");
  el30.setAttribute("handle", "redInput");
  el30.setAttribute("is", "coral-textfield");
  el30.setAttribute("type", "number");
  el30.setAttribute("placeholder", Coral["i18n"]["get"]('R'));
  el30.setAttribute("maxlength", "3");
  el30.setAttribute("value", "");
  el30.setAttribute("variant", "quiet");
  el24.appendChild(el30);
  var el31 = document.createTextNode("\n    ");
  el24.appendChild(el31);
  el22.appendChild(el24);
  var el32 = document.createTextNode("\n    ");
  el22.appendChild(el32);
  var el33 = document.createElement("div");
  el33.setAttribute("role", "group");
  el33.setAttribute("labelledby", uid+"-g");
  var el34 = document.createTextNode("\n      ");
  el33.appendChild(el34);
  var el35 = document.createElement("label");
  el35.id = uid+"-g";
  el35.textContent = Coral["i18n"]["get"]('G');
  el33.appendChild(el35);
  var el36 = document.createTextNode("\n      ");
  el33.appendChild(el36);
  var el37 = this["greenSlider"] = document.createElement("coral-colorinput-slider");
  el37.setAttribute("labelledby", uid+"-g");
  el37.setAttribute("handle", "greenSlider");
  el37.setAttribute("min", "0");
  el37.setAttribute("max", "255");
  el37.setAttribute("value", "0");
  el37.setAttribute("gradient", "#000000 #00FF00");
  el33.appendChild(el37);
  var el38 = document.createTextNode("\n      ");
  el33.appendChild(el38);
  var el39 = this["greenInput"] = document.createElement("input","coral-textfield");
  el39.setAttribute("labelledby", uid+"-g");
  el39.setAttribute("handle", "greenInput");
  el39.setAttribute("is", "coral-textfield");
  el39.setAttribute("type", "number");
  el39.className += " coral3-ColorInput-editRgb";
  el39.setAttribute("placeholder", Coral["i18n"]["get"]('G'));
  el39.setAttribute("maxlength", "3");
  el39.setAttribute("value", "");
  el39.setAttribute("variant", "quiet");
  el33.appendChild(el39);
  var el40 = document.createTextNode("\n    ");
  el33.appendChild(el40);
  el22.appendChild(el33);
  var el41 = document.createTextNode("\n    ");
  el22.appendChild(el41);
  var el42 = document.createElement("div");
  el42.setAttribute("role", "group");
  el42.setAttribute("labelledby", uid+"-b");
  var el43 = document.createTextNode("\n      ");
  el42.appendChild(el43);
  var el44 = document.createElement("label");
  el44.id = uid+"-b";
  el44.textContent = Coral["i18n"]["get"]('B');
  el42.appendChild(el44);
  var el45 = document.createTextNode("\n      ");
  el42.appendChild(el45);
  var el46 = this["blueSlider"] = document.createElement("coral-colorinput-slider");
  el46.setAttribute("labelledby", uid+"-b");
  el46.setAttribute("handle", "blueSlider");
  el46.setAttribute("min", "0");
  el46.setAttribute("max", "255");
  el46.setAttribute("value", "0");
  el46.setAttribute("gradient", "#000000 #0000FF");
  el42.appendChild(el46);
  var el47 = document.createTextNode("\n      ");
  el42.appendChild(el47);
  var el48 = this["blueInput"] = document.createElement("input","coral-textfield");
  el48.setAttribute("labelledby", uid+"-b");
  el48.setAttribute("handle", "blueInput");
  el48.setAttribute("is", "coral-textfield");
  el48.setAttribute("type", "number");
  el48.setAttribute("placeholder", Coral["i18n"]["get"]('B'));
  el48.setAttribute("maxlength", "3");
  el48.setAttribute("value", "");
  el48.setAttribute("variant", "quiet");
  el42.appendChild(el48);
  var el49 = document.createTextNode("\n    ");
  el42.appendChild(el49);
  el22.appendChild(el42);
  var el50 = document.createTextNode("\n    ");
  el22.appendChild(el50);
  var el51 = document.createElement("div");
  el51.setAttribute("role", "group");
  el51.setAttribute("labelledby", uid+"-a");
  var el52 = document.createTextNode("\n      ");
  el51.appendChild(el52);
  var el53 = document.createElement("label");
  el53.id = uid+"-a";
  el53.textContent = Coral["i18n"]["get"]('A');
  el51.appendChild(el53);
  var el54 = document.createTextNode("\n      ");
  el51.appendChild(el54);
  var el55 = this["alphaSlider"] = document.createElement("coral-colorinput-slider");
  el55.setAttribute("labelledby", uid+"-a");
  el55.setAttribute("handle", "alphaSlider");
  el55.setAttribute("min", "0");
  el55.setAttribute("max", "100");
  el55.setAttribute("value", "100");
  el55.setAttribute("gradient", "rgba(255,255,255,0) rgba(255,255,255,1)");
  el51.appendChild(el55);
  var el56 = document.createTextNode("\n      ");
  el51.appendChild(el56);
  var el57 = this["alphaInput"] = document.createElement("input","coral-textfield");
  el57.setAttribute("labelledby", uid+"-a");
  el57.setAttribute("handle", "alphaInput");
  el57.setAttribute("is", "coral-textfield");
  el57.setAttribute("type", "number");
  el57.setAttribute("placeholder", Coral["i18n"]["get"]('A'));
  el57.setAttribute("maxlength", "3");
  el57.setAttribute("value", "");
  el57.setAttribute("variant", "quiet");
  el51.appendChild(el57);
  var el58 = document.createTextNode("\n    ");
  el51.appendChild(el58);
  el22.appendChild(el51);
  var el59 = document.createTextNode("\n  ");
  el22.appendChild(el59);
  el2.appendChild(el22);
  var el60 = document.createTextNode("\n");
  el2.appendChild(el60);
  frag.appendChild(el2);
  var el61 = document.createTextNode("\n");
  frag.appendChild(el61);
  return frag;
});

window["Coral"]["templates"]["ColorInput"]["defaultColorPalette"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["defaultPalette"] = document.createElement("div");
  el0.setAttribute("handle", "defaultPalette");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("coral-colorinput-item");
  el2.setAttribute("value", "");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n  ");
  el0.appendChild(el3);
  var el4 = document.createElement("coral-colorinput-item");
  el4.setAttribute("value", "#001F3F");
  el0.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el0.appendChild(el5);
  var el6 = document.createElement("coral-colorinput-item");
  el6.setAttribute("value", "#0074D9");
  el0.appendChild(el6);
  var el7 = document.createTextNode("\n  ");
  el0.appendChild(el7);
  var el8 = document.createElement("coral-colorinput-item");
  el8.setAttribute("value", "#7FDBFF");
  el0.appendChild(el8);
  var el9 = document.createTextNode("\n  ");
  el0.appendChild(el9);
  var el10 = document.createElement("coral-colorinput-item");
  el10.setAttribute("value", "#39CCCC");
  el0.appendChild(el10);
  var el11 = document.createTextNode("\n  ");
  el0.appendChild(el11);
  var el12 = document.createElement("coral-colorinput-item");
  el12.setAttribute("value", "#3D9970");
  el0.appendChild(el12);
  var el13 = document.createTextNode("\n  ");
  el0.appendChild(el13);
  var el14 = document.createElement("coral-colorinput-item");
  el14.setAttribute("value", "#2ECC40");
  el0.appendChild(el14);
  var el15 = document.createTextNode("\n  ");
  el0.appendChild(el15);
  var el16 = document.createElement("coral-colorinput-item");
  el16.setAttribute("value", "#01FF70");
  el0.appendChild(el16);
  var el17 = document.createTextNode("\n  ");
  el0.appendChild(el17);
  var el18 = document.createElement("coral-colorinput-item");
  el18.setAttribute("value", "#FFDC00");
  el0.appendChild(el18);
  var el19 = document.createTextNode("\n  ");
  el0.appendChild(el19);
  var el20 = document.createElement("coral-colorinput-item");
  el20.setAttribute("value", "#FF851B");
  el0.appendChild(el20);
  var el21 = document.createTextNode("\n  ");
  el0.appendChild(el21);
  var el22 = document.createElement("coral-colorinput-item");
  el22.setAttribute("value", "#FF4136");
  el0.appendChild(el22);
  var el23 = document.createTextNode("\n  ");
  el0.appendChild(el23);
  var el24 = document.createElement("coral-colorinput-item");
  el24.setAttribute("value", "#85144B");
  el0.appendChild(el24);
  var el25 = document.createTextNode("\n  ");
  el0.appendChild(el25);
  var el26 = document.createElement("coral-colorinput-item");
  el26.setAttribute("value", "#F012BE");
  el0.appendChild(el26);
  var el27 = document.createTextNode("\n  ");
  el0.appendChild(el27);
  var el28 = document.createElement("coral-colorinput-item");
  el28.setAttribute("value", "#B10DC9");
  el0.appendChild(el28);
  var el29 = document.createTextNode("\n  ");
  el0.appendChild(el29);
  var el30 = document.createElement("coral-colorinput-item");
  el30.setAttribute("value", "#111111");
  el0.appendChild(el30);
  var el31 = document.createTextNode("\n  ");
  el0.appendChild(el31);
  var el32 = document.createElement("coral-colorinput-item");
  el32.setAttribute("value", "#AAAAAA");
  el0.appendChild(el32);
  var el33 = document.createTextNode("\n  ");
  el0.appendChild(el33);
  var el34 = document.createElement("coral-colorinput-item");
  el34.setAttribute("value", "#DDDDDD");
  el0.appendChild(el34);
  var el35 = document.createTextNode("\n");
  el0.appendChild(el35);
  return el0;
});

window["Coral"]["templates"]["ColorInput"]["sliderBase"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  var uid = Coral.commons.getUID();
  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["sliderBar"] = document.createElement("div");
  el2.setAttribute("handle", "sliderBar");
  el2.className += " coral3-ColorInput-sliderBar coral3-Slider-bar";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["fillHandle"] = document.createElement("div");
  el4.setAttribute("handle", "fillHandle");
  el4.className += " coral3-Slider-fill is-hidden";
  el4.setAttribute("role", "presentation");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el2.appendChild(el5);
  frag.appendChild(el2);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = this["leftHandle"] = document.createElement("div");
  el7.setAttribute("handle", "leftHandle");
  el7.className += " coral3-ColorInput-sliderHandle coral3-Slider-handle";
  var el8 = document.createTextNode("\n  ");
  el7.appendChild(el8);
  var el9 = this["leftInput"] = document.createElement("input");
  el9.setAttribute("handle", "leftInput");
  el9.setAttribute("type", "range");
  el9.id = uid;
  el9.className += " coral3-Slider-input";
  el7.appendChild(el9);
  var el10 = document.createTextNode("\n  ");
  el7.appendChild(el10);
  var el11 = document.createElement("coral-tooltip");
  el11.setAttribute("variant", "inspect");
  el11.id = uid+"-tooltip";
  el11.setAttribute("for", uid);
  el11.setAttribute("interaction", "off");
  el7.appendChild(el11);
  var el12 = document.createTextNode("\n");
  el7.appendChild(el12);
  frag.appendChild(el7);
  var el13 = document.createTextNode("\n");
  frag.appendChild(el13);
  return frag;
});

window["Coral"]["templates"]["ColorInput"]["swatchesHeader"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " coral3-ColorInput-swatchesSubview";
  el0.setAttribute("role", "presentation");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral3-ColorInput-swatches-header-title";
  el2.setAttribute("role", "presentation");
  el2.setAttribute("aria-hidden", "true");
  var el3 = document.createTextNode("\n    ");
  el2.appendChild(el3);
  var el4 = this["swatchesHeaderTitle"] = document.createElement("span");
  el4.setAttribute("handle", "swatchesHeaderTitle");
  el4.id = Coral["commons"]["getUID"]();
  el4.setAttribute("role", "heading");
  el4.setAttribute("aria-level", "2");
  el4.textContent = "\n      "+Coral["i18n"]["get"]('Swatches');
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el2.appendChild(el5);
  el0.appendChild(el2);
  var el6 = document.createTextNode("\n  ");
  el0.appendChild(el6);
  var el7 = document.createElement("div");
  el7.className += " coral3-ColorInput-swatches-container";
  el7.setAttribute("role", "presentation");
  el7.setAttribute("aria-labelledby", Coral["commons"]["getUID"]());
  var el8 = document.createTextNode("\n    ");
  el7.appendChild(el8);
  var el9 = this["swatchesContainer"] = document.createElement("div");
  el9.setAttribute("handle", "swatchesContainer");
  el9.setAttribute("role", "presentation");
  el7.appendChild(el9);
  var el10 = document.createTextNode("\n  ");
  el7.appendChild(el10);
  el0.appendChild(el7);
  var el11 = document.createTextNode("\n");
  el0.appendChild(el11);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // try to stay in same color space as long as possible (because of conversions being not 100% accurate ...)
  /** @ignore */
  var colorSpace = {
    RGB: 'rgb',
    HEX: 'hex',
    CMYK: 'cmyk',
    HSB: 'hsb',
    HSL: 'hsl'
  };

  /**
    Coral.Color is used to get a color in different color spaces, calculate tints and shades ...

    @constructor
  */
  Coral.Color = function() {
    // Set defaults
    this._colorSpace = colorSpace.HEX;
    this._value = '';
    this._alpha = 1;
  };

  Coral.Color.prototype = {

    /**
      The value of the color. This value can be set in different formats (HEX, RGB, RGBA, HSB, HSL, HSLA and CMYK).
      Corrects a hex value, if it is represented by 3 or 6 characters with or without '#'.

      e.g:
      HEX:  #FFFFFF
      RGB:  rgb(16,16,16)
      RGBA: rgba(215,40,40,0.9)
      HSB:  hsb(360,100,100)
      HSL:  hsl(360,100%,100%)
      HSLA: hsla(360,100%,100%,0.9)
      CMYK: cmyk(0,100,50,0)

      @type {String}
      @default ""
      @memberof Coral.Color#
    */
    get value() {
      return this._value;
    },
    set value(value) {
      // Two color formats with alpha values
      var rgba = _parseRGBA(value);
      var hsla = _parseHSLA(value);

      var rgb = _parseRGB(value);
      var cmyk = _parseCMYK(value);
      var hsb = _parseHSB(value);
      var hsl = _parseHSL(value);
      var hex = _parseHex(value);

      if (rgba !== null) {
        this._colorSpace = colorSpace.RGB;
        this.alpha = rgba.a;
        value = _serializeRGB({
          r: rgba.r,
          g: rgba.g,
          b: rgba.b
        });
      }
      else if (hsla !== null) {
        this._colorSpace = colorSpace.HSL;
        this.alpha = hsla.a;
        value = _serializeHSL({
          h: hsla.h,
          s: hsla.s,
          l: hsla.l
        });
      }
      else if (rgb !== null) {
        this._colorSpace = colorSpace.RGB;
      }
      else if (cmyk !== null) {
        this._colorSpace = colorSpace.CMYK;
      }
      else if (hsb !== null) {
        this._colorSpace = colorSpace.HSB;
      }
      else if (hsl !== null) {
        this._colorSpace = colorSpace.HSL;
      }
      else if (hex !== null) {
        this._colorSpace = colorSpace.HEX;
      }
      else {
        // restore defaults
        this._colorSpace = colorSpace.HEX;
        value = '';
      }

      this._value = value;
    },

    /**
      The alpha value of the color (value between 0-1).

      @type {Number}
      @default 1
      @memberof Coral.Color#
    */
    get alpha() {
      return this._alpha;
    },
    set alpha(value) {
      if (isNaN(value) || value < 0 || value > 1) {
        return;
      }
      this._alpha = Coral.transform.number(value);
    },

    /**
      The rgb values of the color (value between 0-255).
      e.g.: {r:0, g:0, b:0}

      @type {Object}
      @default null
      @memberof Coral.Color#
    */
    get rgb() {
      var rgb = null;
      if (this._colorSpace === colorSpace.RGB) {
        rgb = _parseRGB(this.value);
      }
      else if (this._colorSpace === colorSpace.HEX) {
        var hex = _parseHex(this.value);
        rgb = _hexToRgb(hex);
      }
      else if (this._colorSpace === colorSpace.CMYK) {
        var cmyk = _parseCMYK(this.value);
        rgb = _cmykToRgb(cmyk);
      }
      else if (this._colorSpace === colorSpace.HSB) {
        var hsb = _parseHSB(this.value);
        rgb = _hsbToRgb(hsb);
      }
      else if (this._colorSpace === colorSpace.HSL) {
        var hsl = _parseHSL(this.value);
        rgb = _hslToRgb(hsl);
      }
      return rgb;
    },
    set rgb(value) {
      this.value = _serializeRGB(value);
    },

    /**
      The serialized rgb values of the color (r,g,b values between 0-255).
      e.g: 'rgb(0,0,0)'

      @type {String}
      @default ""
      @memberof Coral.Color#
    */
    get rgbValue() {
      return _serializeRGB(this.rgb);
    },
    set rgbValue(value) {
      this.value = value;
    },

    /**
      The rgba values of the color (r,g,b values between 0-255 and a between 0-1).
      e.g: {r:0, g:0, b:0, a:1}

      @type {Object}
      @default null
      @memberof Coral.Color#
    */
    get rgba() {
      var rgb = this.rgb;
      if (rgb) {
        return {
          r: rgb.r,
          g: rgb.g,
          b: rgb.b,
          a: this.alpha
        };
      }

      return null;
    },
    set rgba(value) {
      this.value = _serializeRGBA(value);
    },

    /**
      The serialized rgba values of the color (r,g,b values between 0-255 and alpha between 0-1).
      e.g: 'rgba(0,0,0,1)'

      @type {String}
      @default ""
      @memberof Coral.Color#
    */
    get rgbaValue() {
      return _serializeRGBA(this.rgba);
    },
    set rgbaValue(value) {
      this.value = value;
    },

    /**
      The hex value of the color.

      @type {Number}
      @default null
      @memberof Coral.Color#
    */
    get hex() {
      // as hex color space is essentially just the same as rgb and there is no loss in conversion, we can do it this way
      return _rgbToHex(this.rgb);
    },
    set hex(value) {
      this.value = _serializeHex(value);
    },

    /**
      The serialized hex value of the color.
      e.g: '#94CD4B'

      @type {String}
      @default ""
      @memberof Coral.Color#
    */
    get hexValue() {
      return _serializeHex(this.hex);
    },
    set hexValue(value) {
      this.value = value;
    },

    /**
      The cmyk values of the color (all values between 0-100).
      e.g: {c:0, m:100, y:0, k:100}

      @type {Object}
      @default null
      @memberof Coral.Color#
    */
    get cmyk() {
      var cmyk = null;
      var rgb = null;
      if (this._colorSpace === colorSpace.RGB) {
        rgb = _parseRGB(this.value);
        cmyk = _rgbToCmyk(rgb);
      }
      else if (this._colorSpace === colorSpace.HEX) {
        var hex = _parseHex(this.value);
        rgb = _hexToRgb(hex);
        cmyk = _rgbToCmyk(rgb);
      }
      else if (this._colorSpace === colorSpace.CMYK) {
        cmyk = _parseCMYK(this.value);
      }
      else if (this._colorSpace === colorSpace.HSB) {
        var hsb = _parseHSB(this.value);
        rgb = _hsbToRgb(hsb);
        cmyk = _rgbToCmyk(rgb);
      }
      else if (this._colorSpace === colorSpace.HSL) {
        var hsl = _parseHSL(this.value);
        rgb = _hslToRgb(hsl);
        cmyk = _rgbToCmyk(rgb);
      }
      return cmyk;
    },
    set cmyk(value) {
      this.value = _serializeCMYK(value);
    },

    /**
     The serialized cmyk values of the color (all values between 0-100).
     e.g: 'cmyk(100,100,100,100)'

     @type {String}
     @default ""
     @memberof Coral.Color#
    */
    get cmykValue() {
      return _serializeCMYK(this.cmyk);
    },
    set cmykValue(value) {
      this.value = value;
    },

    /**
      The hsb values of the color.
      h (hue has value between 0-360 degree)
      s (saturation has a value between 0-100 percent)
      b (brightness has a value between 0-100 percent)

      @type {Object}
      @default null
      @memberof Coral.Color#
    */
    get hsb() {
      var hsb = null;
      var rgb = null;
      if (this._colorSpace === colorSpace.RGB) {
        rgb = _parseRGB(this.value);
        hsb = _rgbToHsb(rgb);
      }
      else if (this._colorSpace === colorSpace.HEX) {
        var hex = _parseHex(this.value);
        rgb = _hexToRgb(hex);
        hsb = _rgbToHsb(rgb);
      }
      else if (this._colorSpace === colorSpace.CMYK) {
        var cmyk = _parseCMYK(this.value);
        rgb = _cmykToRgb(cmyk);
        hsb = _rgbToHsb(rgb);
      }
      else if (this._colorSpace === colorSpace.HSB) {
        hsb = _parseHSB(this.value);
      }
      else if (this._colorSpace === colorSpace.HSL) {
        var hsl = _parseHSL(this.value);
        rgb = _hslToRgb(hsl);
        hsb = _rgbToHsb(rgb);
      }
      return hsb;
    },
    set hsb(value) {
      this.value = _serializeHSB(value);
    },

    /**
      The serialized hsb values of the color (s and b values between 0-100, h between 0-360).
      e.g: 'hsb(360,100,100)'

      @type {String}
      @default ""
      @memberof Coral.Color#
    */
    get hsbValue() {
      return _serializeHSB(this.hsb);
    },
    set hsbValue(value) {
      this.value = value;
    },

    /*
      The hsl values of the color.
      h (hue has value between 0-360 degree)
      s (saturation has a value between 0-100 percent)
      l (lightness has a value between 0-100 percent)

      @type {Object}
      @default null
      @memberof Coral.Color#
    */
    get hsl() {
      var hsl = null;
      var rgb = null;
      if (this._colorSpace === colorSpace.RGB) {
        rgb = _parseRGB(this.value);
        hsl = _rgbToHsl(rgb);
      }
      else if (this._colorSpace === colorSpace.HEX) {
        var hex = _parseHex(this.value);
        rgb = _hexToRgb(hex);
        hsl = _rgbToHsl(rgb);
      }
      else if (this._colorSpace === colorSpace.CMYK) {
        var cmyk = _parseCMYK(this.value);
        rgb = _cmykToRgb(cmyk);
        hsl = _rgbToHsl(rgb);
      }
      else if (this._colorSpace === colorSpace.HSB) {
        var hsb = _parseHSB(this.value);
        rgb = _hsbToRgb(hsb);
        hsl = _rgbToHsl(rgb);
      }
      else if (this._colorSpace === colorSpace.HSL) {
        hsl = _parseHSL(this.value);
      }
      return hsl;
    },
    set hsl(value) {
      this.value = _serializeHSL(value);
    },

    /**
      The serialized hsl values of the color (s and l values between 0-100 in percent, h between 0-360).
      e.g: 'hsl(360,100%,100%)'

      @type {String}
      @default ""
      @memberof Coral.Color#
    */
    get hslValue() {
      return _serializeHSL(this.hsl);
    },
    set hslValue(value) {
      this.value = value;
    },

    /**
      The hsla values of the color.
      h (hue has value between 0-360 degree)
      s (saturation has a value between 0-100 percent)
      l (lightness has a value between 0-100 percent)
      a (alpha has a value between 0-1)

      @type {Object}
      @default null
      @memberof Coral.Color#
    */
    get hsla() {
      var hsl = this.hsl;
      if (hsl) {
        return {
          h: hsl.h,
          s: hsl.s,
          l: hsl.l,
          a: this.alpha
        };
      }

      return null;
    },
    set hsla(value) {
      this.value = _serializeHSLA(value);
    },

    /**
      The serialized hsla values of the color.
      h (hue has value between 0-360 degree)
      s (saturation has a value between 0-100 percent)
      l (lightness has a value between 0-100 percent)
      a (alpha has a value between 0-1)
      e.g: 'hsla(360,50%,50%,0.9)'

      @type {String}
      @default ""
      @memberof Coral.Color#
    */
    get hslaValue() {
      return _serializeHSLA(this.hsla);
    },
    set hslaValue(value) {
      this.value = value;
    },

    /**
      Clone this color.

      @type {Coral.Color}
      @memberof Coral.Color#
    */
    clone: function() {
      var clone = new Coral.Color();
      clone.value = this.value;
      clone.alpha = this.alpha;
      return clone;
    },

    /**
      Test if this Color is similar to another color.

      @type {Boolean}
      @param {Coral.Color} compareColor
      The color to compare this color too.

      @param {Boolean} [allowSlightColorDifference=true]
      While converting between color spaces slight loses might happen => we should normally consider colors equal,
      even if they are minimally different.

      @memberof Coral.Color#
    */
    isSimilarTo: function(compareColor, allowSlightColorDifference) {

      if (this.rgb === null && (!compareColor || compareColor.rgb === null)) {
        // Consider an rgb of null equal to a null object (or another value of null)
        return true;
      }

      if (!compareColor || compareColor.rgb === null || this.rgb === null) {
        return false;
      }

      var allowedRgbDifference = 1;
      var allowedAlphaDifference = 0.01;

      if (allowSlightColorDifference === false) {
        allowedRgbDifference = 0;
        allowedAlphaDifference = 0;
      }

      var rgb = this.rgb;
      var rgb2 = compareColor.rgb;

      var rDiff = Math.abs(rgb2.r - rgb.r);
      var gDiff = Math.abs(rgb2.g - rgb.g);
      var bDiff = Math.abs(rgb2.b - rgb.b);
      var aDiff = Math.abs(this.alpha - compareColor.alpha);

      if (rDiff <= allowedRgbDifference && gDiff <= allowedRgbDifference && bDiff <= allowedRgbDifference && aDiff <= allowedAlphaDifference) {
        return true;
      }

      return false;
    },


    /**
      Calculates an array of lighter colors.

      @type {Array<Coral.Color>}
      @param {Number} amount
      Amount of tint colors to generate.

      @memberof Coral.Color#
    */
    calculateTintColors: function(amount) {
      var tintColors = [];
      var tintColor = null;

      var rgb = this.rgb;
      if (rgb) {
        var r = rgb.r;
        var g = rgb.g;
        var b = rgb.b;

        var tintFactor = 1;

        for (var i = 1; i <= amount; i++) {
          tintFactor = (i / (amount + 1));
          tintColor = this.clone();
          // alpha value kept from original
          tintColor.rgb = {
            r: r + (255 - r) * tintFactor,
            g: g + (255 - g) * tintFactor,
            b: b + (255 - b) * tintFactor
          };

          tintColors.push(tintColor);
        }
      }

      return tintColors;

    },

    /**
      Calculates an array of darker colors.

      @type {Array<Coral.Color>}
      @param {Number} amount
      Amount of shade colors to generate.

      @memberof Coral.Color#
    */
    calculateShadeColors: function(amount) {
      var shadeColors = [];
      var shadeColor = null;

      var rgb = this.rgb;
      if (rgb) {
        var r = rgb.r;
        var g = rgb.g;
        var b = rgb.b;

        var shadeFactor = 1;

        for (var i = 1; i <= amount; i++) {
          shadeFactor = (i / (amount + 1));
          shadeColor = this.clone();
          // alpha value kept from original
          shadeColor.rgb = {
            r: r * (1 - shadeFactor),
            g: g * (1 - shadeFactor),
            b: b * (1 - shadeFactor)
          };

          shadeColors.push(shadeColor);
        }
      }

      return shadeColors;
    }

  };


  /**
    Transforms part of a color (r,g,b) into a hex value.

    @static
    @param {Number} x
      value between 0-255

    @return {String} Hex representation
    @ignore
  */
  function _hex(x) {
    return ('0' + x.toString(16)).slice(-2);
  }

  /** @ignore */
  function _slice(str, startStr) {
    var sliced = [];

    str = str.toLowerCase();
    startStr = startStr.toLowerCase();

    if (str.indexOf(startStr) !== -1) {
      sliced = str.substring(str.indexOf(startStr) + startStr.length, str.lastIndexOf(')')).split(/,\s*/);
    }

    return sliced;
  }

  /**
    Parse an rgb value into an object.
    e.g.: 'rgb(0,0,0)' => {r:0, g:0, b:0}

    @static
    @param {String} rgbStr
      The string representing the rgb value

    @return {Object} {r, g, b} Returns null if string could not be parsed
    @ignore
  */
  function _parseRGB(rgbStr) {
    var sliced = _slice(rgbStr, 'rgb(');

    if (sliced.length !== 3) {
      return null;
    }

    var r = parseInt(sliced[0], 10);
    var g = parseInt(sliced[1], 10);
    var b = parseInt(sliced[2], 10);

    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return null;
    }

    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
      return null;
    }

    return {
      r: r,
      g: g,
      b: b
    };
  }

  /**
    Serialize an rgb object into a string.
    e.g.: {r:0, g:0, b:0} => 'rgb(0,0,0)'

    @static
    @param {Object} {r, g, b}
    @return {String} rgbStr The string representing the rgb value
    @ignore
  */
  function _serializeRGB(rgb) {
    if (rgb) {
      return 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
    }

    return '';
  }


  /**
    Parse an rgba value into an object.
    e.g.: 'rgba(0,0,0,0.5)' => {r:0, g:0, b:0, a:0.5}

    @static
    @param {String} rgbaStr
      The string representing the rgba value.

    @return {Object} {r, g, b, a} Returns null if string could not be parsed
    @ignore
  */
  function _parseRGBA(rgbaStr) {

    var sliced = _slice(rgbaStr, 'rgba(');

    if (sliced.length !== 4) {
      return null;
    }

    var r = parseInt(sliced[0], 10);
    var g = parseInt(sliced[1], 10);
    var b = parseInt(sliced[2], 10);
    var a = parseFloat(sliced[3]);

    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
      return null;
    }

    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 || a < 0 || a > 1) {
      return null;
    }

    return {
      r: r,
      g: g,
      b: b,
      a: a
    };
  }


  /**
    Serialize an rgba object into a string.
    e.g.: {r:0, g:0, b:0, a:0.5} => 'rgb(0,0,0,0.5)'

    @static
    @param {Object} {r, g, b, a}
    @return {String} rgbaStr The string representing the rgba value
    @ignore
  */
  function _serializeRGBA(rgba) {
    if (rgba) {
      return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + rgba.a + ')';
    }
    return '';
  }

  /**
    Parse an cmyk value into an object.
    e.g.: 'cmyk(0, 100, 50, 0)' => {c:0, m:100, y:50, k:0}

    @static
    @param {String} cmykStr
      The string representing the cmyk value.

    @return {Object} {c, m, y, k} Returns null if string could not be parsed
    @ignore
  */
  function _parseCMYK(cmykStr) {

    var sliced = _slice(cmykStr, 'cmyk(');

    if (sliced.length !== 4) {
      return null;
    }

    var c = parseFloat(sliced[0]);
    var m = parseFloat(sliced[1]);
    var y = parseFloat(sliced[2]);
    var k = parseFloat(sliced[3]);

    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
      return null;
    }

    if (c < 0 || c > 100 || m < 0 || m > 100 || y < 0 || y > 100 || k < 0 || k > 100) {
      return null;
    }

    return {
      c: c,
      m: m,
      y: y,
      k: k
    };
  }

  /**
    Serialize an cmyk object into a string.
    e.g.: {c:0, m:100, y:50, k:0} => 'cmyk(0, 100, 50, 0)'

    @static
    @param {Object} {c, m, y, k}
    @return {String} cmykStr The string representing the cmyk value
    @ignore
  */
  function _serializeCMYK(cmyk) {
    if (cmyk) {

      // make sure there are not more than 2 digits after dot
      var c = parseFloat(cmyk.c.toFixed(2));
      var m = parseFloat(cmyk.m.toFixed(2));
      var y = parseFloat(cmyk.y.toFixed(2));
      var k = parseFloat(cmyk.k.toFixed(2));

      return 'cmyk(' + c + ',' + m + ',' + y + ',' + k + ')';
    }
    return '';
  }

  /**
    Parse an hex value into a number. Corrects a hex value, if it is represented by 3 or 6 characters with or without
    '#'.

    @static
    @param {String} hexStr The string representing the hex value
    @return {Number} Returns a number representing the parsed hex value
    @ignore
  */
  function _parseHex(hexStr) {
    hexStr = hexStr.replace('#', '');

    if (hexStr.length === 3) {
      hexStr = hexStr.charAt(0) + hexStr.charAt(0) +
        hexStr.charAt(1) + hexStr.charAt(1) +
        hexStr.charAt(2) + hexStr.charAt(2);
    }

    // test if this could be a hex value
    var isOk = (/^[0-9A-F]{6}$/i).test(hexStr);
    if (!isOk) {
      return null;
    }

    return parseInt(hexStr, 16);
  }

  /**
    Serialize a hex number into a string.

    @static
    @param {Number}
    @return {String}
    @ignore
  */
  function _serializeHex(hex) {

    // explicitly test null (0 is valid)
    if (hex !== null) {
      var rgb = _hexToRgb(hex);
      return '#' + _hex(rgb.r) + _hex(rgb.g) + _hex(rgb.b);
    }

    return '';
  }

  /**
    Transforms a hex color into RGB representation.

    @static
    @param {Number} hex
      The color hex representation.

    @return {Object} {r, g, b}
    @ignore
  */
  function _hexToRgb(hex) {
    // explicitly test null (0 is valid)
    if (hex !== null) {
      return {
        r: hex >> 16,
        g: (hex & 0x00FF00) >> 8,
        b: (hex & 0x0000FF)
      };
    }
    return null;
  }

  /**
    Transforms a RGB color into HEX representation.

    @static
    @param {Object} {r, g, b}
    @return {Number} hex The color hex representation
    @ignore
  */
  function _rgbToHex(rgb) {
    if (rgb) {
      return _parseHex(_hex(rgb.r) + _hex(rgb.g) + _hex(rgb.b));
    }
    return null;
  }

  /**
    Transforms a cmyk color into RGB representation. Converting CMYK to RGB will incur slight loss because both color
    spaces are not absolute and there will be some round-off error in the conversion process.

    @static
    @param {Object} {c, m, y, k}
    @return {Object} {r, g, b}
    @ignore
  */
  function _cmykToRgb(cmyk) {
    if (!cmyk) {
      return null;
    }

    var result = {
      r: 0,
      g: 0,
      b: 0
    };

    var c = parseFloat(cmyk.c) / 100;
    var m = parseFloat(cmyk.m) / 100;
    var y = parseFloat(cmyk.y) / 100;
    var k = parseFloat(cmyk.k) / 100;

    result.r = 1 - Math.min(1, c * (1 - k) + k);
    result.g = 1 - Math.min(1, m * (1 - k) + k);
    result.b = 1 - Math.min(1, y * (1 - k) + k);

    result.r = Math.round(result.r * 255);
    result.g = Math.round(result.g * 255);
    result.b = Math.round(result.b * 255);

    return result;
  }

  /**
    Transforms a rgb color into cmyk representation. Converting CMYK to RGB will incur slight loss because both color
    spaces are not absolute and there will be some round-off error in the conversion process.

    @static
    @param {Object} {r, g, b}
    @return {Object} {c, m, y, k}
    @ignore
  */
  function _rgbToCmyk(rgb) {
    if (!rgb) {
      return null;
    }

    var result = {
      c: 0,
      m: 0,
      y: 0,
      k: 0
    };

    if (rgb.r === 0 && rgb.g === 0 && rgb.b === 0) {
      result.k = 100;
      return result;
    }

    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;

    result.k = Math.min(1 - r, 1 - g, 1 - b);
    result.c = (1 - r - result.k) / (1 - result.k);
    result.m = (1 - g - result.k) / (1 - result.k);
    result.y = (1 - b - result.k) / (1 - result.k);

    result.c = Math.round(result.c * 100);
    result.m = Math.round(result.m * 100);
    result.y = Math.round(result.y * 100);
    result.k = Math.round(result.k * 100);

    return result;
  }


  /**
    Parse an hsb value into an object.
    e.g.: 'hsb(360,100,0)' => {h:360, s:100, b:0}

    @static
    @param {String} hsbStr
      The string representing the hsb value.

    @return {Object} {h, s, b} Returns null if string could not be parsed
    @ignore
  */
  function _parseHSB(hsbStr) {
    var sliced = _slice(hsbStr, 'hsb(');

    if (sliced.length !== 3) {
      return null;
    }

    // make sure there are not more than 2 digits after dot
    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var b = parseFloat(sliced[2]);

    if (isNaN(h) || isNaN(s) || isNaN(b)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || b < 0 || b > 100) {
      return null;
    }

    return {
      h: h,
      s: s,
      b: b
    };
  }

  /**
    Serialize an hsb object into a string.
    e.g.: {h:0, s:0, b:0} => 'hsb(0,0,0)'

    @static
    @param {Object} {h, s, b}
    @return {String} hsb The string representing the hsb value
    @ignore
  */
  function _serializeHSB(hsb) {
    if (hsb) {

      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsb.h.toFixed(2));
      var s = parseFloat(hsb.s.toFixed(2));
      var b = parseFloat(hsb.b.toFixed(2));

      return 'hsb(' + h + ',' + s + ',' + b + ')';
    }

    return '';
  }


  /**
    Transforms a HSB (same as HSV) color into RGB representation.
    h (hue has value between 0-360 degree)
    s (saturation has a value between 0-100 percent)
    b (brightness has a value between 0-100 percent)

    @static
    @param {Object} {h, s, b}
    @return {Object} {r, g, b}
    @ignore
  */
  function _hsbToRgb(hsb) {
    if (!hsb) {
      return null;
    }

    var h = hsb.h / 360;
    var s = hsb.s / 100;
    var v = hsb.b / 100;

    var r, g, b, i, f, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
    }
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }

  /**
    Transforms a RGB color into HSB (same as HSV) representation.

    @static
    @param {Object} {r, g, b}
    @return {Object} {h, s, b}
    @ignore
  */
  function _rgbToHsb(rgb) {
    if (!rgb) {
      return null;
    }

    var r = rgb.r;
    var g = rgb.g;
    var b = rgb.b;

    var max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      d = max - min,
      h,
      s = (max === 0 ? 0 : d / max),
      v = max / 255;

    switch (max) {
    case min:
      h = 0;
      break;
    case r:
      h = (g - b) + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;
    case g:
      h = (b - r) + d * 2;
      h /= 6 * d;
      break;
    case b:
      h = (r - g) + d * 4;
      h /= 6 * d;
      break;
    }

    return {
      h: h * 360,
      s: s * 100,
      b: v * 100
    };
  }

  /**
    Parse an hsl value into an object.
    e.g.: 'hsl(360,100,0)' => {h:360, s:100, b:0}

    @static
    @param {String} hslStr
    The string representing the hsl value.

    @return {Object} {h, s, l} Returns null if string could not be parsed
    @ignore
  */
  function _parseHSL(hslStr) {
    var sliced = _slice(hslStr, 'hsl(');

    if (sliced.length !== 3) {
      return null;
    }

    // make sure there are not more than 2 digits after dot
    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var l = parseFloat(sliced[2]);

    if (isNaN(h) || isNaN(s) || isNaN(l)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100) {
      return null;
    }

    return {
      h: h,
      s: s,
      l: l
    };
  }

  /**
    Serialize an hsl object into a string.
    e.g.: {h:0, s:0, l:0} => 'hsl(0,0%,0%)'

    @static
    @param {Object} {h, s, l}
    @return {String} hsb The string representing the hsb value
    @ignore
  */
  function _serializeHSL(hsl) {
    if (hsl) {

      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsl.h.toFixed(2));
      var s = parseFloat(hsl.s.toFixed(2));
      var l = parseFloat(hsl.l.toFixed(2));

      return 'hsl(' + h + ',' + s + '%,' + l + '%)';
    }

    return '';
  }


  /**
    Transforms a HSL color into RGB representation.
    h (hue has value between 0-360 degree)
    s (saturation has a value between 0-100 percent)
    l (lightness has a value between 0-100 percent)

    @static
    @param {Object} {h, s, l}
    @return {Object} {r, g, b}
    @ignore
  */
  function _hslToRgb(hsl) {
    if (!hsl) {
      return null;
    }

    var h = hsl.h / 360;
    var s = hsl.s / 100;
    var l = hsl.l / 100;

    var r, g, b;

    if (s === 0) {
      r = g = b = l; // achromatic
    }
    else {
      var hue2rgb = function hue2rgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      };

      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }


    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }

  /**
    Transforms an RGB color into HSL representation.

    @static
    @param {Object} {r, g, b}
    @return {Object} {h, s, l}
    @ignore
  */
  function _rgbToHsl(rgb) {
    if (!rgb) {
      return null;
    }

    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;

    var max = Math.max(r, g, b),
      min = Math.min(r, g, b);
    var h, s,
      l = (max + min) / 2;

    if (max === min) {
      // achromatic
      h = s = 0;
    }
    else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      }
      h /= 6;
    }

    return {
      h: h * 360,
      s: s * 100,
      l: l * 100
    };
  }

  /**
    Parse an hsla value into an object.
    e.g.: 'hsla(360,100%,0%,0.5)' => {h:360, s:100, l:0, 0.5}

    @static
    @param {String} hslStr
    The string representing the hsl value.

    @return {Object} {h, s, l, a} Returns null if string could not be parsed
    @ignore
  */
  function _parseHSLA(hslaStr) {
    var sliced = _slice(hslaStr, 'hsla(');

    if (sliced.length !== 4) {
      return null;
    }

    // make sure there are not more than 2 digits after dot
    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var l = parseFloat(sliced[2]);
    var a = parseFloat(sliced[3]);

    if (isNaN(h) || isNaN(s) || isNaN(l)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100 || a < 0 || a > 1) {
      return null;
    }

    return {
      h: h,
      s: s,
      l: l,
      a: a
    };
  }

  /**
    Serialize an hsla object into a string.
    e.g.: {h:0, s:0, l:0, a:0.5} => 'hsl(0,0%,0%,0.5)'

    @static
    @param {Object} {h, s, l}
    @return {String} hsb The string representing the hsb value
    @ignore
  */
  function _serializeHSLA(hsla) {
    if (hsla) {

      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsla.h.toFixed(2));
      var s = parseFloat(hsla.s.toFixed(2));
      var l = parseFloat(hsla.l.toFixed(2));
      var a = parseFloat(hsla.a.toFixed(2));

      return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';
    }

    return '';
  }

}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /** @ignore */
  var COLOR_TAG_NAME = 'coral-colorinput-item';

  /**
   Enumeration for colorinput variant.

   @memberof Coral.ColorInput
   @enum {String}
  */
  var variant = {
    /** Use ColorInput as a formfield (default)*/
    DEFAULT: 'default',
    /** Use a simple swatch as ColorInput */
    SWATCH: 'swatch'
  };

  /**
    Enumeration for auto generated colors state.

    @memberof Coral.ColorInput
    @enum {String}
  */
  var autoGenerateColors = {
    /** Disable auto generation */
    OFF: 'off',
    /** Automatically generate shades (darker colors) of all colors */
    SHADES: 'shades',
    /** Automatically generate tints (lighter colors) of all colors */
    TINTS: 'tints'
  };

  /**
    Whether swatches view should be displayed.

    @memberof Coral.ColorInput
    @enum {String}
  */
  var showSwatches = {
    /** Display swatches view (default). */
    ON: 'on',
    /** Hide swatches view. */
    OFF: 'off'
  };

  /**
    Whether color properties view should be displayed.

    @memberof Coral.ColorInput
    @enum {String}
  */
  var showProperties = {
    /** Display color properties view (default). */
    ON: 'on',
    /** Hide color properties view. */
    OFF: 'off'
  };

  /**
   Whether default colors should be displayed.

   @memberof Coral.ColorInput
   @enum {String}
   */
  var showDefaultColors = {
    /** Display default colors (default). */
    ON: 'on',
    /** Hide default colors. */
    OFF: 'off'
  };

  Coral.register( /** @lends Coral.ColorInput# */ {

    /**
      @class Coral.ColorInput
      @classdesc An ColorInput component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @mixes Coral.mixin.selectionList
      @borrows Coral.mixin.selectionList#selectedItem as Coral.ColorInput#selectedItem
      @borrows Coral.mixin.selectionList#items as Coral.ColorInput#items
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:add as Coral.ColorInput#coral-collection:add
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:remove as Coral.ColorInput#coral-collection:remove
      @htmltag coral-colorinput
    */
    name: 'ColorInput',
    tagName: 'coral-colorinput',
    className: 'coral3-ColorInput',

    mixins: [
      Coral.mixin.formField,
      Coral.mixin.selectionList({
        itemTagName: COLOR_TAG_NAME,
        allowSingleModeDeselect: true,
        forceSelection: false,
        supportMultiple: false
      })
    ],

    events: {
      'coral-collection:add': '_onItemAddedToCollection',
      'coral-collection:remove': '_onItemRemovedFromCollection',
      'coral-colorinput:change': '_onColorInputSelectColor',
      'coral-overlay:beforeopen': '_beforeOverlayOpen',
      'coral-overlay:close': '_onOverlayClose',
      'key:down .coral3-ColorInput-input:not([readonly])': '_onKeyDown',
      'key:down [handle="colorPreview"]': '_onKeyDown',
      'click [handle="colorPreview"]': '_onColorPreviewClick',
      'global:click': '_onGlobalClick',
      'key:esc input': '_onKeyEsc',
      'key:enter input': '_onKeyEsc'
    },

    properties: {

      /**
       Variant how the colorinput should be displayed.

       @default Coral.ColorInput.variant.DEFAULT
       @type {Coral.ColorInput.variant}
       @htmlattribute variant
       @memberof Coral.ColorInput#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // toggles the related class that handles the layout
          this.classList.toggle('coral3-ColorInput--swatch', this.variant === variant.SWATCH);

          if (this.variant === variant.SWATCH) {
            this._elements.input.setAttribute('tabindex', -1);
            this._elements.colorPreview.removeAttribute('tabindex');
          }
          else {
            this._elements.input.removeAttribute('tabindex');
            this._elements.colorPreview.setAttribute('tabindex', -1);
          }
        }
      },

      /**
        The value of the color. This value can be set in 5 different formats (HEX, RGB, RGBA, HSB and CMYK). Corrects a
        hex value, if it is represented by 3 or 6 characters with or without '#'

        e.g:
        HEX:  #FFFFFF
        RGB:  rgb(16,16,16)
        RGBA: rgba(215,40,40,0.9)
        RGBA: hsb(360,100,100)
        CMYK: cmyk(0,100,50,0)

        @type {String}
        @default ""
        @htmlattribute value
        @fires Coral.mixin.formField#change
        @memberof Coral.ColorInput#
      */
      'value': {
        default: '',
        // valueMustChange should be disabled in order for set() and sync()
        // to always be called when a value is set (so dom is in sync even if input field is changed directly).
        validate: [],
        get: function() {
          return this._value ? this._value : '';
        },
        set: function(value) {

          var oldColor = new Coral.Color();
          oldColor.value = this.value;

          var newColor = new Coral.Color();
          newColor.value = value;

          if (!newColor.isSimilarTo(oldColor, false)) {
            this._value = value;

            // make sure right ColorInput.Item is selected even if input field was set by hand
            this._selectColorInputColor(newColor);

            // trigger a change event
            this.trigger('coral-colorinput:_valuechange');
          }

          // always set the input to the current value
          this._elements.input.value = this.value;
        },
        sync: function() {
          // update color preview
          var currentColor = this.valueAsColor;
          this._elements.colorPreview.style.backgroundColor = currentColor ? currentColor.rgbaValue : '';
          this.classList.toggle('coral3-ColorInput--novalue', this.value === '');
        }
      },

      // JSDocs inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDocs inherited
      'disabled': {
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);

          var input = this._elements.input;
          var colorPreview = this._elements.colorPreview;

          input.disabled = this.disabled;
          colorPreview.disabled = this.disabled || this.readOnly;

          this._syncColorPreviewIcon();

        }
      },

      // JSDocs inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
          this._elements.input.invalid = this.invalid;
        }
      },

      // JSDoc inherited
      'readOnly': {
        sync: function(value) {
          var input = this._elements.input;
          var colorPreview = this._elements.colorPreview;

          input.readOnly = this.readOnly;
          colorPreview.disabled = this.disabled || this.readOnly;

          // Remove invalid aria property identified in automated testing
          this.removeAttribute('aria-readonly');
        }
      },

      // JSDocs inherited
      'required': {
        sync: function() {
          this._elements.input.required = this.required;
        }
      },

      // JSDoc inherited
      'labelledBy': {
        sync: function() {
          // in case the user focuses the buttons, he will still get a notion of the usage of the component
          if (this.labelledBy) {
            this.setAttribute('aria-labelledby', this.labelledBy);
            this._elements.colorPreview.setAttribute('aria-labelledby',
                                                     [this.labelledBy,
                                                      this._elements.colorPreview.label.id].join(' '));
          }
          else {
            this.removeAttribute('aria-labelledby');
            this._elements.colorPreview.removeAttribute('aria-labelledby');
          }
        }
      },

      /**
        Convenient property to get/set the the current color. If the value is no valid color it will return
        <code>null</code> (The getter will return a copy of the current selected color).

        @type {Coral.Color}
        @memberof Coral.ColorInput#
      */
      'valueAsColor': {
        attribute: null,
        get: function() {
          if (!this._color) {
            this._color = new Coral.Color();
          }

          // sync this._color with the hidden field if necessary
          var newColor = new Coral.Color();
          newColor.value = this.value;
          if (!this._color.isSimilarTo(newColor, true)) {
            this._color.value = newColor.value;
            this._color.alpha = newColor.alpha;
          }

          if (this._color.rgb === null) {
            return null;
          }

          return this._color.clone();
        },
        set: function(color) {
          if (!this._color) {
            this._color = new Coral.Color();
          }

          if (!color) {
            // clear color values
            this._color.value = '';
            this.value = '';
          }
          else {
            // set color values
            this._color = color;

            if (color.alpha < 1) {
              // if an alpha value is used store rgba in the hidden field (it is the only format that can store alpha)
              this.value = color.rgbaValue;
            }
            else {
              this.value = color.value;
            }
          }
        }
      },

      /**
        Should shades (darker colors) or tints (lighter colors) automatically be generated.

        @default Coral.ColorInput.autoGenerateColors.OFF
        @type {Coral.ColorInput.autoGenerateColors}
        @htmlattribute autogeneratecolors
        @memberof Coral.ColorInput#
      */
      'autoGenerateColors': {
        default: autoGenerateColors.OFF,
        attribute: 'autogeneratecolors',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(autoGenerateColors)
        ],
        sync: function() {
          this._recalculateGeneratedColors();
        }
      },

      /**
        Whether swatches view should be displayed.

        @default Coral.ColorInput.showSwatches.ON
        @type {Coral.ColorInput.swatches}
        @htmlattribute showswatches
        @memberof Coral.ColorInput#
      */
      'showSwatches': {
        default: showSwatches.ON,
        attribute: 'showswatches',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(showSwatches)
        ],
        sync: function() {
          this._showOrHideView(this._elements.swatchesView, this._showSwatches === Coral.ColorInput.showSwatches.OFF);
        }
      },

      /**
        Whether properties view should be displayed.

        @default Coral.ColorInput.showProperties.ON
        @type {Coral.ColorInput.colorProperties}
        @htmlattribute showproperties
        @memberof Coral.ColorInput#
      */
      'showProperties': {
        default: showProperties.ON,
        attribute: 'showproperties',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(showProperties)
        ],
        sync: function() {
          this._showOrHideView(this._elements.propertiesView, this._showProperties === Coral.ColorInput.showProperties.OFF);
        }
      },

      /**
       Whether default colors should be displayed.

       @default Coral.ColorInput.showDefaultColors.ON
       @htmlattribute showdefaultcolors
       @memberof Coral.ColorInput#
       */
      'showDefaultColors': {
        default: showDefaultColors.ON,
        attribute: 'showdefaultcolors',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(showDefaultColors)
        ],
        sync: function() {
          var defaultPalette = this._elements.defaultPalette;
          if (this._showDefaultColors === Coral.ColorInput.showDefaultColors.ON) {
            if (!defaultPalette.parentNode) {
              this.insertBefore(defaultPalette, this.firstChild || null);
            }
          }
          else if (defaultPalette.parentNode) {
            defaultPalette.parentNode.removeChild(defaultPalette);
          }
        }
      },

      /**
        Short hint that describes the expected value of the ColorInput. It is displayed when the ColorInput is empty
        and the variant is {@link Coral.ColorInput.variant.DEFAULT}

        @type {String}
        @default ""
        @htmlattribute placeholder
        @htmlattributereflected
        @memberof Coral.ColorInput#
      */
      'placeholder': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        get: function() {
          return this._elements.input.placeholder;
        },
        set: function(value) {
          this._elements.input.placeholder = value;
        }
      }
    },

    /** @ignore */
    _onColorPreviewClick: function(event) {

      // restore focus to appropriate element when overlay closes
      this._elements.overlay.returnFocusTo((this.variant === variant.SWATCH ? event.matchedTarget : this._elements.input));

      this._elements.overlay.open = !this._elements.overlay.open;
    },

    /** @ignore */
    _onGlobalClick: function(event) {

      if (!this._elements.overlay.open) {
        return;
      }

      //Don't close when clicked inside itself
      if (!this.contains(event.target)) {
        this._elements.overlay.open = false;
      }
    },

    /** @ignore */
    _onItemAddedToCollection: function(event) {
      if (this._elements.overlay.open && event.detail.item.tagName.toLowerCase() === COLOR_TAG_NAME) {
        // simply close the overlay whenever a color is added
        this._elements.overlay.open = false;
      }
    },

    /** @ignore */
    _onItemRemovedFromCollection: function(event) {
      if (this._elements.overlay.open && event.detail.item.tagName.toLowerCase() === COLOR_TAG_NAME) {
        // simply close the overlay whenever a color is removed
        this._elements.overlay.open = false;
      }
    },

    // JSDocs inherited from Coral.mixin.formField
    _onInputChange: function(event) {
      // method used by Coral.mixin.formField as a callback whenever a form field changes

      if (event.target === this._elements.input) {
        // only handle changes to the hidden input field ...

        // stops the current event
        event.stopPropagation();

        var color = new Coral.Color();
        color.value = event.target[this._eventTargetProperty];

        this._setActiveColor(color);

      }
    },

    /** @ignore */
    _onColorInputSelectColor: function(event) {
      var newSelectedColor = event.detail.selection;

      // set the hidden input fields if there is currently a color selected
      if (newSelectedColor) {
        //update hidden fields
        this.value = newSelectedColor.value;
      }
    },

    /** @ignore */
    _onKeyDown: function(event) {
      event.stopPropagation();

      // restore focus to appropriate element when overlay closes
      this._elements.overlay.returnFocusTo((this.variant === variant.SWATCH ? event.matchedTarget : this._elements.input));

      this._elements.overlay.open = true;
    },

    /** @ignore */
    _onKeyEsc: function() {
      if (!this._elements.overlay.open) {
        return;
      }

      this._elements.overlay.open = false;
    },

    /** @ignore */
    _beforeOverlayOpen: function() {
      // Make sure appropriate tabbable descendant will receive focus
      if (this.showProperties === Coral.ColorInput.showProperties.ON) {
        this._elements.overlay.focusOnShow = this._elements.propertiesView._elements.colorPreview2;
      }
      else if (this.showSwatches === Coral.ColorInput.showSwatches.ON) {
        this._elements.overlay.focusOnShow =
          this._elements.overlay.querySelector('coral-colorinput-swatch[selected] > button') ||
          'coral-colorinput-swatch > button';
      }

      // set aria-expanded state
      this._elements.colorPreview.setAttribute('aria-expanded', true);
    },

    /** @ignore */
    _onOverlayClose: function() {

      // set aria-expanded state
      this._elements.colorPreview.setAttribute('aria-expanded', false);
    },

    /**
      Checks if the current input is valid or not. This check will only be performed on user interaction.

      @ignore
    */
    _validateInputValue: function() {
      this.invalid = this.value !== '' && this.valueAsColor === null;
    },

    /** @ignore */
    _showOrHideView: function(view, hide) {
      view.hidden = hide;
      //Remove both classes and add only the required one
      this._elements.overlay.classList.remove('coral3-ColorInput-onlySwatchesView', 'coral3-ColorInput-onlyPropertiesView');

      if (!this._elements.propertiesView.hidden && this._elements.swatchesView.hidden) {
        this._elements.overlay.classList.add('coral3-ColorInput-onlyPropertiesView');
      }
      else if (this._elements.propertiesView.hidden && !this._elements.swatchesView.hidden) {
        this._elements.overlay.classList.add('coral3-ColorInput-onlySwatchesView');
      }

      // Update accessibility label for colorPreview button when only swatches are shown
      if (this.showProperties === Coral.ColorInput.showProperties.OFF &&
         this.showSwatches === Coral.ColorInput.showSwatches.ON) {
        this._elements.colorPreview.label.textContent = Coral.i18n.get('Swatches');
        this._elements.overlay.setAttribute('aria-label', Coral.i18n.get('Swatches'));
      }
      else {
        this._elements.colorPreview.label.textContent = Coral.i18n.get('Color Picker');
        this._elements.overlay.setAttribute('aria-label', Coral.i18n.get('Color Picker'));
      }
    },

    /** @ignore */
    _recalculateGeneratedColors: function() {
      // remove old generated tint colors
      var childrenList = this.querySelectorAll('coral-colorinput-item[coral-colorinput-generatedcolor]');
      var childrenListLength = childrenList.length;
      for (var i = 0; i < childrenListLength; i++) {
        childrenList[i].remove();
      }

      if (this.autoGenerateColors !== autoGenerateColors.OFF) {
        var colorElements = this.items.getAll();

        var colorEl = null;
        var color = null;
        var colorIndex = 0;
        var generatedIndex = 0;

        var generatedColorEl = null;
        var generatedColors = [];

        for (colorIndex = 0; colorIndex < colorElements.length; colorIndex++) {
          colorEl = colorElements[colorIndex];
          color = new Coral.Color();
          color.value = colorEl.value;

          generatedColors = (this.autoGenerateColors === autoGenerateColors.TINTS) ? color.calculateTintColors(5) : color.calculateShadeColors(5);

          for (generatedIndex = generatedColors.length - 1; generatedIndex >= 0; generatedIndex--) {
            generatedColorEl = new Coral.ColorInput.Item();
            // be sure to add alpha
            generatedColorEl.value = generatedColors[generatedIndex].rgbaValue;
            generatedColorEl.setAttribute('coral-colorinput-generatedcolor', '');
            colorEl.parentNode.insertBefore(generatedColorEl, colorEl.nextSibling);
          }
        }
      }
    },

    /** @ignore */
    _syncColorPreviewIcon: function() {
      var colorPreview = this._elements.colorPreview;

      colorPreview.icon = (this.disabled && this.variant === variant.SWATCH) ? 'lockOn' : '';
      colorPreview.iconSize = Coral.Icon.size.SMALL;
    },

    /** @ignore */
    _setActiveColor: function(color) {
      // method used by subviews to set a color and trigger a change event if needed
      var oldColor = this.valueAsColor ? this.valueAsColor : new Coral.Color();
      this.valueAsColor = color;

      if (!oldColor.isSimilarTo(this.valueAsColor, false)) {

        // test if current color is invalid
        this._validateInputValue();

        // trigger a change event (change events should only be triggered when an user interaction happened)
        this.trigger('change');
      }
    },

    /** @ignore */
    _selectColorInputColor: function(newColor) {
      var selectColorInItems = true;

      if (this.selectedItem) {
        var selectedColor = new Coral.Color();
        selectedColor.value = this.selectedItem.value;

        // only select color if it is not already selected
        selectColorInItems = !selectedColor.isSimilarTo(newColor, true);
      }

      if (selectColorInItems) {
        // select right color in this.items (if necessary and possible)
        this.items.deselectAll();

        var colorElements = this.items.getAll();
        var colorElementsCount = colorElements.length;

        var color = null;
        for (var i = 0; i < colorElementsCount; i++) {
          color = new Coral.Color();
          color.value = colorElements[i].getAttribute('value');

          if (color.isSimilarTo(newColor, true)) {
            colorElements[i].setAttribute('selected', 'true');
            break;
          }
        }
      }
    },

    /** @ignore */
    _initialize: function() {
      this.setAttribute('role', 'combobox');
      this.setAttribute('aria-expanded', false);
    },

    /** @ignore */
    _render: function() {
      // render the default palette (might be hidden later, if own colors are added to the input)
      this.appendChild(Coral.templates.ColorInput.defaultColorPalette.call(this._elements));

      // creates the field and button
      this.appendChild(Coral.templates.ColorInput.base.call(this._elements));

      var overlay = this._elements.overlay;

      // we use 'this' so properly aligns to the input
      overlay.target = this;
      this._elements.propertiesView = overlay.appendChild(new Coral.ColorInput.ColorProperties());
      this._elements.swatchesView = overlay.appendChild(new Coral.ColorInput.Swatches());
    }
  });

  // we export the enumerations
  Coral.ColorInput.autoGenerateColors = autoGenerateColors;
  Coral.ColorInput.showSwatches = showSwatches;
  Coral.ColorInput.showProperties = showProperties;
  Coral.ColorInput.showDefaultColors = showDefaultColors;
  Coral.ColorInput.variant = variant;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ColorInput.Item# */ {

    /**
      @class Coral.ColorInput.Item
      @classdesc A item used by colorinput to store a color.
      @extends Coral.Component
      @htmltag coral-colorinput-item
    */
    name: 'ColorInput.Item',
    tagName: 'coral-colorinput-item',

    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-colorinput',
        // removes disabled
        alwaysEnabled: true
      })
    ],

    properties: {
      /**
        The value of the color. This value can be set in different formats (HEX, RGB, RGBA, HSB, HSL, HSLA and CMYK).
        Corrects a hex value, if it is represented by 3 or 6 characters with or without '#'.

        e.g:
        HEX:  #FFFFFF
        RGB:  rgb(16,16,16)
        RGBA: rgba(215,40,40,0.9)
        HSB: hsb(360,100,100)
        HSL: hsl(360,100,100)
        HSLA: hsla(360,100%,100%, 0.9)
        CMYK: cmyk(0,100,50,0)

        @type {String}
        @default ""
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.ColorInput.Item#
      */
      'value': {
        default: '',
        reflectAttribute: true,
        transform: function(value) {
          // invalid values fallback to empty string
          var color = new Coral.Color();
          color.value = value;

          return (color.rgb !== null) ? value : '';
        }
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ColorInput.AbstractSubview# */ {

    /**
      @class Coral.ColorInput.AbstractSubview
      @classdesc An abstract subview class that other subviews should extend.
      @extends Coral.Component
      @htmltag coral-colorinput-abstractsubview
      @ignore
    */
    name: 'ColorInput.AbstractSubview',
    tagName: 'coral-colorinput-abstractsubview',

    events: {
      'click .coral3-ColorInput-preview': '_onPreviewClicked'
    },

    // JSDocs inherited
    attachedCallback: function() {
      // cache colorinput if this component is attached to dom
      var colorinput = this.closest('coral-colorinput');
      if (colorinput) {

        // save references to bound callbacks (in order to be able to remove them again from event system)
        this.__beforeOverlayOpen = this._beforeOverlayOpen.bind(this);
        this.__onColorInputChange = this._onColorInputChange.bind(this);

        this._colorinput = colorinput;
        this._colorinput.on('coral-overlay:beforeopen', this.__beforeOverlayOpen);
        this._colorinput.on('coral-colorinput:_valuechange', this.__onColorInputChange);

        // trigger one change initially
        this._onColorInputChange();
      }
    },

    // JSDocs inherited
    detachedCallback: function() {
      if (this._colorinput) {
        this._colorinput.off('coral-overlay:beforeopen', this.__beforeOverlayOpen);
        this._colorinput.off('coral-colorinput:_valuechange', this.__onColorInputChange);
      }

      this._colorinput = null;
    },

    /** @ignore */
    _onPreviewClicked: function() {
      if (this._colorinput.valueAsColor !== null) {
        Coral.ColorInput.AbstractSubview._lastValidColor = this._colorinput.valueAsColor;
        this._colorinput._setActiveColor(null);
      }
      else if (Coral.ColorInput.AbstractSubview._lastValidColor !== null) {
        this._colorinput._setActiveColor(Coral.ColorInput.AbstractSubview._lastValidColor);
      }
    },

    /** @ignore */
    _beforeOverlayOpen: function() {
      // overwrite callback in subclass if needed
    },

    /** @ignore */
    _onColorInputChange: function() {
      // overwrite callback in subclass if needed
    }
  });

  // export a static variable used by all subviews
  Coral.ColorInput.AbstractSubview._lastValidColor = null;

}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ColorInput.Slider# */ {

    /**
     @class Coral.ColorInput.Slider
     @classdesc Extends Coral.Slider and adds possibility to set custom background colors/gradients to the slider
     @extends Coral.Slider
     @htmltag coral-colorinput-slider
     @ignore
     */
    name: 'ColorInput.Slider',
    tagName: 'coral-colorinput-slider',
    className: 'coral3-ColorInput-slider coral3-Slider',
    extend: Coral.Slider,

    properties: {

      /**
        The gradient shown as slider background as space separated values (at least 2 values needed).
        e.g: #ff0000 #ffff00 #00ff00 #00ffff #0000ff #ff00ff #ff0000

        @type {String}
        @default ""
        @htmlattribute gradient
        @memberof Coral.ColorInput.Slider#
      */
      'gradient': {
        default: '',
        sync: function() {
          var bar = this._elements.sliderBar;
          var barStyle = bar.style;

          var stops = this.gradient.split(' ');
          var amountStops = stops.length;

          // remove old gradients

          barStyle.backgroundImage = 'none';
          barStyle.filter = '';

          if (amountStops < 2) {
            return;
          }

          var i = 0;
          var partialGradientStr = '';
          for (i = 0; i < amountStops; i++) {
            partialGradientStr += ', ' + stops[i] + ' ' + Math.abs(i * 100 / (amountStops - 1)) + '%';
          }

          barStyle.backgroundImage = '-moz-linear-gradient(right' + partialGradientStr + ')';
          barStyle.backgroundImage = '-ms-linear-gradient(right' + partialGradientStr + ')';
          barStyle.backgroundImage = '-o-linear-gradient(right' + partialGradientStr + ')';
          barStyle.backgroundImage = '-webkit-linear-gradient(left' + partialGradientStr + ')';
          barStyle.backgroundImage = 'linear-gradient(to right' + partialGradientStr + ')';
          barStyle.filter = 'progid:DXImageTransform.Microsoft.gradient(startColorstr=\'' + stops[0] + '\', endColorstr=\'' + stops[1] + '\', gradientType=1)';
        }
      },

      // JSDoc inherited
      'labelledBy': {
        sync: function() {
          // Make sure for attributes stay in sync
          if (this.labelledBy) {
            this._updateForAttributes(this.labelledBy, this._getLabellableElement().id);
          }
        }
      }

    },

    /**
      Labellable element is the input element
      @protected
    */
    _getLabellableElement: function() {
      return this._elements.leftInput;
    },

    /**
     @protected
     */
    _renderTemplate: function() {
      this.appendChild(Coral.templates.ColorInput.sliderBase.call(this._elements));
    }
  });

}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ColorInput.ColorProperties# */ {

    /**
      @class Coral.ColorInput.ColorProperties
      @classdesc A component used by colorinput for setting color properties.
      @extends Coral.Component
      @htmltag coral-colorinput-colorproperties
      @ignore
    */
    name: 'ColorInput.ColorProperties',
    tagName: 'coral-colorinput-colorproperties',
    className: 'coral3-ColorInput-colorProperties',
    extend: Coral.ColorInput.AbstractSubview,

    events: {
      'change [handle="redSlider"]': '_onRedSliderChange',
      'change [handle="greenSlider"]': '_onGreenSliderChange',
      'change [handle="blueSlider"]': '_onBlueSliderChange',
      'change [handle="alphaSlider"]': '_onAlphaSliderChange',
      'change .coral3-ColorInput-editHex': '_onChangeHex',
      'change .coral3-ColorInput-editRgba': '_onChangeRgba'
    },

    /** @ignore */
    _render: function() {
      this.appendChild(Coral.templates.ColorInput.colorProperties.call(this._elements));
    },

    /** @ignore */
    _onColorInputChange: function() {

      var newColor = this._colorinput.valueAsColor;
      var colorPreview = this._elements.colorPreview2;
      var rgba;

      if (!newColor) {

        // update the colorPreview background color, state, and label
        colorPreview.setAttribute('aria-pressed', 'true');
        colorPreview.setAttribute('aria-label', Coral.i18n.get('Color not set'));

        //reset Hex value to empty
        this._elements.hexInput.value = '';
      }
      else {
        rgba = newColor.rgba;

        // update the colorPreview background color, state, and label
        colorPreview.style.backgroundColor = newColor.rgbValue;
        colorPreview.setAttribute('aria-pressed', 'false');
        colorPreview.setAttribute('aria-label', Coral.i18n.get('{value}, Color', { value: (parseFloat(rgba.a) === 1 ? newColor.value : newColor.rgbaValue) }));

        // update the Hex input value
        this._elements.hexInput.value = newColor.hexValue.substr(1);
      }

      var prefixes = ['red','green','blue','alpha'];
      var prefixesLength = prefixes.length;
      var i;
      var prefix;
      var abbr;
      var isAlpha;
      var val;

      // Make sure subcomponents are ready to accept value change
      Coral.commons.ready(this, function(self) {
        // update rgba slider and input values
        for (i = 0; i < prefixesLength; i++) {
          prefix = prefixes[i];
          abbr = prefix.substr(0,1);
          isAlpha = i === prefixesLength - 1;

          // default slider and input value
          val = isAlpha ? 100 : 127;

          // with new color, get appropriate RGBA value
          if (newColor) {
            val = !rgba ? '' : isAlpha ? parseInt(rgba[abbr] * 100, 10) : rgba[abbr];
          }

          // update the slider and input values
          self._elements[prefix + 'Slider'].value = self._elements[prefix + 'Input'].value = val;
        }
      });

      if (colorPreview === document.activeElement) {
        // force blur and focus on colorButton so that new color or state is announced
        colorPreview.blur();
        
        // delay focus by 100ms so that screen reader has time to adjust to label with updated color value
        setTimeout(function() {
          colorPreview.focus();
        }, 100);
      }
    },

    /** @ignore */
    _onRedSliderChange: function(event) {
      this._elements.redInput.value = this._elements.redSlider.value;
      this._onChangeRgba(event);
    },

    /** @ignore */
    _onGreenSliderChange: function(event) {
      this._elements.greenInput.value = this._elements.greenSlider.value;
      this._onChangeRgba(event);
    },

    /** @ignore */
    _onBlueSliderChange: function(event) {
      this._elements.blueInput.value = this._elements.blueSlider.value;
      this._onChangeRgba(event);
    },

    /** @ignore */
    _onAlphaSliderChange: function(event) {
      this._elements.alphaInput.value = this._elements.alphaSlider.value;
      this._onChangeRgba(event);
    },

    /** @ignore */
    _onChangeHex: function(event) {
      event.stopPropagation();

      var value = '#' + this._elements.hexInput.value; //Value of hexInput field is without '#'.
      var color = new Coral.Color();
      color.value = value;

      if (color.hex === null) {
        // no valid color value
        this._elements.hexInput.value = '';
        //Save last valid color
        if (this._colorinput.valueAsColor !== null) {
          Coral.ColorInput.AbstractSubview._lastValidColor = this._colorinput.valueAsColor;
        }
        this._colorinput._setActiveColor(null);
      }
      else {
        this._colorinput._setActiveColor(color);
      }
    },

    /** @ignore */
    _onChangeRgba: function(event) {
      event.stopPropagation();

      var r = parseInt(this._elements.redInput.value, 10);
      var g = parseInt(this._elements.greenInput.value, 10);
      var b = parseInt(this._elements.blueInput.value, 10);
      var a = parseInt(this._elements.alphaInput.value, 10);

      var colorValid = true;
      if (isNaN(r) || r < 0 || r > 255) {
        colorValid = false;
        this._elements.redInput.value = '';
      }

      if (isNaN(g) || g < 0 || g > 255) {
        colorValid = false;
        this._elements.greenInput.value = '';
      }

      if (isNaN(b) || b < 0 || b > 255) {
        colorValid = false;
        this._elements.blueInput.value = '';
      }

      if (isNaN(a) || a < 0 || a > 100) {
        colorValid = false;
        this._elements.alphaInput.value = '';
      }

      if (colorValid) {
        var color = new Coral.Color();
        color.rgba = {
          r: r,
          g: g,
          b: b,
          a: (a / 100)
        };
        this._colorinput._setActiveColor(color);
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var SWATCH_TAG_NAME = 'coral-colorinput-swatch';

  Coral.register( /** @lends Coral.ColorInput.Swatches# */ {

    /**
      @class Coral.ColorInput.Swatches
      @classdesc A component used by colorinput selecting color from swatches.
      @extends Coral.Component
      @htmltag coral-colorinput-swatches
      @ignore
    */
    name: 'ColorInput.Swatches',
    tagName: 'coral-colorinput-swatches',
    className: 'coral3-ColorInput-swatches',
    extend: Coral.ColorInput.AbstractSubview,

    mixins: [
      Coral.mixin.selectionList({
        itemTagName: SWATCH_TAG_NAME,
        allowSingleModeDeselect: true,
        forceSelection: false,
        supportMultiple: false
      })
    ],

    events: {
      'click coral-colorinput-swatch': '_onSwatchClicked',
      'keydown .coral3-ColorInput-swatch': '_onKeyDown',
      'capture:focus coral-colorinput-swatch': '_onFocus'
    },


    /** @ignore */
    _render: function() {
      // add header
      this.appendChild(Coral.templates.ColorInput.swatchesHeader.call(this._elements));

      // add accessibility label
      this.setAttribute('aria-labelledby', this._elements.swatchesHeaderTitle.id);
    },

    /** @ignore */
    _beforeOverlayOpen: function() {

      // relayout swatches if items have been added/removed/moved...
      var colorElements = this._colorinput.items.getAll();
      var colorsElementsChanged = false;
      if (!this._cachedColorElements) {
        colorsElementsChanged = true;
      }
      else if (this._cachedColorElements.length !== colorElements.length) {
        colorsElementsChanged = true;
      }
      else if (this._cachedColorElements.length === colorElements.length) {
        for (var i = 0; i < colorElements.length; i++) {
          if (this._cachedColorElements[i] !== colorElements[i]) {
            colorsElementsChanged = true;
            break;
          }
        }
      }

      this._cachedColorElements = colorElements;

      if (colorsElementsChanged) {
        this._layoutColorSwatch();
      }

      this._ensureKeyboardAccess();
    },

    /** @ignore */
    _onColorInputChange: function() {
      this._ensureKeyboardAccess();
    },

    /**
      If no swatch is selected, make sure that the first swatch is tabbable
      @ignore
    */
    _ensureKeyboardAccess: function() {
      //
      if (!this.querySelector('coral-colorinput-swatch[selected]')) {
        var firstSwatch = this.querySelector('coral-colorinput-swatch');
        if (firstSwatch) {
          firstSwatch.tabIndex = 0;
        }
      }
    },

    /** @ignore */
    _layoutColorSwatch: function() {

      // Clear container before adding elements to avoid multiple addition
      this._elements.swatchesContainer.innerHtml = '';
      var colors = this._colorinput.items.getAll();

      var colorsLength = colors.length;
      var swatchSelected = false;
      for (var colorCount = 0; colorCount < colorsLength; colorCount++) {
        var color = colors[colorCount];

        var swatch = new Coral.ColorInput.Swatch();
        this._elements.swatchesContainer.appendChild(swatch);
        swatch.targetColor = color;

        if (color.selected) {
          swatch.selected = color.selected;
          swatchSelected = true;
        }

        swatch.setAttribute('aria-selected', swatch.selected);

        // Update color button tabindex depending on selected state
        swatch.tabIndex = swatch.selected ? 0 : -1;
      }

      // If no swatch is selected, make sure that the first swatch is focusable
      if (!swatchSelected) {
        this._ensureKeyboardAccess();
      }
    },

    /** @ignore */
    _onSwatchClicked: function(event) {
      event.stopPropagation();

      var colorButton = event.target;
      var swatch = colorButton.closest(SWATCH_TAG_NAME);

      if (!swatch.selected) {
        var color = new Coral.Color();
        color.value = swatch.targetColor ? swatch.targetColor.value : '';
        this._colorinput._setActiveColor(color);
        swatch.selected = true;
      }
      swatch.firstChild.focus();
    },

    /** @ignore */
    _onKeyDown: function(event) {
      var overlay = this._colorinput._elements.overlay;

      // only if overlay is open
      if (!overlay.open) {
        return;
      }

      var allItems = this.items.getAll();

      var currentIndex = allItems.indexOf(event.matchedTarget);
      var preventDefault = true;
      var newIndex = currentIndex;

      switch (event.which) {
      case 13: //return
        // Wait a frame before closing so that focus is restored correctly
        Coral.commons.nextFrame(function() {
          overlay.open = false;
        });
        break;
      case 37: //left arrow
        newIndex -= 1;
        break;
      case 38: //up arrow
        newIndex -= 4;
        break;
      case 39: //right arrow
        newIndex += 1;
        break;
      case 40: //down arrow
        newIndex += 4;
        break;
      default:
        preventDefault = false;
        break;
      }

      // If any action has been taken prevent event propagation
      if (preventDefault) {
        event.preventDefault();


        if (newIndex < 0 || newIndex >= allItems.length) {
          return;
        }

        // show right page in carousel and focus right swatch
        var swatch = allItems[newIndex];
        var color = new Coral.Color();
        color.value = swatch.targetColor ? swatch.targetColor.value : '';
        this._colorinput._setActiveColor(color);
        swatch.selected = true;
        swatch.firstChild.focus();
      }
    },

    /**
      Ensure that only one swatch can receive tab focus at a time
      @ignore
    */
    _onFocus: function (event) {
      var allItems = this.items.getAll();

      for (var i = 0; i < allItems.length; i++) {
        var swatch = allItems[i];
        if (!swatch.contains(event.matchedTarget)) {
          swatch.tabIndex = -1;
        }
      }
      event.matchedTarget.tabIndex = 0;
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ColorInput.Swatch# */ {

    /**
      @class Coral.ColorInput.Swatch
      @classdesc A component used by colorinput to display colors in the swatches view.
      @extends Coral.Component
      @htmltag coral-colorinput-swatch
      @ignore
    */
    name: 'ColorInput.Swatch',
    tagName: 'coral-colorinput-swatch',
    className: 'coral3-ColorInput-swatch',
    extend: Coral.ColorInput.AbstractSubview,

    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-colorinput-swatches',
        // removes disabled
        alwaysEnabled: true
      })
    ],

    properties: {
      /**
        The Coral.ColorInput.Item that the swatch is a visual representation of. It accepts a DOM element or a CSS selector.
        If a CSS selector is provided, the first matching element will be used.

        @type {HTMLElement|String}
        @default
        @htmlattribute targetcolor
        @memberof Coral.ColorInput.Swatch#
      */
      'targetColor': {
        default: null,
        attribute: 'targetcolor',
        set: function(value) {

          if (typeof value === 'string') {
            value = this.querySelector(value);
          }

          // Store new value
          this._targetColor = value;
        },
        sync: function() {
          var cssColorValue = '';
          var hexColorValue = '';

          if (this._targetColor) {
            var color = new Coral.Color();
            color.value = this._targetColor.value;
            cssColorValue = color.rgbaValue;
            hexColorValue = color.hexValue;
          }

          // Update background color and text label for color swatch
          if (cssColorValue) {
            this._elements.colorButton.style.backgroundColor = cssColorValue;
            this._elements.colorButton.label.textContent = hexColorValue;
            this.setAttribute('aria-value', hexColorValue);
          }
          else {
            this._elements.colorButton.classList.add('coral3-ColorInput-swatch-novalue');
            this._elements.colorButton.label.textContent = Coral.i18n.get('unset');
            this.setAttribute('aria-value', '');
          }
        }
      },

      /**
        Whether the color preview is disabled or not.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @memberof Coral.ColorInput.Swatch#
      */
      'disabled': Coral.property.proxy({
        path: '_elements.colorButton.disabled'
      }),

      // JSDoc inherited
      'selected': {
        sync: function() {
          if (this.selected) {
            this._elements.colorButton.setAttribute('aria-label',
                                                    Coral.i18n.get('checked') + ' ' + this._elements.colorButton.label.textContent);
          }
          else {
            this._elements.colorButton.removeAttribute('aria-label');
          }
        }
      },

      /**
        The tabindex of the color preview.

        @type {Integer}
        @default 0
        @htmlattribute tabindex
        @memberof Coral.ColorInput.Swatch#
      */
      'tabIndex': Coral.property.proxy({
        path: '_elements.colorButton.tabIndex'
      })
    },

    /** @ignore */
    _render: function() {
      this._elements.colorButton = new Coral.Button();
      this._elements.colorButton.icon = 'check';
      this._elements.colorButton.type = 'button';
      this._elements.colorButton.setAttribute('role', 'presentation');

      // Make color button label visible to screen readers only
      this._elements.colorButton.label.classList.add('u-coral-screenReaderOnly');
      this.appendChild(this._elements.colorButton);
    },

    /** @ignore */
    _onColorInputChange: function() {
      if (this.targetColor) {
        // sync selections
        this.selected = this.targetColor.selected;
      }
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["ColumnView"] = window["Coral"]["templates"]["ColumnView"] || {};
window["Coral"]["templates"]["ColumnView"]["loadIndicator"] = (function anonymous(data_0
/**/) {
    var data = data_0;
    var el0 = document.createElement("div");
    el0.className += " coral3-ColumnView-column-loading";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-wait");
    el2.setAttribute("centered", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';
  
  function scrollTo(element, to, duration, callback) {
    if (duration <= 0) {
      return;
    }
    
    var difference = to - element.scrollLeft;
    var perTick = difference / duration * 10;
    
    window.setTimeout(function() {
      element.scrollLeft = element.scrollLeft + perTick;
      if (element.scrollLeft === to) {
        if (callback) {
          callback();
        }
      }
      else {
        scrollTo(element, to, duration - 10);
      }
    }, 10);
  }

  /**
    Enumeration representing the ColumnView selection modes.

    @memberof Coral.ColumnView
    @enum {String}
   */
  var selectionMode = {
    /** None is default, selection of items does not happen based on click */
    NONE: 'none',
    /** Single selection mode, only one item per column can be selected. */
    SINGLE: 'single',
    /** Multiple selection mode, multiple items per column can be selected. */
    MULTIPLE: 'multiple'
  };

  // the column views's base classname
  var CLASSNAME = 'coral3-ColumnView';

  Coral.register( /** @lends Coral.ColumnView# */ {
    /**
      @class Coral.ColumnView
      @classdesc A ColumnView component
      @htmltag coral-columnview
      @extends Coral.Component
    */
    name: 'ColumnView',
    tagName: 'coral-columnview',
    className: CLASSNAME,

    events: {
      // Prevents text selection while selecting multiple items
      'global:keyup': '_onGlobalKeyUp',
      'global:keydown': '_onGlobalKeyDown',

      'key:up': '_onKeyUp',
      'key:down': '_onKeyDown',
      'key:right': '_onKeyRight',
      'key:left': '_onKeyLeft',
      'key:shift+up': '_onKeyShiftAndUp',
      'key:shift+down': '_onKeyShiftAndDown',
      'key:space': '_onKeySpace',

      // column events
      'coral-columnview-column:_loaditems': '_onColumnLoadItems',
      'coral-columnview-column:_activeitemchanged': '_onColumnActiveItemChanged',
      'coral-columnview-column:_selecteditemchanged': '_onColumnSelectedItemChanged'
    },

    properties: {
      /**
        Collection that holds all the columns inside the ColumnView. See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.ColumnView#
      */
      'columns': {
        get: function() {
          // constructs the collection on first request
          if (!this._columns) {
            this._columns = new Coral.ColumnView.Collection({
              host: this,
              itemTagName: 'coral-columnview-column'
            });
          }

          return this._columns;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Collection used to represent the coral-columnview-item across all columns. See {@link Coral.Collection} for more
        details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.ColumnView#

        @private
      */
      'items': {
        get: function() {
          // constructs the collection on first request
          if (!this._items) {
            this._items = new Coral.ColumnView.Collection({
              host: this,
              itemTagName: 'coral-columnview-item'
            });
          }

          return this._items;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Selection mode of the ColumnView.

        @type {Coral.ColumnView.selectionMode}
        @default Coral.ColumnView.selectionMode.NONE
        @htmlattribute selectionmode
        @memberof Coral.ColumnView#
      */
      'selectionMode': {
        default: selectionMode.NONE,
        attribute: 'selectionmode',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(selectionMode)
        ],
        set: function(value) {
          this._selectionMode = value;

          // propagates the selection mode to the columns
          this.columns.getAll().forEach(function(item) {
            item.setAttribute('_selectionmode', value);
          });
        },
        sync: function() {
          this.classList.remove(this._className + '--selection');

          if (this.selectionMode !== Coral.ColumnView.selectionMode.NONE) {
            this.classList.add(this._className + '--selection');
          }

          // @a11y
          this.setAttribute('aria-multiselectable', this.selectionMode === Coral.ColumnView.selectionMode.MULTIPLE);
        }
      },

      /**
        First selected item of the ColumnView.

        @type {HTMLElement}
        @readonly
        @memberof Coral.ColumnView#
      */
      'selectedItem': {
        get: function() {
          return this.selectionMode !== selectionMode.NONE ? this.items.getFirstSelected() : null;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Array containing the set selected items. The items will match only one column since selection across columns is
        not allowed.

        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.ColumnView#
      */
      'selectedItems': {
        get: function() {
          return this.selectionMode !== selectionMode.NONE ? this.items.getSelected() : [];
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Active Item that corresponds to the last item in the path.


        @type {HTMLElement}
        @readonly
        @memberof Coral.ColumnView#
      */
      'activeItem': {
        get: function() {
          return this.items.getLastActive();
        },
        set: function() {
          // Read-only
        }
      }
    },

    /** @private */
    _onColumnActiveItemChanged: function(event) {
      // this is a private event and should not leave the column view
      event.stopImmediatePropagation();

      // ignores event handling due to bulk select operation
      if (this._bulkSelectionChange) {
        return;
      }

      var column = event.target;

      // clears the internal selection cursor
      this._handleKeyboardMultiselect(null);

      this._bulkSelectionChange = true;

      if (!event.detail.activeItem) {
        // all items to the right must be removed. we do this at the end to be able to extract the values before
        // removing everything
        this._afterItemSelectedInColumn(column);
      }
      else {
        // when there is an active item, selection must not exist
        this.items.deselectAll();

        // we need to deactivate every item to the right of the new active item to keep a correct DOM representation
        var nextColumn = column.nextElementSibling;
        while (nextColumn) {
          Array.prototype.forEach.call(nextColumn.querySelectorAll('coral-columnview-item[active]'), function(item) {
            item.removeAttribute('active');
          });
          nextColumn = nextColumn.nextElementSibling;
        }
      }

      this._bulkSelectionChange = false;

      // we trigger the appropiate events
      this._validateColumnViewChange();
    },

    /**
      Requests external data to be loaded.

      @fires Coral.ColumnView#coral-columnview:loaditems

      @param {HTMLElement} column
        The column that is requesting more data to be loaded.
      @param {Number} start
        The amount of items inside the column.
      @param {HTMLElement} [item]
        Item that activated the load.

      @private
    */
    _onColumnLoadItems: function(event) {
      // this is a private event and should not leave the column view
      event.stopImmediatePropagation();

      // triggers an event to indicate more data could be loaded
      this.trigger('coral-columnview:loaditems', {
        column: event.target,
        start: event.detail.start,
        item: event.detail.item
      });
    },

    /** @private */
    _onColumnSelectedItemChanged: function(event) {
      // this is a private event and should not leave the column view
      event.stopImmediatePropagation();

      // ignores event handling due to bulk select operation
      if (this._bulkSelectionChange || this.selectionMode === selectionMode.NONE) {
        return;
      }

      this._bulkSelectionChange = true;
      // we need to deselect any other selection that is not part of the same column
      this._oldSelection.forEach(function(el) {
        if (event.detail.selection.indexOf(el) === -1) {
          el.removeAttribute('selected');
        }
      });
      this._bulkSelectionChange = false;

      // we trigger the appropiate events
      this._validateColumnViewChange();
    },

    /** @private */
    _onGlobalKeyUp: function(event) {
      // removes the class to stop selection
      if (event.keyCode === 16) {
        this.classList.remove('is-unselectable');
      }
    },

    /** @private */
    _onGlobalKeyDown: function(event) {
      // adds a class that prevents the text selection, otherwise shift + click would select the text
      if (event.keyCode === 16) {
        this.classList.add('is-unselectable');
      }
    },

    /** @private */
    _onKeyShiftAndUp: function(event) {
      event.preventDefault();

      // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster
      var oldSelectedItems = this._oldSelection;

      this._isKeyBoardMultiselect = true;

      // first make sure to select the active item as we want to multiselect
      if (oldSelectedItems.length === 0) {
        var activeItem = this.activeItem;

        if (activeItem) {
          activeItem.setAttribute('selected', '');
        }
      }

      // gets all the selected items of the active column. calling _getSelectedItems() will include the active item
      // if it was selected
      var selectedItems = this._items._getSelectedItems();
      // reference of the last selected item to know the direction of the selection while using the multiselection
      var lastSelected = this._lastSelected;

      var selectedItem;
      // when no previous selection is stored we need to initialize it with the current information
      if (!lastSelected) {
        selectedItem = selectedItems[0].previousElementSibling;
        // selects the item
        selectedItem.setAttribute('selected', '');
      }
      else if (lastSelected.item) {
        selectedItem = lastSelected.item;

        // we have reached the upper selection limit
        if (selectedItem.matches(':first-child')) {
          this._isKeyBoardMultiselect = false;
          return;
        }

        if (!lastSelected.direction || lastSelected.direction === 'up') {
          selectedItem = selectedItem.previousElementSibling;
          selectedItem.setAttribute('selected', '');
        }
        else {

          if (selectedItem !== lastSelected.firstSelectedItem) {
            selectedItem.removeAttribute('selected');
          }
          else {
            // switches the direction if this was the last item selected
            lastSelected.direction = 'up';
          }

          selectedItem = selectedItem.previousElementSibling;
          selectedItem.setAttribute('selected', '');
        }
      }

      // stores the reference and direction to be able to perform the multiple selection correctly
      this._lastSelected = {
        item: selectedItem,
        direction: (lastSelected && lastSelected.direction) ? lastSelected.direction : 'up',
        firstSelectedItem: (lastSelected && lastSelected.firstSelectedItem) ?
          lastSelected.firstSelectedItem :
          selectedItem.nextElementSibling
      };

      this._isKeyBoardMultiselect = false;
    },

    /** @private */
    _onKeyShiftAndDown: function(event) {
      event.preventDefault();

      // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster
      var oldSelectedItems = this._oldSelection;

      this._isKeyBoardMultiselect = true;

      // first make sure to select the active item as we want to multiselect
      if (oldSelectedItems.length === 0) {
        var activeItem = this.activeItem;

        if (activeItem) {
          activeItem.setAttribute('selected', '');
        }
      }

      // gets all the selected items of the active column. calling _getSelectedItems() will include the active item
      // if it was selected
      var selectedItems = this._items._getSelectedItems();

      // reference of the last selected item to know the direction of the selection while using the multiselection
      var lastSelected = this._lastSelected;

      var selectedItem;
      // when no previous selection is stored we need to initialize it with the current information
      if (!lastSelected) {
        selectedItem = selectedItems[selectedItems.length - 1].nextElementSibling;
        // selects the item
        selectedItem.setAttribute('selected', '');
      }
      else if (lastSelected.item) {
        selectedItem = lastSelected.item;

        // we have reached the lower selection limit
        if (selectedItem.matches(':last-child')) {
          this._isKeyBoardMultiselect = false;
          return;
        }

        if (!lastSelected.direction || lastSelected.direction === 'down') {
          selectedItem = selectedItem.nextElementSibling;
          selectedItem.setAttribute('selected', '');
        }
        else {
          if (selectedItem !== lastSelected.firstSelectedItem) {
            selectedItem.removeAttribute('selected');
          }
          else {
            // switches the direction if this was the last item selected
            lastSelected.direction = 'down';
          }

          selectedItem = selectedItem.nextElementSibling;
          selectedItem.setAttribute('selected', '');
        }
      }

      // stores the reference and direction to be able to perform the multiple selection correctly
      this._lastSelected = {
        item: selectedItem,
        direction: (lastSelected && lastSelected.direction) ? lastSelected.direction : 'down',
        firstSelectedItem: (lastSelected && lastSelected.firstSelectedItem) ?
          lastSelected.firstSelectedItem :
          selectedItem.previousElementSibling
      };

      this._isKeyBoardMultiselect = false;
    },

    /** @private */
    _onKeyUp: function(event) {
      event.preventDefault();

      // selection will win over active buttons, because they are the right most item. using _oldSelection since it
      // should be equivalent to this.items._getSelectedItems() but faster
      var selectedItems = this._oldSelection;

      var item;
      if (selectedItems.length !== 0) {
        var selectedItem = selectedItems[0];

        item = selectedItem.previousElementSibling;
        if (item) {
          item = selectedItem;
        }
      }
      else {
        // when there is no active item to select, we get the last item of the column. this way users can interact with
        // the column view when there is nothing selected or activated
        if (this._oldActiveItem === null) {
          item = this.items._getSelectableItems().pop();
        }
        else {
          item = this._oldActiveItem.previousElementSibling;
        }
      }

      // we use click instead of selected to force the deselection of the other items
      item.click();
    },

    /** @private */
    _onKeyDown: function(event) {
      event.preventDefault();

      // selection will win over active buttons, because they are the right most item. using _oldSelection since it
      // should be equivalent to this.items._getSelectedItems() but faster
      var selectedItems = this._oldSelection;

      var item;
      if (selectedItems.length !== 0) {
        var selectedItem = selectedItems[selectedItems.length - 1];

        item = selectedItem.nextElementSibling;

        // when
        if (!item) {
          item = selectedItem;
        }
      }
      else {
        // when there is no active item to select, we get the first item of the column. this way users can interact with
        // the column view when there is nothing selected or activated
        if (this._oldActiveItem === null) {
          item = this.items._getSelectableItems()[0];
        }
        else {
          item = this._oldActiveItem.nextElementSibling;
        }
      }

      // we use click instead of selected to force the deselection of the other items
      item.click();
    },

    /** @private */
    _onKeyRight: function(event) {
      event.preventDefault();

      var nextColumn = this.activeItem.closest('coral-columnview-column').nextElementSibling;

      if (nextColumn) {
        // we need to make sure the column is initialized
        Coral.commons.ready(nextColumn, function() {
          nextColumn.items._getSelectableItems()[0].click();
        });
      }
    },

    /** @private */
    _onKeyLeft: function(event) {
      event.preventDefault();

      // we can only navigate left when there is a column on the left side to navigate to
      var previousColumn;
      // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster
      var selectedItems = this._oldSelection;

      // when there is selection, we use the previous column as a reference
      if (selectedItems.length !== 0) {
        previousColumn = selectedItems[0].closest('coral-columnview-column').previousElementSibling;
      }
      // otherwise we use the activeItems as a reference
      else {
        previousColumn = this.activeItem.closest('coral-columnview-column').previousElementSibling;
      }

      if (previousColumn) {
        // we need to make sure the column is initialized
        Coral.commons.ready(previousColumn, function() {
          if (previousColumn.activeItem) {
            // if there is an active item simply click it again
            previousColumn.activeItem.click();
          }
          else {
            // we need to find a candicate for activation
            var firstSelectedItem = previousColumn.items._getSelectedItems()[0];

            if (firstSelectedItem) {
              firstSelectedItem.click();
            }
            else {
              previousColumn.items._getSelectableItems()[0].click();
            }
          }
        });
      }
    },

    /** @private */
    _onKeySpace: function(event) {
      event.preventDefault();

      // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster
      var selectedItems = this._oldSelection;

      // when there is a selection, we need to activate the first item of the selection
      if (selectedItems.length !== 0) {
        selectedItems[0].setAttribute('active', '');
      }
      else {
        var activeItem = this.activeItem;
        // toggles the selection between active and selected
        if (activeItem) {
          // select the item
          activeItem.setAttribute('selected', '');
        }
      }
    },

    /** @private */
    _arraysAreDifferent: function(selection, oldSelection) {
      var diff = [];
      
      if (oldSelection.length === selection.length) {
        diff = oldSelection.filter(function(item) {
          return selection.indexOf(item) === -1;
        });
      }
  
      // since we guarantee that they are arrays, we can start by comparing their size
      return oldSelection.length !== selection.length || diff.length !== 0;
    },

    /** @private */
    _handleKeyboardMultiselect: function(newSelectedItem) {
      if (!this._isKeyBoardMultiselect) {
        this._lastSelected = undefined;

        // if there is a new selected item save this (but without direction info)
        if (newSelectedItem) {
          this._lastSelected = {
            item: newSelectedItem,
            direction: null,
            firstSelectedItem: newSelectedItem
          };
        }
      }
    },

    /**
      Scrolls the given {@link Coral.ColumnView.Column} into view.

      @param {HTMLElement} column
        The column that needs to be scrolled into view.
      @param {Boolean} clearEmptyColumns
        Remove empty columns once animation is done.

      @private
    */
    // @todo: improve animation effect when key is kept press
    _scrollColumnIntoView: function(column, clearEmptyColumns, triggerEvent) {
      var left = 0;
      var duration;

      // we return if the column is not inside the current column view
      if (!this.contains(column)) {
        return;
      }

      // make sure to clear columns next to this column if animation is done
      var self = this;
      var completeCallback = function() {
        if (clearEmptyColumns) {
          self._removeEmptyColumnsWithSmoothTransition(triggerEvent);
        }
      };

      // scroll right to the given column
      if (column.getBoundingClientRect().left + column.offsetWidth >= this.offsetWidth) {
        var next = column.nextElementSibling;
        while (next) {
          next.parentNode.removeChild(next);
          next = column.nextElementSibling;
        }

        left = this.scrollWidth - this.offsetWidth;
        duration = (left - this.scrollLeft);
        scrollTo(this, left, duration, completeCallback);
      }
      else if (clearEmptyColumns) {
        this._removeEmptyColumnsWithSmoothTransition(triggerEvent);
      }
    },

    /**
      Handling of the column view after selecting an item.

      @param {HTMLElement} column

      @private
    */
    _afterItemSelectedInColumn: function(column) {
      // @todo: emptying the columns allows them to be queried
      this._emptyColumnsNextToColumn(column);
      this._scrollColumnIntoView(column, true, true);
    },

    /**
      Empties all the columns to the right of the provided column.

      @param {HTMLElement} column

      @private
    */
    _emptyColumnsNextToColumn: function(column) {
      if (column !== null) {
        var next = column.nextElementSibling;
        while (next && next.innerHTML.length) {
          next.innerHTML = '';
          next = next.nextElementSibling;
        }
      }
    },

    /**
      Remove all empty columns with a smooth transition. Optionally the navigate event is triggered when all the extra
      columns are removed from the DOM.

      @param {Boolean} triggerEvent
        Whether the navigate event must be triggered.

      @private
    */
    _removeEmptyColumnsWithSmoothTransition: function(triggerEvent) {
      // fade width of empty items to 0 before removing the columns (for better usability while navigating)
      var emptyColumns = Array.prototype.filter.call(this.querySelectorAll('coral-columnview-column, coral-columnview-preview'), function(el) {
        return !el.firstChild;
      });

      var self = this;
      
      emptyColumns.forEach(function(column, i) {
        column.style.visibility = 'hidden';
        column.classList.add('is-collapsing');
        Coral.commons.transitionEnd(column, function() {
          column.remove();
          if (i === (emptyColumns.length - 1) && triggerEvent) {
            self._validateNavigation(self.columns.last());
          }
        });
        column.style.width = 0;
      });
    },

    /** @private */
    _triggerCollectionEvents: function(addedNodes, removedNodes) {
      var item;
      var addedNodesCount = addedNodes.length;
      for (var i = 0; i < addedNodesCount; i++) {
        item = addedNodes[i];
        if (item.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
          // we use the property since the item may not be ready
          item.setAttribute('_selectionmode', this.selectionMode);
          this.trigger('coral-collection:add', {
            item: item
          });
        }
      }

      // @todo: check if special handling is needed when selected column is removed
      var removedNodesCount = removedNodes.length;
      for (var j = 0; j < removedNodesCount; j++) {
        item = removedNodes[j];
        // @todo: should I handle it specially if it was selected? should a selection and active event be triggered?
        if (item.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
          this.trigger('coral-collection:remove', {
            item: item
          });
        }
      }
    },

    /** @private */
    _setStateFromDOM: function() {
      // @todo: should I trigger change events?
      // initial state of the columnview
      this._oldActiveItem = this.activeItem;
      this._oldSelection = this.selectedItems;
    },

    /** @private */
    _handleMutation: function(mutations) {
      var mutationsCount = mutations.length;
      for (var i = 0; i < mutationsCount; i++) {
        var mutation = mutations[i];

        // we handle the collection events
        this._triggerCollectionEvents(mutation.addedNodes, mutation.removedNodes);
      }

      // sets the internal state based on the existing columns
      this._setStateFromDOM();
    },

    /**
      Determines if something of the internal state of the component has changed. Active item event is always triggered
      first and then the selection event.

      @private
    */
    _validateColumnViewChange: function() {
      // we evaluate first the active event since we always need to trigger active first and then selection
      var activeItem = this.activeItem;
      var oldActiveItem = this._oldActiveItem || null;

      // same column events are only triggered if the active item changed, otherwise they are ignored
      if (activeItem !== oldActiveItem) {
        this.trigger('coral-columnview:activeitemchange', {
          activeItem: activeItem,
          oldActiveItem: oldActiveItem
        });

        // we cache the old active item to be able to report correct change events
        this._oldActiveItem = activeItem;
      }

      // when there is no selection we avoid triggering any change event but we do not stop items from having the
      // selected attribute
      if (this.selectionMode === selectionMode.NONE) {
        return;
      }

      var newSelection = this.selectedItems;
      var oldSelection = this._oldSelection || [];

      // use first newly selected item for new selection
      var newSelectedItems = newSelection.filter(function(item) {
        return oldSelection.indexOf(item) === -1;
      });
      this._handleKeyboardMultiselect(newSelectedItems.length > 0 ? newSelectedItems[0] : null);

      if (this._arraysAreDifferent(newSelection, oldSelection)) {
        this.trigger('coral-columnview:change', {
          selection: newSelection,
          oldSelection: oldSelection
        });

        // changes the old selection array since we selected something new
        this._oldSelection = newSelection;
      }
    },

    /** @ignore */
    _initialize: function() {
      // @a11y
      this.setAttribute('role', 'tree');
      // @a11y: the columnview needs to be focusable to handle a11y properly
      this.setAttribute('tabindex', '0');

      // default value of inner flag to process events
      this._bulkSelectionChange = false;

      // initializes the mutation observer that used to detect when new items are added or removed
      this._observer = new MutationObserver(this._handleMutation.bind(this));
      this._observer.observe(this, {
        // only watch the childList, items will tell us if selected/value/content changes
        childList: true
      });

      // no need to wait for the mutation observers
      this._setStateFromDOM();
    },

    /** @ignore */
    focus: function() {
      // selected items go first because there is no active item in a column with selection
      var item = this.selectedItems[0] || this.activeItem;
      if (item) {
        item.focus();
      }
    },

    /**
      Sets the next column given a reference column. This will handle cleaning the DOM and removing any columns as
      required.

      @param {HTMLElement} newColumn
        The new column to add to the column view. It will be placed next to the <code>referenceColumn</code> if
        provided.
      @param {HTMLElement} referenceColumn
        The column that will be used as a reference to place the new column. This column needs to be already inside the
        DOM.
      @param {Boolean} [scrollToColumn = true]
        Whether the columnview show scroll to have the <code>newColumn</code> visible.

      @fires Coral.ColumnView#coral-columnview:navigate
    */
    setNextColumn: function(newColumn, referenceColumn, scrollToColumn) {
      scrollToColumn = typeof scrollToColumn === 'undefined' || scrollToColumn;

      var column = referenceColumn || null;

      // handles the case where the first column needs to be added
      if (column === null || !this.contains(column)) {
        this.appendChild(newColumn);
      }
      else {
        var nextColumn = column.nextElementSibling;

        if (nextColumn) {
          this._emptyColumnsNextToColumn(column);
          var before = nextColumn.nextElementSibling;
          this.removeChild(nextColumn);
          this.insertBefore(newColumn, before);
        }
        else {
          this.appendChild(newColumn);
        }
      }

      var self = this;
      // if we want to scroll to it, we need for it to be ready due to measurements
      Coral.commons.ready(newColumn, function() {
        if (scrollToColumn) {
          // event is not triggered because it is handled separately
          self._scrollColumnIntoView(newColumn, true, false);
        }

        // we notify that the columnview navigated and it is ready to be used
        self._validateNavigation(newColumn);
      });
    },

    /**
      Triggers the navigation event. Navigation would happen when a) a new column is added, and it is ready to be
      used or b) columns are removed and the active changed. In case the column is actually a preview column, the event
      will only be triggered when there is no selection (meanning a real navigation was performed).

      @param {HTMLElement} column
        Last column of the ColumnView.

      @fires Coral.ColumnView#coral-columnview:navigate

      @private
    */
    _validateNavigation: function(column) {
      // we use _oldSelection because it is faster
      if (column.tagName === 'CORAL-COLUMNVIEW-PREVIEW' && this._oldSelection.length !== 0) {
        return;
      }

      this.trigger('coral-columnview:navigate', {
        activeItem: this.activeItem,
        column: column
      });
    }

    /**
      Triggered when additional items can be loaded into the ColumnView. This will happen when the current column can
      still hold more items, when the user scrolls down the current column or when a new column needs to be loaded. If
      <code>preventDefault()</code> is called, then a loading indicator will be shown.
      {@link Coral.ColumnView.Column#loading} should be set to false to indicate that the data has been successfully
      loaded.

      @event Coral.ColumnView#coral-columnview:loaditems

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.column
        The column that is requesting more items. While doing pagination, it will become the target of the loaded items.
      @param {Number} event.detail.start
        Indicates the current amount of items in the <code>column</code> to do pagination. If <code>item</code> is
        available, start will be 0 to denote that the column should be loaded from the start.
      @param {HTMLElement} event.detail.item
        The item that ininitialized the load. If item is provided, it means that a new column needs to be added after
        the load is performed. In this scenario, <code>column</code> will be refer to the column that holds the item.
    */

    /**
      Triggered when the selection inside the column change. In case both the selection and the active item change,
      the <code>coral-columnview:activeitemchange</code> will be triggered first.

      @event Coral.ColumnView#coral-columnview:change

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.column
        The column whose selection changed.
      @param {HTMLElement|Array.<HTMLElement>} event.detail.selection
        The new selection of the Column.
      @param {HTMLElement|Array.<HTMLElement>} event.detail.oldSelection
        The old selection of the Column.
    */

    /**
      Triggered when the active item of the column changes.

      @event Coral.ColumnView#coral-columnview:activeitemchange

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.column
        The column whose active item has changed.
      @param {HTMLElement} event.detail.activeItem
        The currently active item of the column.
      @param {HTMLElement} event.detail.oldActiveItem
        The item of the column that was active before.
    */

    /**
      Triggered when the navigation is complete and the new columns are ready.

      @event Coral.ColumnView#coral-columnview:navigate

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.column
        The last Column of the ColumnView that is used to determine the path. If the navigate was triggered because a
        new <code>Coral.ColumnView.Column</code> was added, then it will match that column. In case the path was
        reduced, the column will match the last column.
      @param {HTMLElement} event.detail.activeItem
        The currently active item of the ColumnView.
    */
  });

  // exports the enumerations
  Coral.ColumnView.selectionMode = selectionMode;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    The default Collection as used by ColumnView.

    @param {HTMLElement} options.host
      The element that hosts the collection.
    @param {String} options.itemTagName
      The tag name of the elements that constitute a collection item.

    @constructor
    @ignore
   */
  var Collection = function(options) {
    this._host = options.host;
    // target where the new items are added
    this._target = options.target || this._host;
    this._itemTagName = options.itemTagName;
  };

  // Assigns the prototype to get access to the Collection signature methods:
  Collection.prototype = Object.create(Coral.Collection.prototype);

  Collection.prototype.add = function(item, before) {
    if (!(item instanceof HTMLElement)) {
      // Creates a new item and initializes its values:
      var config = item;
      item = document.createElement(this._itemTagName);
      item.set(config, true);
    }

    this._target.insertBefore(item, before);

    return item;
  };

  Collection.prototype.getAll = function() {
    return Array.prototype.slice.call(this._host.getElementsByTagName(this._itemTagName));
  };

  Collection.prototype.getSelected = function() {
    return this._getSelectedItems();
  };

  Collection.prototype.getFirstSelected = function() {
    return this._getSelectedItems()[0] || null;
  };

  Collection.prototype.getLastSelected = function() {
    return this._getSelectedItems().pop() || null;
  };

  Collection.prototype.getFirstActive = function() {
    return this._getActiveItems()[0] || null;
  };

  Collection.prototype.getLastActive = function() {
    return this._getActiveItems().pop() || null;
  };

  /*
    The deselection routines below are not using jQuery "removeAttr" because it does not work correctly on elements that
    have not yet been upgraded. More detail at:

    https://wiki.corp.adobe.com/pages/viewpage.action?spaceKey=CUI&title=Gotchas
   */
  Collection.prototype.deselectAll = function() {
    this
      ._getAllItems()
      .forEach(function(el) {
        if (el.hasAttribute('selected')) {
          el.removeAttribute('selected');
        }
      });
  };

  Collection.prototype.deselectAllExcept = function(item) {
    this
      ._getAllItems()
      .forEach(function(el) {
        if (el.hasAttribute('selected') && el !== item) {
          el.removeAttribute('selected');
        }
      });
  };

  Collection.prototype.deselectAllExceptLast = function() {
    this
      ._getAllItems()
      .filter(function(el) {
        return el.hasAttribute('selected');
      })
      .slice(0, -1)
      .forEach(function(el) {
        el.removeAttribute('selected');
      });
  };

  Collection.prototype.deselectAndDeactivateAll = function() {
    this
      ._getAllItems()
      .forEach(function(el) {
        if (el.hasAttribute('selected') || el.hasAttribute('active')) {
          el.removeAttribute('active');
          el.removeAttribute('selected');
        }
      });
  };

  Collection.prototype.deselectAndDeactivateAllExcept = function(item) {
    this
      ._getAllItems()
      .forEach(function(el) {
        if (el.hasAttribute('selected') || el.hasAttribute('active')) {
          el.removeAttribute('selected');
          if (el !== item) {
            el.removeAttribute('active');
          }
        }
      });
  };

  Collection.prototype.deactivateAll = function(item) {
    this
      ._getAllItems()
      .forEach(function(el) {
        if (el.hasAttribute('active')) {
          el.removeAttribute('active');
        }
      });
  };

  Collection.prototype.deactivateAllExcept = function(item) {
    this
      ._getAllItems()
      .forEach(function(el) {
        if (el.hasAttribute('active') && el !== item) {
          el.removeAttribute('active');
        }
      });
  };

  Collection.prototype.deactivateAllExceptFirst = function() {
    this
      ._getAllItems()
      .filter(function(el) {
        return el.hasAttribute('active');
      })
      .slice(1)
      .forEach(function(el) {
        el.removeAttribute('active');
      });
  };

  /*
    Internal
  */

  /**
    Gets a list of all non nested child items.

    @private

    @returns {HTMLElement} items.
  */
  Collection.prototype._getAllItems = function() {
    return this.getAll();
  };

  /**
    Gets a list of all selectable items. For an item to be selectable it cannot be disabled or hidden.

    @private

    @returns {HTMLElement} items.
  */
  Collection.prototype._getSelectableItems = function() {
    return this.getAll().filter(function(item) {
      return !(item.hasAttribute('disabled') || item.hasAttribute('hidden'));
    });
  };

  /**
    Gets a list of all selected items. A selected item can be hidden.

    @private

    @returns {HTMLElement} items.
  */
  Collection.prototype._getSelectedItems = function() {
    return this.getAll().filter(function(item) {
      return item.hasAttribute('selected') && !item.hasAttribute('disabled');
    });
  };

  /**
    Gets a list of all active items. An active item can be hidden.

    @private

    @returns {HTMLElement} items.
  */
  Collection.prototype._getActiveItems = function() {
    return this.getAll().filter(function(item) {
      return item.hasAttribute('active') && !item.hasAttribute('disabled');
    });
  };

  /**
    The default Collection used by the ColumnView.

    @class
    @extends Coral.Collection
    @ignore
  */
  Coral.ColumnView.Collection = Collection;
})();

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    The number of milliseconds for which scroll events should be debounced.

    @type {Number}
    @ignore
  */
  var SCROLL_DEBOUNCE = 100;

  /**
    Height if every item to avoid using offsetHeight during calculations.

    @ignore
  */
  var ITEM_HEIGHT = 48;

  Coral.register( /** @lends Coral.ColumnView.Column# */ {
    /**
      @class Coral.ColumnView.Column
      @classdesc A Coral.ColumnView.Column component
      @htmltag coral-columnview-column
      @extends Coral.Component
    */
    name: 'ColumnView.Column',
    tagName: 'coral-columnview-column',
    className: 'coral3-ColumnView-column',

    events: {
      // we need to use capture as scroll events do not bubble
      'capture:scroll coral-columnview-column-content': '_onContentScroll',
      'click coral-columnview-column-content': '_onColumnContentClick',

      // item interaction
      'click coral-columnview-item': '_onItemClick',
      'click coral-columnview-item-thumbnail': '_onItemThumbnailClick',

      // item events
      'coral-columnview-item:_activechanged coral-columnview-item': '_onItemActiveChange',
      'coral-columnview-item:_selectedchanged coral-columnview-item': '_onItemSelectedChange'
    },

    properties: {
      /**
        The current active item.

        @type {HTMLElement}
        @readonly
        @memberof Coral.ColumnView.Column#
      */
      'activeItem': {
        get: function() {
          return this.items.getFirstActive();
        },
        set: function() {
          // Read-only
        }
      },

      /**
        The content of the column. This container is where the items should be added and is responsible for handling the
        scrolling.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.ColumnView.Column#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-columnview-column-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.ColumnView.Column#
      */
      'items': {
        get: function() {
          // we do lazy initialization of the collection
          if (!this._items) {
            this._items = new Coral.ColumnView.Collection({
              host: this,
              target: this.content,
              itemTagName: 'coral-columnview-item'
            });
          }

          return this._items;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Returns the first selected item in the ColumnView. The value <code>null</code> is returned if no element is
        selected.

        @type {?HTMLElement}
        @readonly
        @memberof Coral.ColumnView.Column#
      */
      'selectedItem': {
        get: function() {
          return this._selectionMode !== Coral.ColumnView.selectionMode.NONE ? this.items.getFirstSelected() : null;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Returns an Array containing the set selected items inside this Column.

        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.ColumnView.Column#
      */
      'selectedItems': {
        get: function() {
          return this._selectionMode !== Coral.ColumnView.selectionMode.NONE ? this.items.getSelected() : [];
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Private property that indicates the selection mode. If the <code>Coral.ColumnView.Column</code> is not inside
        a <code>Coral.ColumnView</code> this value will be <code>undefined</code>.

        @type {Coral.ColumnView.selectionMode}
        @memberof Coral.ColumnView.Column#
        @private
      */
      '_selectionMode': {
        attribute: '_selectionmode',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(Coral.ColumnView.selectionMode)
        ],
        set: function(value) {
          this.__selectionMode = value;

          this._setStateFromDOM();
        }
      },
  
      /**
        Returns an Array containing the last selected items inside this Column in selected order.
        
        @type {Array.<HTMLElement>}
        @memberof Coral.ColumnView.Column#
        @private
      */
      '_lastSelectedItems': {
        get: function() {
          return this.__lastSelectedItems || this.selectedItems;
        },
        set: function(value) {
          this.__lastSelectedItems = value;
        }
      }
    },

    /** @private */
    _onItemClick: function(event) {
      // since transform will kill the modification, we trigger the event manually
      if (event.matchedTarget.hasAttribute('active')) {
        // directly calls the event since setting the attribute will not trigger an event
        this._onItemActiveChange(event);
      }
      else {
        // sets the item as active. while handling mouse interaction, items are not toggled
        event.matchedTarget.setAttribute('active', '');
      }
    },

    /** @private */
    _onItemThumbnailClick: function(event) {
      if (this._selectionMode && this._selectionMode !== Coral.ColumnView.selectionMode.NONE) {
        // stops propagation so that active is not called as well
        event.stopPropagation();

        var item = event.matchedTarget.parentElement;

        // toggles the selection of the item
        var isSelected = item.hasAttribute('selected');

        if (!isSelected) {
          if (this._selectionMode === Coral.ColumnView.selectionMode.SINGLE) {
            item.setAttribute('active', '');
          }
          // Handle multi-selection with shiftKey
          else if (event.shiftKey && this._selectionMode === Coral.ColumnView.selectionMode.MULTIPLE) {
            var lastSelectedItem = this._lastSelectedItems[this._lastSelectedItems.length - 1];
            
            if (lastSelectedItem) {
              var items = this.items.getAll();
              var lastSelectedItemIndex = items.indexOf(lastSelectedItem);
              var selectedItemIndex = items.indexOf(item);
              
              // true : selection goes up, false : selection goes down
              var direction = selectedItemIndex < lastSelectedItemIndex;
              var selectionRange = [];
              var selectionIndex = lastSelectedItemIndex;
              
              // Retrieve all items in the range
              while (selectedItemIndex !== selectionIndex) {
                selectionIndex = direction ? selectionIndex - 1 : selectionIndex + 1;
                selectionRange.push(items[selectionIndex]);
              }
              
              // Select all items in the range silently
              selectionRange.forEach(function(rangeItem) {
                // Except for item which is needed to trigger the selection change event
                if (rangeItem !== item) {
                  rangeItem.set('selected', true, true);
                }
              });
            }
          }
        }
  
        item[isSelected ? 'removeAttribute' : 'setAttribute']('selected', '');
      }
    },

    /**
      Handles the item activation, this causes the current item to get active and sets the next column to the item's
      src.

      @private
    */
    _onItemActiveChange: function(event) {
      // we stop propagation since it is a private event
      event.stopImmediatePropagation();

      // ignores event handling due to bulk select operation
      if (this._bulkSelectionChange) {
        return;
      }

      var item = event.matchedTarget;

      this._bulkSelectionChange = true;
      // clears the selection and keeps the item active. this force only 1 item to be active per column
      this.items.deselectAndDeactivateAllExcept(item);
      this._bulkSelectionChange = false;

      // we check if the selection requires an event to be triggered
      this._validateColumnChange(item);

      // loads data using the item as the activator and 0 as the start since it is a new column
      this._loadItems(0, item);
    },

    /**
      Handles selecting multiple items in the same column. Selection could result in none, a single or multiple selected
      items.

      @private
    */
    _onItemSelectedChange: function(event) {
      // we stop propagation since it is a private event
      event.stopImmediatePropagation();

      // item that was selected
      var item = event.target;
      var isSelected = item.selected;
      
      if (isSelected) {
        // Remember the last selected item
        this._lastSelectedItems.push(item);
      }
      else {
        var removedItemIndex = this._lastSelectedItems.indexOf(item);
        if (removedItemIndex !== -1) {
          this._lastSelectedItems = this._lastSelectedItems.splice(removedItemIndex, 1);
        }
      }

      // ignores event handling due to bulk select operation
      if (this._bulkSelectionChange) {
        return;
      }

      // when the item is selected, we need to enforce the selection mode
      if (isSelected) {
        this._bulkSelectionChange = true;
        // when there is selection, no item can be active
        this.items.deactivateAll();

        // enforces the selection mode
        if (this._selectionMode === Coral.ColumnView.selectionMode.SINGLE) {
          this.items.deselectAllExcept(item);
        }
        this._bulkSelectionChange = false;
      }

      // we make sure the change event is triggered before the load event.
      this._validateColumnChange();
    },

    /** @ignore */
    _tryToLoadAdditionalItems: function() {
      // makes sure that not too many events are triggered (only one per frame)
      if (this._bulkCollectionChange) {
        return;
      }

      this._bulkCollectionChange = true;

      var self = this;
      // we use setTimeout instead of nextFrame because macrotasks allow for more flexibility since they are less
      // aggressive in executing the code
      setTimeout(function() {
        // trigger 'coral-columnview:loaditems' asynchronously in order to be sure the application is done
        // adding/removing elements. Also make sure that only one event is triggered at once

        // bulkCollectionChange has to be reset before loading new items
        self._bulkCollectionChange = false;
        self._loadFittingAdditionalItems();
      }, 0);
    },

    /** @private */
    _onContentScroll: function(event) {
      clearTimeout(this._scrollTimeout);
      this._scrollTimeout = setTimeout(this._onDebouncedScroll, SCROLL_DEBOUNCE);
    },

    /**
      Handles the column click. When the column body is clicked, we need to deselect everything up to that column.

      @private
     */
    _onColumnContentClick: function(event) {
      // we make sure the content was clicked directly and not an item
      if (event.target !== event.matchedTarget) {
        return;
      }

      event.preventDefault();

      // ignores event handling due to bulk select operation
      if (this._bulkSelectionChange) {
        return false;
      }

      this._bulkSelectionChange = true;
      // clears the current column
      this.items.deselectAndDeactivateAll();
      this._bulkSelectionChange = false;

      // we check if the selection requires an event to be triggered
      this._validateColumnChange();
    },

    /** @private */
    _onDebouncedScroll: function() {
      var threshold = 20;
      if (this.content.scrollTop + this.offsetHeight >= this.content.scrollHeight - threshold) {
        this._loadItems(this.items.length, undefined);
      }
    },

    /** @private */
    _arraysAreDifferent: function(selection, oldSelection) {
      var diff = [];

      if (oldSelection.length === selection.length) {
        diff = oldSelection.filter(function(item) {
          return selection.indexOf(item) === -1;
        });
      }

      // since we guarantee that they are arrays, we can start by comparing their size
      return oldSelection.length !== selection.length || diff.length !== 0;
    },

    /** @private */
    _validateColumnChange: function(item) {
      var newActiveItem = this.activeItem;
      var oldActiveItem = this._oldActiveItem || null;

      // we have to force the event in case the same active item was clicked again, but still try to avoid triggering as
      // less events as possible
      if (newActiveItem !== oldActiveItem || item === newActiveItem) {
        this.trigger('coral-columnview-column:_activeitemchanged', {
          activeItem: newActiveItem,
          oldActiveItem: oldActiveItem
        });

        // we cache the active item for the next time
        this._oldActiveItem = newActiveItem;
      }

      var newSelection = this.selectedItems;
      var oldSelection = this._oldSelection;

      if (this._arraysAreDifferent(newSelection, oldSelection)) {
        this.trigger('coral-columnview-column:_selecteditemchanged', {
          selection: newSelection,
          oldSelection: oldSelection
        });

        // changes the old selection array since we selected something new
        this._oldSelection = newSelection;
      }
    },

    /**
      Loads additional Items if the current items of the column to not exceed its height and a path this.next is given.

      @private
    */
    _loadFittingAdditionalItems: function() {
      var itemsCount = this.items.length;
      // this value must match $columnview-item-height
      var itemsHeight = itemsCount * ITEM_HEIGHT;

      // we request more items if there is still space for them. in case the values are the same, we request more data
      // just to be sure, specially when the value is 0
      if (itemsHeight <= this.offsetHeight) {
        this._loadItems(itemsCount, undefined);
      }
    },

    /**
      Loads additional items. If the given item is not <code>active</code>, no data will be requested.

      @param {Number} count
        Amount of items in the column.
      @param {?HTMLElement} item
        Item that triggered the load.

      @private
    */
    _loadItems: function(count, item) {
      // if the given item is not active, it should not request data
      if (!item || item.hasAttribute('active')) {
        this.trigger('coral-columnview-column:_loaditems', {
          start: count,
          item: item
        });
      }
    },

    /** @private */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      var self = this;
      // instead of being super aggresive on requesting data, we use setTimeout so it is schedulled after all the code
      // has been executed (macrotask), this way events can be added before
      setTimeout(function() {
        Coral.commons.ready(self, function() {
          self._loadFittingAdditionalItems();
        });
      }, 0);
    },

    /**
      Updates the active and selected options from the DOM.

      @ignore
    */
    _setStateFromDOM: function() {
      // if the selection mode has not been set, we do no try to force selection
      if (this._selectionMode) {
        // single: only the last item is selected
        if (this._selectionMode === Coral.ColumnView.selectionMode.SINGLE) {
          this.items.deselectAllExceptLast();
        }
        // none: deselects everything
        else if (this._selectionMode === Coral.ColumnView.selectionMode.NONE) {
          this.items.deselectAll();
        }

        // makes sure only one item is active
        this.items.deactivateAllExceptFirst();
      }
    },

    /** @private */
    _handleMutation: function(mutations) {
      var mutationsCount = mutations.length;
      for (var i = 0; i < mutationsCount; i++) {
        var mutation = mutations[i];
        // we handle the collection events
        this._triggerCollectionEvents(mutation.addedNodes, mutation.removedNodes);
      }

      this._setStateFromDOM();

      // in case items were added removed and selection changed
      this._validateColumnChange();

      // checks if more items can be added after the childlist change
      this._tryToLoadAdditionalItems();
    },

    /** @private */
    _triggerCollectionEvents: function(addedNodes, removedNodes) {
      var item;
      var addedNodesCount = addedNodes.length;
      for (var i = 0; i < addedNodesCount; i++) {
        item = addedNodes[i];
        if (item.tagName === 'CORAL-COLUMNVIEW-ITEM') {
          this.trigger('coral-collection:add', {
            item: item
          });
        }
      }

      var removedNodesCount = removedNodes.length;
      for (var j = 0; j < removedNodesCount; j++) {
        item = removedNodes[j];
        if (item.tagName === 'CORAL-COLUMNVIEW-ITEM') {
          this.trigger('coral-collection:remove', {
            item: item
          });
        }
      }
    },

    /** @ignore */
    _render: function() {
      // queries the content zone
      var content = this.querySelector('coral-columnview-column-content');

      // when the content zone was not created, we need to make sure that everything is added inside it as a content.
      // this stops the content zone from being voracious
      if (content === null) {
        content = document.createElement('coral-columnview-column-content');
        // move the contents of the item into the content zone
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      this.content = content;
    },

    /** @ignore */
    _initialize: function() {
      // @a11y
      this.setAttribute('role', 'group');

      // default value of inner flag to process events
      this._bulkSelectionChange = false;

      // cache bound event handler functions
      this._onDebouncedScroll = this._onDebouncedScroll.bind(this);

      this._observer = new MutationObserver(this._handleMutation.bind(this));
      // items outside the scroll area are not supported
      this._observer.observe(this._elements.content, {
        // only watch the childList, items will tell us if selected/value/content changes
        childList: true
      });

      // @todo: initial collection items needs to be triggered

      // handles the initial selection
      this._setStateFromDOM();

      // we keep a list of the last selection to determine if something changed. we need to do this after
      // validateSelection since it modifies the initial state based on the option
      this._oldSelection = this.selectedItems;
      this._oldActiveItem = this.activeItem;
    }
  });

  /**
    @class Coral.ColumnView.Column.Content
    @classdesc The ColumnView Content
    @htmltag coral-columnview-column-content
    @extends HTMLElement
  */
  Coral.ColumnView.Column.Content = function() {
    return document.createElement('coral-columnview-column-content');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for item variants.

    @enum {String}
    @memberof Coral.ColumnView.Item
  */
  var variant = {
    /** Default item variant. Contains no special decorations. */
    DEFAULT: 'default',
    /** An item with a right arrow indicating that the navigation will go one level down. */
    DRILLDOWN: 'drilldown'
  };

  // the items's base classname
  var CLASSNAME = 'coral3-ColumnView-item';

  // builds a string containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  Coral.register( /** @lends Coral.ColumnView.Item# */ {
    /**
      @class Coral.ColumnView.Item
      @classdesc A Coral.ColumnView.Item component
      @htmltag coral-columnview-item
      @extends Coral.Component
    */
    name: 'ColumnView.Item',
    tagName: 'coral-columnview-item',
    className: CLASSNAME,

    properties: {

      /**
        The content of the item.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.ColumnView.Item#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-columnview-item-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        The thumbnail of the item. It is used to hold an icon or an image.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.ColumnView.Item#
      */
      'thumbnail': Coral.property.contentZone({
        handle: 'thumbnail',
        tagName: 'coral-columnview-item-thumbnail',
        insert: function(thumbnail) {
          this.insertBefore(thumbnail, this.content || null);
        }
      }),

      /**
        The item's variant.

        @type {Coral.ColumnView.Item.variant}
        @default Coral.ColumnView.Item.variant.DEFAULT
        @htmlattribute variant
        @htmlattributereflected
        @memberof Coral.ColumnView.Item#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== Coral.ColumnView.Item.variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }
        }
      },

      /**
        Specifies the icon that will be placed inside the thumbnail. The size of the icon is always controlled by the
        component.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.ColumnView.Item#
      */
      'icon': {
        default: '',
        transform: Coral.transform.string,
        sync: function() {

          // ignored if it is an empty string
          if (this.icon) {
            // creates a new icon element
            if (!this._elements.icon) {
              this._elements.icon = document.createElement('coral-icon');
            }

            this._elements.icon.icon = this.icon;
            this._elements.icon.size = Coral.Icon.size.SMALL;

            // removes all the items, since the icon attribute has precedence
            this._elements.thumbnail.innerHTML = '';

            // adds the newly created icon
            this._elements.thumbnail.appendChild(this._elements.icon);
          }
        }
      },

      /**
        Whether the item is selected.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.ColumnView.Item#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-columnview-item:_selectedchanged',
        sync: function() {
          this.classList.toggle('is-selected', this.selected);
          this.setAttribute('aria-selected', this.selected || this.active);
        }
      },

      /**
        Whether the item is active.

        @type {Boolean}
        @default false
        @htmlattributereflected
        @memberof Coral.ColumnView.Item#
      */
      'active': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-columnview-item:_activechanged',
        sync: function() {
          this.classList.toggle('is-active', this.active);
          this.setAttribute('aria-selected', this.active || this.selected);
        }
      }
    },

    /** @ignore */
    _render: function() {
      // queries all the content zones
      var thumbnail = this.querySelector('coral-columnview-item-thumbnail') ||
        document.createElement('coral-columnview-item-thumbnail');
      var content = this.querySelector('coral-columnview-item-content');

      // we add the thumbnail if we had to create it
      if (!thumbnail.parentNode) {
        this.insertBefore(thumbnail, this.firstChild || null);
      }

      // when the content zone was not created, we need to make sure that everything is added inside it as a content
      if (content === null) {
        content = document.createElement('coral-columnview-item-content');

        // move the contents of the item into the content zone
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      this.thumbnail = thumbnail;
      this.content = content;
    },

    /** @private */
    _initialize: function() {
      // @a11y
      this.setAttribute('role', 'treeitem');
    }
  });

  // exports the variants enumeration
  Coral.ColumnView.Item.variant = variant;

  /**
    @class Coral.ColumnView.Item.Content
    @classdesc The ColumnView Item Content
    @htmltag coral-columnview-item-content
    @extends HTMLElement
  */
  Coral.ColumnView.Item.Content = function() {
    return document.createElement('coral-columnview-item-content');
  };

  /**
    @class Coral.ColumnView.Item.Thumbnail
    @classdesc The ColumnView Item Thumbnail
    @htmltag coral-columnview-item-thumbnail
    @extends HTMLElement
  */
  Coral.ColumnView.Item.Thumbnail = function() {
    return document.createElement('coral-columnview-item-thumbnail');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.ColumnView.Preview# */ {
    /**
      @class Coral.ColumnView.Preview
      @classdesc A Coral.ColumnView.Preview component
      @htmltag coral-columnview-preview
      @extends Coral.Component
    */
    name: 'ColumnView.Preview',
    tagName: 'coral-columnview-preview',
    className: 'coral3-ColumnView-column',

    properties: {
      /**
        The content of the Preview.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.ColumnView.Preview#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-columnview-preview-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      })
    },

    /** @ignore */
    _render: function() {
      // queries the content zone
      var content = this.querySelector('coral-columnview-preview-content');

      // when the content zone was not created, we need to make sure that everything is added inside it as a content.
      // this stops the content zone from being voracious
      if (content === null) {
        content = document.createElement('coral-columnview-preview-content');

        // move the contents of the item into the content zone
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      this.content = content;
    }
  });

  /**
    @class Coral.ColumnView.Preview.Content
    @classdesc The ColumnView Item Content
    @htmltag coral-columnview-preview-content
    @extends HTMLElement
  */
  Coral.ColumnView.Preview.Content = function() {
    return document.createElement('coral-columnview-preview-content');
  };

  /**
    @class Coral.ColumnView.Preview.Asset
    @classdesc The ColumnView Column Preview Asset
    @htmltag coral-columnview-preview-asset
    @extends HTMLElement
  */
  Coral.ColumnView.Preview.Asset = function() {
    return document.createElement('coral-columnview-preview-asset');
  };

  /**
    @class Coral.ColumnView.Preview.Label
    @classdesc The ColumnView Column Preview Label
    @htmltag coral-columnview-preview-label
    @extends HTMLElement
  */
  Coral.ColumnView.Preview.Label = function() {
    return document.createElement('coral-columnview-preview-label');
  };

  /**
    @class Coral.ColumnView.Preview.Value
    @classdesc The ColumnView Column Preview Value
    @htmltag coral-columnview-preview-value
    @extends HTMLElement
  */
  Coral.ColumnView.Preview.Value = function() {
    return document.createElement('coral-columnview-preview-value');
  };

  /**
    @class Coral.ColumnView.Preview.Separator
    @classdesc The ColumnView Column Preview Separator
    @htmltag coral-columnview-preview-separator
    @extends HTMLElement
  */
  Coral.ColumnView.Preview.Separator = function() {
    return document.createElement('coral-columnview-preview-separator');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["CycleButton"] = window["Coral"]["templates"]["CycleButton"] || {};
window["Coral"]["templates"]["CycleButton"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["button"] = document.createElement("button","coral-button");
  el0.id = Coral["commons"]["getUID"]();
  el0.setAttribute("handle", "button");
  el0.className += " coral3-CycleButton-button";
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("variant", "quiet");
  el0.setAttribute("iconsize", "S");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["openIcon"] = document.createElement("coral-icon");
  el2.setAttribute("handle", "openIcon");
  el2.setAttribute("icon", "chevronDown");
  el2.setAttribute("size", "xs");
  el2.className += " coral3-CycleButton-openIcon";
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  frag.appendChild(el0);
  var el4 = document.createTextNode("\n");
  frag.appendChild(el4);
  var el5 = this["overlay"] = document.createElement("coral-overlay");
  el5.setAttribute("handle", "overlay");
  el5.className += " coral3-CycleButton-overlay";
  el5.setAttribute("returnfocus", "on");
  el5.setAttribute("focusonshow", "on");
  el5.setAttribute("trapfocus", "on");
  el5.setAttribute("placement", "bottom");
  var el6 = document.createTextNode("\n  ");
  el5.appendChild(el6);
  var el7 = this["selectList"] = document.createElement("coral-selectlist");
  el7.setAttribute("handle", "selectList");
  el7.id = Coral["commons"]["getUID"]();
  el5.appendChild(el7);
  var el8 = document.createTextNode("\n  ");
  el5.appendChild(el8);
  var el9 = this["actionList"] = document.createElement("coral-buttonlist");
  el9.setAttribute("handle", "actionList");
  el9.setAttribute("hidden", "");
  el5.appendChild(el9);
  var el10 = document.createTextNode("\n");
  el5.appendChild(el10);
  frag.appendChild(el5);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Regex used to remove whitespace from selectedItem label for use as an aria-label for accessibility.

    @ignore
  */
  var WHITESPACE_REGEX = /[\t\n\r ]+/g;

  /** @ignore */
  var ITEM_TAG_NAME = 'coral-cyclebutton-item';

  /** @ignore */
  var ACTION_TAG_NAME = 'coral-cyclebutton-action';

  /**
   Enum for CycleButton displayMode values.

   @enum {String}
   @memberof Coral.CycleButton
   */
  var displayMode = {
    /** Icon display mode **/
    ICON: 'icon',
    /** Text display mode **/
    TEXT: 'text',
    /** Icon and text display mode **/
    ICON_TEXT: 'icontext'
  };

  Coral.register( /** @lends Coral.CycleButton# */ {
    /**
      A CycleButton is a simple multi-state toggle button.

      @class Coral.CycleButton
      @classdesc A CycleButton component
      @extends Coral.Component
      @borrows Coral.mixin.selectionList#selectedItem as Coral.CycleButton#selectedItem
      @borrows Coral.mixin.selectionList#items as Coral.CycleButton#items
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:add as Coral.CycleButton#coral-collection:add
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:remove as Coral.CycleButton#coral-collection:remove
      @htmltag coral-cyclebutton
    */
    name: 'CycleButton',
    tagName: 'coral-cyclebutton',
    className: 'coral3-CycleButton',

    mixins: [
      Coral.mixin.selectionList({
        itemTagName: ITEM_TAG_NAME,
        supportMultiple: false,
        forceSelection: true,
        role: 'presentation'
      })
    ],

    events: {
      'click :not(coral-cyclebutton-action)': '_onItemClick',
      'click button[is="coral-buttonlist-item"]': '_onActionClick',
      'key:down [aria-expanded=false]': '_onItemClick',
      'coral-selectlist:change': '_onSelectListChange',

      'coral-cyclebutton-item:_iconchanged coral-cyclebutton-item[selected]': '_onSelectedItemPropertyChange',
      'coral-cyclebutton-item:_displaymodechanged coral-cyclebutton-item[selected]': '_onSelectedItemPropertyChange',

      'global:click': '_onGlobalClick',
      'global:touchstart': '_onGlobalClick',
      'global:key:escape': '_onEscapeKey'
    },

    properties: {
      /**
        General icon of the CycleButton. The icon will be displayed no matter the selection. If the selected item has
        its own icon, it will be overwritten.

        @type {String}
        @default ""
        @memberof Coral.CycleButton#
      */
      'icon': {
        default: '',
        sync: function() {
          if (this.selectedItem) {
            this._renderSelectedItem(this.selectedItem);
          }
        }
      },

      /**
        Number of items that can be directly cycled through before collapsing. If <code>0</code> is used, the items
        will never be collapsed.

        @type {Number}
        @default 3
        @htmlattribute threshold
        @memberof Coral.CycleButton#
      */
      'threshold': {
        default: 3,
        transform: Coral.transform.number,
        validate: [
          Coral.validate.valueMustChange,
          function(newValue, oldValue) {
            return newValue !== null && newValue > -1;
          }
        ],
        sync: function() {
          this._checkExtended();
        }
      },

      /**
        The Collection Interface that allows interaction with the {@link Coral.CycleButton.Action} elements.
        See {@link Coral.Collection} for more details regarding Collection APIs.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.CycleButton#
      */
      'actions': {
        set: function() {},
        get: function() {
          if (!this._actions) {
            this._actions = new Coral.Collection({
              host: this,
              itemTagName: ACTION_TAG_NAME,
              itemSelector: ACTION_TAG_NAME
            });
          }
          return this._actions;
        }
      },

      /**
        The CycleButton's displayMode. This defines how the selected item is displayed. If the selected item does not
        have the necessary icon or text information then fallback to show whichever is available. The appearance of
        collapsed items in the popover are not affected by this property. The displayMode property can be set on an
        item to override the component level value when that item is selected.

        @type {Coral.CycleButton.displayMode}
        @default Coral.CycleButton.displayMode.ICON
        @htmlattribute displaymode
        @memberof Coral.CycleButton#
       */
      'displayMode': {
        default: displayMode.ICON,
        attribute: 'displaymode',
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(displayMode)
        ],
        sync: function() {
          if (this.selectedItem) {
            this._renderSelectedItem(this.selectedItem);
          }
        }
      }
    },

    /** @ignore */
    _onEscapeKey: function(event) {
      // When escape is pressed, hide ourselves
      if (this._elements.overlay._isTopOverlay()) {
        this._hideOverlay();
      }
    },

    /** @ignore */
    _onGlobalClick: function(event) {
      if (!this._elements.overlay.open) {
        return;
      }

      // makes sure we don't hide ourselves when clicked
      var eventTargetWithinOverlayTarget = this._elements.overlay.contains(event.target);
      var eventTargetWithinItself = this.contains(event.target);
      if (!eventTargetWithinOverlayTarget && !eventTargetWithinItself) {
        this._hideOverlay();
      }
    },

    /** @private **/
    _onItemAttached: function() {
      this._checkExtended();
    },

    /** @private **/
    _onItemDetached: function() {
      this._checkExtended();
    },

    /** @private */
    _onItemClick: function(event) {
      event.preventDefault();

      var items = this.items.getAll();
      var itemCount = items.length;

      if (!(event.matchedTarget === this._elements.button || event.matchedTarget.tagName.toLowerCase() === ITEM_TAG_NAME)) {
        return;
      }

      // When we have more than a specified number of items, use the overlay selection. If threshold is 0, then we never
      // show the popover. If there are actions, we always show the popover.
      if (this._isExtended()) {
        // we toggle the overlay if it was already open
        if (this._elements.overlay.open) {
          this._hideOverlay();
        }
        else {
          this._showOverlay();
          // Set focus on selectList item after overlay opened
          this._focusItem(this.selectedItem._elements.selectListItem);
        }
      }
      // Unless this is the only item we have, select the next item in line:
      else if (itemCount > 1) {
        this._selectCycleItem(this.selectedItem.nextElementSibling || items[0]);
        this._focusItem(this._elements.button);
      }
    },

    /**
      Render the provided item as selected according to resolved icon and displayMode properties.

      @private
     */
    _renderSelectedItem: function(item) {
      if (!item) {
        return;
      }

      // resolve effective values by checking for item and component level properties
      var effectiveDisplayMode = this.displayMode;
      var effectiveIcon = item.icon || this.icon || '';

      if (item.displayMode !== Coral.CycleButton.Item.displayMode.INHERIT) {
        effectiveDisplayMode = item.displayMode;
      }
      if (!item.content.textContent.trim() || !effectiveIcon.trim()) {
        // if icon or text missing then we fallback to showing whichever is available
        effectiveDisplayMode = displayMode.ICON_TEXT;
      }

      // manipulate button sub-component depending on display mode
      if (effectiveDisplayMode === displayMode.ICON) {
        this._elements.button.icon = effectiveIcon;
        this._elements.button.label.innerHTML = '';

        // @a11y
        var ariaLabel = item.content.textContent.replace(WHITESPACE_REGEX, ' ');
        this._elements.button.setAttribute('aria-label', ariaLabel);
        this._elements.button.setAttribute('title', ariaLabel);
      }
      else {
        // handle display modes that include text
        if (effectiveDisplayMode === displayMode.TEXT) {
          this._elements.button.icon = '';
        }
        if (effectiveDisplayMode === displayMode.ICON_TEXT) {
          this._elements.button.icon = effectiveIcon;
        }
        this._elements.button.label.innerHTML = item.content.innerHTML;

        // @a11y we do not require aria attributes since we already show text
        this._elements.button.removeAttribute('aria-label');
        this._elements.button.removeAttribute('title');
      }
    },

    /** @private */
    _onItemSelected: function(item) {
      if (item) {
        this._renderSelectedItem(item);
      }
    },

    /**
      Update currently selected item if it's <code>icon</code> or <code>displayMode</code> properties have changed.

      @private
    */
    _onSelectedItemPropertyChange: function(event) {
      // stops propagation because the event is internal to the component
      event.stopImmediatePropagation();
      this._renderSelectedItem(event.target);
    },

    /** @private */
    _onSelectListChange: function(event) {
      event.stopImmediatePropagation();
      event.preventDefault();

      var selectListItem = event.detail.selection;
      if (selectListItem) {
        var origNode = selectListItem._elements.originalItem;

        this._selectCycleItem(origNode);
        this._focusItem(this._elements.button);

        // Hide the overlay, cleanup will be done before overlay.show()
        this._hideOverlay();
      }
    },

    /** @private */
    _onActionClick: function(event) {
      event.stopPropagation();

      var item = event.matchedTarget;
      var proxyEvent = item._elements.originalItem.trigger('click');

      if (!proxyEvent.defaultPrevented) {
        this._hideOverlay();
      }
    },

    /** @private */
    _isExtended: function() {
      var hasActions = this.actions.getAll().length > 0;
      return (this.threshold > 0 && this.items.getAll().length >= this.threshold) || hasActions;
    },

    /** @private */
    _checkExtended: function() {
      var isExtended = this._isExtended();
      this.classList.toggle('coral3-CycleButton--extended', isExtended);

      // @a11y
      if (isExtended) {
        var uid = this._elements.selectList.id;
        this._elements.button.setAttribute('aria-owns', uid);
        this._elements.button.setAttribute('aria-controls', uid);
        this._elements.button.setAttribute('aria-haspopup', true);
        this._elements.button.setAttribute('aria-expanded', false);
      }
      else {
        this._elements.button.removeAttribute('aria-owns');
        this._elements.button.removeAttribute('aria-controls');
        this._elements.button.removeAttribute('aria-haspopup');
        this._elements.button.removeAttribute('aria-expanded');
      }
    },

    /** @ignore */
    _focusItem: function(item) {
      if (item) {
        Coral.commons.nextFrame(function() {
          item.focus();
        });
      }
    },

    /** @ignore */
    _hideOverlay: function() {
      // @a11y
      this._elements.button.setAttribute('aria-expanded', false);
      this._elements.overlay.hide();
    },

    /** @ignore */
    _getSelectListItem: function(item) {
      var selectListItem = new Coral.SelectList.Item();

      // we do first the content, so that the icon is not destroyed
      selectListItem.content.innerHTML = item.content.innerHTML;

      // If an icon was specified we need to create an element for it and add it directly to the selectList Item
      if (item.icon) {
        var icon = new Coral.Icon().set({
          icon: item.icon,
          size: Coral.Icon.size.SMALL
        });

        selectListItem.content.insertBefore(icon, selectListItem.content.firstChild);
      }

      selectListItem._elements.originalItem = item;
      item._elements.selectListItem = selectListItem;

      return selectListItem;
    },

    /** @ignore */
    _getActionListItem: function(action) {
      var actionListItem = new Coral.ButtonList.Item();

      actionListItem.icon = action.icon;
      actionListItem.content.innerHTML = action.content.innerHTML;

      actionListItem._elements.originalItem = action;
      action._elements.buttonListItem = actionListItem;

      return actionListItem;
    },

    /** @ignore */
    _populateLists: function() {
      var selectList = this._elements.selectList;
      var actionList = this._elements.actionList;
      var items = this.items.getAll();
      var actions = this.actions.getAll();
      var itemCount = items.length;
      var actionCount = actions.length;
      var selectListItem;
      var actionListItem;

      // we empty the existing items before populating the lists again
      selectList.items.clear();
      actionList.items.clear();

      // adds the items to the selectList
      for (var i = 0; i < itemCount; i++) {
        var item = items[i];
        selectListItem = this._getSelectListItem(item);

        // we have set the selected state after attaching otherwise will get
        // Uncaught Error: Coral.SelectList.Item cannot be selected before being added as a child
        selectList.items.add(selectListItem);

        selectListItem.set({
          disabled: item.disabled,
          selected: item.selected
        }, true);
      }

      // adds any additional actions to the actions buttonList
      if (actionCount > 0) {
        for (var j = 0; j < actionCount; j++) {
          var action = actions[j];

          actionListItem = this._getActionListItem(action);
          actionList.items.add(actionListItem);
          actionListItem.disabled = action.disabled;
        }

        this._elements.actionList.removeAttribute('hidden');
      }
      else {
        this._elements.actionList.setAttribute('hidden', true);
      }
    },

    /** @private */
    _selectCycleItem: function(item) {
      item.selected = true;
    },

    /** @ignore */
    _showOverlay: function() {
      // @a11y
      this._elements.button.setAttribute('aria-expanded', true);

      this._populateLists();
      this._elements.overlay.show();
    },

    /** @ignore */
    _render: function() {
      // Cleanup template elements (supporting cloneNode)
      var templateElements = this.querySelectorAll('[handle]');
      for (var i = 0; i < templateElements.length; ++i) {
        var currentElement = templateElements[i];
        if (currentElement.parentNode === this) {
          this.removeChild(currentElement);
        }
      }

      // We insert the template before the items
      this.insertBefore(Coral.templates.CycleButton.base.call(this._elements), this.firstChild);

      // Assign the button as the target for the overlay (faster than querySelect the target via id)
      this._elements.overlay.target = this._elements.button;

      // Gives the focus back to button once the overlay is closed
      this._elements.overlay.returnFocusTo(this._elements.button);
    },

    /** @ignore */
    _initialize: function() {
      // @a11y
      this._elements.button.setAttribute('aria-expanded', false);

      // checks the component's extended mode
      this._checkExtended();

      var self = this;
      // handles the initial selected item's icon
      Coral.commons.nextFrame(function() {
        self._onItemSelected(self.selectedItem);
      });
    }

    /**
      Triggered when the selected item has changed.

      @event Coral.CycleButton#coral-cyclebutton:change

      @param {Object} event Event object
      @param {Object} event.detail
      @param {HTMLElement} event.detail.oldSelection
        The prior selected item(s).
      @param {HTMLElement} event.detail.selection
        The newly selected item(s).
    */
  });

  // exports the displayMode enumeration
  Coral.CycleButton.displayMode = displayMode;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for CycleButton.Item displayMode values.

    @enum {String}
    @memberof Coral.CycleButton.Item
  */
  var displayMode = {
    /** Icon display mode **/
    ICON: 'icon',
    /** Text display mode **/
    TEXT: 'text',
    /** Icon and text display mode **/
    ICON_TEXT: 'icontext',
    /** Inherit display mode **/
    INHERIT: 'inherit'
  };

  Coral.register( /** @lends Coral.CycleButton.Item# */ {
    /**
      @class Coral.CycleButton.Item
      @classdesc A CycleButton item
      @extends Coral.Component
      @mixes Coral.mixin.selectionList.Item
      @borrows Coral.mixin.selectionList.Item#selected as Coral.CycleButton.Item#selected
      @htmltag coral-cyclebutton-item
    */
    name: 'CycleButton.Item',
    tagName: 'coral-cyclebutton-item',

    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-cyclebutton'
      })
    ],

    properties: {
      /**
        The Item's icon. See {@link Coral.Icon} for valid icon names.

        @type {String}
        @default ""
        @htmlattribute icon
        @htmlattributereflected
        @memberof Coral.CycleButton.Item#
      */
      'icon': {
        default: '',
        reflectAttribute: true,
        trigger: 'coral-cyclebutton-item:_iconchanged'
      },

      /**
        Item content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.CycleButton.Item#
      */
      'content': {
        contentZone: true,
        get: function() {
          return this;
        },
        set: function() {}
      },

      /**
        The displayMode to be used when the particular item is selected. When this value is set to <code>inherit</code>
        it will defer to the component level displayMode. If the selected item does not have the necessary icon or text
        information, then fallback to show whichever is available. The appearance of collapsed items in the popover are
        not affected by this property.

        @type {Coral.CycleButton.Item.displayMode}
        @default Coral.CycleButton.Item.displayMode.INHERIT
        @htmlattribute displaymode
        @memberof Coral.CycleButton.Item#
      */
      'displayMode': {
        default: displayMode.INHERIT,
        attribute: 'displaymode',
        reflectAttribute: true,
        trigger: 'coral-cyclebutton-item:_displaymodechanged',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(displayMode)
        ]
      }
    }
  });

  // exports the displayMode enumeration
  Coral.CycleButton.Item.displayMode = displayMode;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.CycleButton.Action# */ {
    /**
      @class Coral.CycleButton.Action
      @classdesc A CycleButton action
      @extends Coral.Component
      @htmltag coral-cyclebutton-action
    */
    name: 'CycleButton.Action',
    tagName: 'coral-cyclebutton-action',

    properties: {
      /**
        The Action's icon. See {@link Coral.Icon} for valid icon names.

        @type {String}
        @default ""
        @htmlattribute icon
        @htmlattributereflected
        @memberof Coral.CycleButton.Action#
      */
      'icon': {
        default: '',
        reflectAttribute: true
      },

      /**
        Action content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.CycleButton.Action#
      */
      'content': {
        contentZone: true,
        get: function() {
          return this;
        },
        set: function() {}
      }
    }
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-datepicker"] = {"en-US":{"Time":"Time","Calendar":"Calendar"},"de-DE":{"Time":"Zeit","Calendar":"Kalender"},"fr-FR":{"Time":"Heure","Calendar":"Calendrier"},"it-IT":{"Time":"Ora","Calendar":"Calendario"},"ja-JP":{"Time":"時間","Calendar":"カレンダー"},"es-ES":{"Time":"Hora","Calendar":"Calendario"},"ko-KR":{"Time":"시간","Calendar":"달력"},"zh-CN":{"Time":"时间","Calendar":"日历"},"zh-TW":{"Time":"時間","Calendar":"日曆"},"pt-BR":{"Time":"Hora","Calendar":"Calendário"},"nl-NL":{"Time":"Tijd","Calendar":"Kalender"},"da-DK":{"Time":"Tid","Calendar":"Kalender"},"fi-FI":{"Time":"Aika","Calendar":"Kalenteri"},"nb-NO":{"Time":"Klokkeslett","Calendar":"Kalender"},"sv-SE":{"Time":"Tid","Calendar":"Kalender"},"cs-CZ":{"Time":"Čas","Calendar":"Kalendář"},"pl-PL":{"Time":"Czas","Calendar":"Kalendarz"},"ru-RU":{"Time":"Время","Calendar":"Календарь"},"tr-TR":{"Time":"Zaman","Calendar":"Takvim"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Datepicker"] = window["Coral"]["templates"]["Datepicker"] || {};
window["Coral"]["templates"]["Datepicker"]["base"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["hiddenInput"] = document.createElement("input");
  el0.setAttribute("type", "hidden");
  el0.setAttribute("handle", "hiddenInput");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["input"] = document.createElement("input","coral-textfield");
  el2.setAttribute("is", "coral-textfield");
  el2.setAttribute("type", "text");
  el2.setAttribute("handle", "input");
  el2.className += " coral-InputGroup-input";
  el2.setAttribute("role", "textbox");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["toggleButtonContainer"] = document.createElement("div");
  el4.className += " coral-InputGroup-button";
  el4.setAttribute("handle", "toggleButtonContainer");
  var el5 = document.createTextNode("\n  ");
  el4.appendChild(el5);
  var el6 = this["toggle"] = document.createElement("button","coral-button");
  el6.setAttribute("is", "coral-button");
  el6.setAttribute("type", "button");
  el6.setAttribute("icon", "calendar");
  el6.setAttribute("iconsize", "S");
  el6.setAttribute("handle", "toggle");
  el6.setAttribute("aria-haspopup", "true");
  el6.setAttribute("aria-label", Coral["i18n"]["get"]('Calendar'));
  el6.setAttribute("title", Coral["i18n"]["get"]('Calendar'));
  el4.appendChild(el6);
  var el7 = document.createTextNode("\n");
  el4.appendChild(el7);
  frag.appendChild(el4);
  var el8 = document.createTextNode("\n");
  frag.appendChild(el8);
  var el9 = this["popover"] = document.createElement("coral-popover");
  el9.setAttribute("handle", "popover");
  el9.id = Coral["commons"]["getUID"]();
  el9.setAttribute("alignmy", "right top");
  el9.setAttribute("alignat", "right bottom");
  el9.setAttribute("collision", "fit");
  frag.appendChild(el9);
  return frag;
});

window["Coral"]["templates"]["Datepicker"]["popovercontent"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  
  var uid = Coral.commons.getUID();

  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["calendar"] = document.createElement("coral-calendar");
  el2.setAttribute("handle", "calendar");
  el2.className += " u-coral-borderless";
  el2.setAttribute("aria-labelledby", uid+"-calendar");
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = document.createElement("span");
  el4.id = uid+"-calendar";
  el4.className += " u-coral-screenReaderOnly";
  el4.setAttribute("hidden", "");
  el4.textContent = Coral["i18n"]["get"]("Calendar");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el2.appendChild(el5);
  frag.appendChild(el2);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = this["clockContainer"] = document.createElement("div");
  el7.className += " coral3-Datepicker-clockContainer";
  el7.setAttribute("handle", "clockContainer");
  var el8 = document.createTextNode("\n  ");
  el7.appendChild(el8);
  var el9 = this["clock"] = document.createElement("coral-clock");
  el9.setAttribute("handle", "clock");
  el9.setAttribute("aria-labelledby", uid+"-clock");
  var el10 = document.createTextNode("\n    ");
  el9.appendChild(el10);
  var el11 = document.createElement("span");
  el11.id = uid+"-clock";
  el11.className += " u-coral-screenReaderOnly";
  el11.setAttribute("hidden", "");
  el11.textContent = Coral["i18n"]["get"]("Time");
  el9.appendChild(el11);
  var el12 = document.createTextNode("\n  ");
  el9.appendChild(el12);
  el7.appendChild(el9);
  var el13 = document.createTextNode("\n");
  el7.appendChild(el13);
  frag.appendChild(el7);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
   Enum for Datepicker variant values.

   @enum {String}
   @memberof Coral.Datepicker
  */
  var variant = {
    /** A default, gray Datepicker. */
    DEFAULT: 'default',
    /** A Datepicker with no border or background. */
    QUIET: 'quiet'
  };

  var CLASSNAME = 'coral-InputGroup';

  // builds a string containing all possible variant classnames. This will be used to remove
  // classnames when the variant changes.
  var ALL_VARIANT_CLASSES = [];
  for (var variantKey in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantKey]);
  }

  /** @ignore */
  function toMoment(value, format) {
    if (value === 'today') {
      return moment();
    }
    else if (moment.isMoment(value)) {
      return value.isValid() ? value.clone() : null;
    }
    else {
      // if the value provided is a date it does not make sense to provide a format to parse the date
      var result = moment(value, value instanceof Date ? null : format);
      return result.isValid() ? result : null;
    }
  }

  /**
    Datepicker types.

    @enum {String}
    @memberof Coral.Datepicker
  */
  var type = {
    /** The selection overlay contains only a calendar. */
    DATE: 'date',
    /** Provides both calendar and time controls in the selection overlay. */
    DATETIME: 'datetime',
    /** The selection overlay provides only time controls */
    TIME: 'time'
  };

  // Used to determine if the client is on a mobile device
  var IS_MOBILE_DEVICE = navigator.userAgent.match(/iPhone|iPad|iPod|Android/i) !== null;

  var NATIVE_FORMATS = {
    date: 'YYYY-MM-DD',
    datetime: 'YYYY-MM-DD[T]HH:mmZ',
    time: 'HH:mm'
  };

  Coral.register( /** @lends Coral.Datepicker# */ {
    /**
      @class Coral.Datepicker
      @classdesc A Datepicker component.
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-datepicker
    */
    name: 'Datepicker',
    tagName: 'coral-datepicker',
    className: CLASSNAME,

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'click coral-calendar [handle="table"] a': '_onCalendarDayClick',
      'change coral-calendar,coral-clock': '_onChange',

      'coral-overlay:beforeopen [handle="popover"]': '_onPopoverBeforeOpen',
      'coral-overlay:open [handle="popover"]': '_onPopoverOpenOrClose',
      'coral-overlay:close [handle="popover"]': '_onPopoverOpenOrClose',

      'key:esc coral-clock input[is=coral-textfield]': '_onEscapeKey',
      'key:alt+down [handle="input"],[handle="toggle"]': '_onAltDownKey',
      'key:down [handle="toggle"]': '_onAltDownKey'
    },

    properties: {

      /**
        The type of datepicker to show to the user.

        See {@link Coral.Datepicker.type}

        @type {Coral.Datepicker.type}
        @default Coral.Datepicker.type.DATE
        @htmlattribute type
        @htmlattributereflected
        @memberof Coral.Datepicker#
      */
      'type': {
        default: type.DATE,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(type)
        ],
        sync: function() {
          var isTime = this.type === type.TIME;
          var isDate = this.type === type.DATE;

          this._elements.toggle.icon = isTime ? 'clock' : 'calendar';

          var toggleLabel = isTime ? Coral.i18n.get('Time') : Coral.i18n.get('Calendar');
          this._elements.toggle.setAttribute('aria-label', toggleLabel);
          this._elements.toggle.setAttribute('title', toggleLabel);

          this._elements.clockContainer.style.display = !isDate ? '' : 'none';
          this._elements.clockContainer.setAttribute('aria-hidden', isDate);

          this._elements.calendar.style.display = isTime ? 'none' : '';
          this._elements.calendar.setAttribute('aria-hidden', isTime);
        },
        alsoSync: ['_useNativeInput']
      },

      /**
        The format used to display the selected date(time) to the user. If the user manually types a date, this format
        will be used to parse the value. When using this component on a mobile device, the display format must follow
        the format used by the native input. The default value depends on the <code>type</code>, which can be one from
        <code>YYYY-MM-DD</code>, <code>YYYY-MM-DD[T]HH:mmZ</code> or <code>HH:mm</code>. If an empty string is provided,
        then the default value per type will be used. See http://momentjs.com/docs/#/displaying/ for valid format string
        options.

        @type {String}
        @default "YYYY-MM-DD"
        @htmlattribute displayformat
        @memberof Coral.Datepicker#
      */
      'displayFormat': {
        attribute: 'displayformat',
        transform: function(value) {
          value = Coral.transform.string(value).trim();
          return value === '' ? NATIVE_FORMATS[this.type] : value;
        },
        get: function() {
          // we ignore _useNativeInput when the type is datetime because it is not supported by mobile libraries
          return this._useNativeInput && this.type !== type.DATETIME ?
            NATIVE_FORMATS[this.type] :
            (typeof this._displayFormat === 'undefined' ? NATIVE_FORMATS[this.type] : this._displayFormat);
        },
        set: function(value) {
          this._displayFormat = value;
          this._elements.clock.displayFormat = value;
        },
        sync: function() {
          this._elements.input.value = this._getValueAsString(this._value, this.displayFormat);
        }
      },

      /**
        The format to use on expressing the selected date as a string on the <code>value</code> attribute. The value
        will be sent to the server using this format. If an empty string is provided, then the default value per type
        will be used. See http://momentjs.com/docs/#/displaying/ for valid format string options.

        @type {String}
        @default "YYYY-MM-DD"
        @htmlattribute valueformat
        @memberof Coral.Datepicker#
      */
      'valueFormat': {
        attribute: 'valueformat',
        transform: function(value) {
          value = Coral.transform.string(value).trim();
          return value === '' ? NATIVE_FORMATS[this.type] : value;
        },
        get: function() {
          return typeof this._valueFormat === 'undefined' ? NATIVE_FORMATS[this.type] : this._valueFormat;
        },
        set: function(value) {
          this._valueFormat = value;
          this._elements.calendar.valueFormat = value;
          this._elements.hiddenInput.value = this.value;
        }
      },

      /**
        The value of the element, interpreted as a date, or <code>null</code> if conversion is not possible.

        @type {?Date}
        @default null
        @memberof Coral.Datepicker#
      */
      'valueAsDate': {
        attribute: null,
        transform: function(value) {
          return (value instanceof Date) ? moment(value) : '';
        },
        get: function() {

          var value = this._value;

          // If type is DATE, then you strip out the time
          if (this.type === 'date' && value) {
            value = value.startOf('day');
          }

          return value ? value.toDate() : null;
        },
        set: function(value) {
          this.value = value;
        }
      },

      /**
        The minimum date that the Datepicker will accept as valid. It must not be greated that its maximum. It accepts
        both date and string values. When a string is provided, it should match the
        {@link Coral.Datepicker#valueFormat}.

        See {@link Coral.Calendar#min}

        @type {?String|?Date}
        @default null
        @htmlattribute min
        @memberof Coral.Datepicker#
      */
      'min': {
        get: function() {
          return this._elements.calendar.min;
        },
        set: function(value) {
          this._elements.calendar.min = value;
        }
      },

      /**
        The maximum date that the Datepicker will accept as valid. It must not be less than its minimum. It accepts both
        date and string values. When a string is provided, it should match the {@link Coral.Datepicker#valueFormat}.

        See {@link Coral.Calendar#max}

        @type {String|?Date}
        @default null
        @htmlattribute max
        @memberof Coral.Datepicker#
      */
      'max': {
        get: function() {
          return this._elements.calendar.max;
        },
        set: function(value) {
          this._elements.calendar.max = value;
        }
      },

      /**
        The format used to display the current month and year. See http://momentjs.com/docs/#/displaying/ for valid
        format string options.

        See {@link Coral.Calendar#startDay}

        @type {String}
        @default "MMMM YYYY"
        @htmlattribute headerformat
        @memberof Coral.Datepicker#
      */
      'headerFormat': Coral.property.proxyAttr({
        handle: 'calendar',
        attribute: 'headerformat'
      }),

      /**
        Defines the start day for the week, 0 = Sunday, 1 = Monday etc., as depicted on the calendar days grid.

        See {@link Coral.Calendar#startDay}

        @type {Number}
        @default 0
        @htmlattribute startday
        @memberof Coral.Datepicker#
      */
      'startDay': Coral.property.proxyAttr({
        handle: 'calendar',
        attribute: 'startday'
      }),

      /**
        The current value. When set to "today", the value is coerced into the client's local date expressed as string
        formatted in accordance to the set <code>valueFormat</code>.

        See {@link Coral.Calendar#value}

        @type {String}
        @default ""
        @fires Coral.mixin.formField#change
        @htmlattribute value
        @memberof Coral.Datepicker#
      */
      'value': {
        transform: function(value) {
          return toMoment(value, this.valueFormat);
        },
        get: function() {
          return this._getValueAsString(this._value, this.valueFormat);
        },
        set: function(value) {
          this._value = value;

          this._elements.calendar.valueAsDate = this.valueAsDate;
          this._elements.clock.valueAsDate = this.valueAsDate;
          this._elements.input.value = this._getValueAsString(this._value, this.displayFormat);
          this._elements.hiddenInput.value = this.value;
        }
      },

      // JSDocs inherited
      'name': {
        get: function(value) {
          return this._elements.hiddenInput.name;
        },
        set: function(value) {
          this._elements.hiddenInput.name = value;
        }
      },

      // JSDocs inherited
      'disabled': {
        set: function(value) {
          this._disabled = value;
          this.classList.toggle('is-disabled', this.disabled);

          this._elements.input.disabled = this.disabled;
          this._elements.hiddenInput.disabled = this.disabled;
          this._elements.toggle.disabled = this.disabled || this.readOnly;
        }
      },

      // JSDocs inherited
      'invalid': {
        sync: function() {
          var invalid = this.invalid;

          this.classList.toggle('is-invalid', invalid);
          this._elements.input.invalid = invalid;
          this._elements.input.setAttribute('aria-invalid', invalid);
        }
      },

      // JSDoc inherited
      'readOnly': {
        set: function(value) {
          this._readOnly = value;
          
          this._elements.input.readOnly = this.readOnly;
          this._elements.toggle.disabled = this.readOnly || this.disabled;
        }
      },

      // JSDocs inherited
      'required': {
        set: function(value) {
          this._required = value;
          
          this._elements.input.required = this.required;
        }
      },

      // JSDoc inherited
      'labelledBy': {
        sync: function() {
          // in case the user focuses the buttons, he will still get a notion of the usage of the component
          if (this.labelledBy) {
            this.setAttribute('aria-labelledby', this.labelledBy);
          }
          else {
            this.removeAttribute('aria-labelledby');
          }
        }
      },

      /**
        Short hint that describes the expected value of the Datepicker. It is displayed when the Datepicker is empty.

        @type {String}
        @default ""
        @htmlattribute placeholder
        @htmlattributereflected
        @memberof Coral.Datepicker#
      */
      'placeholder': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        get: function() {
          return this._elements.input.placeholder;
        },
        set: function(value) {
          this._elements.input.placeholder = value;
        }
      },
      /**
       The datepicker's variant.

       @type {Coral.Datepicker.variant}
       @default Coral.Datepicker.variant.DEFAULT
       @htmlattribute variant
       @memberof Coral.Datepicker#
       */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        set: function(value) {
          this._variant = value;

          // passes down the variant to the underlying components
          // we have to do this because default of button is not 'default', but 'secondary'
          this._elements.toggle.variant = value === variant.DEFAULT ?
            Coral.Button.variant.DEFAULT : Coral.Button.variant.QUIET;
          this._elements.input.variant = value;
        },
        sync: function() {
          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);

          if (this.variant !== Coral.Datepicker.variant.DEFAULT) {
            this.classList.add(this._className + '--' + this.variant);
          }
        }
      },
      /**
        When <code>true</code> the component will default to the native input for the date selection. When
        {@link Coral.Datepicker.type.DATETIME} has been set, it will still use the Coral way because mobile browsers
        cannot handle a datetime input.

        @ignore
      */
      '_useNativeInput': {
        attribute: null,
        sync: function() {
          // we ignore _useNativeInput when the type is datetime because it is not supported by mobile libraries
          if (this._useNativeInput && this.type !== type.DATETIME) {
            // Switch to native date/time picker:
            this._elements.toggle.hidden = true;
            this._elements.input.setAttribute('type', this.type);

            // Remove pop-over, and related attributes:
            // @todo: This currently breaks Coral.Select:
            //this.removeChild(this._elements.popover);
            this.removeAttribute('aria-haspopup');
            this.removeAttribute('aria-expanded');
            this.removeAttribute('aria-owns');
          }
          else {
            // Switch to CoralUI Calendar picker:
            this._elements.toggle.hidden = false;
            this._elements.input.setAttribute('type', 'text');

            // Attach pop-over, and related attributes:
            if (this._elements.popover.parentNode !== this) {
              this.insertBefore(this._elements.popover, this.firstChild);
            }

            this.setAttribute('aria-haspopup', 'true');
            this.setAttribute('aria-expanded', 'false');
            this.setAttribute('aria-owns', this._elements.popover.id);
          }
        }
      }
    },

    /**
      Sets the correct labellable target.

      @protected
    */
    _getLabellableElement: function() {
      return this._elements.input;
    },

    /** @ignore */
    _render: function() {
      // Cleanup template elements (supporting cloneNode)
      var templateElements = this.querySelectorAll('[handle]');
      for (var i = 0; i < templateElements.length; ++i) {
        var currentElement = templateElements[i];
        if (currentElement.parentNode === this) {
          this.removeChild(currentElement);
        }
      }

      // creates the inner components
      this.appendChild(Coral.templates.Datepicker.base.call(this._elements));

      // creates and stores the contents of the popover
      this._calendarFragment = Coral.templates.Datepicker.popovercontent.call(this._elements);

      // Point at the button from the bottom
      this._elements.popover.target = this._elements.toggle;
    },

    /** @ignore */
    _renderCalendar: function() {
      if (this._elements.popover.content.innerHTML === '') {
        this._elements.popover.content.appendChild(this._calendarFragment);
        this._calendarFragment = undefined;
      }
    },

    /** @ignore */
    _initialize: function() {
      // we only have AUTO mode.
      this._useNativeInput = IS_MOBILE_DEVICE;
      this.setAttribute('role', 'datepicker');
    },

    /** @ignore */
    _onPopoverBeforeOpen: function(event) {
      this._elements.calendar._validateCalendar();
      this._renderCalendar();
    },

    /**
      Matches the accessibility to the state of the popover.

      @ignore
    */
    _onPopoverOpenOrClose: function(event) {
      var self = this;

      this.setAttribute('aria-expanded', this._elements.popover.open);

      // set focus to calendar grid
      if (this._elements.popover.open) {
        Coral.commons.nextFrame(function() {
          if (self.type === type.TIME) {
            self._elements.clock.focus();
          }
          else {
            self._elements.calendar.focus();
          }
        });
      }
    },

    /** @ignore */
    _onCalendarDayClick: function() {
      // since a selection has been made, we close the popover. we cannot use the _onChange listener to handle this
      // because clicking on the same button will not trigger a change event
      this._elements.popover.open = false;
    },

    /** @ignore */
    _onInputChange: function(event) {
      // because we are reimplementing the form field mix in, we will have to stop the propagation and trigger the
      // 'change' event from here
      event.stopPropagation();

      this.value = moment(event.target.value, this.displayFormat);
      this._validateValue();

      this.trigger('change');
    },

    /** @ignore */
    _onChange: function(event) {
      event.stopPropagation();

      // we create the new value using both calendar and clock controls
      // datepicker should set the current time as default when no time is set, but a date was chosen (if in datetime
      // mode)
      this.value = this._mergeCalendarAndClockDates(true);
      this._validateValue();

      this.trigger('change');
    },

    /** @ignore */
    _onEscapeKey: function(event) {
      this._elements.popover.open = false;
    },

    /** @private */
    _onAltDownKey: function(event) {
      // Stop any consequences of pressing the key
      event.preventDefault();

      if (!this._elements.popover.open) {
        this._elements.popover.open = true;
      }
    },

    /** @ignore */
    _validateValue: function() {
      // calendar validates only on user input, we have to manually force the validation
      this._elements.calendar._validateCalendar();

      // check if the current value is valid and update the internal state of the component
      if (this.type === type.DATE) {
        this.invalid = this._elements.calendar.invalid;
      }
      else if (this.type === type.TIME) {
        this.invalid = this._elements.clock.invalid;
      }
      else {
        this.invalid = this._elements.calendar.invalid || this._elements.clock.invalid;
      }
    },

    /** @ignore */
    _mergeCalendarAndClockDates: function(autoSetTimeIfNeeded) {
      var value = moment(this._elements.calendar.valueAsDate);
      var time = this._elements.clock.valueAsDate;

      if (autoSetTimeIfNeeded && value && !time && this.type === type.DATETIME) {
        // datepicker should set the current time as default when no time is set, but a date was chosen (if in datetime
        // mode)
        time = moment().toDate();
      }

      if (time) {
        if (!value.isValid()) {
          value = moment();
        }

        value.hours(time.getHours());
        value.minutes(time.getMinutes());
      }

      return value;
    },

    /**
      Helper class that converts the internal moment value into a String using the provided date format. If the value is
      invalid, empty string will be returned.

      @param {?Moment} value
        The value representing the date. It has to be a moment object or <code>null</code>
      @param {String} format
        The Date format to be used.

      @ignore
    */
    _getValueAsString: function(value, format) {
      return value && value.isValid() ? value.format(format) : '';
    }
  });

  // export the variant enumeration
  Coral.Datepicker.variant = variant;
  // Expose enums globally
  Coral.Datepicker.type = type;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Drawer"] = window["Coral"]["templates"]["Drawer"] || {};
window["Coral"]["templates"]["Drawer"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["slider"] = document.createElement("div");
  el0.setAttribute("handle", "slider");
  el0.className += " coral3-Drawer-slider";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["contentWrapper"] = document.createElement("div");
  el2.setAttribute("handle", "contentWrapper");
  el2.className += " coral3-Drawer-content";
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  frag.appendChild(el0);
  var el4 = document.createTextNode("\n");
  frag.appendChild(el4);
  var el5 = document.createElement("div");
  el5.className += " coral3-Drawer-toggle";
  var el6 = document.createTextNode("\n  ");
  el5.appendChild(el6);
  var el7 = this["toggle"] = document.createElement("button","coral-button");
  el7.className += " coral3-Drawer-toggleButton";
  el7.setAttribute("type", "button");
  el7.setAttribute("handle", "toggle");
  el7.setAttribute("is", "coral-button");
  el7.setAttribute("variant", "minimal");
  el7.setAttribute("icon", "chevronDown");
  el7.setAttribute("iconSize", "XS");
  el7.setAttribute("aria-label", "coral-drawer");
  el5.appendChild(el7);
  var el8 = document.createTextNode("\n");
  el5.appendChild(el8);
  frag.appendChild(el5);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Drawer directions.

    @enum {String}
    @memberof Coral.Drawer
  */
  var direction = {
    /** A drawer with a toggle button on the bottom. */
    DOWN: 'down',
    /** A drawer with a toggle button on top. */
    UP: 'up'
  };

  // The drawer's base classname
  var CLASSNAME = 'coral3-Drawer';

  // A string of all possible direction classnames
  var ALL_DIRECTION_CLASSES = [];
  for (var directionValue in direction) {
    ALL_DIRECTION_CLASSES.push(CLASSNAME + '--' + direction[directionValue]);
  }

  Coral.register( /** @lends Coral.Drawer# */ {

    /**
      @class Coral.Drawer
      @classdesc A Drawer component
      @extends Coral.Component
      @htmltag coral-drawer
    */
    name: 'Drawer',
    tagName: 'coral-drawer',
    className: CLASSNAME,

    events: {
      'click .coral3-Drawer-toggleButton:not(:disabled)': '_onClick'
    },

    properties: {
      /**
        Whether this item is disabled or not. This will stop every user interaction with the item.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.Drawer#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.setAttribute('aria-disabled', this.disabled);
          this.classList.toggle('is-disabled', this.disabled);
          this._elements.toggle.disabled = this.disabled;
        }
      },

      /**
        The drawer's content element.

        @type {HTMLElement}
        @htmlttribute content
        @contentzone
        @memberof Coral.Drawer#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-drawer-content',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.contentWrapper.appendChild(content);
        }
      }),
  
      /**
        The drawer's direction.
        
        @type {Coral.Drawer.direction}
        @default Coral.Drawer.direction.DOWN
        @htmlattribute direction
        @memberof Coral.Drawer#
      */
      'direction': {
        default: direction.DOWN,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(direction)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_DIRECTION_CLASSES);
          this.classList.add(this._className + '--' + this.direction);
      
          this._updateIcon();
        }
      },

      /**
        Whether the Drawer is expanded or not.

        @type {Boolean}
        @default false
        @htmlattribute open
        @htmlattributereflected
        @memberof Coral.Drawer#
      */
      'open': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          var self = this;
          self.setAttribute('aria-expanded', self.open);
          self._updateIcon();
          
          var slider = self._elements.slider;
          // Don't animate on initialization
          if (self._animate) {
            Coral.commons.transitionEnd(slider, function() {
              // Remove height as we want the drawer to naturally grow if content is added later
              if (self.open) {
                slider.style.height = '';
              }

              // Trigger once transition is finished
              self.trigger('coral-drawer:' + (self.open ? 'open' : 'close'));
            });
            
            if (!self.open) {
              // Force height to enable transition
              slider.style.height = slider.scrollHeight + 'px';
            }
  
            // Do transition in next frame as browser might batch up the height property change before painting
            Coral.commons.nextFrame(function() {
              slider.style.height = self.open ? slider.scrollHeight + 'px' : 0;
            });
          }
          else {
            // Make sure it's animated next time
            self._animate = true;
            
            // Hide it on initialization if closed
            if (!self.open) {
              slider.style.height = 0;
            }
          }
        }
      }
    },

    /** @private */
    _onClick: function() {
      this.open = !this.open;
    },

    /** @private */
    _updateIcon: function() {
      if (this.direction === direction.UP) {
        this._elements.toggle.icon = this.open ? 'chevronDown' : 'chevronUp';
      }
      else if (this.direction === direction.DOWN) {
        this._elements.toggle.icon = this.open ? 'chevronUp' : 'chevronDown';
      }
    },

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var fragment = document.createDocumentFragment();

      // Render the template
      fragment.appendChild(Coral.templates.Drawer.base.call(this._elements));

      // Fetch or create the content content zone element
      var content = this.querySelector('coral-drawer-content') || document.createElement('coral-drawer-content');

      // Add the content zone to the frag
      this.content = content;

      // Move any remaining elements into the content sub-component
      while (this.firstChild) {
        content.appendChild(this.firstChild);
      }

      // Add the frag to the component
      this.appendChild(fragment);
    }

    /**
      Triggered when the drawer is opened

      @event Coral.Drawer#coral-drawer:open

      @param {Object} event
        Event object
    */

    /**
      Triggered when the drawer is closed

      @event Coral.Drawer#coral-drawer:close

      @param {Object} event
        Event object
    */
  });

  Coral.register( /** @lends Coral.Drawer.Content */ {
    /**
     @class Coral.Drawer.Content
     @classdesc A Drawer Content component
     @extends Coral.Component
     @htmltag coral-drawer-content
     */
    name: 'Drawer.Content',
    tagName: 'coral-drawer-content'
  });

  // exports the direction enumeration
  Coral.Drawer.direction = direction;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["FileUpload"] = window["Coral"]["templates"]["FileUpload"] || {};
window["Coral"]["templates"]["FileUpload"]["base"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["input"] = document.createElement("input");
  el0.setAttribute("handle", "input");
  el0.className += " coral3-FileUpload-input is-unselectable";
  el0.setAttribute("tabindex", "-1");
  el0.setAttribute("name", "");
  el0.setAttribute("type", "file");
  el0.setAttribute("accept", "");
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var XHR_EVENT_NAMES = ['loadstart', 'progress', 'load', 'error', 'loadend', 'readystatechange', 'abort', 'timeout'];

  /**
    Enumeration representing HTTP methods that can be used to upload files.

    @memberof Coral.FileUpload
    @enum {String}
  */
  var method = {
    /** Send a POST request. Used when creating a resource. */
    'POST': 'POST',
    /** Send a PUT request. Used when replacing a resource. */
    'PUT': 'PUT',
    /** Send a PATCH request. Used when partially updating a resource. */
    'PATCH': 'PATCH'
  };

  // Validator/transform is used in the property and internally
  var isValidMethod = Coral.validate.enumeration(method);
  var transformMethod = function(value) {
    return typeof value === 'string' ? value.toUpperCase() : value;
  };

  Coral.register( /** @lends Coral.FileUpload# */ {

    /**
      @class Coral.FileUpload
      @classdesc A FileUpload component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-fileupload
    */
    name: 'FileUpload',
    tagName: 'coral-fileupload',
    className: 'coral3-FileUpload',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      // Clickable hooks
      'click [coral-fileupload-submit]': '_onSubmitButtonClick',
      'click [coral-fileupload-clear]': 'clear',
      'click [coral-fileupload-select]': '_showFileDialog',
      'click [coral-fileupload-abort]': 'abort',
      'click [coral-fileupload-abortfile]': '_onAbortFileClick',
      'click [coral-fileupload-removefile]': '_onRemoveFileClick',
      'click [coral-fileupload-uploadfile]': '_onUploadFileClick',

      // Drag & Drop zones
      'dragenter [coral-fileupload-dropzone]': '_onDragAndDrop',
      'dragover [coral-fileupload-dropzone]': '_onDragAndDrop',
      'dragleave [handle="input"]': '_onDragAndDrop',
      'drop [handle="input"]': '_onDragAndDrop',

      // Accessibility
      'capture:focus [coral-fileupload-select]': '_onButtonFocusIn',
      'capture:focus [handle="input"]': '_onInputFocusIn',
      'capture:blur [handle="input"]': '_onInputFocusOut'
    },

    properties: {
      // JSDoc inherited
      'disabled': {
        set: function(value) {
          this._disabled = value;
          this._elements.input.disabled = this.disabled;
        },
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);

          this._setElementState();
        }
      },

      // JSDoc inherited
      'invalid': {
        set: function(value) {
          this._invalid = value;
          this._elements.input.setAttribute('aria-invalid', this.invalid);
        },
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);

          this._setElementState();
        }
      },

      // JSDoc inherited
      'readOnly': {
        set: function(value) {
          this._readOnly = value;
          this._elements.input.disabled = this.readOnly;
        },
        sync: function() {
          this.classList.toggle('is-readOnly', this.readOnly);

          this._setElementState();
        }
      },

      // JSDoc inherited
      'required': {
        set: function(value) {
          this._elements.input.required = value;
        },
        get: function() {
          return this._elements.input.required;
        },
        sync: function() {
          this.classList.toggle('is-required', this.required);

          this._setElementState();
        }
      },

      // JSDoc inherited
      'value': {
        set: function(value) {
          if (value === '' || value === null) {
            this._clearQueue();
            this._clearFileInputValue();
          }
          else {
            // Throws dom exception if value is different than an empty string or null
            throw new Error('Coral.FileUpload accepts a filename, which may only be programmatically set to the' +
              ' empty string.');
          }
        },
        get: function() {
          var item = (this._uploadQueue) ? this._getQueueItem(0) : null;

          // The first selected filename, or the empty string if no files are selected.
          return (item) ? 'C:\\fakepath\\' + item.file.name : '';
        }
      },

      /**
        The names of the currently selected files.
        When {@link Coral.FileUpload#multiple} is <code>false</code>, this will be an array of length 1.

        @type {Array.<String>}
        @memberof Coral.FileUpload#
      */
      'values': {
        validate: [
          Coral.validate.valueMustChange,
          function(values) {
            return Array.isArray(values);
          }
        ],
        set: function(values) {
          if (values.length) {
            this.value = values[0];
          }
          else {
            this.value = '';
          }
        },
        get: function() {
          var values = this._uploadQueue.map(function(item) {
            return 'C:\\fakepath\\' + item.file.name;
          });

          if (values.length && !this.multiple) {
            values = [values[0]];
          }

          return values;
        }
      },

      // JSDoc inherited
      labelledBy: {
        sync: function() {
          // The specified labelledBy property.
          var labelledBy = this.labelledBy;

          // An array of element ids to label control, the last being the select button element id.
          var ids = [];

          var button = this.querySelector('[coral-fileupload-select]');

          if (button) {
            ids.push(button.id);
          }

          // If a labelledBy property exists,
          if (labelledBy) {
            // prepend the labelledBy value to the ids array
            ids.unshift(labelledBy);
          }

          // Set aria-labelledby attribute on the labellable element joining ids array into space-delimited list of ids.
          this._elements.input.setAttribute('aria-labelledby', ids.join(' '));
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      /**
        Array of additional parameters as key:value to send in addition of files.
        A parameter must contain a <code>name</code> key:value and optionally a <code>value</code> key:value.

        @type {Array.<Object>}
        @default []
        @memberof Coral.FileUpload#
      */
      'parameters': {
        default: function() {
          return [];
        },
        attribute: null,
        validate: [
          Coral.validate.valueMustChange,
          function(newValue, oldValue) {
            // Verify that every item has a name
            return Array.isArray(newValue) && newValue.every(function(el) {
                return el && el.name;
              });
          }
        ],
        sync: function() {
          if (!this.async) {
            Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function(input) {
              input.parentNode.removeChild(input);
            });

            // Add extra parameters
            this.parameters.forEach(function(param) {
              var input = document.createElement('input');
              input.type = 'hidden';
              input.name = param.name;
              input.value = param.value;
              
              this.appendChild(input);
            }.bind(this));
          }
        }
      },

      /**
        Whether files should be uploaded asynchronously via XHR or synchronously e.g. within a
        <code>&lt;form&gt;</code> tag. One option excludes the other. Setting a new <code>async</code> value removes all
        files from the queue.

        @type {Boolean}
        @default false
        @htmlattributereflected
        @memberof Coral.FileUpload#
      */
      'async': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          this._async = value;

          // Sync extra parameters in case of form submission
          if (!this._async) {
            this._syncProp('parameters');
          }

          // Clear file selection
          if (this._uploadQueue) {
            this._clearQueue();
            this._clearFileInputValue();
          }
        }
      },

      /**
        The URL where the upload request should be sent. When used within a <code>&lt;form&gt;</code> tag to upload
        synchronously, the action of the form is used. If an element is clicked that has a
        <code>[coral-fileupload-submit]</code> attribute as well as a <code>[formaction]</code> attribute, the action of
        the clicked element will be used. Set this property before calling {@link Coral.FileUpload#upload} to reset the
        action set by a click.

        @type {String}
        @default ""
        @htmlattribute action
        @memberof Coral.FileUpload#
      */
      'action': {
        default: '',
        attribute: 'action',
        transform: Coral.transform.string,
        attributeTransform: Coral.transform.string,
        set: function(action) {
          this._action = action;

          // Reset button action as action was set explcitly
          this._buttonAction = null;
        }
      },

      /**
        The HTTP method to use when uploading files asynchronously. When used within a <code>&lt;form&gt;</code> tag to
        upload synchronously, the method of the form is used. If an element is clicked that has a
        <code>[coral-fileupload-submit]</code> attribute as well as a <code>[formmethod]</code> attribute, the method of
        the clicked element will be used. Set this property before calling {@link Coral.FileUpload#upload} to reset the
        method set by a click.

        @type {Coral.FileUpload.method}
        @default Coral.FileUpload.method.POST
        @htmlattribute method
        @memberof Coral.FileUpload#
      */
      'method': {
        default: method.POST,
        transform: transformMethod,
        validate: [
          Coral.validate.valueMustChange,
          isValidMethod
        ],
        set: function(value) {
          this._method = value;

          // Reset button method as method was set explcitly
          this._buttonMethod = null;
        }
      },

      /**
        Whether more than one file can be chosen at the same time to upload.

        @type {Boolean}
        @default false
        @htmlattribute multiple
        @htmlattributereflected
        @memberof Coral.FileUpload#
      */
      'multiple': Coral.property.proxy({
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        path: '_elements.input.multiple'
      }),

      /**
        File size limit in bytes for one file. The value of 0 indicates unlimited, which is also the default.

        @type {Number}
        @htmlattribute sizelimit
        @default 0
        @memberof Coral.FileUpload#
      */
      'sizeLimit': {
        default: 0,
        attribute: 'sizelimit',
        transform: Coral.transform.number,
        attributeTransform: Coral.transform.number
      },

      /**
        MIME types allowed for uploading (proper MIME types, wildcard '*' and file extensions are supported). To specify
        more than one value, separate the values with a comma (e.g.
        <code>&lt;input accept="audio/*,video/*,image/*" /&gt;</code>.

        @type {String}
        @default ""
        @htmlattribute accept
        @htmlattributereflected
        @memberof Coral.FileUpload#
      */
      'accept': Coral.property.proxy({
        reflectAttribute: true,
        path: '_elements.input.accept'
      }),

      /**
        Whether the upload should start immediately after file selection.

        @type {Boolean}
        @default false
        @htmlattribute autostart
        @htmlattributereflected
        @memberof Coral.FileUpload#
      */
      'autoStart': {
        default: false,
        attribute: 'autostart',
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr
      },

      /**
        Files waiting impatiently to be uploaded.

        @readonly
        @default []
        @type {Array.<Object>}
        @memberof Coral.FileUpload#
      */
      'uploadQueue': {
        attribute: null,
        set: function() {}
      }
    },

    /** @private */
    _onButtonFocusIn: function(event) {
      // Get the input
      var input = this._elements.input;

      // Get the button
      var button = event.matchedTarget;

      // Move the input to after the button
      // This lets the next focused item be the correct one according to tab order
      button.parentNode.insertBefore(input, button.nextElementSibling);

      // Make sure the input gets focused on FF
      window.setTimeout(function() {
        input.focus();
      }, 100);
    },

    /** @private */
    _onInputFocusIn: function(event) {
      var button = this.querySelector('[coral-fileupload-select]');
      if (button) {
        // Remove from the tab order so shift+tab works
        button.tabIndex = -1;

        // So shifting focus backwards with screen reader doesn't create a focus trap
        button.setAttribute('aria-hidden', true);

        // Mark the button as focused
        button.classList.add('is-focused');
      }
    },

    /** @private */
    _onInputFocusOut: function(event) {
      // Unmark all the focused buttons
      var button = this.querySelector('[coral-fileupload-select].is-focused');
      button.classList.remove('is-focused');

      // Wait a frame so that shifting focus backwards with screen reader doesn't create a focus trap
      Coral.commons.nextFrame(function() {
        button.tabIndex = 0;
        // @a11y: aria-hidden is removed to prevent focus trap when navigating backwards using a screen reader's
        // virtual cursor
        button.removeAttribute('aria-hidden');
      });
    },

    /** @private */
    _onAbortFileClick: function(event) {
      if (!this.async) {
        throw new Error('Coral.FileUpload does not support aborting file(s) upload on synchronous mode.');
      }

      // Get file to abort
      var fileName = event.target.getAttribute('coral-fileupload-abortfile');
      if (fileName) {
        this._abortFile(fileName);
      }
    },

    /** @private */
    _onRemoveFileClick: function(event) {
      if (!this.async) {
        throw new Error('Coral.FileUpload does not support removing a file from the queue on synchronous mode.');
      }
      else {
        // Get file to remove
        var fileName = event.target.getAttribute('coral-fileupload-removefile');
        if (fileName) {
          this._clearFile(fileName);
        }
      }
    },

    /** @private */
    _onUploadFileClick: function(event) {
      if (!this.async) {
        throw new Error('Coral.FileUpload does not support uploading a file from the queue on synchronous mode.');
      }

      // Get file to upload
      var fileName = event.target.getAttribute('coral-fileupload-uploadfile');
      if (fileName) {
        this.upload(fileName);
      }
    },

    /** @private */
    _onDragAndDrop: function(event) {
      // Set dragging classes
      if (event.type === 'dragenter' || event.type === 'dragover') {
        this._addDragClass();
      }
      else if (event.type === 'dragleave' || event.type === 'drop') {
        this._removeDragClass();
      }

      this.trigger('coral-fileupload:' + event.type);
    },

    _addDragClass: function() {
      clearTimeout(this._removeClassTimeout);
      this._removeClassTimeout = setTimeout(this._doAddDragClass, 10);
    },

    _doAddDragClass: function() {
      this.classList.add('is-dragging');
      
      var dropZone = this.querySelector('[coral-fileupload-dropzone]');
      if (dropZone) {
        dropZone.classList.add('is-dragging');
      }

      // Put the input on top to enable file drop
      this._elements.input.classList.remove('is-unselectable');
    },

    _removeDragClass: function() {
      clearTimeout(this._removeClassTimeout);
      this._removeClassTimeout = setTimeout(this._doRemoveDragClass, 10);
    },

    _doRemoveDragClass: function() {
      this.classList.remove('is-dragging');
  
      var dropZone = this.querySelector('[coral-fileupload-dropzone]');
      if (dropZone) {
        dropZone.classList.remove('is-dragging');
      }

      // Disable user interaction with the input
      this._elements.input.classList.add('is-unselectable');
    },

    /**
      Handles clicks to submit buttons

      @private
    */
    _onSubmitButtonClick: function(event) {
      var target = event.matchedTarget;

      // Override or reset the action/method given the button's configuration
      this._buttonAction = target.getAttribute('formaction') || null;

      // Make sure the method provided by the button is valid
      var buttonMethod = transformMethod(target.getAttribute('formmethod'));
      this._buttonMethod = buttonMethod && isValidMethod(buttonMethod) ? buttonMethod : null;

      // Start the file upload
      this.upload();
    },

    /**
      Handles changes to the input element.

      @private
    */
    _onInputChange: function(event) {
      // Stop the current event
      event.stopPropagation();

      if (this.disabled) {
        return;
      }

      var self = this;
      var files = [];
      var items = [];

      // Retrieve files for select event
      if (event.target.files && event.target.files.length) {
        this._clearQueue();
        files = event.target.files;

        // Verify if multiple file upload is allowed
        if (!this.multiple) {
          files = [files[0]];
        }
      }
      // Retrieve files for drop event
      else if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
        this._clearQueue();
        files = event.dataTransfer.files;

        // Verify if multiple file upload is allowed
        if (!this.multiple) {
          files = [files[0]];
        }
      }
      else {
        return;
      }


      // Initialize items
      for (var i = 0; i < files.length; i++) {
        items.push(new Coral.FileUpload.Item(files[i]));
      }

      // Verify if file is allowed to be uploaded and trigger events accordingly
      items.forEach(function(item) {

        // If file is not found in uploadQueue using filename
        if (!self._getQueueItemByFilename(item.file.name)) {

          // Check file size
          if (self.sizeLimit && item.file.size > self.sizeLimit) {
            self.trigger('coral-fileupload:filesizeexceeded', {
              item: item
            });
          }
          // Check mime type
          else if (self.accept && !item._isMimeTypeAllowed(self.accept)) {
            self.trigger('coral-fileupload:filemimetyperejected', {
              item: item
            });
          }
          else {
            // Add item to queue
            self._uploadQueue.push(item);

            self.trigger('coral-fileupload:fileadded', {
              item: item
            });
          }
        }
      });

      if (this.autoStart) {
        this.upload();
      }

      // Explicitly re-emit the change event
      if (this._triggerChangeEvent) {
        this.trigger('change');
      }

      // Clear file input once files are added to the queue to make sure next file selection will trigger a change event
      if (this.async) {
        this._clearFileInputValue();
      }
    },

    /**
      Sets the disabled/readonly state of elements with the associated special attributes

      @private
    */
    _setElementState: function() {
      Array.prototype.forEach.call(this.querySelectorAll(
        '[coral-fileupload-select],' +
        '[coral-fileupload-dropzone],' +
        '[coral-fileupload-submit],' +
        '[coral-fileupload-clear],' +
        '[coral-fileupload-abort],' +
        '[coral-fileupload-abortfile],' +
        '[coral-fileupload-removefile],' +
        '[coral-fileupload-uploadfile]'
      ), function(item) {
        item.classList.toggle('is-invalid', this.invalid);
        item.classList.toggle('is-disabled', this.disabled);
        item.classList.toggle('is-required', this.required);
        item.classList.toggle('is-readOnly', this.readOnly);
        item[(this.disabled || this.readOnly) ? 'setAttribute' : 'removeAttribute']('disabled', '');
      }.bind(this));
    },

    /** @private */
    _clearQueue: function() {
      this._uploadQueue.slice().forEach(function(item) {
        this._clearFile(item.file.name);
      }.bind(this));
    },

    /**
      Remove a file or all files from the upload queue.

      @param {String} [filename]
        The filename of the file to remove. If a filename is not provided, all files will be removed.
    */
    clear: function(filename) {
      if (!this.async) {
        if (typeof filename === 'string') {
          throw new Error('Coral.FileUpload does not support removing a file from the queue on synchronous mode.');
        }
        this._clearQueue();
        this._clearFileInputValue();
      }
      else {
        if (typeof filename === 'string') {
          this._clearFile(filename);
        }
        else {
          this._clearQueue();
        }
      }
    },

    /**
      Clear file selection on the file input

      @private
    */
    _clearFileInputValue: function() {
      this._elements.input.value = '';
    },

    /**
      Remove a file from the upload queue.

      @param {String} filename
        The filename of the file to remove.

      @private
    */
    _clearFile: function(filename) {
      var item = this._getQueueItemByFilename(filename);
      if (item) {
        // Abort file upload
        this._abortFile(filename);

        // Remove file from queue
        this._uploadQueue.splice(this._getQueueIndex(filename), 1);

        this.trigger('coral-fileupload:fileremoved', {
          item: item
        });
      }
    },

    /**
      Uploads a file in the queue. If an array is provided as the first argument, it is used as the parameters.

      @param filename {String}
        The name of the file to upload.
      @param {Array.<Object>} [parameters]
        The filename of the file to upload.

      @private
    */
    _uploadFile: function(filename) {
      var item = this._getQueueItemByFilename(filename);
      if (item) {
        this._abortFile(filename);
        this._ajaxUpload(item);
      }
    },

    /**
      Uploads the given filename, or all the files into the queue. It accepts extra parameters that are sent with the
      file.

      @param {String} [filename]
        The name of the file to upload.
    */
    upload: function(filename) {
      if (!this.async) {
        if (typeof filename === 'string') {
          throw new Error('Coral.FileUpload does not support uploading a file from the queue on synchronous mode.');
        }

        var form = this.closest('form');
        if (!form) {
          form = document.createElement('form');
          form.method = this.method.toLowerCase();
          form.enctype = 'multipart/form-data';
          form.action = this.action;
          form.hidden = true;
          
          form.appendChild(this._elements.input);

          Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function(input) {
            form.appendChild(input);
          });
          
          // Make sure the form is connected before submission
          this.appendChild(form);
        }

        var input = document.createElement('input');
        input.type = 'hidden';
        input.name = '_charset_';
        input.value = 'utf-8';
        
        form.submit();
      }
      else {
        if (typeof filename === 'string') {
          this._uploadFile(filename);
        }
        else {
          var self = this;
          self._uploadQueue.forEach(function(item) {
            self._abortFile(item.file.name);
            self._ajaxUpload(item);
          });
        }
      }
    },

    /** @private */
    _showFileDialog: function(event) {
      // Show the dialog
      // This ONLY works when the call stack traces back to another click event!
      this._elements.input.click();
    },

    /**
      Abort specific file upload.

      @param {String} filename
        The filename identifies the file to abort.

      @private
    */
    _abortFile: function(filename) {
      var item = this._getQueueItemByFilename(filename);
      if (item && item._xhr) {
        item._xhr.abort();
        item._xhr = null;
      }
    },

    /**
      Abort upload of a given file or all files in the queue.

      @param {String} [filename]
        The filename of the file to abort. If a filename is not provided, all files will be aborted.
    */
    abort: function(filename) {
      if (!this.async) {
        throw new Error('Coral.FileUpload does not support aborting file(s) upload on synchronous mode.');
      }

      if (typeof filename === 'string') {
        // Abort a single file
        this._abortFile(filename);
      }
      else {
        // Abort all files
        var self = this;
        self._uploadQueue.forEach(function(item) {
          self._abortFile(item.file.name);
        });
      }
    },

    /**
      Handles the ajax upload.

      @private
    */
    _ajaxUpload: function(item) {
      var self = this;

      // Use the action/method provided by the last button click, if provided
      var action = this._buttonAction || this.action;
      var requestMethod = this._buttonMethod ? this._buttonMethod.toUpperCase() : this.method;

      // We merge the global parameters with the specific file parameters and send them all together
      var parameters = self.parameters.concat(item.parameters);

      var formData = new FormData();

      parameters.forEach(function(additionalParameter) {
        formData.append(additionalParameter.name, additionalParameter.value);
      });

      formData.append('_charset_', 'utf-8');
      formData.append(this.name, item._originalFile);

      // Store the XHR on the item itself
      item._xhr = new XMLHttpRequest();

      // Opening before being able to set response type to avoid IE11 InvalidStateError
      item._xhr.open(requestMethod, action);

      // Reflect specific xhr properties
      item._xhr.timeout = item.timeout;
      item._xhr.responseType = item.responseType;
      item._xhr.withCredentials = item.withCredentials;

      XHR_EVENT_NAMES.forEach(function(name) {
        // Progress event is the only event among other ProgressEvents that can trigger multiple times.
        // Hence it's the only one that gives away usable progress information.
        var isProgressEvent = (name === 'progress');
        (isProgressEvent ? item._xhr.upload : item._xhr).addEventListener(name, function(event) {
          var detail = {
            item: item,
            action: action,
            method: requestMethod
          };

          if (isProgressEvent) {
            detail.lengthComputable = event.lengthComputable;
            detail.loaded = event.loaded;
            detail.total = event.total;
          }

          self.trigger('coral-fileupload:' + name, detail);
        });
      });

      item._xhr.send(formData);
    },

    /** @private */
    _getLabellableElement: function() {
      return this;
    },

    /** @private */
    _getQueueItemByFilename: function(filename) {
      return this._getQueueItem(this._getQueueIndex(filename));
    },

    /** @private */
    _getQueueItem: function(index) {
      return index > -1 ? this._uploadQueue[index] : null;
    },

    /** @private */
    _getQueueIndex: function(filename) {
      var index = -1;
      this._uploadQueue.some(function(item, i) {
        if (item.file.name === filename) {
          index = i;
          return true;
        }
      });
      return index;
    },

    /** @private */
    _getTargetChangeInput: function() {
      return this._elements.input;
    },

    /** @ignore */
    _positionInputOnDropZone: function() {
      var input = this._elements.input;
      var dropZone = this.querySelector('[coral-fileupload-dropzone]');

      if (dropZone) {
        var size = dropZone.getBoundingClientRect();

        input.style.top = parseInt(dropZone.offsetTop, 10) + 'px';
        input.style.left = parseInt(dropZone.offsetLeft, 10) + 'px';
        input.style.width = parseInt(size.width, 10) + 'px';
        input.style.height = parseInt(size.height, 10) + 'px';
      }
      else {
        input.style.width = '0';
        input.style.height = '0';
      }
    },

    /** @ignore */
    _initialize: function() {
      // @a11y
      this.setAttribute('role', 'group');

      this._uploadQueue = [];

      this._doAddDragClass = this._doAddDragClass.bind(this);
      this._doRemoveDragClass = this._doRemoveDragClass.bind(this);
      this._positionInputOnDropZone = this._positionInputOnDropZone.bind(this);

      // IE11 requires one more frame or the resize listener <object> will appear as an overlaying white box
      Coral.commons.nextFrame(function() {
        Coral.commons.addResizeListener(this, this._positionInputOnDropZone);
      }.bind(this));

      var button = this.querySelector('[coral-fileupload-select]');

      if (button) {
        button.id = button.id || Coral.commons.getUID();
      }

      // If no labelledby is specified, ensure input is at labelledby the select button
      this._queueSync(['labelledBy']);
  
      // Reposition the input under the specified dropzone
      this._observer = new MutationObserver(this._positionInputOnDropZone);
      this._observer.observe(this, {
        childList: true,
        attributes: true,
        attributeFilter: ['coral-fileupload-dropzone'],
        subtree: true
      });
    },

    /** @ignore */
    _render: function() {
      // Fetch additional parameters if any
      var parameters = [];
      Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function(input) {
        parameters.push({
          name: input.name,
          value: input.value
        });
      });
      this.parameters = parameters;

      // Remove the input if it's already there
      // A fresh input is preferred to value = '' as it may not work in all browsers
      var input = this.querySelector('[handle="input"]');
      if (input) {
        input.parentNode.removeChild(input);
      }

      // Remove the object if it's already there
      var object = this.querySelector('object');
      if (object) {
        object.parentNode.removeChild(object);
      }

      // Add the input to the component
      this.appendChild(Coral.templates.FileUpload.base.call(this._elements));
    }

    /**
      Triggered when a file size exceeds the file size limit.

      @event Coral.FileUpload#coral-fileupload:filesizeexceeded

      @param {Object} event
        Event object
      @param {Coral.FileUpload.Item} event.detail.item
        The rejected FileUpload item.
    */

    /**
      Triggered when a file is rejected due to its MIME type. Event should not
      be relied upon as a sufficient security measure - server side validation
      is still necessary from a security perspective.

      @event Coral.FileUpload#coral-fileupload:filemimetyperejected

      @param {Object} event
        Event object
      @param {Coral.FileUpload.Item} event.detail.item
        The rejected FileUpload item.
    */

    /**
      Triggered when a file is added to the queue.

      @event Coral.FileUpload#coral-fileupload:fileadded

      @param {Object} event
        Event object
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered when a file is removed from the queue.

      @event Coral.FileUpload#coral-fileupload:fileremoved

      @param {Object} event
        Event object
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered when the upload has begun.

      @event Coral.FileUpload#coral-fileupload:loadstart

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered when the upload has successfully finished.

      @event Coral.FileUpload#coral-fileupload:load

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered when the upload is stopped.

      @event Coral.FileUpload#coral-fileupload:loadend

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered every time the readyState changes.

      @event Coral.FileUpload#coral-fileupload:readystatechange

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered during upload progress.

      @event Coral.FileUpload#coral-fileupload:progress

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
      @param {Boolean} event.detail.lengthComputable
        Whether the upload progress can be calculated.
      @param {Number} event.detail.loaded
        The upload progress in bytes.
      @param {Number} event.detail.total
        The total upload size in bytes.
    */

    /**
      Triggered when the upload reaches a timeout.

      @event Coral.FileUpload#coral-fileupload:timeout

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered when the upload fails.

      @event Coral.FileUpload#coral-fileupload:error

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered when the upload is terminated.

      @event Coral.FileUpload#coral-fileupload:abort

      @param {Object} event
        Event object
      @param {Object} event.detail.action
        The URL the file is being uploaded to.
      @param {Coral.FileUpload.method} event.detail.method
        HTTP method used to upload.
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */

    /**
      Triggered when a file enters a dropzone.

      @event Coral.FileUpload#coral-fileupload:dragenter

      @param {Object} event
        Event object
    */

    /**
      Triggered when a file is being dragged over a dropzone.

      @event Coral.FileUpload#coral-fileupload:dragover

      @param {Object} event
        Event object
    */

    /**
      Triggered when a file is dragged out of a dropzone.

      @event Coral.FileUpload#coral-fileupload:dragleave

      @param {Object} event
        Event object
    */

    /**
      Triggered when a file is dropped on a dropzone.

      @event Coral.FileUpload#coral-fileupload:drop

      @param {Object} event
        Event object
      @param {Coral.FileUpload.Item} event.detail.item
        FileUpload item.
    */
  });

  // Expose enumerations
  Coral.FileUpload.method = method;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Response types.

    @enum {String}
    @memberof Coral.FileUpload.Item
  */
  var responseType = {
    /** String type. */
    TEXT: 'text',
    /** Array buffer type. */
    ARRAY_BUFFER: 'arraybuffer',
    /** Blob type. */
    BLOB: 'blob',
    /** Document type. */
    DOCUMENT: 'document',
    /** JavaScript object, parsed from a JSON string returned by the server. */
    JSON: 'json'
  };

  var MIME_TYPE_REGEXP = /(.+)\/(.+)$/; // eg text/plain
  var FILE_EXTENSION_REGEXP = /\.(.+)$/; // eg .txt
  var SHORTCUT_REGEXP = /.*/; // eg text
  var MIME_TYPE_AUDIO = 'audio/*';
  var MIME_TYPE_IMAGE = 'image/*';
  var MIME_TYPE_VIDEO = 'video/*';
  var MIME_TYPES = {
    '.123': 'application/vnd.lotus-1-2-3',
    '.3dml': 'text/vnd.in3d.3dml',
    '.3g2': 'video/3gpp2',
    '.3gp': 'video/3gpp',
    '.a': 'application/octet-stream',
    '.aab': 'application/x-authorware-bin',
    '.aac': 'audio/x-aac',
    '.aam': 'application/x-authorware-map',
    '.aas': 'application/x-authorware-seg',
    '.abw': 'application/x-abiword',
    '.acc': 'application/vnd.americandynamics.acc',
    '.ace': 'application/x-ace-compressed',
    '.acu': 'application/vnd.acucobol',
    '.acutc': 'application/vnd.acucorp',
    '.adp': 'audio/adpcm',
    '.aep': 'application/vnd.audiograph',
    '.afm': 'application/x-font-type1',
    '.afp': 'application/vnd.ibm.modcap',
    '.ai': 'application/postscript',
    '.aif': 'audio/x-aiff',
    '.aifc': 'audio/x-aiff',
    '.aiff': 'audio/x-aiff',
    '.air': 'application/vnd.adobe.air-application-installer-package+zip',
    '.ami': 'application/vnd.amiga.ami',
    '.apk': 'application/vnd.android.package-archive',
    '.application': 'application/x-ms-application',
    '.apr': 'application/vnd.lotus-approach',
    '.asc': 'application/pgp-signature',
    '.asf': 'video/x-ms-asf',
    '.asm': 'text/x-asm',
    '.aso': 'application/vnd.accpac.simply.aso',
    '.asx': 'video/x-ms-asf',
    '.atc': 'application/vnd.acucorp',
    '.atom': 'application/atom+xml',
    '.atomcat': 'application/atomcat+xml',
    '.atomsvc': 'application/atomsvc+xml',
    '.atx': 'application/vnd.antix.game-component',
    '.au': 'audio/basic',
    '.avi': 'video/x-msvideo',
    '.aw': 'application/applixware',
    '.azf': 'application/vnd.airzip.filesecure.azf',
    '.azs': 'application/vnd.airzip.filesecure.azs',
    '.azw': 'application/vnd.amazon.ebook',
    '.bat': 'application/x-msdownload',
    '.bcpio': 'application/x-bcpio',
    '.bdf': 'application/x-font-bdf',
    '.bdm': 'application/vnd.syncml.dm+wbxml',
    '.bh2': 'application/vnd.fujitsu.oasysprs',
    '.bin': 'application/octet-stream',
    '.bmi': 'application/vnd.bmi',
    '.bmp': 'image/bmp',
    '.book': 'application/vnd.framemaker',
    '.box': 'application/vnd.previewsystems.box',
    '.boz': 'application/x-bzip2',
    '.bpk': 'application/octet-stream',
    '.btif': 'image/prs.btif',
    '.bz': 'application/x-bzip',
    '.bz2': 'application/x-bzip2',
    '.c': 'text/x-c',
    '.c4d': 'application/vnd.clonk.c4group',
    '.c4f': 'application/vnd.clonk.c4group',
    '.c4g': 'application/vnd.clonk.c4group',
    '.c4p': 'application/vnd.clonk.c4group',
    '.c4u': 'application/vnd.clonk.c4group',
    '.cab': 'application/vnd.ms-cab-compressed',
    '.car': 'application/vnd.curl.car',
    '.cat': 'application/vnd.ms-pki.seccat',
    '.cc': 'text/x-c',
    '.cct': 'application/x-director',
    '.ccxml': 'application/ccxml+xml',
    '.cdbcmsg': 'application/vnd.contact.cmsg',
    '.cdf': 'application/x-netcdf',
    '.cdkey': 'application/vnd.mediastation.cdkey',
    '.cdx': 'chemical/x-cdx',
    '.cdxml': 'application/vnd.chemdraw+xml',
    '.cdy': 'application/vnd.cinderella',
    '.cer': 'application/pkix-cert',
    '.cgm': 'image/cgm',
    '.chat': 'application/x-chat',
    '.chm': 'application/vnd.ms-htmlhelp',
    '.chrt': 'application/vnd.kde.kchart',
    '.cif': 'chemical/x-cif',
    '.cii': 'application/vnd.anser-web-certificate-issue-initiation',
    '.cil': 'application/vnd.ms-artgalry',
    '.cla': 'application/vnd.claymore',
    '.class': 'application/java-vm',
    '.clkk': 'application/vnd.crick.clicker.keyboard',
    '.clkp': 'application/vnd.crick.clicker.palette',
    '.clkt': 'application/vnd.crick.clicker.template',
    '.clkw': 'application/vnd.crick.clicker.wordbank',
    '.clkx': 'application/vnd.crick.clicker',
    '.clp': 'application/x-msclip',
    '.cmc': 'application/vnd.cosmocaller',
    '.cmdf': 'chemical/x-cmdf',
    '.cml': 'chemical/x-cml',
    '.cmp': 'application/vnd.yellowriver-custom-menu',
    '.cmx': 'image/x-cmx',
    '.cod': 'application/vnd.rim.cod',
    '.com': 'application/x-msdownload',
    '.conf': 'text/plain',
    '.cpio': 'application/x-cpio',
    '.cpp': 'text/x-c',
    '.cpt': 'application/mac-compactpro',
    '.crd': 'application/x-mscardfile',
    '.crl': 'application/pkix-crl',
    '.crt': 'application/x-x509-ca-cert',
    '.csh': 'application/x-csh',
    '.csml': 'chemical/x-csml',
    '.csp': 'application/vnd.commonspace',
    '.css': 'text/css',
    '.cst': 'application/x-director',
    '.csv': ['text/csv', 'application/vnd.ms-excel'],
    '.cu': 'application/cu-seeme',
    '.curl': 'text/vnd.curl',
    '.cww': 'application/prs.cww',
    '.cxt': 'application/x-director',
    '.cxx': 'text/x-c',
    '.daf': 'application/vnd.mobius.daf',
    '.dataless': 'application/vnd.fdsn.seed',
    '.davmount': 'application/davmount+xml',
    '.dcr': 'application/x-director',
    '.dcurl': 'text/vnd.curl.dcurl',
    '.dd2': 'application/vnd.oma.dd2+xml',
    '.ddd': 'application/vnd.fujixerox.ddd',
    '.deb': 'application/x-debian-package',
    '.def': 'text/plain',
    '.deploy': 'application/octet-stream',
    '.der': 'application/x-x509-ca-cert',
    '.dfac': 'application/vnd.dreamfactory',
    '.dic': 'text/x-c',
    '.diff': 'text/plain',
    '.dir': 'application/x-director',
    '.dis': 'application/vnd.mobius.dis',
    '.dist': 'application/octet-stream',
    '.distz': 'application/octet-stream',
    '.djv': 'image/vnd.djvu',
    '.djvu': 'image/vnd.djvu',
    '.dll': 'application/x-msdownload',
    '.dmg': 'application/octet-stream',
    '.dms': 'application/octet-stream',
    '.dna': 'application/vnd.dna',
    '.doc': 'application/msword',
    '.docm': 'application/vnd.ms-word.document.macroenabled.12',
    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    '.dot': 'application/msword',
    '.dotm': 'application/vnd.ms-word.template.macroenabled.12',
    '.dotx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
    '.dp': 'application/vnd.osgi.dp',
    '.dpg': 'application/vnd.dpgraph',
    '.dsc': 'text/prs.lines.tag',
    '.dtb': 'application/x-dtbook+xml',
    '.dtd': 'application/xml-dtd',
    '.dts': 'audio/vnd.dts',
    '.dtshd': 'audio/vnd.dts.hd',
    '.dump': 'application/octet-stream',
    '.dvi': 'application/x-dvi',
    '.dwf': 'model/vnd.dwf',
    '.dwg': 'image/vnd.dwg',
    '.dxf': 'image/vnd.dxf',
    '.dxp': 'application/vnd.spotfire.dxp',
    '.dxr': 'application/x-director',
    '.ecelp4800': 'audio/vnd.nuera.ecelp4800',
    '.ecelp7470': 'audio/vnd.nuera.ecelp7470',
    '.ecelp9600': 'audio/vnd.nuera.ecelp9600',
    '.ecma': 'application/ecmascript',
    '.edm': 'application/vnd.novadigm.edm',
    '.edx': 'application/vnd.novadigm.edx',
    '.efif': 'application/vnd.picsel',
    '.ei6': 'application/vnd.pg.osasli',
    '.elc': 'application/octet-stream',
    '.eml': 'message/rfc822',
    '.emma': 'application/emma+xml',
    '.eol': 'audio/vnd.digital-winds',
    '.eot': 'application/vnd.ms-fontobject',
    '.eps': 'application/postscript',
    '.epub': 'application/epub+zip',
    '.es3': 'application/vnd.eszigno3+xml',
    '.esf': 'application/vnd.epson.esf',
    '.et3': 'application/vnd.eszigno3+xml',
    '.etx': 'text/x-setext',
    '.exe': 'application/x-msdownload',
    '.ext': 'application/vnd.novadigm.ext',
    '.ez': 'application/andrew-inset',
    '.ez2': 'application/vnd.ezpix-album',
    '.ez3': 'application/vnd.ezpix-package',
    '.f': 'text/x-fortran',
    '.f4v': 'video/x-f4v',
    '.f77': 'text/x-fortran',
    '.f90': 'text/x-fortran',
    '.fbs': 'image/vnd.fastbidsheet',
    '.fdf': 'application/vnd.fdf',
    '.fe_launch': 'application/vnd.denovo.fcselayout-link',
    '.fg5': 'application/vnd.fujitsu.oasysgp',
    '.fgd': 'application/x-director',
    '.fh': 'image/x-freehand',
    '.fh4': 'image/x-freehand',
    '.fh5': 'image/x-freehand',
    '.fh7': 'image/x-freehand',
    '.fhc': 'image/x-freehand',
    '.fig': 'application/x-xfig',
    '.fli': 'video/x-fli',
    '.flo': 'application/vnd.micrografx.flo',
    '.flv': 'video/x-flv',
    '.flw': 'application/vnd.kde.kivio',
    '.flx': 'text/vnd.fmi.flexstor',
    '.fly': 'text/vnd.fly',
    '.fm': 'application/vnd.framemaker',
    '.fnc': 'application/vnd.frogans.fnc',
    '.for': 'text/x-fortran',
    '.fpx': 'image/vnd.fpx',
    '.frame': 'application/vnd.framemaker',
    '.fsc': 'application/vnd.fsc.weblaunch',
    '.fst': 'image/vnd.fst',
    '.ftc': 'application/vnd.fluxtime.clip',
    '.fti': 'application/vnd.anser-web-funds-transfer-initiation',
    '.fvt': 'video/vnd.fvt',
    '.fzs': 'application/vnd.fuzzysheet',
    '.g3': 'image/g3fax',
    '.gac': 'application/vnd.groove-account',
    '.gdl': 'model/vnd.gdl',
    '.geo': 'application/vnd.dynageo',
    '.gex': 'application/vnd.geometry-explorer',
    '.ggb': 'application/vnd.geogebra.file',
    '.ggt': 'application/vnd.geogebra.tool',
    '.ghf': 'application/vnd.groove-help',
    '.gif': 'image/gif',
    '.gim': 'application/vnd.groove-identity-message',
    '.gmx': 'application/vnd.gmx',
    '.gnumeric': 'application/x-gnumeric',
    '.gph': 'application/vnd.flographit',
    '.gqf': 'application/vnd.grafeq',
    '.gqs': 'application/vnd.grafeq',
    '.gram': 'application/srgs',
    '.gre': 'application/vnd.geometry-explorer',
    '.grv': 'application/vnd.groove-injector',
    '.grxml': 'application/srgs+xml',
    '.gsf': 'application/x-font-ghostscript',
    '.gtar': 'application/x-gtar',
    '.gtm': 'application/vnd.groove-tool-message',
    '.gtw': 'model/vnd.gtw',
    '.gv': 'text/vnd.graphviz',
    '.gz': 'application/x-gzip',
    '.h': 'text/x-c',
    '.h261': 'video/h261',
    '.h263': 'video/h263',
    '.h264': 'video/h264',
    '.hbci': 'application/vnd.hbci',
    '.hdf': 'application/x-hdf',
    '.hh': 'text/x-c',
    '.hlp': 'application/winhlp',
    '.hpgl': 'application/vnd.hp-hpgl',
    '.hpid': 'application/vnd.hp-hpid',
    '.hps': 'application/vnd.hp-hps',
    '.hqx': 'application/mac-binhex40',
    '.htke': 'application/vnd.kenameaapp',
    '.htm': 'text/html',
    '.html': 'text/html',
    '.hvd': 'application/vnd.yamaha.hv-dic',
    '.hvp': 'application/vnd.yamaha.hv-voice',
    '.hvs': 'application/vnd.yamaha.hv-script',
    '.icc': 'application/vnd.iccprofile',
    '.ice': 'x-conference/x-cooltalk',
    '.icm': 'application/vnd.iccprofile',
    '.ico': 'image/x-icon',
    '.ics': 'text/calendar',
    '.ief': 'image/ief',
    '.ifb': 'text/calendar',
    '.ifm': 'application/vnd.shana.informed.formdata',
    '.iges': 'model/iges',
    '.igl': 'application/vnd.igloader',
    '.igs': 'model/iges',
    '.igx': 'application/vnd.micrografx.igx',
    '.iif': 'application/vnd.shana.informed.interchange',
    '.imp': 'application/vnd.accpac.simply.imp',
    '.ims': 'application/vnd.ms-ims',
    '.in': 'text/plain',
    '.ipk': 'application/vnd.shana.informed.package',
    '.irm': 'application/vnd.ibm.rights-management',
    '.irp': 'application/vnd.irepository.package+xml',
    '.iso': 'application/octet-stream',
    '.itp': 'application/vnd.shana.informed.formtemplate',
    '.ivp': 'application/vnd.immervision-ivp',
    '.ivu': 'application/vnd.immervision-ivu',
    '.jad': 'text/vnd.sun.j2me.app-descriptor',
    '.jam': 'application/vnd.jam',
    '.jar': 'application/java-archive',
    '.java': 'text/x-java-source',
    '.jisp': 'application/vnd.jisp',
    '.jlt': 'application/vnd.hp-jlyt',
    '.jnlp': 'application/x-java-jnlp-file',
    '.joda': 'application/vnd.joost.joda-archive',
    '.jpe': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.jpg': 'image/jpeg',
    '.jpgm': 'video/jpm',
    '.jpgv': 'video/jpeg',
    '.jpm': 'video/jpm',
    '.js': 'application/javascript',
    '.json': 'application/json',
    '.kar': 'audio/midi',
    '.karbon': 'application/vnd.kde.karbon',
    '.kfo': 'application/vnd.kde.kformula',
    '.kia': 'application/vnd.kidspiration',
    '.kil': 'application/x-killustrator',
    '.kml': 'application/vnd.google-earth.kml+xml',
    '.kmz': 'application/vnd.google-earth.kmz',
    '.kne': 'application/vnd.kinar',
    '.knp': 'application/vnd.kinar',
    '.kon': 'application/vnd.kde.kontour',
    '.kpr': 'application/vnd.kde.kpresenter',
    '.kpt': 'application/vnd.kde.kpresenter',
    '.ksh': 'text/plain',
    '.ksp': 'application/vnd.kde.kspread',
    '.ktr': 'application/vnd.kahootz',
    '.ktz': 'application/vnd.kahootz',
    '.kwd': 'application/vnd.kde.kword',
    '.kwt': 'application/vnd.kde.kword',
    '.latex': 'application/x-latex',
    '.lbd': 'application/vnd.llamagraphics.life-balance.desktop',
    '.lbe': 'application/vnd.llamagraphics.life-balance.exchange+xml',
    '.les': 'application/vnd.hhe.lesson-player',
    '.lha': 'application/octet-stream',
    '.link66': 'application/vnd.route66.link66+xml',
    '.list': 'text/plain',
    '.list3820': 'application/vnd.ibm.modcap',
    '.listafp': 'application/vnd.ibm.modcap',
    '.log': 'text/plain',
    '.lostxml': 'application/lost+xml',
    '.lrf': 'application/octet-stream',
    '.lrm': 'application/vnd.ms-lrm',
    '.ltf': 'application/vnd.frogans.ltf',
    '.lvp': 'audio/vnd.lucent.voice',
    '.lwp': 'application/vnd.lotus-wordpro',
    '.lzh': 'application/octet-stream',
    '.m13': 'application/x-msmediaview',
    '.m14': 'application/x-msmediaview',
    '.m1v': 'video/mpeg',
    '.m2a': 'audio/mpeg',
    '.m2v': 'video/mpeg',
    '.m3a': 'audio/mpeg',
    '.m3u': 'audio/x-mpegurl',
    '.m4u': 'video/vnd.mpegurl',
    '.m4v': 'video/x-m4v',
    '.ma': 'application/mathematica',
    '.mag': 'application/vnd.ecowin.chart',
    '.maker': 'application/vnd.framemaker',
    '.man': 'text/troff',
    '.mathml': 'application/mathml+xml',
    '.mb': 'application/mathematica',
    '.mbk': 'application/vnd.mobius.mbk',
    '.mbox': 'application/mbox',
    '.mc1': 'application/vnd.medcalcdata',
    '.mcd': 'application/vnd.mcd',
    '.mcurl': 'text/vnd.curl.mcurl',
    '.mdb': 'application/x-msaccess',
    '.mdi': 'image/vnd.ms-modi',
    '.me': 'text/troff',
    '.mesh': 'model/mesh',
    '.mfm': 'application/vnd.mfmp',
    '.mgz': 'application/vnd.proteus.magazine',
    '.mht': 'message/rfc822',
    '.mhtml': 'message/rfc822',
    '.mid': 'audio/midi',
    '.midi': 'audio/midi',
    '.mif': 'application/vnd.mif',
    '.mime': 'message/rfc822',
    '.mj2': 'video/mj2',
    '.mjp2': 'video/mj2',
    '.mlp': 'application/vnd.dolby.mlp',
    '.mmd': 'application/vnd.chipnuts.karaoke-mmd',
    '.mmf': 'application/vnd.smaf',
    '.mmr': 'image/vnd.fujixerox.edmics-mmr',
    '.mny': 'application/x-msmoney',
    '.mobi': 'application/x-mobipocket-ebook',
    '.mov': 'video/quicktime',
    '.movie': 'video/x-sgi-movie',
    '.mp2': 'audio/mpeg',
    '.mp2a': 'audio/mpeg',
    '.mp3': 'audio/mpeg',
    '.mp4': 'video/mp4',
    '.mp4a': 'audio/mp4',
    '.mp4s': 'application/mp4',
    '.mp4v': 'video/mp4',
    '.mpa': 'video/mpeg',
    '.mpc': 'application/vnd.mophun.certificate',
    '.mpe': 'video/mpeg',
    '.mpeg': 'video/mpeg',
    '.mpg': 'video/mpeg',
    '.mpg4': 'video/mp4',
    '.mpga': 'audio/mpeg',
    '.mpkg': 'application/vnd.apple.installer+xml',
    '.mpm': 'application/vnd.blueice.multipass',
    '.mpn': 'application/vnd.mophun.application',
    '.mpp': 'application/vnd.ms-project',
    '.mpt': 'application/vnd.ms-project',
    '.mpy': 'application/vnd.ibm.minipay',
    '.mqy': 'application/vnd.mobius.mqy',
    '.mrc': 'application/marc',
    '.ms': 'text/troff',
    '.mscml': 'application/mediaservercontrol+xml',
    '.mseed': 'application/vnd.fdsn.mseed',
    '.mseq': 'application/vnd.mseq',
    '.msf': 'application/vnd.epson.msf',
    '.msh': 'model/mesh',
    '.msi': 'application/x-msdownload',
    '.msl': 'application/vnd.mobius.msl',
    '.msty': 'application/vnd.muvee.style',
    '.mts': 'model/vnd.mts',
    '.mus': 'application/vnd.musician',
    '.musicxml': 'application/vnd.recordare.musicxml+xml',
    '.mvb': 'application/x-msmediaview',
    '.mwf': 'application/vnd.mfer',
    '.mxf': 'application/mxf',
    '.mxl': 'application/vnd.recordare.musicxml',
    '.mxml': 'application/xv+xml',
    '.mxs': 'application/vnd.triscape.mxs',
    '.mxu': 'video/vnd.mpegurl',
    '.n-gage': 'application/vnd.nokia.n-gage.symbian.install',
    '.nb': 'application/mathematica',
    '.nc': 'application/x-netcdf',
    '.ncx': 'application/x-dtbncx+xml',
    '.ngdat': 'application/vnd.nokia.n-gage.data',
    '.nlu': 'application/vnd.neurolanguage.nlu',
    '.nml': 'application/vnd.enliven',
    '.nnd': 'application/vnd.noblenet-directory',
    '.nns': 'application/vnd.noblenet-sealer',
    '.nnw': 'application/vnd.noblenet-web',
    '.npx': 'image/vnd.net-fpx',
    '.nsf': 'application/vnd.lotus-notes',
    '.nws': 'message/rfc822',
    '.o': 'application/octet-stream',
    '.oa2': 'application/vnd.fujitsu.oasys2',
    '.oa3': 'application/vnd.fujitsu.oasys3',
    '.oas': 'application/vnd.fujitsu.oasys',
    '.obd': 'application/x-msbinder',
    '.obj': 'application/octet-stream',
    '.oda': 'application/oda',
    '.odb': 'application/vnd.oasis.opendocument.database',
    '.odc': 'application/vnd.oasis.opendocument.chart',
    '.odf': 'application/vnd.oasis.opendocument.formula',
    '.odft': 'application/vnd.oasis.opendocument.formula-template',
    '.odg': 'application/vnd.oasis.opendocument.graphics',
    '.odi': 'application/vnd.oasis.opendocument.image',
    '.odp': 'application/vnd.oasis.opendocument.presentation',
    '.ods': 'application/vnd.oasis.opendocument.spreadsheet',
    '.odt': 'application/vnd.oasis.opendocument.text',
    '.oga': 'audio/ogg',
    '.ogg': 'audio/ogg',
    '.ogv': 'video/ogg',
    '.ogx': 'application/ogg',
    '.onepkg': 'application/onenote',
    '.onetmp': 'application/onenote',
    '.onetoc': 'application/onenote',
    '.onetoc2': 'application/onenote',
    '.opf': 'application/oebps-package+xml',
    '.oprc': 'application/vnd.palm',
    '.org': 'application/vnd.lotus-organizer',
    '.osf': 'application/vnd.yamaha.openscoreformat',
    '.osfpvg': 'application/vnd.yamaha.openscoreformat.osfpvg+xml',
    '.otc': 'application/vnd.oasis.opendocument.chart-template',
    '.otf': 'application/x-font-otf',
    '.otg': 'application/vnd.oasis.opendocument.graphics-template',
    '.oth': 'application/vnd.oasis.opendocument.text-web',
    '.oti': 'application/vnd.oasis.opendocument.image-template',
    '.otm': 'application/vnd.oasis.opendocument.text-master',
    '.otp': 'application/vnd.oasis.opendocument.presentation-template',
    '.ots': 'application/vnd.oasis.opendocument.spreadsheet-template',
    '.ott': 'application/vnd.oasis.opendocument.text-template',
    '.oxt': 'application/vnd.openofficeorg.extension',
    '.p': 'text/x-pascal',
    '.p10': 'application/pkcs10',
    '.p12': 'application/x-pkcs12',
    '.p7b': 'application/x-pkcs7-certificates',
    '.p7c': 'application/pkcs7-mime',
    '.p7m': 'application/pkcs7-mime',
    '.p7r': 'application/x-pkcs7-certreqresp',
    '.p7s': 'application/pkcs7-signature',
    '.pas': 'text/x-pascal',
    '.pbd': 'application/vnd.powerbuilder6',
    '.pbm': 'image/x-portable-bitmap',
    '.pcf': 'application/x-font-pcf',
    '.pcl': 'application/vnd.hp-pcl',
    '.pclxl': 'application/vnd.hp-pclxl',
    '.pct': 'image/x-pict',
    '.pcurl': 'application/vnd.curl.pcurl',
    '.pcx': 'image/x-pcx',
    '.pdb': 'application/vnd.palm',
    '.pdf': 'application/pdf',
    '.pfa': 'application/x-font-type1',
    '.pfb': 'application/x-font-type1',
    '.pfm': 'application/x-font-type1',
    '.pfr': 'application/font-tdpfr',
    '.pfx': 'application/x-pkcs12',
    '.pgm': 'image/x-portable-graymap',
    '.pgn': 'application/x-chess-pgn',
    '.pgp': 'application/pgp-encrypted',
    '.pic': 'image/x-pict',
    '.pkg': 'application/octet-stream',
    '.pki': 'application/pkixcmp',
    '.pkipath': 'application/pkix-pkipath',
    '.pl': 'text/plain',
    '.plb': 'application/vnd.3gpp.pic-bw-large',
    '.plc': 'application/vnd.mobius.plc',
    '.plf': 'application/vnd.pocketlearn',
    '.pls': 'application/pls+xml',
    '.pml': 'application/vnd.ctc-posml',
    '.png': 'image/png',
    '.pnm': 'image/x-portable-anymap',
    '.portpkg': 'application/vnd.macports.portpkg',
    '.pot': 'application/vnd.ms-powerpoint',
    '.potm': 'application/vnd.ms-powerpoint.template.macroenabled.12',
    '.potx': 'application/vnd.openxmlformats-officedocument.presentationml.template',
    '.ppa': 'application/vnd.ms-powerpoint',
    '.ppam': 'application/vnd.ms-powerpoint.addin.macroenabled.12',
    '.ppd': 'application/vnd.cups-ppd',
    '.ppm': 'image/x-portable-pixmap',
    '.pps': 'application/vnd.ms-powerpoint',
    '.ppsm': 'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
    '.ppsx': 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
    '.ppt': 'application/vnd.ms-powerpoint',
    '.pptm': 'application/vnd.ms-powerpoint.presentation.macroenabled.12',
    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    '.pqa': 'application/vnd.palm',
    '.prc': 'application/x-mobipocket-ebook',
    '.pre': 'application/vnd.lotus-freelance',
    '.prf': 'application/pics-rules',
    '.ps': 'application/postscript',
    '.psb': 'application/vnd.3gpp.pic-bw-small',
    '.psd': 'image/vnd.adobe.photoshop',
    '.psf': 'application/x-font-linux-psf',
    '.ptid': 'application/vnd.pvi.ptid1',
    '.pub': 'application/x-mspublisher',
    '.pvb': 'application/vnd.3gpp.pic-bw-var',
    '.pwn': 'application/vnd.3m.post-it-notes',
    '.pwz': 'application/vnd.ms-powerpoint',
    '.py': 'text/x-python',
    '.pya': 'audio/vnd.ms-playready.media.pya',
    '.pyc': 'application/x-python-code',
    '.pyo': 'application/x-python-code',
    '.pyv': 'video/vnd.ms-playready.media.pyv',
    '.qam': 'application/vnd.epson.quickanime',
    '.qbo': 'application/vnd.intu.qbo',
    '.qfx': 'application/vnd.intu.qfx',
    '.qps': 'application/vnd.publishare-delta-tree',
    '.qt': 'video/quicktime',
    '.qwd': 'application/vnd.quark.quarkxpress',
    '.qwt': 'application/vnd.quark.quarkxpress',
    '.qxb': 'application/vnd.quark.quarkxpress',
    '.qxd': 'application/vnd.quark.quarkxpress',
    '.qxl': 'application/vnd.quark.quarkxpress',
    '.qxt': 'application/vnd.quark.quarkxpress',
    '.ra': 'audio/x-pn-realaudio',
    '.ram': 'audio/x-pn-realaudio',
    '.rar': 'application/x-rar-compressed',
    '.ras': 'image/x-cmu-raster',
    '.rcprofile': 'application/vnd.ipunplugged.rcprofile',
    '.rdf': 'application/rdf+xml',
    '.rdz': 'application/vnd.data-vision.rdz',
    '.rep': 'application/vnd.businessobjects',
    '.res': 'application/x-dtbresource+xml',
    '.rgb': 'image/x-rgb',
    '.rif': 'application/reginfo+xml',
    '.rl': 'application/resource-lists+xml',
    '.rlc': 'image/vnd.fujixerox.edmics-rlc',
    '.rld': 'application/resource-lists-diff+xml',
    '.rm': 'application/vnd.rn-realmedia',
    '.rmi': 'audio/midi',
    '.rmp': 'audio/x-pn-realaudio-plugin',
    '.rms': 'application/vnd.jcp.javame.midlet-rms',
    '.rnc': 'application/relax-ng-compact-syntax',
    '.roff': 'text/troff',
    '.rpm': 'application/x-rpm',
    '.rpss': 'application/vnd.nokia.radio-presets',
    '.rpst': 'application/vnd.nokia.radio-preset',
    '.rq': 'application/sparql-query',
    '.rs': 'application/rls-services+xml',
    '.rsd': 'application/rsd+xml',
    '.rss': 'application/rss+xml',
    '.rtf': 'application/rtf',
    '.rtx': 'text/richtext',
    '.s': 'text/x-asm',
    '.saf': 'application/vnd.yamaha.smaf-audio',
    '.sbml': 'application/sbml+xml',
    '.sc': 'application/vnd.ibm.secure-container',
    '.scd': 'application/x-msschedule',
    '.scm': 'application/vnd.lotus-screencam',
    '.scq': 'application/scvp-cv-request',
    '.scs': 'application/scvp-cv-response',
    '.scurl': 'text/vnd.curl.scurl',
    '.sda': 'application/vnd.stardivision.draw',
    '.sdc': 'application/vnd.stardivision.calc',
    '.sdd': 'application/vnd.stardivision.impress',
    '.sdkd': 'application/vnd.solent.sdkm+xml',
    '.sdkm': 'application/vnd.solent.sdkm+xml',
    '.sdp': 'application/sdp',
    '.sdw': 'application/vnd.stardivision.writer',
    '.see': 'application/vnd.seemail',
    '.seed': 'application/vnd.fdsn.seed',
    '.sema': 'application/vnd.sema',
    '.semd': 'application/vnd.semd',
    '.semf': 'application/vnd.semf',
    '.ser': 'application/java-serialized-object',
    '.setpay': 'application/set-payment-initiation',
    '.setreg': 'application/set-registration-initiation',
    '.sfd-hdstx': 'application/vnd.hydrostatix.sof-data',
    '.sfs': 'application/vnd.spotfire.sfs',
    '.sgl': 'application/vnd.stardivision.writer-global',
    '.sgm': 'text/sgml',
    '.sgml': 'text/sgml',
    '.sh': 'application/x-sh',
    '.shar': 'application/x-shar',
    '.shf': 'application/shf+xml',
    '.si': 'text/vnd.wap.si',
    '.sic': 'application/vnd.wap.sic',
    '.sig': 'application/pgp-signature',
    '.silo': 'model/mesh',
    '.sis': 'application/vnd.symbian.install',
    '.sisx': 'application/vnd.symbian.install',
    '.sit': 'application/x-stuffit',
    '.sitx': 'application/x-stuffitx',
    '.skd': 'application/vnd.koan',
    '.skm': 'application/vnd.koan',
    '.skp': 'application/vnd.koan',
    '.skt': 'application/vnd.koan',
    '.sl': 'text/vnd.wap.sl',
    '.slc': 'application/vnd.wap.slc',
    '.sldm': 'application/vnd.ms-powerpoint.slide.macroenabled.12',
    '.sldx': 'application/vnd.openxmlformats-officedocument.presentationml.slide',
    '.slt': 'application/vnd.epson.salt',
    '.smf': 'application/vnd.stardivision.math',
    '.smi': 'application/smil+xml',
    '.smil': 'application/smil+xml',
    '.snd': 'audio/basic',
    '.snf': 'application/x-font-snf',
    '.so': 'application/octet-stream',
    '.spc': 'application/x-pkcs7-certificates',
    '.spf': 'application/vnd.yamaha.smaf-phrase',
    '.spl': 'application/x-futuresplash',
    '.spot': 'text/vnd.in3d.spot',
    '.spp': 'application/scvp-vp-response',
    '.spq': 'application/scvp-vp-request',
    '.spx': 'audio/ogg',
    '.src': 'application/x-wais-source',
    '.srx': 'application/sparql-results+xml',
    '.sse': 'application/vnd.kodak-descriptor',
    '.ssf': 'application/vnd.epson.ssf',
    '.ssml': 'application/ssml+xml',
    '.stc': 'application/vnd.sun.xml.calc.template',
    '.std': 'application/vnd.sun.xml.draw.template',
    '.stf': 'application/vnd.wt.stf',
    '.sti': 'application/vnd.sun.xml.impress.template',
    '.stk': 'application/hyperstudio',
    '.stl': 'application/vnd.ms-pki.stl',
    '.str': 'application/vnd.pg.format',
    '.stw': 'application/vnd.sun.xml.writer.template',
    '.sus': 'application/vnd.sus-calendar',
    '.susp': 'application/vnd.sus-calendar',
    '.sv4cpio': 'application/x-sv4cpio',
    '.sv4crc': 'application/x-sv4crc',
    '.svd': 'application/vnd.svd',
    '.svg': 'image/svg+xml',
    '.svgz': 'image/svg+xml',
    '.swa': 'application/x-director',
    '.swf': 'application/x-shockwave-flash',
    '.swi': 'application/vnd.arastra.swi',
    '.sxc': 'application/vnd.sun.xml.calc',
    '.sxd': 'application/vnd.sun.xml.draw',
    '.sxg': 'application/vnd.sun.xml.writer.global',
    '.sxi': 'application/vnd.sun.xml.impress',
    '.sxm': 'application/vnd.sun.xml.math',
    '.sxw': 'application/vnd.sun.xml.writer',
    '.t': 'text/troff',
    '.tao': 'application/vnd.tao.intent-module-archive',
    '.tar': 'application/x-tar',
    '.tcap': 'application/vnd.3gpp2.tcap',
    '.tcl': 'application/x-tcl',
    '.teacher': 'application/vnd.smart.teacher',
    '.tex': 'application/x-tex',
    '.texi': 'application/x-texinfo',
    '.texinfo': 'application/x-texinfo',
    '.text': 'text/plain',
    '.tfm': 'application/x-tex-tfm',
    '.tgz': 'application/x-gzip',
    '.tif': 'image/tiff',
    '.tiff': 'image/tiff',
    '.tmo': 'application/vnd.tmobile-livetv',
    '.torrent': 'application/x-bittorrent',
    '.tpl': 'application/vnd.groove-tool-template',
    '.tpt': 'application/vnd.trid.tpt',
    '.tr': 'text/troff',
    '.tra': 'application/vnd.trueapp',
    '.trm': 'application/x-msterminal',
    '.tsv': 'text/tab-separated-values',
    '.ttc': 'application/x-font-ttf',
    '.ttf': 'application/x-font-ttf',
    '.twd': 'application/vnd.simtech-mindmapper',
    '.twds': 'application/vnd.simtech-mindmapper',
    '.txd': 'application/vnd.genomatix.tuxedo',
    '.txf': 'application/vnd.mobius.txf',
    '.txt': 'text/plain',
    '.u32': 'application/x-authorware-bin',
    '.udeb': 'application/x-debian-package',
    '.ufd': 'application/vnd.ufdl',
    '.ufdl': 'application/vnd.ufdl',
    '.umj': 'application/vnd.umajin',
    '.unityweb': 'application/vnd.unity',
    '.uoml': 'application/vnd.uoml+xml',
    '.uri': 'text/uri-list',
    '.uris': 'text/uri-list',
    '.urls': 'text/uri-list',
    '.ustar': 'application/x-ustar',
    '.utz': 'application/vnd.uiq.theme',
    '.uu': 'text/x-uuencode',
    '.vcd': 'application/x-cdlink',
    '.vcf': 'text/x-vcard',
    '.vcg': 'application/vnd.groove-vcard',
    '.vcs': 'text/x-vcalendar',
    '.vcx': 'application/vnd.vcx',
    '.vis': 'application/vnd.visionary',
    '.viv': 'video/vnd.vivo',
    '.vor': 'application/vnd.stardivision.writer',
    '.vox': 'application/x-authorware-bin',
    '.vrml': 'model/vrml',
    '.vsd': 'application/vnd.visio',
    '.vsf': 'application/vnd.vsf',
    '.vss': 'application/vnd.visio',
    '.vst': 'application/vnd.visio',
    '.vsw': 'application/vnd.visio',
    '.vtu': 'model/vnd.vtu',
    '.vxml': 'application/voicexml+xml',
    '.w3d': 'application/x-director',
    '.wad': 'application/x-doom',
    '.wav': 'audio/x-wav',
    '.wax': 'audio/x-ms-wax',
    '.wbmp': 'image/vnd.wap.wbmp',
    '.wbs': 'application/vnd.criticaltools.wbs+xml',
    '.wbxml': 'application/vnd.wap.wbxml',
    '.wcm': 'application/vnd.ms-works',
    '.wdb': 'application/vnd.ms-works',
    '.wiz': 'application/msword',
    '.wks': 'application/vnd.ms-works',
    '.wm': 'video/x-ms-wm',
    '.wma': 'audio/x-ms-wma',
    '.wmd': 'application/x-ms-wmd',
    '.wmf': 'application/x-msmetafile',
    '.wml': 'text/vnd.wap.wml',
    '.wmlc': 'application/vnd.wap.wmlc',
    '.wmls': 'text/vnd.wap.wmlscript',
    '.wmlsc': 'application/vnd.wap.wmlscriptc',
    '.wmv': 'video/x-ms-wmv',
    '.wmx': 'video/x-ms-wmx',
    '.wmz': 'application/x-ms-wmz',
    '.wpd': 'application/vnd.wordperfect',
    '.wpl': 'application/vnd.ms-wpl',
    '.wps': 'application/vnd.ms-works',
    '.wqd': 'application/vnd.wqd',
    '.wri': 'application/x-mswrite',
    '.wrl': 'model/vrml',
    '.wsdl': 'application/wsdl+xml',
    '.wspolicy': 'application/wspolicy+xml',
    '.wtb': 'application/vnd.webturbo',
    '.wvx': 'video/x-ms-wvx',
    '.x32': 'application/x-authorware-bin',
    '.x3d': 'application/vnd.hzn-3d-crossword',
    '.xap': 'application/x-silverlight-app',
    '.xar': 'application/vnd.xara',
    '.xbap': 'application/x-ms-xbap',
    '.xbd': 'application/vnd.fujixerox.docuworks.binder',
    '.xbm': 'image/x-xbitmap',
    '.xdm': 'application/vnd.syncml.dm+xml',
    '.xdp': 'application/vnd.adobe.xdp+xml',
    '.xdw': 'application/vnd.fujixerox.docuworks',
    '.xenc': 'application/xenc+xml',
    '.xer': 'application/patch-ops-error+xml',
    '.xfdf': 'application/vnd.adobe.xfdf',
    '.xfdl': 'application/vnd.xfdl',
    '.xht': 'application/xhtml+xml',
    '.xhtml': 'application/xhtml+xml',
    '.xhvml': 'application/xv+xml',
    '.xif': 'image/vnd.xiff',
    '.xla': 'application/vnd.ms-excel',
    '.xlam': 'application/vnd.ms-excel.addin.macroenabled.12',
    '.xlb': 'application/vnd.ms-excel',
    '.xlc': 'application/vnd.ms-excel',
    '.xlm': 'application/vnd.ms-excel',
    '.xls': 'application/vnd.ms-excel',
    '.xlsb': 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
    '.xlsm': 'application/vnd.ms-excel.sheet.macroenabled.12',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    '.xlt': 'application/vnd.ms-excel',
    '.xltm': 'application/vnd.ms-excel.template.macroenabled.12',
    '.xltx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
    '.xlw': 'application/vnd.ms-excel',
    '.xml': 'application/xml',
    '.xo': 'application/vnd.olpc-sugar',
    '.xop': 'application/xop+xml',
    '.xpdl': 'application/xml',
    '.xpi': 'application/x-xpinstall',
    '.xpm': 'image/x-xpixmap',
    '.xpr': 'application/vnd.is-xpr',
    '.xps': 'application/vnd.ms-xpsdocument',
    '.xpw': 'application/vnd.intercon.formnet',
    '.xpx': 'application/vnd.intercon.formnet',
    '.xsl': 'application/xml',
    '.xslt': 'application/xslt+xml',
    '.xsm': 'application/vnd.syncml+xml',
    '.xspf': 'application/xspf+xml',
    '.xul': 'application/vnd.mozilla.xul+xml',
    '.xvm': 'application/xv+xml',
    '.xvml': 'application/xv+xml',
    '.xwd': 'image/x-xwindowdump',
    '.xyz': 'chemical/x-xyz',
    '.zaz': 'application/vnd.zzazz.deck+xml',
    '.zip': 'application/zip',
    '.zir': 'application/vnd.zul',
    '.zirz': 'application/vnd.zul',
    '.zmm': 'application/vnd.handheld-entertainment+xml'
  };

  /**
    @class Coral.FileUpload.Item
    @classdesc A FileUpload item encapsulating file meta-data
    @param {File|HTMLElement} file
      The file element.

  */
  Coral.FileUpload.Item = function(file) {
    this._originalFile = file;
    this._xhr = null;

    // Defaults
    this._parameters = [];
    this._withCredentials = false;
    this._timeout = 0;
    this._responseType = Coral.FileUpload.Item.responseType.TEXT;
    this._readyState = 0;
    this._response = null;
    this._responseText = '';
    this._responseXML = null;
    this._status = 0;
    this._statusText = '';
  };

  Coral.FileUpload.Item.prototype = {};

  /**
    The File.

    @name file
    @readonly
    @type {File}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'file', {
    get: function() {
      return this._originalFile;
    },
    set: function(value) {
      // readonly
    }
  });

  /**
    Array of additional parameters as key:value to be uploaded with the file.
    A parameter must contain a <code>name</code> key:value and optionally a <code>value</code> key:value.

    @name parameters
    @type {Array.<Object>}
    @default []
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'parameters', {
    get: function() {
      return this._parameters;
    },
    set: function(value) {
      if (Coral.validate.valueMustChange(value, this._parameters)) {
        // Verify that every item has a name
        var validate = Array.isArray(value) && value.every(function(el) {
            return el && el.name;
          });

        if (validate) {
          this._parameters = value;
        }
      }
    }
  });

  /**
    The item xhr <code>withCredentials</code> property.

    @name withCredentials
    @type {Boolean}
    @default false
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'withCredentials', {
    get: function() {
      return this._withCredentials;
    },
    set: function(value) {
      value = Coral.transform.boolean(value);
      if (Coral.validate.valueMustChange(value, this._withCredentials)) {
        this._withCredentials = value;
      }
    }
  });

  /**
    The item xhr <code>timeout</code> property.

    @name timeout
    @type {Number}
    @default 0
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'timeout', {
    get: function() {
      return this._timeout;
    },
    set: function(value) {
      if (Coral.validate.valueMustChange(value, this._timeout)) {
        var timeout = Coral.transform.number(value);
        if (timeout !== null) {
          this._timeout = timeout;
          if (this._xhr) {
            this._xhr.timeout = timeout;
          }
        }
      }
    }
  });

  /**
    The item xhr <code>responseType</code> property.

    @name responseType
    @default {Coral.FileUpload.Item.responseType.TEXT}
    @type {Coral.FileUpload.Item.responseType}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'responseType', {
    get: function() {
      return this._responseType;
    },
    set: function(value) {
      if (Coral.validate.valueMustChange(value, this._responseType) &&
        Coral.validate.enumeration(responseType)(value)) {
        this._responseType = value;
        if (this._xhr) {
          this._xhr.responseType = value;
        }
      }
    }
  });

  /**
    The item xhr <code>readyState</code> property.

    @name readyState
    @readonly
    @default 0
    @type {Number}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'readyState', {
    get: function() {
      return this._xhr ? this._xhr.readyState : this._readyState;
    },
    set: function(value) {
      // readonly
    }
  });

  /**
    The item xhr <code>responseType</code> property. Depends on {@link Coral.FileUpload.Item#responseType}.

    @name response
    @readonly
    @default ""
    @type {String|ArrayBuffer|Blob|Document}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'response', {
    get: function() {
      return this._xhr ? this._xhr.response : this._response;
    },
    set: function(value) {
      // readonly
    }
  });

  /**
    The item xhr <code>responseText</code> property.

    @name responseText
    @readonly
    @default ""
    @type {String}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'responseText', {
    get: function() {
      return this._xhr ? this._xhr.responseText : this._responseText;
    },
    set: function(value) {
      // readonly
    }
  });

  /**
    The item xhr <code>responseXML</code> property.

    @name responseXML
    @readonly
    @default null
    @type {HTMLElement}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'responseXML', {
    get: function() {
      return this._xhr ? this._xhr.responseXML : this._responseXML;
    },
    set: function(value) {
      // readonly
    }
  });

  /**
    The item xhr <code>status</code> property.

    @name status
    @readonly
    @default 0
    @type {Number}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'status', {
    get: function() {
      return this._xhr ? this._xhr.status : this._status;
    },
    set: function(value) {
      // readonly
    }
  });

  /**
    The item xhr <code>statusText</code> property.

    @name statusText
    @readonly
    @default ""
    @type {String}
    @memberof Coral.FileUpload.Item#
  */
  Object.defineProperty(Coral.FileUpload.Item.prototype, 'statusText', {
    get: function() {
      return this._xhr ? this._xhr.statusText : this._statusText;
    },
    set: function(value) {
      // readonly
    }
  });

  /**
    @ignore
  */
  Coral.FileUpload.Item.prototype._isMimeTypeAllowed = function(acceptedMimeTypes) {
    var isAllowed = false;

    // Unrecognized browser mime types have a file type of ''.
    var fileType = this.file.type || 'application/unknown';

    if (!fileType.match(MIME_TYPE_REGEXP)) {
      // File mime type is erroneous
      return false;
    }

    return acceptedMimeTypes.split(',').some(function(allowedMimeType) {
      allowedMimeType = allowedMimeType.trim();

      if (allowedMimeType === '*' ||
        allowedMimeType === '.*' ||
        allowedMimeType === '*/*' ||
        fileType === 'application/unknown') {
        // Explicit wildcard case: allow any file
        // Allow unknown mime types
        isAllowed = true;
      }
      else if (allowedMimeType.match(MIME_TYPE_REGEXP)) {
        if (allowedMimeType === MIME_TYPE_AUDIO) {
          isAllowed = (fileType.indexOf(MIME_TYPE_AUDIO.slice(0, -1)) === 0);
        }
        else if (allowedMimeType === MIME_TYPE_IMAGE) {
          isAllowed = (fileType.indexOf(MIME_TYPE_IMAGE.slice(0, -1)) === 0);
        }
        else if (allowedMimeType === MIME_TYPE_VIDEO) {
          isAllowed = (fileType.indexOf(MIME_TYPE_VIDEO.slice(0, -1)) === 0);
        }
        else {
          // Proper mime type case: directly compare with file mime type
          isAllowed = (fileType === allowedMimeType);
        }
      }
      else if (allowedMimeType.match(FILE_EXTENSION_REGEXP)) {
        // File extension case
        var allowedMimeTypes = MIME_TYPES[allowedMimeType];
        
        // Depending on OS and browser, a file extension can map to different mime types
        // e.g .csv maps to "text/csv" on Mac OS and to "application/vnd.ms-excel" on Windows
        if (Array.isArray(allowedMimeTypes)) {
          isAllowed = allowedMimeTypes.some(function(mimeType) {
            return fileType === mimeType;
          });
        }
        else {
          isAllowed = (fileType === MIME_TYPES[allowedMimeType]);
        }
      }
      else if (allowedMimeType.match(SHORTCUT_REGEXP)) {
        // "Shortcut" case: only compare first part of the file mime type with the shortcut
        isAllowed = (fileType.split('/')[0] === allowedMimeType);
      }

      // Break the loop if file mime type is allowed
      return isAllowed;
    }.bind(this));
  };

  // Export enum
  Coral.FileUpload.Item.responseType = responseType;
})();

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // @temp - Enable debug messages when writing tests
  var DEBUG = 0;

  // IE does not set the complete property to true if an image cannot be loaded. This code must be outside of the
  // masonry to make sure that the listener catches images which fail loading before the masonry is initalized.
  // @polyfill ie11
  document.addEventListener('error', function(event) {
    var target = event.target;
    if (target && target.tagName === 'IMG') {
      target._loadError = true;
    }
  }, true);

  function itemFilter(element) {
    // Ignore children which are being removed
    return element && element.tagName === 'CORAL-MASONRY-ITEM' && !element._removing;
  }

  function isRemovingOrRemoved(item) {
    return item._removing || !item.parentNode;
  }

  Coral.register( /** @lends Coral.Masonry# */ {
    /**
      @class Coral.Masonry
      @classdesc A masonry component
      @extends Coral.Component
      @htmltag coral-masonry
     */
    name: 'Masonry',
    tagName: 'coral-masonry',
    className: 'coral3-Masonry',

    events: {
      'resize': '_onResize',
      'global:resize': '_onWindowResize',

      // Loaded
      'global:load': '_updateLoaded',
      'capture:load img': '_updateLoaded',
      'capture:error img': '_updateLoaded',

      // Drag and drop
      'coral-dragaction:dragstart coral-masonry-item': '_onItemDragStart',
      'coral-dragaction:dragover coral-masonry-item': '_onItemDragMove',
      'coral-dragaction:dragend coral-masonry-item': '_onItemDragEnd',

      // Keyboard
      'capture:focus coral-masonry-item': '_onItemFocus'
    },

    properties: {

      /**
        {@link Coral.Collection} which allows to interact with the masonry items.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Masonry#
       */
      'items': {
        get: function() {
          return this._items;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        The layout name for this masonry. Must be one of {@link Coral.Masonry.layouts}. The following layout types are
        available by default:
        <ul>
          <li>fixed-centered: Layout with fixed width centered items</li>
          <li>fixed-spread: Layout with fixed width and evenly spread items</li>
          <li>variable: Layout with variable width items</li>
          <li>dashboard: Layout with variable width items which are expanded in their height to fill gaps</li>
        </ul>

        @type {String}
        @htmlattribute layout
        @htmlattributereflected
        @memberof Coral.Masonry#
       */
      'layout': {
        default: '',
        reflectAttribute: true,
        get: function() {
          return this._layoutName;
        },
        set: function(layoutName) {
          var layouts = Coral.Masonry && Coral.Masonry._layouts;
          if (!layouts) {
            // Browsers which support custom elements natively will upgrade the masonries in the html document
            // immediately when registerElement is called. The problem is that this is before the elements are
            // registered. Therefore, we repeat the set layout call here:
            window.setTimeout(function() {
              this.layout = layoutName;
            }.bind(this), 0);
            return;
          }
          if (layoutName === '') {
            // Resolve default layout
            layoutName = Object.keys(layouts)[0];
          }
          if (layoutName !== this._layoutName) {
            if (layouts[layoutName]) {
              this._layoutName = layoutName;
              this._scheduleLayout('new layout');
            }
            else if (window.console) {
            // @temp - Enable debug messages when writing tests
              if (DEBUG) {
                console.error('Coral.Masonry: Unknown layout:', layoutName);
              }
            }
          }
        }
      },

      /**
        The first selected item or <code>null</code> if no item is selected.

        @type {Coral.Masonry.Item}
        @readonly
        @memberof Coral.Masonry#
       */
      'selectedItem': {
        get: function() {
          var items = this.items.getAll();
          for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (item.selected) {
              return item;
            }
          }
          return null;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        An array of all selected items.

        @type {Array.<Coral.Masonry.Item>}
        @readonly
        @memberof Coral.Masonry#
       */
      'selectedItems': {
        get: function() {
          var selectedItems = [];
          var items = this.items.getAll();
          for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (item.selected) {
              selectedItems.push(item);
            }
          }
          return selectedItems;
        },
        set: function() {
          // Read-only
        }
      },

      // TODO this is layout specific. move to layout?
      /**
        The spacing between the items and the masonry container in pixel. If this property is not set, then it falls
        back to the CSS padding of the masonry and margin of the items.

        @type {?Number}
        @default null
        @htmlattribute spacing
        @memberof Coral.Masonry#
       */
      'spacing': {
        default: null,
        transform: function(value) {
          var number = Coral.transform.number(value);
          return (number !== null) ? Math.max(0, number) : null;
        },
        sync: function() {
          this._scheduleLayout('spacing');
        }
      },

      /**
        Whether or not it is possible to order items with drag & drop.

        @type {Boolean}
        @default false
        @htmlattribute orderable
        @memberof Coral.Masonry.Item#
       */
      'orderable': {
        default: false,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this._updateDragActions();
        }
      }

    },

    /**
      Selects all items.

      @see {@link #deselectAll}
     */
    selectAll: function() {
      this._setAllSelected(true);
    },

    /**
      Deselects all items.

      @see {@link #selectAll}
     */
    deselectAll: function() {
      this._setAllSelected(false);
    },

    /** @private */
    _setAllSelected: function(selected) {
      var items = this.items.getAll();
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (item.selected !== selected) {
          item.selected = selected;
        }
      }
    },

    /**
      Schedules a layout for the next animation frame. Even if called many times, the layout happens still just once.

      @param reason just for debugging purposes
      @private
     */
    _scheduleLayout: function(reason) {
      if (!this._forceDebounce && !this._layoutScheduled) {
        Coral.commons.nextFrame(function() {
          // Skip layout if a layout was forced in between
          if (this._layoutScheduled) {
            this._doLayout(reason);
            // Cancel potentially scheduled layout if the current layout was enforced by calling doLayout directly
            this._layoutScheduled = false;
          }
        }.bind(this));
        this._layoutScheduled = true;
      }
    },

    /** @private */
    _scheduleDebouncedLayout: function(reason, force) {
      // Do not force debounce if the masonry isn't layouted yet. Safari sometimes triggers resize events while loading.
      if (force && this._layouted) {
        this._forceDebounce = true;
      }
      window.clearTimeout(this._debounceId);
      this._debounceId = window.setTimeout(function() {
        this._forceDebounce = false;
        this._scheduleLayout('window resize');
      }.bind(this), 500);
    },

    /**
      Callback which has to be called when the dimensions have changed or the masonry turned visible.

      @private
     */
    _onResize: function() {
      // Ignore resize event which is triggered when listener is added
      if (this._componentReady) {
        if (!this._layouted) {
          // The masonry was first invisible, render it now immediately
          this._doLayout('became visible');
        }
        else {
          this._scheduleDebouncedLayout('resize', false);
        }
      }
    },

    /** @private */
    _onWindowResize: function() {
      this._scheduleDebouncedLayout('window resize', true);
    },

    /**
      Performs a layout. Should only be called by {@link #_scheduleLayout} if possible.

      @private
     */
    _doLayout: function(reason) {
      var visible = !!this.offsetParent;
      var LayoutClass = Coral.Masonry._layouts[this.layout];
      if (this._forceDebounce || !LayoutClass || !visible) {
        return;
      }

      if (!this._layout) {
        this._layout = new LayoutClass(this);
      }
      // Check if the layout has changed
      else if (this._layout.name !== this.layout) {
        this._layout.destroy();
        this._layout = new LayoutClass(this);
      }

      // Animate insertion. In the attachedCallback of the item, the is-beforeInserting class was already added. This
      // class is now removed again which allows to transition between the is-beforeInserting and is-inserting class.
      // By separating the code and batching the changes, the overhead is reduced significantly.
      var i;
      var newItems = this._newItems;
      for (i = 0; i < newItems.length; i++) {
        newItems[i]._insert();
      }

      // Position the items
      this._layout.layout();
      this._layouted = true;

      // Mark newly added items as managed. Before this class is added, the items are invisible. The reason why this is
      // done here after positioning the items is that it seems to be the only way to ensure that the items are never
      // shown at the wrong position. There used to be two cases when this happened:
      // - When the masonry is first invisible and later shown because the resize event is triggered too late.
      // - In some browsers (e.g. Safari) always when items are added dynamically
      for (i = 0; i < newItems.length; i++) {
        newItems[i].classList.add('is-managed');
      }
      newItems.length = 0; // clear

      // Update loaded class. Cannot be done in _updateLoaded because it has to happen after the positioning.
      this.classList.toggle('is-loaded', this._loaded);

      // Ensure that the tabbable item is set & still valid
      var tabbableItem = this._tabbableItem;
      if (!tabbableItem || isRemovingOrRemoved(tabbableItem)) {
        this._setTabbableItem(this.items.first());
      }

      // Focus the next item if the previously focused item has been removed
      var focusedItem = this._focusedItem;
      if (focusedItem) {
        if (isRemovingOrRemoved(focusedItem) && this._focusedItemNext) {
          this._focusedItemNext.focus();
        }
        else if (focusedItem !== document.activeElement) {
          this._focusedItem = null;
          this._focusedItemNext = null;
        }
      }

      // Prevent endless observation loop (skip mutations which have been caused by the layout)
      this._observer.takeRecords();
    },

    /** @ignore */
    _initialize: function() {
      this._loaded = false;
      this._layouted = false;
      this._layoutScheduled = false;
      this._forceDebounce = false;
      this._debounceId = null;

      this._items = new Coral.Collection({
        host: this,
        itemTagName: 'CORAL-MASONRY-ITEM',
        filter: itemFilter
      });
      this._newItems = [];
      this._tabbableItem = null;

      // Relayout when child elements change or are added/removed
      // Should this mutation observer become a bottleneck, it could be replaced with a resize listener
      this._observer = new MutationObserver(this._scheduleLayout.bind(this, 'mutation'));
      this._observer.observe(this, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      });
    },

    /** @private */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      // This indicates that the initial items are being attached
      this._attaching = true;
      Coral.commons.nextFrame(function() {
        this._attaching = false;
        // Update loaded after all items have been attached
        this._updateLoaded();
      }.bind(this));
    },

    /** @ignore */
    _updateLoaded: function() {
      // Wait until complete because fonts might be loaded after interactive
      if (!this._loaded && document.readyState === 'complete') {
        var loaded = true;
        var images = this.querySelectorAll('img');
        for (var i = 0; i < images.length; i++) {
          var image = images[i];
          // _loadError is set in a listener at the top of this file
          if (image.src && !image.complete && !image._loadError) {
            loaded = false;
            break;
          }
        }
        this._loaded = loaded;
      }
      this._scheduleLayout(); // A loaded image might have made an item bigger
    },

    /** @private */
    _onItemAdded: function(item) {
      item._updateDragAction(this.orderable);
      this._newItems.push(item);

      // Hack to prevent flickering in some browsers which don't support custom elements natively (e.g. Safari)
      if (this._attaching && item.nextElementSibling === null) {
        this._doLayout('last item attached');
      }

      // Collection event
      this.trigger('coral-collection:add', {
        item: item
      });
    },

    /** @private */
    _onItemRemoved: function(item) {
      item._updateDragAction(false);
      item.classList.remove('is-managed');

      // Collection event
      this.trigger('coral-collection:remove', {
        item: item
      });
    },

    /** @private */
    _onItemFocus: function(e) {
      var item = e.target;
      if (item === e.matchedTarget) {
        this._setTabbableItem(item);

        // Remember the focused item and a sibling for the case when the currently focused item is removed and another
        // item has to be selected in _doLayout
        this._focusedItem = item;
        this._focusedItemNext = [item.nextElementSibling, item.previousElementSibling].filter(itemFilter)[0];
      }
    },

    /** @private */
    _setTabbableItem: function(item) {
      if (this._tabbableItem) {
        this._tabbableItem._setTabbable(false);
      }
      if (item) {
        item._setTabbable(true);
      }
      this._tabbableItem = item;
    },

    /** @private */
    _updateDragActions: function() {
      var items = this.items.getAll();
      for (var i = 0; i < items.length; i++) {
        items[i]._updateDragAction(this.orderable);
      }
    },

    /** @private */
    _onItemDragStart: function(e) {
      var item = e.target;
      if (item === e.matchedTarget) {
        this._layout.detach(item);
        item._oldBefore = getPreviousItem(item);

        var placeholder = item._dropPlaceholder = new Coral.Masonry.Item();

        // Add a content div with the right dimension instead of setting the dimension on the item directly. This is
        // necessary because some layouts modify the dimensions as well.
        var contentDiv = document.createElement('div');
        contentDiv.style.width = item.clientWidth + 'px';
        contentDiv.style.height = item.clientHeight + 'px';
        placeholder.appendChild(contentDiv);

        // Insert placeholder before dragged item
        placeholder.classList.add('coral3-Masonry-item--placeholder');
        this.insertBefore(placeholder, item);
      }
    },

    /** @private */
    _onItemDragMove: function(e) {
      var item = e.target;
      var placeholder = item._dropPlaceholder;
      if (item === e.matchedTarget && placeholder) {
        var prevPos = item._prevDragPos;
        var pos = relativePosition(this, item);
        // If the current move is approaching the previous placeholder target, then it must not move the placeholder
        // again. Otherwise it can happen with multi-column items that the items jump around hectically while dragging
        // an item.
        if (!prevPos || !this._isApproachingPlaceholder(pos, prevPos, placeholder)) {
          // Find item below cursor
          var itemBelow = this._layout.itemAt(pos.left, pos.top);
          if (itemBelow && itemBelow !== placeholder) {

            // If the item below (the dragged item) is preceding the placeholder, then it has to insert the placeholder
            // before the item below (the dragged item)
            if (placeholder.compareDocumentPosition(itemBelow) & document.DOCUMENT_POSITION_PRECEDING) {
              itemBelow.parentNode.insertBefore(placeholder, itemBelow);
            }
            else {
              itemBelow.parentNode.insertBefore(placeholder, itemBelow.nextSibling);
            }
          }
        }
        item._prevDragPos = pos;
      }
    },

    /**
      @return {Boolean} true if the new position isn't further away from the center of the placeholder than the
      previous position.

      @private
     */
    _isApproachingPlaceholder: function(pos, prevPos, placeholder) {
      var placeholderPos = relativePosition(this, placeholder);
      var placeholderWidth = placeholder.offsetWidth;
      var placeholderHeight = placeholder.offsetHeight;
      var placeholderX = placeholderPos.left + placeholderWidth / 2;
      var placeholderY = placeholderPos.top + placeholderHeight / 2;
      // A weighted distance is used to improve the user experience with rather long/high cards
      return weightedDistance(placeholderX, placeholderY, pos.left, pos.top, placeholderWidth, placeholderHeight) <=
        weightedDistance(placeholderX, placeholderY, prevPos.left, prevPos.top, placeholderWidth, placeholderHeight);
    },

    /** @private */
    _onItemDragEnd: function(e) {
      var item = e.target;
      var placeholder = item._dropPlaceholder;
      if (item === e.matchedTarget && placeholder) {
        // Replace the drop placeholder with this item
        this.replaceChild(item, placeholder);

        // Trigger order event
        item.trigger('coral-masonry:order', {
          item: item,
          oldBefore: item._oldBefore,
          before: getPreviousItem(item)
        }, true, false);

        // Drop transition
        this._layout.reattach(item);
        item.classList.add('is-dropping');
        Coral.commons.transitionEnd(item, function() {
          item.classList.remove('is-dropping');
        });
      }
      item._oldBefore = null;
      item._dropPlaceholder = null;
      item._prevDragPos = null;
    }

    /**
      Triggered when an item is reordered.

      @event Coral.Masonry#coral-masonry:order

      @param {Object} event
        Event object
      @param {Coral.Masonry.Item} event.detail.item
        The reordered item
      @param {?Coral.Masonry.Item} event.detail.oldBefore
        The previous item before the reordering.
      @param {?Coral.Masonry.Item} event.detail.before
        The previous item after the reordering.
     */

  });

  /**
   * Returns the position of the second element relative to the first element.
   */
  function relativePosition(el1, el2) {
    var rect1 = el1.getBoundingClientRect();
    var rect2 = el2.getBoundingClientRect();
    return {
      left: rect2.left - rect1.left,
      top: rect2.top - rect1.top
    };
  }

  function weightedDistance(x1, y1, x2, y2, unitWidth, unitHeight) {
    return Math.sqrt(Math.pow((x2 - x1) / unitWidth, 2) + Math.pow((y2 - y1) / unitHeight, 2));
  }

  function getPreviousItem(item) {
    var previousItem = item.previousElementSibling;
    return itemFilter(previousItem) ? previousItem : null;
  }

  /**
    Base class for masonry layouts.

    Whenever a change is detected, the {@link Coral.Masonry.Layout#layout} method is called. This method must then
    ensure that all the items are positioned correctly.

    Layout-specific keyboard support must be handled by adding event listeners to the masonry in the constructor. Such
    event listeners must be removed in the {@link Coral.Masonry.Layout#destroy} method.

    @param masonry
    @class Coral.Masonry.Layout
   */
  function Layout(masonry) {
    this._masonry = masonry;
  }
  Layout.prototype = {
    /**
      Lays out the masonry items according to the implementation.
     */
    layout: function() {},

    /**
      Removes all layout-specific attributes, style, data and event listeners from the masonry and its items.
     */
    destroy: function() {},

    /**
      Removes the item from the control of the layout. This can be used to position the item differently,
      for example for drag&drop.

      @param {Coral.Masonry.Item} item
      @see #reattach
     */
    detach: function(item) {},

    /**
      Adds the item to the control of the layout again. The layout has to ensure that the item will be transitioned to
      its normal position flawlessly.

      @param {Coral.Masonry.Item} item
      @see #detach
     */
    reattach: function(item) {},

    /**
      Returns the item at the given position. The position coordinates are relative to the masonry.

      If an item is being transitioned when this method is called, then it must choose the item based on the final
      instead of the current position.

      @param {number} x
      @param {number} y
      @return {?Coral.Masonry.Item}
     */
    itemAt: function(x, y) {}

  };
  Coral.Masonry.Layout = Layout;

  /**
    Registry for masonry layouts.

    @type {Object.<string,Layout>}
    @private
   */
  Coral.Masonry._layouts = {};

  /**
    Registers a layout with the given name.
    The name can then be set at {@link Coral.Masonry.layout} to render a masonry with the this registered layout.

    @param {String} name the lower case name of the layout
    @param {Layout} Layout class which extends {@link Layout}
   */
  Coral.Masonry.registerLayout = function(name, Layout) {
    Layout.prototype.name = name;
    Coral.Masonry._layouts[name] = Layout;
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Masonry.Item# */ {
    /**
      @class Coral.Masonry.Item
      @classdesc A masonry item component
      @extends Coral.Component
      @htmltag coral-masonry-item
    */
    name: 'Masonry.Item',
    tagName: 'coral-masonry-item',
    className: 'coral3-Masonry-item',
    properties: {

      /**
        Item content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Masonry.Item#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      },

      /** @private */
      '_removing': {
        default: false,
        sync: function() {
          this.classList.toggle('is-removing', this._removing);
        }
      },

      /**
        Whether the item is selected.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Masonry.Item#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle('is-selected', this.selected);
          this.setAttribute('aria-selected', this.selected);
        }
      }
    },

    /** @ignore */
    _initialize: function() {
      this._masonry = null; // Represents ownership (necessary when the item is moved which triggers callbacks)
      this.setAttribute('tabindex', '-1'); // Make programmatically focusable
      this._dragAction = null;
    },

    /** @private */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      if (!this._removing) {
        var newMasonry = this.parentNode;
        if (newMasonry && newMasonry.tagName === 'CORAL-MASONRY' && newMasonry !== this._masonry) { // check if just moving
          this._masonry = newMasonry;

          // Insert animation start style. This is separated from _insert because otherwise we would have to enforce a
          // reflow between changing the classes for every item (which is slow).
          this.classList.add('is-beforeInserting');

          newMasonry._onItemAdded(this);
        }
      }
    },

    /**
      Animates the insertion of the item.

      @private
     */
    _insert: function() {
      if (this.classList.contains('is-beforeInserting')) {
        this.classList.remove('is-beforeInserting');
        this.classList.add('is-inserting');
        Coral.commons.transitionEnd(this, function() {
          this.classList.remove('is-inserting');
        }.bind(this));
      }
    },

    /** @private */
    detachedCallback: function() {
      if (!this.parentNode) { // check if item is being from document
        var masonry = this._masonry;
        if (!this._removing && masonry) {
          // Attach again for remove transition
          this._removing = true;
          masonry.appendChild(this);
          Coral.commons.transitionEnd(this, function() {
            this.remove();
          }.bind(this));
        }
        else { // remove transition completed
          this._removing = false;
          this._masonry = null;
          if (masonry) {
            masonry._onItemRemoved(this);
          }
        }
      }

      Coral.Component.prototype.detachedCallback.call(this);
    },

    /** @private */
    _setTabbable: function(tabbable) {
      this.setAttribute('tabindex', tabbable ? 0 : -1);
    },

    /** @private */
    _updateDragAction: function(enabled) {
      var handle;
      if (enabled) {
        // Find handle
        if (this.getAttribute('coral-masonry-draghandle') !== null) {
          handle = this;
        }
        else {
          handle = this.querySelector('[coral-masonry-draghandle]');
          if (!handle) {
            enabled = false; // Disable drag&drop if handle wasn't found
          }
        }
      }
      if (enabled) {
        if (!this._dragAction) {
          this._dragAction = new Coral.DragAction(this);
          this._dragAction.dropZone = this.parentNode;
        }
        this._dragAction.handle = handle;
      }
      else {
        if (this._dragAction) {
          this._dragAction.destroy();
          this._dragAction = null;
        }
      }
    }
  });

}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  function csspx(el, property) {
    return parseFloat(window.getComputedStyle(el)[property], 10);
  }

  // TODO if the property changes, it will not automatically relayout the masonry
  // TODO test columnWidth and colspan property and default values
  function getPositiveNumberProperty(element, property, attribute, defaultValue) {
    var value = element[property];
    if (value === undefined) {
      value = element.getAttribute(attribute);
    }
    value = parseInt(value, 10);
    if (value <= 0 || isNaN(value)) {
      value = defaultValue;
    }
    return value;
  }

  /**
    Base class for column-based masonry layouts.

    @class
    @extends Coral.Masonry.Layout
   */
  function ColumnLayout(masonry) {
    Coral.Masonry.Layout.apply(this, arguments);
    this._columns = [];

    var up = this._moveFocusVertically.bind(this, true);
    var down = this._moveFocusVertically.bind(this, false);
    var left = this._moveFocusHorizontally.bind(this, true);
    var right = this._moveFocusHorizontally.bind(this, false);
    var home = this._moveFocusHomeEnd.bind(this, true);
    var end = this._moveFocusHomeEnd.bind(this, false);

    var keys = this._keys = new Coral.Keys(masonry, {
      context: this
    });
    keys.on('up', up).on('k', up);
    keys.on('down', down).on('j', down);
    keys.on('left', left).on('h', left);
    keys.on('right', right).on('l', right);
    keys.on('home', home);
    keys.on('end', end);
  }
  ColumnLayout.prototype = Coral.commons.extend(Object.create(Coral.Masonry.Layout.prototype), {

    /** @inheritdoc */
    layout: function(secondTry) {
      var masonry = this._masonry;

      var items = masonry.items.getAll();
      if (items.length > 0) {
        // For best possible performance none of these function calls must both read and write attributes in a loop to
        // avoid unnecessary reflows.
        this._init(items);
        this._writeStyles(items);
        this._readStyles(items);
        this._positionItems(items);
      }
      else {
        this._columns.length = 0;
      }

      // Update the height of the masonry (otherwise it has a height of 0px due to the absolutely positioned items)
      var contentHeight = this._getContentHeight();
      masonry.style.height = (contentHeight - this._verSpacing + this._verPadding) + 'px';

      // Check if the masonry has changed its width due to the changed height (can happen because of appearing/disappearing scrollbars)
      if (!secondTry && this._masonryInnerWidth !== masonry.clientWidth) {
        this.layout(true);
      }
      else {
        // Post layout hook for sub classes
        this._postLayout(contentHeight);
      }
    },

    /**
      Initialize layout variables.

      @private
     */
    _init: function(items) {
      var firstItem = items[0];
      var masonry = this._masonry;
      this._columnWidth = getPositiveNumberProperty(masonry, 'columnWidth', 'columnwidth', 200);

      this._zeroOffsetLeft = -csspx(firstItem, 'marginLeft');
      this._masonryInnerWidth = masonry.clientWidth; // with padding

      var spacing = this._masonry.spacing;
      if (typeof spacing === 'number') {
        this._horSpacing = spacing;
        this._verSpacing = spacing;
        this._offsetLeft = spacing + this._zeroOffsetLeft;
        this._offsetTop = spacing - csspx(firstItem, 'marginTop');
        this._verPadding = 2 * spacing;
        this._masonryAvailableWidth = masonry.clientWidth - spacing;
      }
      else {
        this._horSpacing = csspx(firstItem, 'marginLeft') + csspx(firstItem, 'marginRight');
        this._verSpacing = csspx(firstItem, 'marginTop') + csspx(firstItem, 'marginBottom');
        this._offsetLeft = csspx(masonry, 'paddingLeft');
        this._offsetTop = csspx(masonry, 'paddingTop');
        this._verPadding = this._offsetTop + this._verSpacing + csspx(masonry, 'paddingBottom');
        this._masonryAvailableWidth = masonry.clientWidth - this._offsetLeft - csspx(masonry, 'paddingRight');
      }

      // Initialize column objects
      var columnCount = Math.max(1, Math.floor(this._masonryAvailableWidth / (this._columnWidth + this._horSpacing)));
      this._columns.length = columnCount;
      for (var ci = 0; ci < columnCount; ci++) {
        this._columns[ci] = {
          height: this._offsetTop,
          items: []
        };
      }

      // Prepare layout data
      for (var ii = 0; ii < items.length; ii++) {
        var item = items[ii];

        var layoutData = item._layoutData;
        if (!layoutData) {
          item._layoutData = layoutData = {};
        }

        // Read colspan
        layoutData.colspan = Math.min(getPositiveNumberProperty(item, 'colspan', 'colspan', 1), this._columns.length);
      }
    },

    /**
      Updates the width of all items.

      @param items
      @private
     */
    _writeStyles: function(items) {
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var layoutData = item._layoutData;

        // Update width
        var itemWidth = Math.round(this._getItemWidth(layoutData.colspan));
        if (layoutData.width !== itemWidth) {
          item.style.width = itemWidth + 'px';
          layoutData.width = itemWidth;
        }
        this._writeItemStyle(item);
      }
    },

    /**
      @param colspan column span of the item
      @return the width of the item for the given colspan
      @private
     */
    _getItemWidth: function(colspan) {},

    /**
      Hook to execute layout specific item preparation.

      @param item
      @private
     */
    _writeItemStyle: function(item) {},

    /**
      Reads the dimension of all items.

      @param items
      @private
     */
    _readStyles: function(items) {
      // Record size of items in a separate loop to avoid unneccessary reflows
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var layoutData = item._layoutData;
        layoutData.height = Math.round(item.getBoundingClientRect().height);
        layoutData.ignored = layoutData.detached || !item.offsetParent;
      }
    },

    /**
      Update the position of all items.

      @param items
      @private
     */
    _positionItems: function(items) {
      var j;

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var layoutData = item._layoutData;
        if (layoutData.ignored) { // Skip ignored items
          continue;
        }

        // Search for column with the least height
        var maxLength = this._columns.length - (layoutData.colspan - 1);
        var minColumnIndex = -1;
        var minColumnHeight;
        for (j = 0; j < maxLength; j++) {
          var columnHeight = this._offsetTop; // can be negative if set spacing < item css margin
          for (var y = 0; y < layoutData.colspan; y++) {
            columnHeight = Math.max(columnHeight, this._columns[j + y].height);
          }
          if (minColumnIndex === -1 || columnHeight < minColumnHeight) {
            minColumnIndex = j;
            minColumnHeight = columnHeight;
          }
        }

        var top = minColumnHeight;
        var left = Math.round(this._getItemLeft(minColumnIndex));

        // Check if position has changed
        if (layoutData.left !== left || layoutData.top !== top) {
          layoutData.columnIndex = minColumnIndex;
          layoutData.itemIndex = this._columns[minColumnIndex].items.length;
          layoutData.left = left;
          layoutData.top = top;

          setTransform(item, 'translate(' + left + 'px, ' + top + 'px)');
        }

        // Remember new column height to position all other items
        var newColumnHeight = top + layoutData.height + this._verSpacing;
        for (j = 0; j < layoutData.colspan; j++) {
          var column = this._columns[minColumnIndex + j];
          column.height = newColumnHeight;
          column.items.push(item);
        }
      }
    },

    /**
      @param columnIndex
      @return the left position for the given column index
      @private
     */
    _getItemLeft: function(columnIndex) {},

    /**
      @returns {number} the height of the content (independent of the current gird container height)
      @private
     */
    _getContentHeight: function() {
      return this._columns.reduce(function(height, column) {
          return Math.max(height, column.height);
        }, 0) - this._offsetTop;
    },

    /**
      Hook which is called after the positioning is done.

      @param contentHeight
      @private
     */
    _postLayout: function(contentHeight) {},

    /**
      Moves the focus vertically.

      @private
     */
    _moveFocusVertically: function(up, event) {
      var currentLayoutData = event.target._layoutData;
      if (!currentLayoutData) {
        return;
      }

      // Choose item above or below
      var nextItemIndex = currentLayoutData.itemIndex + (up ? -1 : 1);
      var nextItem = this._columns[currentLayoutData.columnIndex].items[nextItemIndex];

      if (nextItem) {
        nextItem.focus();
        event.preventDefault(); // prevent scrolling at the same time
      }
    },

    /**
      Moves the focus horizontally.

      @private
     */
    _moveFocusHorizontally: function(left, event) {
      var currentLayoutData = event.target._layoutData;
      if (!currentLayoutData) {
        return;
      }

      var nextItem;

      // Choose item on the left or right which overlaps the most with the current item
      var nextColumnIndex = currentLayoutData.columnIndex + (left ? -1 : currentLayoutData.colspan);
      var nextColumn = this._columns[nextColumnIndex];
      if (nextColumn) {
        var currentItemBottom = currentLayoutData.top + currentLayoutData.height;
        var nextItemOverlap = 0;

        // Iterate through all items in the bordering column and look for the item which overlaps the most
        for (var i = 0; i < nextColumn.items.length; i++) {
          var item = nextColumn.items[i];
          var layoutData = item._layoutData;
          var itemBottom = layoutData.top + layoutData.height;

          // Check if items overlap
          if (currentLayoutData.top <= itemBottom && currentItemBottom >= layoutData.top) {
            // Calculate the overlapping height
            var itemOverlap = (currentLayoutData.height - Math.max(0, layoutData.top - currentLayoutData.top) -
              Math.max(0, currentItemBottom - itemBottom)) / layoutData.height; // relative overlap with current item
            if (itemOverlap > nextItemOverlap) {
              nextItemOverlap = itemOverlap;
              nextItem = item;
            }
          }
          else if (currentLayoutData.top + currentLayoutData.height < layoutData.top) {
            // Item is too far below, stop searching
            break;
          }
        }
      }

      if (nextItem) {
        nextItem.focus();
        event.preventDefault(); // prevent scrolling at the same time
      }
    },

    /**
      Moves the focus to first or last item based on the visual order.

      @private
     */
    _moveFocusHomeEnd: function(home, event) {
      var currentLayoutData = event.target._layoutData;
      if (!currentLayoutData) {
        return;
      }

      var nextItem;
      var columns = this._columns;

      // when home is pressed, we take the first item of the first column
      if (home) {
        nextItem = columns[0] && columns[0].items[0];
      }
      else {
        // when end is pressed, we take the last item of the last column; since some columns are empty, we need to
        // iterate backwards to find the first column that has items
        for (var i = columns.length - 1; i > -1; i--) {
          // since we found a column with items, we take the last item as the next one
          if (columns[i].items.length > 0) {
            nextItem = columns[i].items[columns[i].items.length - 1];
            break;
          }
        }
      }

      if (nextItem) {
        nextItem.focus();
        // we prevent the scrolling
        event.preventDefault();
      }
    },

    /** @inheritdoc */
    destroy: function() {
      this._keys.destroy();

      var items = this._masonry.items.getAll();
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        delete item._layoutData;
        setTransform(item, '');
        this._resetItem(item);
      }
    },

    /**
      Hook to remove layout specific style and data from the item.

      @param item
      @private
     */
    _resetItem: function(item) {},

    /** @inheritdoc */
    detach: function(item) {
      item._layoutData.detached = true;
    },

    /** @inheritdoc */
    reattach: function(item) {
      var layoutData = item._layoutData;
      layoutData.detached = false;
      var rect = item.getBoundingClientRect();
      setTransition(item, 'none'); // Disable transition while repositioning
      item.style.left = '';
      item.style.top = '';
      setTransform(item, '');
      var nullRect = item.getBoundingClientRect();
      layoutData.left = rect.left - nullRect.left;
      layoutData.top = rect.top - nullRect.top;
      setTransform(item, 'translate(' + layoutData.left + 'px, ' + layoutData.top + 'px)');
      item.getBoundingClientRect(); // Enforce position
      setTransition(item, ''); // Enable transition again
    },

    /** @inheritdoc */
    itemAt: function(x, y) {
      // TODO it would be more efficient to pick first the right column
      var items = this._masonry.items.getAll();
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var layoutData = item._layoutData;
        if (layoutData && !layoutData.ignored && (
          layoutData.left <= x && layoutData.left + layoutData.width >= x &&
          layoutData.top <= y && layoutData.top + layoutData.height >= y)) {
          return item;
        }
      }

      return null;
    }
  });

  function getFirstRowFilledColumns(columns, items) {
    var filledColumns = 0;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      filledColumns += item._layoutData.colspan;
      if (filledColumns >= columns.length) {
        return columns.length;
      }
    }
    return filledColumns;
  }

  /**
    Layout with fixed width centered items. The width of the items is defined with the <code>columnwidth</code>
    attribute.

    @example
    <coral-masonry layout="fixed-centered" columnwidth="300">

    @param masonry
    @class
    @extends ColumnLayout
   */
  function FixedCenteredColumnLayout(masonry) {
    ColumnLayout.apply(this, arguments);
  }

  FixedCenteredColumnLayout.prototype = Coral.commons.extend(Object.create(ColumnLayout.prototype), {

    /** @inheritdoc */
    _writeStyles: function(items) {
      this._outerColumnWidth = this._columnWidth + this._horSpacing;

      // If the first row isn't filled, then the items will be centered
      var filledColumns = getFirstRowFilledColumns(this._columns, items);
      this._offsetLeft += (this._masonryAvailableWidth - filledColumns * this._outerColumnWidth) / 2;

      ColumnLayout.prototype._writeStyles.apply(this, arguments);
    },

    /** @inheritdoc */
    _getItemWidth: function(colspan) {
      return this._columnWidth * colspan + this._horSpacing * (colspan - 1);
    },

    /** @inheritdoc */
    _getItemLeft: function(columnIndex) {
      return this._offsetLeft + (this._outerColumnWidth * columnIndex);
    }
  });

  Coral.Masonry.registerLayout('fixed-centered', FixedCenteredColumnLayout);

  /**
    Layout with fixed width and evenly spread items. The width of the items is defined with the <code>columnwidth</code>
    attribute.

    @example
    <coral-masonry layout="fixed-spread" columnwidth="300">

    @param masonry
    @class
    @extends ColumnLayout
   */
  function FixedSpreadColumnLayout(masonry) {
    ColumnLayout.apply(this, arguments);
  }

  FixedSpreadColumnLayout.prototype = Coral.commons.extend(Object.create(ColumnLayout.prototype), {

    /** @inheritdoc */
    _writeStyles: function(items) {
      var columns = this._columns;

      // If the first row is not filled, then the items should be aligned left
      this._alignLeft = getFirstRowFilledColumns(columns, items) < columns.length;
      if (!this._alignLeft) {
        var remainingWidth = this._masonryInnerWidth - this._columnWidth * columns.length;
        this._horSpacing = remainingWidth / (columns.length + 1);
      }

      ColumnLayout.prototype._writeStyles.apply(this, arguments);
    },

    /** @inheritdoc */
    _getItemWidth: function(colspan) {
      return this._columnWidth * colspan + this._horSpacing * (colspan - 1);
    },

    /** @inheritdoc */
    _getItemLeft: function(columnIndex) {
      return this._zeroOffsetLeft + this._columnWidth * columnIndex + this._horSpacing * (columnIndex + 1);
    }
  });

  Coral.Masonry.registerLayout('fixed-spread', FixedSpreadColumnLayout);

  /**
    Layout with variable width items. The minimal width of the items is defined with the <code>columnwidth</code>
    attribute.

    @example
    <coral-masonry layout="variable" columnwidth="300">

    @param masonry
    @class
    @extends ColumnLayout
   */
  function VariableColumnLayout(masonry) {
    ColumnLayout.apply(this, arguments);
  }

  VariableColumnLayout.prototype = Coral.commons.extend(Object.create(ColumnLayout.prototype), {

    /** @inheritdoc */
    _getItemWidth: function(colspan) {
      return this._masonryAvailableWidth / this._columns.length * colspan - this._horSpacing;
    },

    /** @inheritdoc */
    _getItemLeft: function(columnIndex) {
      return this._offsetLeft + this._masonryAvailableWidth * columnIndex / this._columns.length;
    }
  });

  Coral.Masonry.registerLayout('variable', VariableColumnLayout);

  /**
    Layout with variable width items which are expanded in their height to fill gaps (which are common with colspan).
    The minimal width of the items is defined with the <code>columnwidth</code> attribute.

    @example
    <coral-masonry layout="dashboard" columnwidth="300">

    @param masonry
    @class
    @extends VariableColumnLayout
   */
  function DashboardColumnLayout(masonry) {
    VariableColumnLayout.apply(this, arguments);
  }

  DashboardColumnLayout.prototype = Coral.commons.extend(Object.create(VariableColumnLayout.prototype), {

    /** @inheritdoc */
    _writeItemStyle: function(item) {
      // Reset height because otherwise getBoundingClientRect() will not return the real height
      this._resetItem(item);
    },

    /** @inheritdoc */
    _postLayout: function(contentHeight) {
      for (var columnIndex = 0; columnIndex < this._columns.length; columnIndex++) {
        var column = this._columns[columnIndex];
        var nextItemTop = contentHeight + this._offsetTop;

        // Fill gaps by expanding the height of the items
        for (var itemIndex = column.items.length - 1; itemIndex >= 0; itemIndex--) {
          var item = column.items[itemIndex];
          var layoutData = item._layoutData;
          if (layoutData.columnIndex === columnIndex) {
            var expandedHeight = nextItemTop - layoutData.top - this._verSpacing;
            item.style.height = expandedHeight + 'px';
          }
          nextItemTop = layoutData.top;
        }
      }
    },

    /** @inheritdoc */
    _resetItem: function(item) {
      item.style.height = '';
    }
  });

  function setTransform(el, value) {
    el.style.setProperty('-webkit-transform', value);
    el.style.setProperty('-ms-transform', value);
    el.style.transform = value;
  }

  function setTransition(el, value) {
    el.style.setProperty('-webkit-transition', value);
    el.style.setProperty('-ms-transition', value);
    el.style.transition = value;
  }

  Coral.Masonry.registerLayout('dashboard', DashboardColumnLayout);
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Multifield"] = window["Coral"]["templates"]["Multifield"] || {};
window["Coral"]["templates"]["Multifield"]["item"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["remove"] = document.createElement("button","coral-button");
  el0.setAttribute("type", "button");
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("handle", "remove");
  el0.setAttribute("variant", "quiet");
  el0.setAttribute("icon", "delete");
  el0.setAttribute("iconsize", "S");
  el0.className += " coral3-Multifield-remove";
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["move"] = document.createElement("button","coral-button");
  el2.setAttribute("type", "button");
  el2.setAttribute("is", "coral-button");
  el2.setAttribute("handle", "move");
  el2.setAttribute("variant", "quiet");
  el2.setAttribute("icon", "moveUpDown");
  el2.setAttribute("iconsize", "S");
  el2.className += " coral3-Multifield-move";
  frag.appendChild(el2);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var ITEM_TAG_NAME = 'coral-multifield-item';
  var IS_DRAGGING_CLASS = 'is-dragging';
  var IS_AFTER_CLASS = 'is-after';
  var IS_BEFORE_CLASS = 'is-before';
  var TEMPLATE_SUPPORT = 'content' in document.createElement('template');

  // Collection
  var MultifieldCollection = function(options) {
    // calls the 'super' constructor
    Coral.Collection.apply(this, arguments);
  };

  // Assigns the prototype to get access to the Collection signature methods
  MultifieldCollection.prototype = Object.create(Coral.Collection.prototype);

  MultifieldCollection.prototype.add = function(item, insertBefore) {
    // container and itemtagname are the minimum options that need to be provided to automatically handle this function
    if (this._container && this._itemTagName) {
      if (!(item instanceof HTMLElement)) {
        // creates an instance of an item from the object
        item = document.createElement(this._itemTagName).set(item, true);
      }
      
      if (!insertBefore) {
        insertBefore = this.last();
        if (insertBefore) {
          insertBefore = insertBefore.nextElementSibling;
        }
      }

      // inserts the element in the specified container
      this._container.insertBefore(item, insertBefore || this._container.firstChild);

      return item;
    }
  };

  Coral.register( /** @lends Coral.Multifield# */ {
    /**
      @class Coral.Multifield
      @classdesc A Multifield component
      @extends Coral.Component
      @htmltag coral-multifield
    */
    name: 'Multifield',
    tagName: 'coral-multifield',
    className: 'coral3-Multifield',

    events: {
      'coral-dragaction:dragstart coral-multifield-item': '_onDragStart',
      'coral-dragaction:drag coral-multifield-item': '_onDrag',
      'coral-dragaction:dragend coral-multifield-item': '_onDragEnd',

      'click [coral-multifield-add]': '_onAddItemClick',
      'click .coral3-Multifield-remove': '_onRemoveItemClick'
    },

    properties: {
      /**
        The Collection Interface that allows interacting with the Coral.Multifield items that the component contains.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Multifield#
      */
      'items': {
        get: function() {
          if (!this._items) {
            this._items = new MultifieldCollection({
              host: this,
              itemTagName: ITEM_TAG_NAME,
              // allows multifields to be nested
              itemSelector: ':scope > ' + ITEM_TAG_NAME
            });
          }

          return this._items;
        },
        // read-only
        set: function() {}
      },

      /**
        The Multifield template element. It will be used to render a new item once the element with the attribute
        <code>coral-multifield-add</code> is clicked. It supports the <code>template</code> tag. While specifying the
        template from markup, it should include the <code>coral-multifield-template</code> attribute.
        NOTE: On IE11, only <code>template.content</code> is supported to add/remove elements to the template.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Multifield#
      */
      'template': Coral.property.contentZone({
        tagName: 'template',
        handle: 'template',
        insert: function(template) {
          this.appendChild(template);
        },
        set: function(value) {
          // allows non custom elements to behave like a content zone
          if (!value.set) {
            value.set = this._internalTemplateSet;
          }

          // @polyfill IE
          if (!TEMPLATE_SUPPORT) {
            var frag = document.createDocumentFragment();
            while (value.firstChild) {
              frag.appendChild(value.firstChild);
            }
            value.content = frag;
          }
        }
      })
    },

    /** @ignore */
    _onAddItemClick: function(event) {
      var parent = event.target.closest('coral-multifield');
      if (parent && parent === this) {
        this.items.add(new Coral.Multifield.Item());

        this.trigger('change');
      }
    },

    /** @ignore */
    _onRemoveItemClick: function(event) {
      if (event.matchedTarget.parentNode.parentNode === this) {
        event.matchedTarget.parentNode.remove();

        this.trigger('change');
      }
    },

    /** @ignore */
    _onDragStart: function(event) {
      if (event.target.parentNode === this) {
        var dragElement = event.detail.dragElement;
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);
        
        dragElement.classList.add(IS_DRAGGING_CLASS);
        items.forEach(function(item, i) {
          if (i < dragElementIndex) {
            item.classList.add(IS_BEFORE_CLASS);
          }
          else if (i > dragElementIndex) {
            item.classList.add(IS_AFTER_CLASS);
          }
        });
      }
    },

    /** @ignore */
    _onDrag: function(event) {
      if (event.target.parentNode === this) {
        var items = this.items.getAll();
        var marginBottom = 0;
        
        if (items.length) {
          marginBottom = parseFloat(window.getComputedStyle(items[0]).marginBottom);
        }
  
        items.forEach(function(item) {
          if (!item.classList.contains(IS_DRAGGING_CLASS)) {
            var dragElement = event.detail.dragElement;
            var dragElementBoundingClientRect = dragElement.getBoundingClientRect();
            var itemBoundingClientRect = item.getBoundingClientRect();
            var itemOffsetTop = itemBoundingClientRect.top + document.body.scrollTop;
            var isAfter = event.detail.pageY < (itemOffsetTop + itemBoundingClientRect.height / 2);
            var itemReorderedTop = dragElementBoundingClientRect.height + marginBottom + 'px';

            item.classList.toggle(IS_AFTER_CLASS, isAfter);
            item.classList.toggle(IS_BEFORE_CLASS, !isAfter);
            
            if (item.classList.contains(IS_AFTER_CLASS)) {
              item.style.top = items.indexOf(item) < items.indexOf(dragElement) ? itemReorderedTop : '';
            }

            if (item.classList.contains(IS_BEFORE_CLASS)) {
              var afterDragElement = items.indexOf(item) > items.indexOf(dragElement);
              item.style.top = afterDragElement ? '-' + itemReorderedTop : '';
            }
          }
        });
      }
    },

    /** @ignore */
    _onDragEnd: function(event) {
      if (event.target.parentNode === this) {
        var dragElement = event.detail.dragElement;
        var items = this.items.getAll();
        var beforeArr = [];
        var afterArr = [];
        
        items.forEach(function(item) {
          if (item.classList.contains(IS_AFTER_CLASS)) {
            afterArr.push(item);
          }
          else if (item.classList.contains(IS_BEFORE_CLASS)) {
            beforeArr.push(item);
          }
          
          item.classList.remove(IS_DRAGGING_CLASS, IS_AFTER_CLASS, IS_BEFORE_CLASS);
          item.style.top = '';
          item.style.position = '';
        });
        
        var before = afterArr.shift();
        var after = beforeArr.pop();

        if (before) {
          this.insertBefore(dragElement, before);
          this.trigger('change');
        }
        if (after) {
          this.insertBefore(dragElement, after.nextElementSibling);
          this.trigger('change');
        }
      }
    },

    /** @ignore */
    _render: function() {
      // Tells the collection to automatically detect the items and handle the events
      this.items._startHandlingItems();
  
      // Fetch the template content zone element (support nested multifield)
      // The id is generated by Coral.Collection
      var template = this.querySelector('#'+ this.id +' > template[coral-multifield-template]');

      // Create the template content zone elements if not found and add it to the frag
      if (!template) {
        template = document.createElement('template');
        template.setAttribute('coral-multifield-template', '');
        this.appendChild(template);
      }

      // allows non custom elements to behave like a content zone
      if (!template.set) {
        template.set = this._internalTemplateSet;
      }

      // Assign the content zones, moving them into place in the process
      this.template = template;
    },

    /**
      Register a set function that allows the given tag to behave like a Coral.Component. This allows setting values
      using the set notation.

      @param {Object} properties
        An object with key:value pairs of the properties to assign.

      @private
    */
    _internalTemplateSet: function(properties) {
      var property;
      var value;

      // Set a map of properties
      for (property in properties) {
        value = properties[property];

        this[property] = value;
      }
    },
    
    /** @private */
    _renderTemplate: function(item) {
      // Insert the template if item content is empty
      if (!item.content.firstChild) {
        // @polyfill IE
        if (!TEMPLATE_SUPPORT) {
          // Before cloning, put the nested templates content back in the DOM
          var nestedTemplates = this.template.content.querySelectorAll('template[coral-multifield-template]');
          Array.prototype.forEach.call(nestedTemplates, function(template) {
            while (template.content.firstChild) {
              template.appendChild(template.content.firstChild);
            }
          });
        }
        
        // Clone the template and append it to the item content
        item.content.appendChild(document.importNode(this.template.content, true));
      }
    },

    /** @ignore */
    _initialize: function() {
      var self = this;
      self.setAttribute('role', 'list');
      
      var handleItems = function(item) {
        self._renderTemplate(item);
      };
      
      // Move nodes added to the <template> to its content fragment
      self._observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];
            var template = self.template;
            
            if (template.contains(addedNode) && template !== addedNode) {
              // Move the node to the template content
              template.content.appendChild(addedNode);
              // Update all items content with the template content
              self.items.getAll().forEach(handleItems);
            }
  
            // Update the item content with the template content
            if (addedNode.tagName && addedNode.tagName.toLowerCase() === ITEM_TAG_NAME && addedNode.parentNode === self) {
              self._renderTemplate(addedNode);
            }
          }
        });
      });

      // Watch for changes to the template element
      self._observer.observe(self, {
        childList: true,
        subtree: true
      });
  
      // Update all items content with the template content
      Coral.commons.ready(self, function() {
        self.items.getAll().forEach(handleItems);
      });
    }

    /**
      Triggered when the items are reordered/added/removed and when item fields are updated.

      @event Coral.Multifield#change

      @param {Object} event
        Event object
    */
  });

  Coral.register( /** @lends Coral.Multifield.Item# */ {
    /**
      @class Coral.Multifield.Item
      @classdesc A Multifield item component
      @extends Coral.Component
      @htmltag coral-multifield-item
    */
    name: 'Multifield.Item',
    tagName: 'coral-multifield-item',
    className: 'coral3-Multifield-item',

    properties: {
      /**
        The item content.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Multifield.Item#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-multifield-item-content',
        defaultContentZone: true,
        insert: function(content) {
          // Insert the content zone before the move and remove buttons
          this.insertBefore(content, this.firstChild);
        }
      })
    },

    /** @ignore */
    _render: function() {
      var move = this.querySelector('[handle="move"]');
      var remove = this.querySelector('[handle="remove"]');
      var content = this.querySelector('coral-multifield-item-content');
      
      // In case it was rendered just assign the elements
      if (move && remove && content) {
        this._elements.move = move;
        this._elements.remove = remove;
        this.content = content;
      }
      else {
        // Create a temporary fragment
        var fragment = document.createDocumentFragment();
  
        // Query/create content element
        content = content ||
          document.createElement('coral-multifield-item-content');
  
        // Move all into the content element
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
  
        // Add multifield item template
        fragment.appendChild(Coral.templates.Multifield.item.call(this._elements));
  
        // Assign the content zones, moving them into place in the process
        this.content = content;
  
        // Add the frag to the component
        this.appendChild(fragment);
      }
    },

    /** @ignore */
    _initialize: function() {
      this.setAttribute('role', 'listitem');
  
      // Attach drag events
      var dragAction = new Coral.DragAction(this);
      dragAction.axis = 'vertical';
      dragAction.handle = this._elements.move;
    }
  });

  /**
    @class Coral.Multifield.Item.Content
    @classdesc The Multifield item content
    @htmltag coral-multifield-item-content
    @extends HTMLElement
  */
  Coral.Multifield.Item.Content = function() {
    return document.createElement('coral-multifield-item-content');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-numberinput"] = {"en-US":{"Decrement":"Decrement","Increment":"Increment"},"fr-FR":{"Decrement":"Décrémenter","Increment":"Incrémenter"},"de-DE":{"Decrement":"Reduzieren","Increment":"Erhöhen"},"it-IT":{"Decrement":"Decrementare","Increment":"Incrementare"},"es-ES":{"Decrement":"Reducir","Increment":"Aumentar"},"pt-BR":{"Decrement":"Decrementar","Increment":"Incrementar"},"ja-JP":{"Decrement":"減らす","Increment":"増やす"},"ko-KR":{"Decrement":"감소","Increment":"증가"},"zh-CN":{"Decrement":"减量","Increment":"增量"},"zh-TW":{"Decrement":"減量","Increment":"增量"},"nl-NL":{"Decrement":"Verlagen","Increment":"Verhogen"},"da-DK":{"Decrement":"Reduktion","Increment":"Dataændring"},"fi-FI":{"Decrement":"Vähennys","Increment":"Lisäys"},"nb-NO":{"Decrement":"Reduser","Increment":"Øk"},"sv-SE":{"Decrement":"Minskning","Increment":"Ökning"},"cs-CZ":{"Decrement":"Odpočet","Increment":"Přírůstek"},"pl-PL":{"Decrement":"Zmniejsz","Increment":"Zwiększ"},"ru-RU":{"Decrement":"Снижение","Increment":"Прирост"},"tr-TR":{"Decrement":"Azaltma","Increment":"Artırma"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["NumberInput"] = window["Coral"]["templates"]["NumberInput"] || {};
window["Coral"]["templates"]["NumberInput"]["base"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  
  data.uid = Coral.commons.getUID();

  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("span");
  el2.className += " coral-InputGroup-button";
  el2.setAttribute("role", "presentation");
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["stepUp"] = document.createElement("button","coral-button");
  el4.className += " coral3-NumberInput-stepUp";
  el4.setAttribute("type", "button");
  el4.setAttribute("is", "coral-button");
  el4.setAttribute("handle", "stepUp");
  el4.setAttribute("title", Coral["i18n"]["get"]('Increment'));
  el4.setAttribute("aria-label", Coral["i18n"]["get"]('Increment'));
  el4.setAttribute("icon", "chevronUp");
  el4.setAttribute("iconsize", "XS");
  el4.setAttribute("tabindex", "-1");
  el4.setAttribute("aria-controls", data_0["uid"]);
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el2.appendChild(el5);
  var el6 = this["stepDown"] = document.createElement("button","coral-button");
  el6.className += " coral3-NumberInput-stepDown";
  el6.setAttribute("type", "button");
  el6.setAttribute("is", "coral-button");
  el6.setAttribute("handle", "stepDown");
  el6.setAttribute("title", Coral["i18n"]["get"]('Decrement'));
  el6.setAttribute("aria-label", Coral["i18n"]["get"]('Decrement'));
  el6.setAttribute("icon", "chevronDown");
  el6.setAttribute("iconsize", "XS");
  el6.setAttribute("tabindex", "-1");
  el6.setAttribute("aria-controls", data_0["uid"]);
  el2.appendChild(el6);
  var el7 = document.createTextNode("\n  ");
  el2.appendChild(el7);
  var el8 = this["liveregion"] = document.createElement("span");
  el8.setAttribute("role", "presentation");
  el8.setAttribute("handle", "liveregion");
  el8.setAttribute("aria-live", "assertive");
  el8.setAttribute("aria-atomic", "true");
  el8.setAttribute("aria-relevant", "additions text");
  el8.className += " u-coral-screenReaderOnly";
  el8.setAttribute("aria-hidden", "true");
  el2.appendChild(el8);
  var el9 = document.createTextNode("\n");
  el2.appendChild(el9);
  frag.appendChild(el2);
  var el10 = document.createTextNode("\n");
  frag.appendChild(el10);
  var el11 = this["input"] = document.createElement("input","coral-textfield");
  el11.setAttribute("is", "coral-textfield");
  el11.setAttribute("handle", "input");
  el11.setAttribute("type", "number");
  el11.className += " coral3-NumberInput-input coral-InputGroup-input";
  el11.id = data_0["uid"];
  frag.appendChild(el11);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var clearLiveRegionTimeout;
  var LIVEREGION_TIMEOUT_DELAY = 3000;
  var MSPOINTER_TYPE_MOUSE = 0x00000004;
  var flagTouchStart = false;
  var flagStepButtonClick = false;
  
  function handleDecimalOperation(operator, value1, value2) {
    var result = operator === '+' ? value1 + value2 : value1 - value2;
    
    // Check if we have decimals
    if (value1 % 1 !== 0 || value2 % 1 !== 0) {
      var value1Decimal = value1.toString().split('.');
      var value2Decimal = value2.toString().split('.');
      var value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;
      var value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;
      var multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));
      
      // Transform the decimals to integers based on the multiplier
      value1 = Math.round(value1 * multiplier);
      value2 = Math.round(value2 * multiplier);
      
      // Perform the operation on integers values to make sure we don't get a fancy decimal value
      result = operator === '+' ? value1 + value2 : value1 - value2;
      
      // Transform the integer result back to decimal
      result /= multiplier;
    }
    
    return result;
  }

  Coral.register(/** @lends Coral.NumberInput# */{
    /**
      @class Coral.NumberInput
      @classdesc A NumberInput component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-numberinput
    */
    name: 'NumberInput',
    tagName: 'coral-numberinput',
    className: 'coral3-NumberInput coral-InputGroup',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      'key:up': '_onKeyUp',
      'key:pageup': '_onKeyUp',
      'key:down': '_onKeyDown',
      'key:pagedown': '_onKeyDown',
      'key:home': '_onKeyHome',
      'key:end': '_onKeyEnd',
      'touchstart [handle=stepUp], [handle=stepDown]': '_onTouchStart',
      'pointerdown [handle=stepUp], [handle=stepDown]': '_onTouchStart',
      'MSPointerDown [handle=stepUp], [handle=stepUp]': '_onTouchStart',
      'MSPointerDown [handle=stepDown], [handle=stepDown]': '_onTouchStart',

      'click [handle=stepUp]': '_onStepUpButtonClick',
      'click [handle=stepDown]': '_onStepDownButtonClick',

      'mousewheel [handle="input"]': '_onInputMouseWheel',
      'DOMMouseScroll [handle="input"]': '_onInputMouseWheel',

      'capture:focus': '_onFocus',
      'capture:blur': '_onBlur'
    },

    properties: {
      // JSDoc inherited
      'value': {
        transform: function(value) {
          return isNaN(value) ? '' : String(value);
        },
        get: function() {
          return this._elements.input.value;
        },
        set: function(value) {
          // sets the value immediately so it is picked up in form submits
          this._elements.input.value = value;

          // in order to keep the reset value in sync, we need to handle the "value" attribute of the inner input
          var valueAttribute = this.getAttribute('value');
          this._elements.input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
        },
        alsoSync: ['invalid', 'disabled'],
        sync: function() {
          // @a11y: aria-valuetext is used so that VoiceOver does not announce a percentage
          this._elements.input.setAttribute('aria-valuenow', this.value);
          this._elements.input.setAttribute('aria-valuetext', this.value);

          // If the event triggering a value change is a click on a +/- button,
          // announce the new value using the live region.
          if (flagStepButtonClick || !!window.chrome) {
            this._updateLiveRegion(this.value);
          // Otherwise, clear the live region.
          } else {
            this._updateLiveRegion();
          }

          flagStepButtonClick = false;
        }
      },

      /**
        The value returned as a Number. Value is <code>NaN</code> if conversion to Number is not possible.

        @type {Number}
        @default NaN
        @memberof Coral.NumberInput#
      */
      'valueAsNumber': {
        attribute: null,
        transform: Coral.transform.float,
        get: function() {
          return parseFloat(this.value);
        },
        set: function(value) {
          // sets the value immediately so it is picked up in form submits
          this._elements.input.value = value;

          this._queueSync('value', 'invalid', 'disabled');
        }
      },

      /**
        The minimum value for the NumberInput. If a value below the minimum is set, the NumberInput will be marked as
        invalid but the value will be preserved. Stepping down the NumberInput via {@link Coral.NumberInput#stepDown}
        or the decrement button respects the minimum value. It reflects the <code>min</code> attribute to the DOM.

        @type {?Number}
        @default null
        @htmlattribute min
        @htmlattributereflected
        @memberof Coral.NumberInput#
      */
      'min': {
        default: null,
        reflectAttribute: true,
        transform: Coral.transform.number,
        alsoSync: ['invalid', 'disabled'],
        sync: function() {
          if (this.min === null) {
            this._elements.input.removeAttribute('aria-valuemin');
            this._elements.input.removeAttribute('min');
          }
          else {
            // sets the min in the input so that keyboard handles this component
            this._elements.input.setAttribute('aria-valuemin', this.min);
            this._elements.input.min = this.min;
          }
        }
      },

      /**
        The maximum value for the NumberInput. If a value above the maximum is set, the NumberInput will be marked as
        invalid but the value will be preserved. Stepping up the NumberInput via {@link Coral.NumberInput#stepUp} or
        the increment button respects the maximum value. It reflects the <code>max</code> attribute to the DOM.

        @type {?Number}
        @default null
        @htmlattribute max
        @htmlattributereflected
        @memberof Coral.NumberInput#
      */
      'max': {
        default: null,
        reflectAttribute: true,
        transform: Coral.transform.number,
        alsoSync: ['invalid', 'disabled'],
        sync: function() {
          if (this.max === null) {
            this._elements.input.removeAttribute('aria-valuemax');
            this._elements.input.removeAttribute('max');
          }
          else {
            // sets the max in the input so that keyboard handles this component
            this._elements.input.setAttribute('aria-valuemax', this.max);
            this._elements.input.max = this.max;
          }
        }
      },

      /**
        The amount to increment by when stepping up or down. It can be the string <code>any</code> or any positive
        floating point number. If this is not set to <code>any<code>, the control accepts only values at multiples of
        the step value greater than the minimum.

        @type {Number|String}
        @default 1
        @htmlattribute step
        @htmlattributereflected
        @memberof Coral.NumberInput#
      */
      'step': {
        default: 1,
        transform: function(value) {
          return value === 'any' ? value : Coral.transform.number(value);
        },
        validate: [
          Coral.validate.valueMustChange,
          function(newValue, oldValue) {
            // step value has to be a positive number or any
            return newValue !== null && (newValue > 0 || newValue === 'any' );
          }
        ],
        sync: function() {
          this._elements.input.step = this.step;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);

          this._elements.input.disabled = this.disabled;

          this._setButtonState();
        }
      },

      // JSDoc inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);

          this._elements.input.invalid = this.invalid;
        }
      },

      // JSDoc inherited
      'readOnly': {
        sync: function() {
          this._elements.input.readOnly = this.readOnly;

          this._setButtonState();
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this._elements.input.required = this.required;
        }
      },

      // JSDoc inherited
      'labelledBy': {
        sync: function() {
          // in case the user focuses the buttons, he will still get a notion of the usage of the component
          this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);
        }
      },

      /**
        Short hint that describes the expected value of the NumberInput. It is displayed when the NumberInput is empty.

        @type {String}
        @default ""
        @htmlattribute placeholder
        @htmlattributereflected
        @memberof Coral.NumberInput#
      */
      'placeholder': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        get: function() {
          return this._elements.input.placeholder;
        },
        set: function(value) {
          this._elements.input.placeholder = value;
        }
      }
    },

    // overrides the behavior from mixin-formfield
    reset: function() {
      // since there is an internal value, this one handles the reset
      this._elements.input.reset();
    },

    // overrides the behavior from mixin-formfield
    clear: function() {
      // since there is an internal value, this one handles the clear
      this._elements.input.clear();
    },

    /**
      Increments the value by <code>step</code>. If the current value is <code>null</code> or <code>''</code>, it is
      considered as 0. The new value will always respect the <code>min</code> and <code>max</code> values if available.
    */
    stepUp: function() {
      // uses the Number representation since it simplifies the calculations
      var value = this.valueAsNumber;
      var step = this._getActualStep();
      if (isNaN(value)) {
        this.value = this.max !== null ? Math.min(step, this.max) : step;
      }
      else {
        var newValue = handleDecimalOperation('+', value, step);
        this.value = this.max !== null ? Math.min(newValue, this.max) : newValue;
      }
    },

    /**
      Decrements the value by <code>step</code>. If the current value is <code>null</code> or <code>''</code>, it is
      considered as 0. The new value will always respect the <code>min</code> and <code>max</code> values if available.
    */
    stepDown: function() {
      // uses the Number representation since it simplifies the calculations
      var value = this.valueAsNumber;
      var step = this._getActualStep();
      if (isNaN(value)) {
        this.value = this.min !== null ? Math.max(-step, this.min) : -step;
      }
      else {
        var newValue = handleDecimalOperation('-', value, step);
        this.value = this.min !== null ? Math.max(newValue, this.min) : newValue;
      }
    },

    /**
      If the value is 'any' there is no allowed step, that means we incremenet with the default (as if the step was not
      defined).

      @returns {Number} the valid step according to the specs.

      @ignore
    */
    _getActualStep: function() {
      return this.step === 'any' ? this._properties.step.default : this.step;
    },

    /**
      Checks if the current NumberInput is valid or not. This is done by checking that the current value is between the
      provided <code>min</code> and <code>max</code> values. This check is only performed on user interaction.

      @ignore
    */
    _validateInputValue: function() {
      this.invalid = this.value !== '' && (window.isNaN(Number(this.value)) ||
        (this.max !== null && this.value > this.max || this.min !== null && this.value < this.min) ||
        (this.step !== 'any' && this.value % this._getActualStep() !== 0));
    },

    /**
      Sets the correct state of the buttons based on <code>disabled</code>, <code>min</code>, <code>max</code> and
      <code>readOnly</code> properties.

      @ignore
    */
    _setButtonState: function() {
      this._elements.stepUp.disabled = this.disabled || (this.max !== null && this.value >= this.max) || this.readOnly;
      this._elements.stepDown.disabled = this.disabled || (this.min !== null && this.value <= this.min) || this.readOnly;
    },

    /**
      Triggers a change event. This is only done if the provided values are different.

      @param {String} newValue
        The new value of the component.
      @param {String} oldValue
        The old value of the component.

      @private
    */
    _triggerChange: function(newValue, oldValue) {
      // if the underlaying value stayed the same, there no need to trigger an event
      if (newValue !== oldValue) {
        this.trigger('change');
      }
    },

    /**
      Flags a touchstart or pointer event so that we can determine if an event originates from a touch screen interaction
      or from a mouse interaction. An event originating from a mouse interaction should shift the focus to the input,
      while an event originating from a touch interaction should not change the focus. On a touch screen, if the user
      presses the increment or decrement button, focus should not shift to the input and open the software keyboard.

      @ignore
      */
    _onTouchStart: function(event) {
      if (event.type === 'touchstart' ||
          (event.pointerType !== 'mouse' &&
           event.pointerType !== MSPOINTER_TYPE_MOUSE)) {
        flagTouchStart = true;
      }
    },

    /**
      Per WAI-ARIA spinbutton design pattern, http://www.w3.org/TR/wai-aria-practices/#spinbutton, shift focus to the
      input if it does not currently have focus. We make an exception for touch devices, because a better user
      experience is for the focus to remain on an increment or decrement button without shifting focus and opening the
      soft keyboard.

      @ignore
    */
    _setFocusToInput: function() {
      if (!flagTouchStart && document.activeElement !== this._elements.input) {
        this._elements.input.focus();
      }
      flagTouchStart = false;
    },

    /**
      Handles the click on the step up button. It causes the NumberInput to step up its value and returns the focus back
      to the input. This way the clicked button does not get focus.

      @fires Coral.mixin.formField#change
      @ignore
    */
    _onStepUpButtonClick: function(event) {
      event.preventDefault();

      // stores the old value before stepup
      var oldValue = this.value;

      flagStepButtonClick = event.type === 'click';

      this._setFocusToInput();

      this.stepUp();

      // we only do this on user interaction
      this._validateInputValue();

      // checks if we need to trigger a change event
      this._triggerChange(this.value, oldValue);
    },

    /**
      Handles the click on the step down button. It causes the NumberInput to step down its value and returns the focus
      back to the input. This way the clicked button does not get focus.

      @fires Coral.mixin.formField#change
      @ignore
    */
    _onStepDownButtonClick: function(event) {
      event.preventDefault();

      // stores the old value before stepdown
      var oldValue = this.value;

      flagStepButtonClick = event.type === 'click';

      this._setFocusToInput();

      this.stepDown();

      // we only do this on user interaction
      this._validateInputValue();

      // checks if we need to trigger a change event
      this._triggerChange(this.value, oldValue);
    },

    /**
      Handles the home key press. If a max has been set, the value will be modified to match it, otherwise the key is
      ignored.

      @ignore
    */
    _onKeyHome: function(event) {
      event.preventDefault();

      // stops interaction if the numberinput is disabled or readonly
      if (this.disabled || this.readOnly) {
        return;
      }

      // sets the max value only if it exists
      if (this.max !== null) {
        // stores the old value before setting the max
        var oldValue = this.value;

        // When appropriate flagStepButtonClick will trigger a live region update.
        flagStepButtonClick = true;

        this.value = this.max;

        // checks if we need to trigger a change event
        this._triggerChange(this.value, oldValue);
      }

      this._setFocusToInput();
    },

    /**
      Handles the end key press. If a min has been set, the value will be modified to match it, otherwise the key is
      ignored.

      @ignore
    */
    _onKeyEnd: function(event) {
      event.preventDefault();

      // stops interaction if the numberinput is disabled or readonly
      if (this.disabled || this.readOnly) {
        return;
      }

      // sets the min value only if it exists
      if (this.min !== null) {
        // stores the old value before setting the min
        var oldValue = this.value;

        // When appropriate, flagStepButtonClick will trigger a live region update.
        flagStepButtonClick = true;

        this.value = this.min;

        // checks if we need to trigger a change event
        this._triggerChange(this.value, oldValue);
      }

      this._setFocusToInput();
    },

    /**
      Handles the up action by steping up the NumberInput. It prevents the default action.

      @ignore
    */
    _onKeyUp: function(event) {
      event.preventDefault();

      // stops interaction if the numberinput is disabled or readonly
      if (this.disabled || this.readOnly) {
        return;
      }

      this._onStepUpButtonClick(event);
    },

    /**
      Handles the down action by steping down the NumberInput. It prevents the default action.

      @ignore
    */
    _onKeyDown: function(event) {
      event.preventDefault();

      // stops interaction if the numberinput is disabled or readonly
      if (this.disabled || this.readOnly) {
        return;
      }

      this._onStepDownButtonClick(event);
    },

    /**
      Handles the Mousewheel to increment/decrement values.

      @ignore
    */
    _onInputMouseWheel: function(event) {
      // stops interaction if the numberinput is disabled or readonly or is not focused (this is the case where its hovered but not focused)
      if (this.disabled || this.readOnly || this._elements.input !== document.activeElement) {
        return;
      }
  
      // else we prevent the default event like user scrolling the page and handle the mouse wheel input
      event.preventDefault();
      
      // stores the old value to calculate the change
      var oldValue = this.value;

      var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail || event.deltaY)));
      if (delta < 0) {
        this.stepDown();
      }
      else {
        this.stepUp();
      }

      // checks if we need to trigger a change event
      this._triggerChange(this.value, oldValue);
    },

    /**
      Overrides the method from formField to be able to add validation after the user has changed the value.

      @private
    */
    _onInputChange: function(event) {
      // stops the current event
      event.stopPropagation();

      // we only do this on user interaction
      this._validateInputValue();

      // we force the sync of the value,invalid and disabled properties
      this._queueSync('value', 'invalid', 'disabled');

      // we always trigger a change since it came from user interaction
      this.trigger('change');
    },

    /**
      Handles focus event.

      @ignore
    */
    _onFocus: function(event) {
      this.classList.add('is-focused');
      this._elements.input.classList.add('is-focused');
      this._elements.liveregion.removeAttribute('role');
      this._elements.liveregion.removeAttribute('aria-hidden');
    },

    /**
      Handles blur event.

      @ignore
    */
    _onBlur: function(event) {
      // If descendants have lost focus, remove the is-focused class.
      if (!this.contains(document.activeElement)) {
        this.classList.remove('is-focused');
        this._elements.input.classList.remove('is-focused');
      }

      // clear liveregion
      this._elements.liveregion.setAttribute('role', 'presentation');
      this._elements.liveregion.setAttribute('aria-hidden', true);
      this._clearLiveRegion();
    },

    /**
      Modified to target the input instead of the button. This is used by the Coral.mixin.formField to be able to
      properly label the component.

      @private
    */
    _getLabellableElement: function() {
      return this._elements.input;
    },

    /** @ignore */
    _clearLiveRegion: function() {
      var liveregion = this._elements.liveregion;
      if (liveregion.firstChild) {
        liveregion.removeChild(liveregion.firstChild);
      }
    },

    /** @ignore */
    _updateLiveRegion: function (value) {
      var self = this;
      var textNode;

      clearTimeout(clearLiveRegionTimeout);
      this._clearLiveRegion();

      if (value && value !== '') {
        textNode = document.createTextNode(value);
        Coral.commons.nextFrame(function() {
          self._elements.liveregion.appendChild(textNode);
          clearLiveRegionTimeout = setTimeout(self._clearLiveRegion.bind(self),
                                              LIVEREGION_TIMEOUT_DELAY);
        });
      }
    },

    /** @ignore */
    _initialize: function() {
      this.setAttribute('role', 'group');

      if (this._elements.input.type === 'text') {
        this._elements.input.setAttribute('role', 'spinbutton');
      }

      // sets the very initial aria values, in case the 'value' property is never set
      this._elements.input.setAttribute('aria-valuenow', '');
      this._elements.input.setAttribute('aria-valuetext', '');
    },

    /** @ignore */
    _render: function() {
      // clean up
      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }

      this.appendChild(Coral.templates.NumberInput.base.call(this._elements));
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.PanelStack# */ {
    /**
      @class Coral.PanelStack
      @classdesc An PanelStack component
      @htmltag coral-panelstack
      @extends Coral.Component
      @mixes Coral.mixin.selectionList
      @borrows Coral.mixin.selectionList#items as Coral.PanelStack#items
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:add as Coral.PanelStack#coral-collection:add
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:remove as Coral.PanelStack#coral-collection:remove
    */
    name: 'PanelStack',
    tagName: 'coral-panelstack',
    className: 'coral3-PanelStack',

    mixins: [
      Coral.mixin.selectionList({
        itemTagName: 'coral-panel',
        supportMultiple: false,
        forceSelection: false,
        role: 'presentation'
      })
    ],

    properties: {

      /**
        The selected item of the PanelStack.

        @type {HTMLElement}
        @readonly
        @memberof Coral.PanelStack#
      */
      'selectedItem': {
        get: function() {
          return this.items.getLastSelected();
        },
        set: function() {}
      }
    }

    /**
      Triggered when the selected panel has changed.

      @event Coral.PanelStack#coral-panelstack:change

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.selection
        The new selected panel.
      @param {HTMLElement} event.detail.oldSelection
        The prior selected panel.
    */
  });

  Coral.register( /** @lends Coral.Panel */ {
    /**
      @class Coral.Panel
      @classdesc An Item in the PanelStack
      @htmltag coral-panel
      @extends Coral.Component
      @mixes Coral.mixin.selectionList.Item
    */
    name: 'Panel',
    tagName: 'coral-panel',
    className: 'coral3-Panel',

    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-panelstack',
        // removes disabled
        alwaysEnabled: true,
        role: 'tabpanel'
      })
    ],

    properties: {

      /**
        The panelstack items's content element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Panel#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-panel-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        Whether the item is selected. When true, the item will appear as the active element in the PanelStack. The item
        must be a child of a PanelStack before this property is set to true. This property cannot be programmatically set
        to false.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @memberof Coral.Panel#
      */
      'selected': {
        sync: function() {
          this.setAttribute('aria-hidden', !this.selected);
        }
      }
    },

    /** @private */
    _render: function() {
      // Fetch the content zone elements
      var content = this.querySelector('coral-panel-content');

      if (content === null) {
        // Create the content zone elements
        content = document.createElement('coral-panel-content');
        // Finally, move any remaining elements into the content sub-component
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      // Assign the content zone so the insert function will be called
      this.content = content;
    }
  });

  /**
    @class Coral.Panel.Content
    @classdesc A PanelStack Item Content component
    @htmltag coral-panel-content
    @extends HTMLElement
  */
  Coral.Panel.Content = function() {
    return document.createElement('coral-panel-content');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-quickactions"] = {"en-US":{"More actions":"More actions"},"fr-FR":{"More actions":"Autres actions"},"de-DE":{"More actions":"Weitere Aktionen"},"it-IT":{"More actions":"Altre azioni"},"es-ES":{"More actions":"Más acciones"},"pt-BR":{"More actions":"Mais ações"},"ja-JP":{"More actions":"その他のアクション"},"ko-KR":{"More actions":"추가 작업"},"zh-CN":{"More actions":"更多操作"},"zh-TW":{"More actions":"更多動作"},"nl-NL":{"More actions":"Meer acties"},"da-DK":{"More actions":"Flere handlinger"},"fi-FI":{"More actions":"Lisää toimintoja"},"nb-NO":{"More actions":"Flere handlinger"},"sv-SE":{"More actions":"Fler åtgärder"},"cs-CZ":{"More actions":"Další akce"},"pl-PL":{"More actions":"Więcej czynności"},"ru-RU":{"More actions":"Другие действия"},"tr-TR":{"More actions":"Daha fazla işlem"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["QuickActions"] = window["Coral"]["templates"]["QuickActions"] || {};
window["Coral"]["templates"]["QuickActions"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["moreButton"] = document.createElement("button","coral-button");
  el0.className += " coral3-QuickActions-button";
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("type", "button");
  el0.setAttribute("icon", "more");
  el0.setAttribute("iconsize", "S");
  el0.setAttribute("handle", "moreButton");
  el0.setAttribute("title", Coral["i18n"]["get"]('More actions'));
  el0.setAttribute("role", "menuitem");
  el0.setAttribute("aria-haspopup", "true");
  el0.setAttribute("aria-label", Coral["i18n"]["get"]('More actions'));
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["overlay"] = document.createElement("coral-overlay");
  el2.className += " coral3-QuickActions-overlay";
  el2.setAttribute("offset", "5");
  el2.setAttribute("placement", "bottom");
  el2.setAttribute("target", "_prev");
  el2.setAttribute("handle", "overlay");
  frag.appendChild(el2);
  return frag;
});

window["Coral"]["templates"]["QuickActions"]["overlaycontent"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["buttonList"] = document.createElement("coral-buttonlist");
  el0.id = Coral["commons"]["getUID"]();
  el0.className += " coral3-QuickActions-buttonList";
  el0.setAttribute("handle", "buttonList");
  el0.setAttribute("tabindex", "-1");
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Converts a NodeList to an Array.

    @param {NodeList} list
      The NodeList to convert.

    @returns {Array.<Node>} an Array of Nodes.

    @private
  */
  function listToArray(list) {
    for (var res = [], i = 0, listCount = res.length = list.length; i < listCount; i++) {
      res[i] = list[i];
    }
    return res;
  }

  var BUTTON_GAP = 10; // MUST be kept in sync with quickactions.styl $coral-quickactions-button-gap
  var TRANSLATE_DISTANCE = 5; // MUST be kept in sync with quickactions.styl $coral-quickactions-translate-distance
  var BUTTON_FOCUSABLE_SELECTOR = '.coral3-QuickActions-button:not([disabled]):not([hidden])';

  /**
    QuickActions interaction values.

    @enum {String}
    @memberof Coral.QuickActions
  */
  var interaction = {
    /** Show when the target is hovered or focused and hide when the mouse is moved out or focus is lost. */
    ON: 'on',
    /** Do not show or hide automatically. */
    OFF: 'off'
  };

  /**
    QuickActions anchored overlay targets.

    @enum {String}
    @memberof Coral.QuickActions
  */
  var target = {
    /** Use the parent element in the DOM. */
    PARENT: '_parent',
    /** Use the previous sibling element in the DOM. */
    PREVIOUS: '_prev',
    /** Use the next sibling element in the DOM. */
    NEXT: '_next'
  };

  /**
    QuickActions placement values.

    @enum {String}
    @memberof Coral.QuickActions
  */
  var placement = {
    /** QuickActions inset to the top of the target. */
    TOP: 'top',
    /** QuickActions inset to the center of the target. */
    CENTER: 'center',
    /** QuickActions inset to the bottom the target. */
    BOTTOM: 'bottom'
  };

  Coral.register( /** @lends Coral.QuickActions# */ {
    /**
      @class Coral.QuickActions
      @extends Coral.Component
      @extends Coral.Overlay
      @classdesc A QuickActions component.
      @htmltag coral-quickactions
    */
    name: 'QuickActions',
    tagName: 'coral-quickactions',
    className: 'coral3-QuickActions',
    extend: Coral.Overlay,

    /** @protected */
    _overlayAnimationTime: Coral.mixin.overlay.FADETIME,

    events: {
      'global:resize': '_onWindowResize',
      'mouseout': '_onMouseOut',
      'capture:blur': '_onBlur',
      'global:click': '_onGlobalClick',

      // Keyboard interaction
      'global:key:escape': '_onEscapeKeypress',
      'key:home > .coral3-QuickActions-button': '_onHomeKeypress',
      'key:end > .coral3-QuickActions-button': '_onEndKeypress',
      'key:pagedown > .coral3-QuickActions-button': '_onButtonKeypressNext',
      'key:right > .coral3-QuickActions-button': '_onButtonKeypressNext',
      'key:down > .coral3-QuickActions-button': '_onButtonKeypressNext',
      'key:pageup > .coral3-QuickActions-button': '_onButtonKeypressPrevious',
      'key:left > .coral3-QuickActions-button': '_onButtonKeypressPrevious',
      'key:up > .coral3-QuickActions-button': '_onButtonKeypressPrevious',

      // Buttons
      'click > .coral3-QuickActions-button:not([handle="moreButton"])': '_onButtonClick',

      // Overlay
      'coral-overlay:beforeopen': '_onOverlayBeforeOpen',
      'coral-overlay:beforeclose': '_onOverlayBeforeClose',
      'coral-overlay:open': '_onOverlayOpen',
      'coral-overlay:close': '_onOverlayClose',
      'coral-overlay:positioned': '_onOverlayPositioned',

      // ButtonList
      'click [coral-list-item]': '_onButtonListItemClick',

      // Items
      'coral-quickactions-item:_contentchanged': '_onItemChange',
      'coral-quickactions-item:_iconchanged': '_onItemChange',
      'coral-quickactions-item:_hrefchanged': '_onItemChange',
      'coral-quickactions-item:_typechanged': '_onItemTypeChange'
    },

    properties: {
      /**
        The Item collection.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.QuickActions#
      */
      'items': {
        get: function() {
          // we do lazy initialization of the collection
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemTagName: 'coral-quickactions-item',
              onItemRemoved: this._onItemRemoved,
              onCollectionChange: this._onCollectionChange
            });
          }

          return this._items;
        },
        // read-only
        set: function() {}
      },

      /**
        The number of items that are visible in QuickActions (excluding the show more actions button) before a collapse
        is enforced. A value <= 0 disables this feature and shows as many items as possible. Regardless of this
        property, the QuickActions will still fit within their target's width.

        @type {Number}
        @default 4
        @htmlattribute threshold
        @memberof Coral.QuickActions#
      */
      'threshold': {
        default: 4,
        reflectAttribute: true,
        attribute: 'threshold',
        transform: Coral.transform.number
      },

      // JSDoc inherited
      'target': {
        set: function(value) {
          var self = this;
          var target = this._getTarget(value);
          var targetHasChanged = (target !== self._previousTarget);

          if (target && targetHasChanged) {
            // Remove listeners from the previous target
            if (self._previousTarget) {
              var previousTarget = self._getTarget(self._previousTarget);
              if (previousTarget) {
                self._removeTargetEventListeners(previousTarget);
                target.removeAttribute('aria-haspopup');
                target.removeAttribute('aria-owns');
              }
            }

            // Set up listeners for the new target
            self._addTargetEventListeners();

            // Mark the target as owning a popup
            target.setAttribute('aria-haspopup', 'true');
            var ariaOwns = target.getAttribute('aria-owns');
            ariaOwns = (ariaOwns && ariaOwns.length) ? ariaOwns.trim() + ' ' + this.id : this.id;
            target.setAttribute('aria-owns', ariaOwns);

            // Cache for use as previous target
            self._previousTarget = target;
          }
        }
      },

      /**
        Whether the QuickActions should show when the target is interacted with.

        @type {Coral.QuickActions.interaction}
        @default Coral.QuickActions.interaction.ON
        @name interaction
        @htmlattribute interaction
        @memberof Coral.QuickActions#
      */
      'interaction': {
        default: interaction.ON,
        set: function(value) {
          this._interaction = value;

          if (value === interaction.ON) {
            this._addTargetEventListeners();
          }
          else {
            this._removeTargetEventListeners();
          }
        }
      },

      /**
        The point on the QuickActions overlay we should anchor from when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.CENTER_TOP
        @htmlattribute alignmy
        @memberof Coral.QuickActions#
       */
      'alignMy': {
        default: Coral.Overlay.align.CENTER_TOP
      },

      /**
        The point on the target we should anchor to when positioning.

        @type {Coral.Overlay.align}
        @default Coral.Overlay.align.CENTER_TOP
        @htmlattribute alignat
        @memberof Coral.QuickActions#
       */
      'alignAt': {
        default: Coral.Overlay.align.CENTER_TOP
      },

      /**
        The distance the QuickActions should be from the target.

        @type {Number}
        @default 10
        @htmlattribute offset
        @memberof Coral.QuickActions#
      */
      'offset': {
        default: 10
      },

      /**
        The placement of the QuickActions. This property sets {@link Coral.Overlay#alignMy} and
        {@link Coral.Overlay#alignAt}. The value may be one of 'top', 'center' and 'bottom' and indicates the vertical
        alignment of the QuickActions relative to their container.

        @type {Coral.Overlay.placement}
        @default null
        @htmlattribute placement
        @memberof Coral.QuickActions#
      */
      'placement': {
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(placement)
        ],
        set: function(value) {
          var alignValues = this._placementAlignValues[value];

          this.alignMy = alignValues.alignMy;
          this.alignAt = alignValues.alignAt;

          this._placement = value;
        }
      },

      // JSDoc inherited
      'open': {
        sync: function() {
          var self = this;

          if (this.open && !this._openedBefore) {
            // we iterate over all the items initializing them in the correct order
            var items = this.items.getAll();
            for (var i = 0, itemCount = items.length; i < itemCount; i++) {
              this._attachItem(items[i], i);
            }

            this._openedBefore = true;
          }

          var resetMargin = function() {
            // Reset margin following animation
            self.style['marginTop'] = '';
          };

          if (self.open) {
            clearTimeout(this._slideTimeout);
            resetMargin();

            self._layout();

            // We must do the following only after a _layout() otherwise the margin will be considered in the position
            // calculation. We do not want this as we use it to get a sensible starting point for the slide animation.
            self.style['marginTop'] = -TRANSLATE_DISTANCE + 'px';

            Coral.commons.nextFrame(function() {
              // The QuickActions must be visible for us to be able to focus them,
              // this may not be the case if we initially open them, due to the FOUC handling.
              self.style.visibility = 'visible';
              self.focus();
            });
          }
          else {
            Coral.commons.nextFrame(function() {
              if (self._overlayAnimationTime) {
                self._slideTimeout = setTimeout(resetMargin, self._overlayAnimationTime);
              }
              else {
                resetMargin();
              }
            });
          }

          // we toggle "is-selected" on the target to indicate that the over is open
          var target = this._getTarget();
          if (target) {
            target.classList.toggle('is-selected', this.open);
          }
        }
      }
    },

    /** @ignore */
    focus: function() {
      if (this.open && !this.contains(document.activeElement)) {
        var firstFocusableButton = this._getFirstFocusableButton();
        if (firstFocusableButton) {
          firstFocusableButton.focus();
        }
      }
    },

    /** @ignore */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      // We can only take '_prev' or '_next' as target once we have attached
      this.target = this.target;
    },

    /** @ignore */
    _getTarget: function(targetValue) {
      // Use passed target
      targetValue = targetValue || this.target;

      if (targetValue instanceof Node) {
        // Just return the provided Node
        return targetValue;
      }

      // Dynamically get the target node based on target
      var newTarget = null;
      if (typeof targetValue === 'string') {
        if (targetValue === target.PARENT) {
          newTarget = this.parentNode;
        }
        else {
          // Delegate to Coral.Overlay for _prev, _next and general selector
          newTarget = Coral.Overlay.prototype._getTarget.call(this, targetValue);
        }
      }

      return newTarget;
    },

    /** @ignore */
    _addTargetEventListeners: function(target) {
      var self = this;
      var targetElement = (target) ? target : self._getTarget();

      if (!targetElement) {
        return;
      }

      // Interaction-sensitive listeners
      if (self.interaction === interaction.ON) {
        // We do not have to worry about the EventListener being called twice as duplicates are discarded
        targetElement.addEventListener('mouseenter', self._onTargetMouseEnter);
        targetElement.addEventListener('keyup', self._onTargetKeyUp);
        targetElement.addEventListener('keydown', self._onTargetKeyDown);
        targetElement.addEventListener('mouseleave', self._onTargetMouseLeave);
      }
    },

    /** @ignore */
    _removeTargetEventListeners: function(target) {
      var targetElement = (target) ? target : this._getTarget();

      if (!targetElement) {
        return;
      }

      targetElement.removeEventListener('mouseenter', this._onTargetMouseEnter);
      targetElement.removeEventListener('keyup', this._onTargetKeyUp);
      targetElement.removeEventListener('keydown', this._onTargetKeyDown);
      targetElement.removeEventListener('mouseleave', this._onTargetMouseLeave);
    },

    /**
      Toggles whether or not an item is tabbable.

      @param {HTMLElement} item
        The item to process.

      @param {Boolean} tabbable
        Whether the item should be marked tabbable.
      @ignore
    */
    _toggleTabbable: function(item, tabbable) {
      if (item) {
        if (tabbable) {
          if (item.hasAttribute('tabIndex')) {
            item.removeAttribute('tabIndex');
          }
        }
        else {
          item.setAttribute('tabIndex', '-1');
        }
      }
    },

    /**
      Gets the subsequent or previous focusable neighbour relative to an Item button.

      @param {HTMLElement} current
        The current button element from which to find the next selectable neighbour.
      @param {Boolean} [previous]
        Whether to look for a previous neighbour rather than a subsequent one.

      @returns {HTMLElement|undefined} The focusable neighbour. Undefined if no suitable neighbour found.

      @private
    */
    _getFocusableNeighbour: function(current, previous) {
      // we need to convert the result to an array in order to use .indexOf()
      var focusableButtons = listToArray(this._getFocusableButtons());
      var index = focusableButtons.indexOf(current);

      if (index >= 0) {
        if (!previous) {
          // Pick the next focusable button
          if (index < focusableButtons.length - 1) {
            return focusableButtons[index + 1];
          }
        }
        else {
          // Pick the previous focusable button
          if (index !== 0) {
            return focusableButtons[index - 1];
          }
        }
      }
    },

    /**
      Gets the buttons, optionally excluding the more button.

      @param {Boolean} excludeMore
        Whether to exclude the more button.

      @returns {NodeList} The NodeList containing all the buttons.

      @private
    */
    _getButtons: function(excludeMore) {
      var buttonSelector = '.coral3-QuickActions-button';
      buttonSelector = (excludeMore) ? buttonSelector + ':not([handle="moreButton"])' : buttonSelector;

      return this.querySelectorAll(buttonSelector);
    },

    /**
      An element is focusable if it is visible and not disabled.

      @returns {NodeList} A NodeList containing the focusable buttons.

      @private
    */
    _getFocusableButtons: function() {
      // since we use the hidden attribute to hide the items, we can rely on this attribute to determine if the button
      // is hidden, instead of using a more expensive :focusable selector
      return this.querySelectorAll(BUTTON_FOCUSABLE_SELECTOR);
    },

    /**
      Gets the first focusable button.

      @returns {HTMLElement|undefined}
        The first focusable button, undefined if none found.
      @ignore
    */
    _getFirstFocusableButton: function() {
      return this.querySelector(BUTTON_FOCUSABLE_SELECTOR);
    },

    /** @ignore */
    _proxyClick: function(item) {
      var event = item.trigger('click');

      if (!event.defaultPrevented && this.interaction === interaction.ON) {
        this.hide();
      }
    },

    /**
      Gets data from an Item.

      @param {HTMLElement} item
        The Item to get the data from.
      @returns {Object}
        The Item data.
      @ignore
    */
    _getItemData: function(item) {
      return {
        htmlContent: item.innerHTML,
        textContent: item.textContent,
        // fallback to empty string in case it has no icon
        icon: item.getAttribute('icon') || ''
      };
    },

    /** @ignore */
    _attachItem: function(item, index) {
      // since the button has already been initialized we make sure it is up to date
      if (item._elements.button) {
        this._updateItem(item);
        return;
      }

      // if the index was not provided, we need to calculate it
      if (typeof index === 'undefined') {
        index = Array.prototype.indexOf.call(this.items.getAll(), item);
      }

      var itemData = this._getItemData(item);
      var type = Coral.QuickActions.Item.type;

      var button;
      if (item.type === type.BUTTON) {
        button = new Coral.Button().set({
          icon: itemData.icon,
          iconsize: Coral.Icon.size.SMALL,
          type: 'button'
        }, true);
      }
      else if (item.type === type.ANCHOR) {
        button = new Coral.AnchorButton().set({
          icon: itemData.icon,
          iconsize: Coral.Icon.size.SMALL,
          href: item.href
        }, true);
      }

      button.classList.add('coral3-QuickActions-button');
      button.setAttribute('tabindex', '-1');
      button.setAttribute('title', itemData.textContent.trim());
      button.setAttribute('aria-label', itemData.textContent.trim());
      button.setAttribute('role', 'menuitem');

      // 'insertBefore' with an undefined "before" argument fails on IE
      this.insertBefore(button, this.children[index] || null);

      // ButtonList Item
      var buttonListItem;
      if (item.type === type.BUTTON) {
        buttonListItem = new Coral.ButtonList.Item();
      }
      else if (item.type === type.ANCHOR) {
        buttonListItem = new Coral.AnchorList.Item();
        buttonListItem.href = item.href;
      }

      var buttonListItemParent = this._elements.buttonList;

      // 'insertBefore' with an undefined "before" argument fails on IE
      buttonListItemParent.insertBefore(buttonListItem, buttonListItemParent.children[index] || null);
      buttonListItem.tabIndex = -1;
      buttonListItem.content.innerHTML = itemData.htmlContent;
      buttonListItem.icon = itemData.icon;

      item._elements.button = button;
      item._elements.buttonListItem = buttonListItem;
      buttonListItem._elements.quickActionsItem = item;
      button._elements.quickActionsItem = item;
    },

    /**
      Layout calculation; collapses QuickActions as necessary.
    */
    _layout: function() {
      // Set the width of the QuickActions to match that of the target
      this._setWidth();

      var buttons = this._getButtons(true);

      if (!buttons.length) {
        return;
      }

      var buttonListItems = this._elements.buttonList.items.getAll();

      // Temporarily display the QuickActions so we can do the calculation
      var display = this.style.display;
      var temporarilyShown = false;

      if (!this.open) {
        this.style.left -= 10000;
        this.style.top -= 10000;
        this.style.display = 'block';
        temporarilyShown = true;
      }

      var totalAvailableWidth = this.offsetWidth - BUTTON_GAP;
      var buttonMinWidth = window.getComputedStyle(buttons[0], null).getPropertyValue('min-width');
      var buttonWidth = Math.round(parseFloat(buttonMinWidth, 10));
      var buttonOuterWidth = buttonWidth + BUTTON_GAP;
      var totalFittingButtons = 0;
      var widthUsed = 0;

      while (totalAvailableWidth > widthUsed) {
        widthUsed += buttonOuterWidth;

        if (totalAvailableWidth > widthUsed) {
          totalFittingButtons++;
        }
      }

      var handleThreshold = this.threshold > 0;
      var moreButtonsThanThreshold = handleThreshold && (buttons.length > this.threshold);
      var collapse = buttons.length > totalFittingButtons || moreButtonsThanThreshold;

      // +1 to account for the more button
      var collapseToThreshold = collapse && handleThreshold && (this.threshold + 1 < totalFittingButtons);
      var totalButtons = (collapse) ?
        ((collapseToThreshold) ? this.threshold + 1 : totalFittingButtons) : buttons.length;

      // Show all Buttons and ButtonList Items
      for (var i = 0; i < buttons.length; i++) {
        this._toggleTabbable(buttons[i], false);
        buttons[i].show();
        if (buttonListItems[i]) {
          buttonListItems[i].show();
        }
      }

      this._toggleTabbable(this._elements.moreButton, false);

      if (collapse) {
        if (totalButtons > 0) {
          // Hide the buttons we're collapsing
          for (var j = totalButtons - 1; j < buttons.length; j++) {
            buttons[j].hide();
          }

          // Hide the ButtonList items
          for (var k = 0; k < totalButtons - 1; k++) {
            buttonListItems[k].hide();
          }

          // Mark the first button as tabbable
          this._toggleTabbable(buttons[0], true);
        }
        else {
          this._toggleTabbable(this._elements.moreButton, true);
        }

        this._elements.moreButton.show();
      }
      else {
        // Mark the first button as tabbable
        this._toggleTabbable(buttons[0], true);
        this._elements.moreButton.hide();
      }

      // Center the buttons horizontally
      var totalButtonWidth = totalButtons * buttonOuterWidth;
      var shift = Math.round((totalAvailableWidth - totalButtonWidth) / 2);
      this.style['paddingLeft'] = shift + 'px';

      // Reset the QuickActions display if necessary
      if (temporarilyShown) {
        this.style.left += 10000;
        this.style.top += 10000;
        this.style.display = display;
      }

      // Do a reposition of the overlay
      this._position();
    },

    /**
      Sets the width of QuickActions from the target.

      @ignore
    */
    _setWidth: function() {
      var target = this._getTarget();

      if (target) {
        this.style.width = target.offsetWidth + 'px';
      }
    },

    /** @ignore */
    _setButtonListHeight: function() {
      // Set height of ButtonList
      this._elements.buttonList.style.height = '';

      // Measure actual height
      var style = window.getComputedStyle(this._elements.buttonList);
      var height = parseInt(style.height, 10);
      var maxHeight = parseInt(style.maxHeight, 10);

      if (height < maxHeight) {
        // Make it scrollable
        this._elements.buttonList.style.height = height - 1 + 'px';
      }
    },

    /** @ignore */
    _isInternalToComponent: function(element) {
      var target = this._getTarget();

      return element && (this.contains(element) || (target && target.contains(element)));
    },

    /** @ignore */
    _onWindowResize: function() {
      this._layout();
    },

    /** @ignore */
    _onMouseOut: function(event) {
      var toElement = event.toElement || event.relatedTarget;

      // Hide if we mouse leave to any element external to the component and its target
      if (!this._isInternalToComponent(toElement) && this.interaction === interaction.ON) {
        this.hide();
      }
    },

    /** @ignore */
    _onBlur: function(event) {
      var self = this;
      var toElement = event.toElement || event.relatedTarget;

      if (this.interaction === interaction.ON) {
        // In FF toElement is not available to us so we test the newly-focused element
        if (!toElement) {
          // The active element is not ready until the next frame
          Coral.commons.nextFrame(function() {
            toElement = document.activeElement;

            if (!self._isInternalToComponent(toElement)) {
              self.hide();
            }
          });
        }
        else {
          // Hide if we focus out to any element external to the component and its target
          if (!self._isInternalToComponent(toElement)) {
            this.hide();
          }
        }
      }
    },

    /** @ignore */
    _onTargetMouseEnter: function(event) {
      var fromElement = event.fromElement || event.relatedTarget;

      // Open if we aren't already
      if (!this.open && !this._isInternalToComponent(fromElement)) {
        this.show();
      }
    },

    /** @ignore */
    _onTargetKeyUp: function(event) {
      var keyCode = event.keyCode;

      // shift + F10 or ctrl + space (http://www.w3.org/WAI/PF/aria-practices/#popupmenu)
      if (event.shiftKey && keyCode === 121 || event.ctrlKey && keyCode === 32) {
        if (!this.open) {
          if (this.interaction === interaction.ON) {
            // Launched via keyboard and interaction enabled implies a focus trap and return focus.
            // Remember the relevant properties and return their values on hide.
            this._previousTrapFocus = this.trapFocus;
            this._previousReturnFocus = this.returnFocus;
            this.trapFocus = Coral.mixin.overlay.trapFocus.ON;
            this.returnFocus = Coral.mixin.overlay.returnFocus.ON;
          }

          this.show();
        }
      }
    },

    _onTargetKeyDown: function(event) {
      var keyCode = event.keyCode;

      // shift + F10 or ctrl + space (http://www.w3.org/WAI/PF/aria-practices/#popupmenu)
      if (event.shiftKey && keyCode === 121 || event.ctrlKey && keyCode === 32) {
        // Prevent default context menu show or page scroll behaviour
        event.preventDefault();
      }
    },

    /** @ignore */
    _onTargetMouseLeave: function(event) {
      var toElement = event.toElement || event.relatedTarget;

      // Do not hide if we entered the quick actions
      if (!this._isInternalToComponent(toElement)) {
        this.hide();
      }
    },

    /** @ignore */
    _onEscapeKeypress: function(event) {
      if (this.interaction !== interaction.ON) {
        return;
      }

      if (this._elements.overlay.open && this._elements.overlay._isTopOverlay()) {
        this._elements.overlay.hide();
      }
      else if (this.open && this._isTopOverlay()) {
        this.hide();
      }
    },

    /** @ignore */
    _onHomeKeypress: function(event) {
      // prevents the page from scrolling
      event.preventDefault();

      var firstFocusableButton = this._getFirstFocusableButton();

      // Jump focus to the first focusable button
      if (firstFocusableButton) {
        firstFocusableButton.focus();
      }
    },

    /** @ignore */
    _onEndKeypress: function(event) {
      // prevents the page from scrolling
      event.preventDefault();

      var focusableButtons = this._getFocusableButtons();
      var lastFocusableButton = focusableButtons[focusableButtons.length - 1];

      // Jump focus to the last focusable button
      if (lastFocusableButton) {
        lastFocusableButton.focus();
      }
    },

    /** @ignore */
    _onButtonKeypressNext: function(event) {
      event.preventDefault();

      // Handle key presses that imply focus of the next focusable button
      var nextButton = this._getFocusableNeighbour(event.matchedTarget);
      if (nextButton) {
        nextButton.focus();
      }
    },

    /** @ignore */
    _onButtonKeypressPrevious: function(event) {
      event.preventDefault();

      // Handle key presses that imply focus of the previous focusable button
      var previousButton = this._getFocusableNeighbour(event.matchedTarget, true);
      if (previousButton) {
        previousButton.focus();
      }
    },

    /** @ignore */
    _onButtonClick: function(event) {
      var self = this;

      event.stopPropagation();

      if (self._preventClick) {
        return;
      }

      var button = event.matchedTarget;
      var item = button._elements.quickActionsItem;
      self._proxyClick(item);

      // Prevent double click or alternate selection during animation
      setTimeout(function() {
        self._preventClick = false;
      }, self._overlayAnimationTime);

      self._preventClick = true;
    },

    /** @ignore */
    _onGlobalClick: function(event) {
      if (this._elements.moreButton.contains(event.target)) {
        this._elements.overlay.open = !this._elements.overlay.open;
      }
      else {
        var withinOverlay = this._elements.overlay.contains(event.target);

        if (!withinOverlay) {
          this._elements.overlay.open = false;
        }
      }
    },

    /** @ignore */
    _onOverlayBeforeOpen: function(event) {
      if (event.target === this) {
        // Reset double-click prevention flag
        this._preventClick = false;
        this._layout();
      }
      else if (event.target === this._elements.overlay) {
        // do not allow internal Overlay events to escape QuickActions
        event.stopImmediatePropagation();
        this._setButtonListHeight();
      }
    },

    /** @ignore */
    _onOverlayBeforeClose: function(event) {
      if (event.target === this._elements.overlay) {
        // do not allow internal Overlay events to escape QuickActions
        event.stopImmediatePropagation();
      }
    },

    /** @ignore */
    _onOverlayOpen: function(event) {
      var self = this;

      if (event.target === this._elements.overlay) {
        // do not allow internal Overlay events to escape QuickActions
        event.stopImmediatePropagation();

        Coral.commons.nextFrame(function() {
          var focusableItems = self._elements.buttonList.items.getAll().filter(function(item) {
            return !item.hasAttribute('hidden') && !item.hasAttribute('disabled');
          });

          if (focusableItems.length > 0) {
            focusableItems[0].focus();
          }
        });
      }
    },

    /** @ignore */
    _onOverlayClose: function(event) {
      var self = this;

      if (event.target === self) {
        self._elements.overlay.open = false;

        // Return the trapFocus and returnFocus properties to their state before open.
        // Handles the keyboard launch and interaction enabled case, which implies focus trap and focus return.
        // Wait a frame as this is called before the 'open' property sync. Otherwise, returnFocus is set prematurely.
        Coral.commons.nextFrame(function() {
          if (self._previousTrapFocus) {
            self.trapFocus = self._previousTrapFocus;
            self._previousTrapFocus = undefined;
          }

          if (self._previousReturnFocus) {
            self.returnFocus = self._previousReturnFocus;
            self._previousReturnFocus = undefined;
          }
        });
      }
      else if (event.target === self._elements.overlay) {
        // do not allow internal Overlay events to escape QuickActions
        event.stopImmediatePropagation();
      }
    },

    /** @ignore */
    _onOverlayPositioned: function(event) {
      this.style.maxWidth = 'none';

      if (event.target === this._elements.overlay) {
        // do not allow internal Overlay events to escape QuickActions
        event.stopImmediatePropagation();
      }
    },

    /** @ignore */
    _onButtonListItemClick: function(event) {
      var self = this;

      // stops propagation so that this event remains internal to the component
      event.stopImmediatePropagation();

      var buttonListItem = event.matchedTarget;

      if (!buttonListItem) {
        return;
      }

      var item = buttonListItem._elements.quickActionsItem;
      self._proxyClick(item);
    },

    /** @ignore */
    _onItemRemoved: function(item) {
      this._removeItemElements(item);
    },

    /** @ignore */
    _onCollectionChange: function(addedNodes, removeNodes) {
      // Delay the item initialization if the component has not been opened before
      if (!this._openedBefore) {
        return;
      }

      // we use the items to be able to find out the index of the added item in reference to the whole collection
      var items = this.items.getAll();
      var index;
      for (var i = 0, addedNodesCount = addedNodes.length; i < addedNodesCount; i++) {
        // we need to know the item's position in relation to the others
        index = Array.prototype.indexOf.call(items, addedNodes[i]);
        this._attachItem(addedNodes[i], index);
      }

      this._layout();
    },

    /** @ignore */
    _onItemChange: function(event) {
      // stops propagation so that this event remains internal to the component
      event.stopImmediatePropagation();

      this._updateItem(event.target);
    },

    /** @ignore */
    _onItemTypeChange: function(event) {
      // stops propagation so that this event remains internal to the component
      event.stopImmediatePropagation();

      var item = event.target;
      this._removeItemElements(item);
      this._attachItem(item);
      this._layout();
    },

    /** @ignore */
    _removeItemElements: function(item) {
      // Remove the associated Button and ButtonList elements
      if (item._elements.button) {
        item._elements.button.remove();
        item._elements.button._elements.quickActionsItem = undefined;
        item._elements.button = undefined;
      }

      if (item._elements.buttonListItem) {
        item._elements.buttonListItem.remove();
        item._elements.buttonListItem._elements.quickActionsItem = null;
        item._elements.buttonListItem = undefined;
      }
    },

    /** @ignore */
    _updateItem: function(item) {
      var itemData = this._getItemData(item);
      var type = Coral.QuickActions.Item.type;

      var button = item._elements.button;
      if (button) {
        button.icon = itemData.icon;
        button.setAttribute('title', itemData.textContent.trim());
        button.setAttribute('aria-label', itemData.textContent.trim());
        button[item.type === type.ANCHOR ? 'setAttribute' : 'removeAttribute']('href', item.href);
      }

      var buttonListItem = item._elements.buttonListItem;
      if (buttonListItem) {
        buttonListItem.content.innerHTML = itemData.htmlContent;
        buttonListItem[item.type === type.ANCHOR ? 'setAttribute' : 'removeAttribute']('href', item.href);
        buttonListItem.icon = itemData.icon;
      }
    },

    /** @ignore */
    _render: function() {
      // Get an id for distinguishing QuickActions on a single target
      this.id = this.id || Coral.commons.getUID();

      ['moreButton', 'overlay'].forEach(function(handleName) {
        var handle = this.querySelector('[handle="'+ handleName +'"]');
        if (handle) {
          this.removeChild(handle);
        }
      }, this);
      
      // Render the base layout
      this.insertBefore(Coral.templates.QuickActions.base.call(this._elements), this.items.first());

      // Append the overlay content
      this._elements.overlay.appendChild(Coral.templates.QuickActions.overlaycontent.call(this._elements));

      // Cache bound event handler functions
      this._onTargetMouseEnter = this._onTargetMouseEnter.bind(this);
      this._onTargetKeyUp = this._onTargetKeyUp.bind(this);
      this._onTargetMouseLeave = this._onTargetMouseLeave.bind(this);
    },

    /** @ignore */
    _initialize: function() {
      this._openedBefore = false;

      // Make QuickActions focusable
      this.setAttribute('tabIndex', '-1');
      this.setAttribute('role', 'menu');

      // delegates the item handling to the collection
      this.items._startHandlingItems();
    },

    /**
      A map of placement values to their corresponding alignMy and alignAt values. It overrides the default mapping
      provided by Coral.Overlay.

      @ignore
    */
    _placementAlignValues: {
      'top': {
        alignMy: 'center top',
        alignAt: 'center top'
      },
      'center': {
        alignMy: 'center center',
        alignAt: 'center center'
      },
      'bottom': {
        alignMy: 'center bottom',
        alignAt: 'center bottom'
      }
    }
  });

  // Expose enums globally
  Coral.QuickActions.target = target;
  Coral.QuickActions.interaction = interaction;
  Coral.QuickActions.placement = placement;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for item type values.

    @enum {String}
    @memberof Coral.QuickActions.Item
  */
  var type = {
    /** Default button type */
    BUTTON: 'button',
    /** Anchor button type */
    ANCHOR: 'anchor'
  };

  Coral.register( /** @lends Coral.QuickActions.Item# */ {
    /**
      @class Coral.QuickActions.Item
      @extends Coral.Component
      @classdesc A QuickActions Item.
      @htmltag coral-quickactions-item
    */
    name: 'QuickActions.Item',
    tagName: 'coral-quickactions-item',

    properties: {
      /**
        The Item's content zone.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.QuickActions.Item#
      */
      'content': {
        contentZone: true,
        get: function() {
          return this;
        },
        set: function() {}
      },

      /**
        When <code>type</code> is {@link Coral.QuickActions.Item.type.ANCHOR}, the href will be used for the anchor.

        @type {String}
        @default ""
        @htmlattribute href
        @htmlattributereflected
        @fires coral-quickactions-item:_hrefchanged
        @memberof Coral.QuickActions.Item#
      */
      'href': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string,
        trigger: 'coral-quickactions-item:_hrefchanged'
      },

      /**
        Specifies the name of the icon to be shown in the QuickActions Item. See {@link Coral.Icon} for valid icon
        names.

        @type {String}
        @default ""
        @htmlattribute icon
        @htmlattributereflected
        @fires coral-quickactions-item:_iconchanged
        @memberof Coral.QuickActions.Item#

        @see {@link Coral.Icon}
      */
      'icon': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string,
        trigger: 'coral-quickactions-item:_iconchanged'
      },

      /**
        The type of item that will be used. Setting {@link Coral.QuickActions.Item.type.ANCHOR} will allow users to
        navigate using the quickactions proving the correct hypermedia to the users.

        @type {Coral.QuickActions.Item.type}
        @default Coral.QuickActions.Item.type.BUTTON
        @htmlattribute type
        @htmlattributereflected
        @memberof Coral.QuickAction.Item#
      */
      'type': {
        default: type.BUTTON,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(type)
        ],
        trigger: 'coral-quickactions-item:_typechanged'
      }
    },

    /**
      Handles mutations on the Item.

      @fires coral-quickactions-item:_contentchanged

      @private
    */
    _onMutation: function() {
      this.trigger('coral-quickactions-item:_contentchanged');
    },

    /** @ignore */
    _initialize: function() {
      this._observer = new MutationObserver(this._onMutation.bind(this));
      this._observer.observe(this, {
        characterData: true,
        childList: true,
        subtree: true
      });
    }

    /**
      Triggered when an icon of an item was changed.

      @event Coral.QuickActions.Item#coral-quickactions-item:_iconchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when the content of an item was changed.

      @event Coral.QuickActions.Item#coral-quickactions-item:_contentchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when the href of an item was changed.

      @event Coral.QuickActions.Item#coral-quickactions-item:_hrefchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when the type of an item was changed.

      @event Coral.QuickActions.Item#coral-quickactions-item:_typechanged

      @param {Object} event Event object
      @private
    */
  });

  // exports the enum globally
  Coral.QuickActions.Item.type = type;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-search"] = {"it-IT":{"Clear search":"Azzera ricerca"},"ja-JP":{"Clear search":"検索をクリア"},"es-ES":{"Clear search":"Borrar búsqueda"},"ko-KR":{"Clear search":"검색 지우기"},"zh-CN":{"Clear search":"清除搜索"},"zh-TW":{"Clear search":"清除搜尋"},"pt-BR":{"Clear search":"Limpar busca"},"nl-NL":{"Clear search":"Zoekopdracht wissen"},"en-US":{"Clear search":"Clear search"},"de-DE":{"Clear search":"Suche löschen"},"fr-FR":{"Clear search":"Effacer la recherche"},"da-DK":{"Clear search":"Slet søgning"},"fi-FI":{"Clear search":"Tyhjennä haku"},"nb-NO":{"Clear search":"Fjern søk"},"sv-SE":{"Clear search":"Rensa sökningen"},"cs-CZ":{"Clear search":"Vymazat hledání"},"pl-PL":{"Clear search":"Wyczyść wyniki wyszukiwania"},"ru-RU":{"Clear search":"Очистить поиск"},"tr-TR":{"Clear search":"Aramayı temizle"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["search"] = window["Coral"]["templates"]["search"] || {};
window["Coral"]["templates"]["search"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["icon"] = document.createElement("coral-icon");
  el0.className += " coral-DecoratedTextfield-icon";
  el0.setAttribute("size", "S");
  el0.setAttribute("handle", "icon");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["input"] = document.createElement("input","coral-textfield");
  el2.setAttribute("type", "text");
  el2.className += " coral-DecoratedTextfield-input coral3-Search-input";
  el2.setAttribute("is", "coral-textfield");
  el2.setAttribute("handle", "input");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["clearButton"] = document.createElement("button","coral-button");
  el4.setAttribute("type", "button");
  el4.setAttribute("aria-label", Coral["i18n"]["get"]('Clear search'));
  el4.setAttribute("is", "coral-button");
  el4.setAttribute("variant", "minimal");
  el4.setAttribute("icon", "close");
  el4.setAttribute("iconsize", "XS");
  el4.className += " coral-DecoratedTextfield-button";
  el4.setAttribute("handle", "clearButton");
  frag.appendChild(el4);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enum for search variant values.

    @enum {String}
    @memberof Coral.Search
  */
  var variant = {
    /** A default, gray search input */
    DEFAULT: 'default',
    /** A search with no border, no background, no glow */
    QUIET: 'quiet'
  };

  Coral.register( /** @lends Coral.Search# */ {
    /**
      @class Coral.Search
      @classdesc A Search component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-search
    */
    name: 'Search',
    tagName: 'coral-search',
    className: 'coral3-Search coral-DecoratedTextfield',

    mixins: [
      Coral.mixin.formField
    ],

    events: {
      // @todo use Coral.keys when key combos don't interfere with single key execution
      'keydown [handle=input]': '_onEnterKey',
      'keyup [handle=input]': '_onKeyUp',

      // @todo use coralinternalinput from Autocomplete
      'input [handle=input]': '_triggerInputEvent',

      'key:escape [handle=input]': '_clearInput',
      'click [handle=clearButton]:not(:disabled)': '_clearInput'
    },

    properties: {
      // JSDoc inherited
      'value': {
        get: function() {
          return this._elements.input.value;
        },
        set: function(value) {
          // sets the value immediately so it is picked up in form submits
          this._elements.input.value = value;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);

          this._elements.input.disabled = this.disabled;
          this._elements.clearButton.disabled = this.disabled;
        }
      },

      // JSDoc inherited
      'invalid': {
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);

          this._elements.input.classList.toggle('is-invalid', this.invalid);
          this._elements.input.setAttribute('aria-invalid', this.invalid);
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this._elements.input.required = this.required;
        }
      },

      // JSDoc inherited
      'labelledBy': {
        sync: function() {
          // in case the user focuses the buttons, he will still get a notion of the usage of the component
          if (this.labelledBy) {
            this.setAttribute('aria-labelledby', this.labelledBy);
          }
          else {
            this.removeAttribute('aria-labelledby');
          }
        }
      },

      /**
        Short hint that describes the expected value of the Search. It is displayed when the Search is empty.

        @type {String}
        @default ""
        @htmlattribute placeholder
        @htmlattributereflected
        @memberof Coral.Search#
      */
      'placeholder': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string,
        get: function() {
          return this._elements.input.placeholder;
        },
        set: function(value) {
          this._elements.input.placeholder = value;
        }
      },

      /**
        Max length for the Input field.

        @type {Long}
        @htmlattribute maxlength
        @htmlattributereflected
        @memberof Coral.Search#
      */
      'maxLength' : {
        attribute: 'maxlength',
        reflectAttribute: true,
        set: function(value) {
          this._elements.input.maxLength = value;
        },
        get: function() {
          return this._elements.input.maxLength;
        }
      },

      /**
        This sets the left icon on the search component.

        @type {String}
        @default "search"
        @htmlattribute icon
        @htmlattributereflected
        @memberof Coral.Search#
      */
      'icon': {
        default: 'search',
        validate: [], // Let Icon handle this
        reflectAttribute: true,
        set: function(icon) {
          this._elements.icon.icon = icon;

          // Hide if no icon provided
          this._elements.icon.hidden = !this._elements.icon.icon;
        },
        get: function() {
          return this._elements.icon.icon;
        }
      },

      /**
        The search's variant.

        @type {Coral.Search.variant}
        @default Coral.Search.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Search#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // provide the variant internally
          this._elements.input.variant = this.variant;
        }
      }
    },

    /** @ignore */
    _triggerInputEvent: function() {
      this.trigger('coral-search:input');
    },

    /**
      Handles the up action by steping up the Search. It prevents the default action.

      @ignore
    */
    _onEnterKey: function(event) {
      if (event.which === 13) {
        event.preventDefault();

        // stops interaction if the search is disabled
        if (this.disabled) {
          return;
        }

        this.trigger('coral-search:submit');
      }
    },

    /**
      Handles the keydown action.

      @ignore
    */
    _onKeyUp: function(event) {
      this._updateClearButton();
    },

    /**
      Updates the clear button's display status.

      @ignore
    */
    _updateClearButton: function() {
      if (this._elements.input.value === '') {
        this._elements.clearButton.style.display = 'none';
      }
      else {
        this._elements.clearButton.style.display = '';
      }
    },

    /**
      Clears the text in the input box.

      @ignore
    */
    _clearInput: function(event) {
      this._elements.input.value = '';
      this._updateClearButton();
      this._elements.input.focus();

      // If we've been cleared, trigger the event
      this.trigger('coral-search:clear');
    },

    /**
      Modified to target the input instead of the button.

      @private
    */
    _getLabellableElement: function() {
      return this._elements.input;
    },

    /** @ignore */
    _initialize: function() {
      this._updateClearButton();
    },

    /** @ignore */
    _render: function() {
      this.appendChild(Coral.templates.search.base.call(this._elements));
    }

    /**
      Triggerred when input is given.

      @event Coral.Search#coral-search:input

      @param {Object} event
        Event object.
    */

    /**
      Triggerred when the user presses enter.

      @event Coral.Search#coral-search:submit

      @param {Object} event
        Event object.
    */

    /**
      Triggerred when the search is cleared.

      @event Coral.Search#coral-search:clear

      @param {Object} event
        Event object.
    */
  });

  // exports the variants enumeration
  Coral.Search.variant = variant;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["StepList"] = window["Coral"]["templates"]["StepList"] || {};
window["Coral"]["templates"]["StepList"]["step"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["stepMarkerContainer"] = document.createElement("span");
  el0.className += " coral3-Step-markerContainer";
  el0.setAttribute("handle", "stepMarkerContainer");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("span");
  el2.className += " coral3-Step-marker";
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  frag.appendChild(el0);
  var el4 = document.createTextNode("\n");
  frag.appendChild(el4);
  var el5 = this["tooltip"] = document.createElement("coral-tooltip");
  el5.setAttribute("handle", "tooltip");
  el5.setAttribute("target", "_prev");
  el5.setAttribute("placement", "top");
  el5.setAttribute("variant", "inspect");
  el5.setAttribute("interaction", "off");
  el5.setAttribute("offset", "5");
  frag.appendChild(el5);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = document.createElement("span");
  el7.className += " coral3-Step-line";
  frag.appendChild(el7);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enumeration representing StepList interaction patterns.

    @todo support "click only past steps" mode
    @enum {String}
    @memberof Coral.StepList
  */
  var interaction = {
    /** Steps can be clicked to visit them. */
    ON: 'on',
    /** Steps cannot be clicked. */
    OFF: 'off'
  };

  /**
    Enumeration representing the StepList size.

    @enum {String}
    @memberof Coral.StepList
  */
  var size = {
    /** A small-sized StepList. */
    SMALL: 'S',
    /** A large-sized StepList. */
    LARGE: 'L'
  };

  /**
    Gets the target panel of the item.

    @private
    @param {HTMLElement|String} [targetValue]
      A specific target value to use.
    @returns {?HTMLElement}
  */
  function getTarget(targetValue) {

    if (targetValue instanceof Node) {
      // Just return the provided Node
      return targetValue;
    }

    // Dynamically get the target node based on the target
    var newTarget = null;
    if (typeof targetValue === 'string' && targetValue.trim() !== '') {
      newTarget = document.querySelector(targetValue);
    }

    return newTarget;
  }

  // the StepList's base classname
  var CLASSNAME = 'coral3-StepList';

  Coral.register( /** @lends Coral.StepList# */ {

    /**
      @class Coral.StepList
      @classdesc A StepList component
      @htmltag coral-steplist
      @extends Coral.Component
      @mixes Coral.mixin.selectionList
      @borrows Coral.mixin.selectionList#items as Coral.StepList#items
      @borrows Coral.mixin.selectionList#selectedItem as Coral.StepList#selectedItem
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:add as Coral.StepList#coral-collection:add
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:remove as
        Coral.StepList#coral-collection:remove
    */
    name: 'StepList',
    tagName: 'coral-steplist',
    className: CLASSNAME,
    mixins: [
      Coral.mixin.selectionList({
        itemTagName: 'coral-step',
        supportMultiple: false,
        forceSelection: true,
        role: 'tablist'
      })
    ],

    events: {
      'click > coral-step > [handle="stepMarkerContainer"]': '_onStepMarkerClick',
      'click > coral-step > coral-step-label': '_onStepMarkerClick',

      'capture:focus > coral-step': '_onStepMarkerMouseEnter',
      'capture:mouseenter > coral-step': '_onStepMarkerMouseEnter',
      'capture:blur > coral-step': '_onStepMarkerMouseLeave',
      'capture:mouseleave > coral-step': '_onStepMarkerMouseLeave',

      'key:enter > coral-step': '_onStepKeyboardSelect',
      'key:space > coral-step': '_onStepKeyboardSelect',
      'key:home > coral-step': '_onHomeKey',
      'key:end > coral-step': '_onEndKey',
      'key:pagedown > coral-step': '_selectNextItem',
      'key:right > coral-step': '_selectNextItem',
      'key:down > coral-step': '_selectNextItem',
      'key:pageup > coral-step': '_selectPreviousItem',
      'key:left > coral-step': '_selectPreviousItem',
      'key:up > coral-step': '_selectPreviousItem'
    },

    properties: {
      /**
        The target component that will be linked to the StepList. It accepts either a CSS selector or a DOM element. If
        a CSS Selector is provided, the first matching element will be used. Items will be selected based on the index.
        If both target and {@link Coral.Step#target} are set, the second will have higher priority.

        @type {?HTMLElement|String}
        @default null
        @htmlattribute target
        @memberof Coral.StepList#
      */
      'target': {
        default: null,
        validate: function(value) {
          return value === null || typeof value === 'string' || value instanceof Node;
        },
        sync: function() {
          // we do this in the sync in case the target was not yet in the DOM
          var realTarget = getTarget(this.target);

          // we add proper accessibility if available
          if (realTarget) {
            var stepItems = this.items.getAll();
            var panelItems = (realTarget.items ? realTarget.items.getAll() : realTarget.children);

            // we need to add a11y to all components, regardless of whether they can be perfectly paired
            var maxItems = Math.max(stepItems.length, panelItems.length);

            var step;
            var panel;
            for (var i = 0; i < maxItems; i++) {
              step = stepItems[i];
              panel = panelItems[i];

              // if the step has its own target, we assume the target component will handle its own accessibility.
              // if the target is an empty string we simply ignore it
              if (step && step.target && step.target.trim() !== '') {
                continue;
              }

              if (step && panel) {
                // sets the required ids
                step.id = step.id || Coral.commons.getUID();
                panel.id = panel.id || Coral.commons.getUID();

                // creates a 2 way binding for accessibility
                step.setAttribute('aria-controls', panel.id);
                panel.setAttribute('aria-labelledby', step.id);
              }
              else if (step) {
                // cleans the aria since there is no matching panel
                step.removeAttribute('aria-controls');
              }
              else {
                // cleans the aria since there is no matching Step
                panel.removeAttribute('aria-labelledby');
              }
            }
          }
        }
      },

      /**
        The size of the StepList. It accepts both lower and upper case sizes. Currently only "S" and "L" (the default)
        are available.

        @type {Coral.StepList.size}
        @default Coral.StepList.size.LARGE
        @htmlattribute size
        @htmlattributereflected
        @memberof Coral.StepList#
      */
      'size': {
        default: size.LARGE,
        reflectAttribute: true,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        sync: function() {
          this.classList.toggle(CLASSNAME + '--small', this.size === size.SMALL);
        }
      },

      /**
        Whether Steps should be interactive or not. When interactive, a Step can be clicked to jump to it.

        @type {Coral.StepList.interaction}
        @default Coral.StepList.interaction.OFF
        @htmlattribute interaction
        @htmlattributereflected
        @memberof Coral.StepList#
      */
      'interaction': {
        default: interaction.OFF,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(interaction)
        ],
        sync: function() {
          var isInteractive = this.interaction === interaction.ON;

          this.classList.toggle(CLASSNAME + '--interactive', isInteractive);

          var steps = this.items.getAll();
          var stepsCount = steps.length;

          // update tab index for all children
          for (var i = 0; i < stepsCount; i++) {
            steps[i]._syncTabIndex(isInteractive);
          }
        }
      }
    },

    /** @private */
    _onSelectionChange: function(newSelection, oldSelection) {
      // sets the state-related classes every time the selection changes
      this._setStateClasses();
    },

    /** @private */
    _setStateClasses: function() {
      var selectedItemIndex = Infinity;
      this.items.getAll().forEach(function(item, index) {
        // Use attribute instead of property as items might not be initialized
        if (item.hasAttribute('selected')) {
          // Mark which one is selected
          selectedItemIndex = index;
        }

        // Add/remove classes based on index
        item.classList.toggle('is-complete', index < selectedItemIndex);
      });
    },

    /** @private */
    _onStepKeyboardSelect: function(event) {
      if (this.interaction === interaction.ON) {
        event.preventDefault();
        event.stopPropagation();

        var item = event.matchedTarget;
        this._selectAndFocusItem(item);
      }
    },

    /** @private */
    _onStepMarkerClick: function(event) {
      if (this.interaction === interaction.ON) {
        event.preventDefault();
        event.stopPropagation();

        var item = event.matchedTarget.parentNode;
        this._selectAndFocusItem(item);
      }
    },

    /** @private */
    _onStepMarkerMouseEnter: function(event) {
      if (this.size === size.SMALL || this._isHybridMode) {
        var step = event.matchedTarget;
        if (step.selected && this._isHybridMode) {
          return;
        }

        // we only show the tooltip if we have a label to show
        if (step._elements.label.innerHTML.trim() !== '') {
          step._elements.tooltip.content.innerHTML = step._elements.label.innerHTML;
          step._elements.tooltip.open = true;
        }
      }
    },

    /** @private */
    _onStepMarkerMouseLeave: function(event) {
      if (this.size === size.SMALL || this._isHybridMode) {
        var step = event.matchedTarget;

        step._elements.tooltip.open = false;
      }
    },

    /** @private */
    _onHomeKey: function(event) {
      if (this.interaction === interaction.ON) {
        event.preventDefault();

        var item = this.items.getFirstSelectable();
        this._selectAndFocusItem(item);
      }
    },

    /** @private */
    _onEndKey: function(event) {
      if (this.interaction === interaction.ON) {
        event.preventDefault();

        var item = this.items.getLastSelectable();
        this._selectAndFocusItem(item);
      }
    },

    /** @private */
    _selectNextItem: function(event) {
      if (this.interaction === interaction.ON) {
        event.preventDefault();

        this.next();
      }
    },

    /** @private */
    _selectPreviousItem: function(event) {
      if (this.interaction === interaction.ON) {
        event.preventDefault();

        this.previous();
      }
    },

    /** @private */
    _selectAndFocusItem: function(item) {
      if (item) {
        this._selectItem(item);
        item.focus();
      }
    },

    /** @private */
    _setHybridLabel: function(item) {
      if (!item) {
        return;
      }
      
      if (this._isHybridMode) {
        var items = this.items.getAll();
        var itemIndex = items.indexOf(item);
        var middle = items.length / 2;
        var stepSize = 120;

        var marginLeft = (middle - itemIndex) * stepSize - (stepSize / 2);

        // Position item label
        item.label.style.marginLeft = marginLeft + 'px';
        
        // Indicate item index
        item.label.dataset.coralStepIndex = ' (' + (itemIndex + 1) + '/' + items.length + ')';
      }
      else {
        // Restore defaults
        item.label.style.marginLeft = '';
      }
    },

    /** @private */
    _updateLabels: function() {
      var hasOversizedLabel = false;
      var hybridClass = CLASSNAME + '--hybrid';

      this._isHybridMode = false;
      this.classList.remove(hybridClass);

      // when the steplist is small no check is needed
      if (this.size === size.SMALL) {
        return;
      }

      // Check if one label is oversized
      var steps = this.items.getAll();
      var stepsCount = steps.length;
      var actualStep;
      for (actualStep = 0; actualStep < stepsCount; actualStep++) {
        if (steps[actualStep]._labelIsHidden) {
          hasOversizedLabel = true;
          this._isHybridMode = true;
          this.classList.add(hybridClass);
          break;
        }
      }

      for (actualStep = 0; actualStep < stepsCount; actualStep++) {
        if (steps[actualStep].label) {
          var hide = (steps[actualStep].hasAttribute('selected') || !hasOversizedLabel) ? false : true;
          steps[actualStep].label.hidden = hide;
        }
      }

      this._setHybridLabel(this.selectedItem);
    },

    /** @private */
    _onItemAttached: function(event) {
      var step = event.target;
      var stepWidth = step.clientWidth;
      if (step.label && step.label.clientWidth > stepWidth) {
        step._labelIsHidden = true;
      }

      if (this._allChildrenAdded) {
        this._updateLabels();
      }
    },

    /** @private */
    _onItemDetached: function() {
      this._updateLabels();
    },

    /** @private */
    _onItemSelected: function() {
      this._updateLabels();
    },

    /** @private */
    _initialize: function() {
      // setup accessibility
      this.setAttribute('aria-multiselectable', 'false');

      // sets the classes based on the selection
      this._setStateClasses();

      // makes sure that the labels fit
      var self = this;
      Coral.commons.ready(this, function() {
        self._allChildrenAdded = true;
        self._updateLabels();
      });
    },

    /**
      Show the next Step.

      @fires Coral.StepList#coral-steplist:change
    */
    next: function() {
      var item = this.selectedItem;
      if (item) {
        item = this.items.getNextSelectable(item);
        this._selectAndFocusItem(item);
      }
    },

    /**
      Show the previous Step.

      @fires Coral.StepList#coral-steplist:change
    */
    previous: function() {
      var item = this.selectedItem;
      if (item) {
        item = this.items.getPreviousSelectable(item);
        this._selectItem(item);
        item.focus();
      }
    }

    /**
      Triggered when the selected Step has changed.

      @event Coral.StepList#coral-steplist:change

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.selection
        The newly selected Step.
      @param {HTMLElement} event.detail.oldSelection
        The previously selected Step.
    */
  });

  // exports the enumerations
  Coral.StepList.size = size;
  Coral.StepList.interaction = interaction;

  Coral.register( /** @lends Coral.Step */ {
    /**
      @class Coral.Step
      @classdesc An Item in the StepList
      @htmltag coral-step
      @extends Coral.Component
      @mixes Coral.mixin.selectionList.Item
    */
    name: 'Step',
    tagName: 'coral-step',
    className: 'coral3-Step',
    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-steplist',
        role: 'tab',
        alwaysEnabled: true
      })
    ],

    properties: {

      /**
        The Step's label element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Step#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-step-label',
        defaultContentZone: true,
        insert: function(label) {
          this.appendChild(label);
        }
      }),

      /**
        Whether the item is selected. When <code>true</code>, the item will appear as the active element in the
        StepList. The item must be a child of a StepList before this property is set to <code>true</code>.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Step#
      */
      'selected': {
        sync: function() {
          this.classList.toggle('is-selected', this.selected);
          this.setAttribute('aria-selected', this.selected);

          var steplist = this.parentNode;
          if (steplist) {
            this._syncTabIndex(steplist.interaction === interaction.ON);
          }

          // in case the Step is selected, we need to communicate it to the panels
          if (this.selected) {
            var realTarget = getTarget(this.target);
            // if the target was defined at the Step level, it has precedence over everything
            if (realTarget) {
              realTarget.setAttribute('selected', '');
            }
            // we use the target defined at the StepList level
            else if (steplist && steplist.target) {
              realTarget = getTarget(steplist.target);

              if (realTarget) {
                // we get the position of this step inside the steplist
                var currentIndex = steplist.items.getAll().indexOf(this);

                // we select the item with the same index
                var targetItem = (realTarget.items ? realTarget.items.getAll() : realTarget.children)[currentIndex];

                // we select the item if it exists
                if (targetItem) {
                  targetItem.setAttribute('selected', '');
                }
              }
            }
          }
        }
      },

      /**
        The target element that will be selected when this Step is selected. It accepts a CSS selector or a DOM element.
        If a CSS Selector is provided, the first matching element will be used.

        @type {?HTMLElement|String}
        @default null
        @htmlattribute target
        @memberof Coral.Step#
      */
      'target': {
        default: null,
        validate: function(value) {
          return value === null || typeof value === 'string' || value instanceof Node;
        },
        sync: function() {

          var realTarget = getTarget(this.target);

          // we add proper accessibility if available
          if (realTarget) {
            // creates a 2 way binding for accessibility
            this.setAttribute('aria-controls', realTarget.id);
            realTarget.setAttribute('aria-labelledby', this.id);
          }
        }
      }
    },

    /** @private */
    _syncTabIndex: function(isInteractive) {
      // when interaction is on, we enable the tabindex so users can tab into the items
      if (isInteractive) {
        this.setAttribute('tabindex', this.selected ? '0' : '-1');
        this.removeAttribute('aria-readonly');
      }
      else {
        // when off, removing the tabindex allows the component to never get focus
        this.removeAttribute('tabindex');
        this.setAttribute('aria-readonly', 'true');
      }
    },

    /** @private */
    _render: function() {
      // Fetch the content zone elements
      var label = this.querySelector('coral-step-label');

      if (label === null) {
        // Create the content zone elements
        label = document.createElement('coral-step-label');
        // Finally, move any remaining elements into the label sub-component
        while (this.firstChild) {
          label.appendChild(this.firstChild);
        }
      }

      // Assign the content zone so the insert function will be called
      this.label = label;

      // Fetch the tooltip
      var tooltip = this.querySelector('coral-tooltip');
      if (tooltip === null) {
        // We need to create it
        this.appendChild(Coral.templates.StepList.step.call(this._elements));
      }
      else {
        // Store the reference
        this._elements.tooltip = tooltip;
      }
    },

    /** @private */
    _initialize: function() {
      // Generate a unique ID for the Step panel if one isn't already present
      // This will be used for accessibility purposes
      this.id = this.id || Coral.commons.getUID();
    }
  });

  Coral.register( /** @lends Coral.Step.Label */ {
    /**
      @class Coral.Step.Label
      @classdesc A StepList Item Label component
      @extends Coral.Component
      @htmltag coral-step-label
    */
    name: 'Step.Label',
    tagName: 'coral-step-label',
    className: 'coral3-Step-label'
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Switch"] = window["Coral"]["templates"]["Switch"] || {};
window["Coral"]["templates"]["Switch"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["input"] = document.createElement("input");
  el0.className += " coral3-Switch-input";
  el0.setAttribute("handle", "input");
  el0.setAttribute("type", "checkbox");
  el0.id = Coral["commons"]["getUID"]();
  frag.appendChild(el0);
  var el1 = this["label"] = document.createElement("span");
  el1.className += " coral3-Switch-label";
  el1.setAttribute("handle", "label");
  el1.setAttribute("aria-hidden", "true");
  frag.appendChild(el1);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Switch# */ {
    /**
      @class Coral.Switch
      @classdesc A Switch component
      @extends Coral.Component
      @extends Coral.mixin.formField
      @htmltag coral-switch
    */
    name: 'Switch',
    tagName: 'coral-switch',
    className: 'coral3-Switch',

    mixins: [
      Coral.mixin.formField
    ],

    properties: {
      /**
        Whether the switch is on or off. Changing the checked value will cause a
        {@link Coral.mixin.formField#event:change} event to be triggered.

        @type {Boolean}
        @default false
        @htmlattribute checked
        @htmlattributereflected
        @fires Coral.mixin.formField#change
        @memberof Coral.Switch#
      */
      'checked': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        set: function(value) {
          this._checked = value;

          // Instead of doing this on sync, set immediately in the setter. Users may expect the form's serialized values
          // to reflect changes immediately
          this._elements.input.checked = value;
        }
      },

      /**
        The value this switch should submit when checked. Changing this value will not trigger an event.

        @type {String}
        @default "on"
        @htmlattribute value
        @memberof Coral.Switch#
      */
      'value': {
        default: 'on',
        get: function() {
          return this._elements.input.value;
        },
        set: function(value) {
          this._elements.input.value = value;
        }
      },

      // JSDoc inherited
      'name': {
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },

      // JSDoc inherited
      'disabled': {
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this._elements.input.disabled = this.disabled;
        }
      },

      // JSDoc inherited
      'required': {
        sync: function() {
          this._elements.input.required = this.required;
        }
      }
    },

    /*
      Indicates to the formField that the 'checked' property needs to be set in this component.

      @protected
     */
    _componentTargetProperty: 'checked',

    /*
      Indicates to the formField that the 'checked' property has to be extracted from the event.

      @protected
     */
    _eventTargetProperty: 'checked',

    // JSDoc inherited
    clear: function() {
      this.checked = false;
    },

    // JSDoc inherited
    reset: function() {
      this.checked = this._initialCheckedState;
    },

    /** @ignore */
    _render: function() {
      // Create a temporary fragment
      var frag = document.createDocumentFragment();

      // Render the template
      frag.appendChild(Coral.templates.Switch.base.call(this._elements));

      // Clean up
      while (this.firstChild) {
        var child = this.firstChild;
        // Only works if all root template elements have a handle attribute
        if (child.nodeType === Node.TEXT_NODE || (child.hasAttribute && !child.hasAttribute('handle'))) {
          // Add non-template elements to the content
          frag.appendChild(child);
        }
        else {
          // Remove anything else
          this.removeChild(child);
        }
      }

      // Append the fragment to the component
      this.appendChild(frag);
    },

    /** @private */
    _initialize: function() {
      // Cache the initial checked state of the switch (in order to implement reset)
      this._initialCheckedState = this.checked;
    }

  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Table"] = window["Coral"]["templates"]["Table"] || {};
window["Coral"]["templates"]["Table"]["base"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["container"] = document.createElement("div");
  el0.setAttribute("handle", "container");
  el0.className += " coral-Table-wrapper-container";
  el0.setAttribute("role", "presentation");
  el0.setAttribute("coral-table-scroll", "");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["table"] = document.createElement("table");
  el2.setAttribute("handle", "table");
  el2.className += " coral-Table";
  el2.setAttribute("role", "grid");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  frag.appendChild(el0);
  var el4 = document.createTextNode("\n");
  frag.appendChild(el4);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  function getIndexOf(el) {
    var parent = el.parentNode;
    if (!parent) {
      return -1;
    }

    return Array.prototype.indexOf.call(parent.children, el);
  }

  function getSiblingsOf(el, selector, type) {
    var stack = [];

    // Returns siblings of el
    if (!type) {
      ['previousElementSibling', 'nextElementSibling'].forEach(function(direction) {
        var sibling = el;
        while (sibling[direction]) {
          sibling = sibling[direction];
          if (sibling.matches(selector)) {
            stack.push(sibling);
          }
        }
      });
    }
    else {
      var direction = type.indexOf('next') === 0 ? 'nextElementSibling' : 'previousElementSibling';

      // All following siblings of el up to but not including the element matched by the selector
      if (type.indexOf('Until') !== -1) {
        var matches = function () {
          if (typeof selector === 'string') {
            return el[direction].matches(selector);
          }
          else {
            return el[direction] === selector;
          }
        };

        while (el[direction] && !matches() ) {
          stack.push(el = el[direction]);
        }
      }
      // All following siblings of el filtered by a selector.
      else if (type.indexOf('All') !== -1) {
        while (el[direction]) {
          el = el[direction];
          if (el.matches(selector)) {
            stack.push(el);
          }
        }
      }
      // Returns the sibling only if it matches that selector.
      else {
        var sibling = el[direction];
        return sibling && sibling.matches(selector) ? sibling : null;
      }
    }

    return stack;
  }

  /**
    Enum for table variant values.

    @enum {String}
    @memberof Coral.Table
  */
  var variant = {
    /** A default table. */
    DEFAULT: 'default',
    /** A list table using thumbnails as selectable checkboxes. */
    LIST: 'list'
  };

  /**
    Enum for divider values.

    @enum {String}
    @memberof Coral.mixin.tableSection
  */
  var divider = {
    /** No divider. */
    NONE: 'none',
    /** Row divider. */
    ROW: 'row',
    /** Column divider. */
    COLUMN: 'column',
    /** Row and Column divider. */
    CELL: 'cell'
  };

  var CLASSNAME = 'coral-Table-wrapper';

  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
  }

  var IS_HIDDEN = 'is-hidden';
  var IS_DISABLED = 'is-disabled';
  var IS_SORTED = 'is-sorted';
  var IS_UNSELECTABLE = 'is-unselectable';
  var IS_FIRST_ITEM_DRAGGED = 'is-draggedFirstItem';
  var IS_LAST_ITEM_DRAGGED = 'is-draggedLastItem';
  var IS_DRAGGING_CLASS = 'is-dragging';
  var IS_BEFORE_CLASS = 'is-before';
  var IS_AFTER_CLASS = 'is-after';
  var IS_IE_OR_EDGE = navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0 ||
                      window.navigator.userAgent.indexOf('Edge') !== -1;
  var IS_FIREFOX = navigator.userAgent.indexOf('Firefox') !== -1;
  var KEY_SPACE = Coral.Keys.keyToCode('space');

  // @todo
  // Background: sticky header cell size is calculated based on the non sticky header cell size.
  // On initialization, the size might be calculated before the Typekit font is loaded. In result, the calculated size
  // differs from the size with the new font.
  // Adding a resize listener to header cells is too processing heavy (possibly many header cells).
  // And table and table section (<coral-table-head>, <coral-table-row> etc.) are not capturing the size change.
  var root = document.documentElement;
  if (root.className.indexOf('wf-inactive') !== -1 || root.className.indexOf('wf-loading') !== -1) {
    var webFontLoadObserver = new MutationObserver(function() {
      if (root.className.indexOf('wf-active') !== -1) {
        webFontLoadObserver.disconnect();
        var vent = new window.Vent(root);
        vent.dispatch('coral-commons:_webfontload');
      }
    }.bind(this));

    // Watch for class changes
    webFontLoadObserver.observe(root, {
      attributes: true,
      attributeFilter: ['class']
    });
  }

  // Collection
  var TableCollection = function(table) {
    this._table = table;
  };

  // Assigns the prototype to get access to the Collection signature methods
  TableCollection.prototype = Object.create(Coral.Collection.prototype);

  TableCollection.prototype.add = function(item, before) {
    if (!(item instanceof HTMLElement)) {
      // Creates a new item and initializes its values
      var itemObject = item;
      item = document.createElement('tr', 'coral-table-row');
      item.set(itemObject, true);
    }

    var body = this._table._elements.body;
    // Create table body if none
    if (!body) {
      body = document.createElement('tbody', 'coral-table-body');
      this._table._elements.table.appendChild(body);
    }
    return body.insertBefore(item, before || null);
  };

  TableCollection.prototype.getAll = function() {
    return this._table._getRows(['body']);
  };

  Coral.register( /** @lends Coral.Table */ {
    /**
      @class Coral.Table
      @classdesc A Table component
      @extends Coral.Component
      @htmltag coral-table
      @htmlbasetag table
    */
    name: 'Table',
    tagName: 'coral-table',
    className: CLASSNAME,
    baseTagName: 'table',
    extend: HTMLTableElement,

    events: {
      // Table specific
      'global:coral-commons:_webfontload': '_resetLayout',
      'change [coral-table-select]': '_onSelectAll',
      'capture:scroll [handle="container"]': '_onScroll',

      // Head specific
      'click thead[is="coral-table-head"] th[is="coral-table-headercell"]': '_onHeaderCellSort',
      'coral-dragaction:dragstart thead[is="coral-table-head"] th[is="coral-table-headercell"]': '_onHeaderCellDragStart',
      'coral-dragaction:drag thead[is="coral-table-head"] tr[is="coral-table-row"] > th[is="coral-table-headercell"]': '_onHeaderCellDrag',
      'coral-dragaction:dragend thead[is="coral-table-head"] tr[is="coral-table-row"] > th[is="coral-table-headercell"]': '_onHeaderCellDragEnd',
      // a11y
      'key:enter th[is="coral-table-headercell"]': '_onHeaderCellSort',
      'key:space th[is="coral-table-headercell"]': '_onHeaderCellSort',

      // Body specific
      'click tbody[is="coral-table-body"] [coral-table-rowselect]': '_onRowSelect',
      'click tbody[is="coral-table-body"] [coral-table-rowlock]': '_onRowLock',
      'click tbody[is="coral-table-body"] tr[is="coral-table-row"][selectable] [coral-table-cellselect]': '_onCellSelect',
      'capture:mousedown tbody[is="coral-table-body"] [coral-table-roworder]:not([disabled])': '_onRowOrder',
      'capture:touchstart tbody[is="coral-table-body"] [coral-table-roworder]:not([disabled])': '_onRowOrder',
      'coral-dragaction:dragstart tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragStart',
      'coral-dragaction:drag tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDrag',
      'coral-dragaction:dragover tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragOver',
      'coral-dragaction:dragend tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragEnd',
      // a11y
      'mousedown tbody[is="coral-table-body"] [coral-table-rowselect]': '_onRowDown',
      'key:enter tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowSelect',
      'key:space tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowSelect',
      'key:pageup tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
      'key:pagedown tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
      'key:left tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
      'key:right tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
      'key:up tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
      'key:down tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
      'key:home tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusFirstItem',
      'key:end tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusLastItem',
      'key:shift+pageup tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
      'key:shift+pagedown tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
      'key:shift+left tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
      'key:shift+right tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
      'key:shift+up tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
      'key:shift+down tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',

      // Private
      'coral-table-row:_multiplechanged': '_onRowMultipleChanged',
      'coral-table-row:_beforeselectedchanged': '_onBeforeRowSelectionChanged',
      'coral-table-row:_selectedchanged': '_onRowSelectionChanged',
      'coral-table-row:_lockedchanged': '_onRowLockedChanged',
      'coral-table-row:_change': '_onRowChange',
      'coral-table-row:_contentchanged': '_onRowContentChanged',
      'coral-table-headercell:_contentchanged': '_resetLayout',
      'coral-table-head:_contentchanged': '_onHeadContentChanged',
      'coral-table-body:_contentchanged': '_onBodyContentChanged',
      'coral-table-body:_empty': '_onBodyEmpty',
      'coral-table-column:_fixedwidthchanged': '_resetLayout',
      'coral-table-column:_fixedwidthsync': '_onFixedWidthSync',
      'coral-table-column:_orderablesync': '_onColumnOrderableSync',
      'coral-table-column:_sortablesync': '_onColumnSortableSync',
      'coral-table-column:_sortabledirectionsync': '_onColumnSortableDirectionSync',
      'coral-table-column:_hiddensync': '_onColumnHiddenSync',
      'coral-table-column:_beforecolumnsort': '_onBeforeColumnSort',
      'coral-table-column:_sort': '_onColumnSort',
      'coral-table-head:_stickysync': '_onHeadStickySync'
    },

    properties: {
      /**
        The head of the table.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Table#
      */
      'head': Coral.property.contentZone({
        tagName: 'thead',
        handle: 'head',
        insert: function(content) {
          // Using the native table API allows to position the head element at the correct position.
          this._elements.table.tHead = content;
        }
      }),

      /**
        The body of the table. Multiple bodies are not supported.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Table#
      */
      'body': Coral.property.contentZone({
        tagName: 'tbody',
        handle: 'body',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.table.appendChild(content);
        }
      }),

      /**
        The foot of the table.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Table#
      */
      'foot': Coral.property.contentZone({
        tagName: 'tfoot',
        handle: 'foot',
        insert: function(content) {
          // Using the native table API allows to position the foot element at the correct position.
          this._elements.table.tFoot = content;
        }
      }),

      /**
        The columns of the table.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Table#
      */
      'columns': Coral.property.contentZone({
        tagName: 'colgroup',
        handle: 'columnGroup',
        insert: function(content) {
          this._elements.table.appendChild(content);
        }
      }),

      /**
        The table's variant.

        @type {Coral.Table.variant}
        @default Coral.Table.variant.DEFAULT
        @htmlattribute variant
        @memberof Coral.Table#
      */
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);
          this.classList.add(CLASSNAME + '--' + this.variant);
        }
      },

      /**
        Whether the items are selectable.

        @type {Boolean}
        @default false
        @htmlattribute selectable
        @htmlattributereflected
        @memberof Coral.Table#
      */
      'selectable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          var rows = this._getRows(['body']);

          if (this.selectable) {
            rows.forEach(function(row) {
              row._toggleSelectable(true);
            });
          }
          else {
            // Clear selection
            rows.forEach(function(row) {
              row._toggleSelectable(false);
            });

            this.trigger('coral-table:change', {
              selection: [],
              oldSelection: this._oldSelection
            });

            // Sync used collection
            this._oldSelection = [];
            this._lastSelectedItems.items = [];
          }
  
          // a11y
          this._toggleFocusable();
        }
      },

      /**
        Whether the table is orderable. If the table is sorted, ordering handles are hidden.

        @type {Boolean}
        @default false
        @htmlattribute orderable
        @htmlattributereflected
        @memberof Coral.Table#
      */
      'orderable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this._getRows(['body']).forEach(function(row) {
            row._toggleOrderable(this.orderable);
          }.bind(this));
  
          // a11y
          this._toggleFocusable();
        }
      },

      /**
        Whether multiple items can be selected.

        @type {Boolean}
        @default false
        @htmlattribute multiple
        @htmlattributereflected
        @memberof Coral.Table#
      */
      'multiple': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          var body = this._elements.body;
          if (body) {
            this._elements.table.setAttribute('aria-multiselectable', this.multiple);
          }

          // Deselect all except last
          if (!this.multiple) {

            var selection = this.selectedItems;

            if (selection.length > 1) {
              selection.forEach(function(row, i) {
                // Don't trigger too many events
                row.set('selected', (i === selection.length - 1), true);
              });

              // Synchronise the table select handle
              var newSelection = this.selectedItems;

              if (newSelection.length) {
                this._setSelectAllHandleState('indeterminate');
              }
              else {
                this._setSelectAllHandleState('unchecked');
              }

              this.trigger('coral-table:change', {
                selection: newSelection,
                oldSelection: selection
              });

              // Sync used collection
              this._oldSelection = newSelection;
              this._lastSelectedItems.items = newSelection;
            }
          }
        }
      },

      /**
        Returns an Array containing the selected items.

        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.Table#
      */
      'selectedItems': {
        get: function() {
          return this._getRows(['body']).filter(function(row) {
            return row.selected;
          });
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Returns the first selected item of the table. The value <code>null</code> is returned if no element is
        selected.

        @type {HTMLElement}
        @readonly
        @memberof Coral.Table#
      */
      'selectedItem': {
        get: function() {
          var selection = this.selectedItems;
          return selection.length ? selection[0] : null;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Table#
      */
      'items': {
        get: function() {
          // Construct the collection on first request
          if (!this._items) {
            this._items = new TableCollection(this);
          }

          return this._items;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Whether the table rows can be locked/unlocked.

        @type {Boolean}
        @default false
        @htmlattribute lockable
        @htmlattributereflected
        @memberof Coral.Table#
      */
      'lockable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this._getRows(['body']).forEach(function(row) {
            row._toggleLockable(this.lockable);
          }.bind(this));
  
          // a11y
          this._toggleFocusable();
        }
      }
    },

    /** @private */
    _onSelectAll: function(event) {
      if (this.selectable) {
        var rows = this._getRows(['body']);

        if (rows.length) {
          if (this.multiple) {
            var selected = event.target.checked;

            rows.forEach(function(row) {
              // Don't trigger too many events
              row.set('selected', selected, true);
            });

            rows = selected ? rows : [];

            // Synchronise the table select handle
            this._setSelectAllHandleState(selected ? 'checked' : 'unchecked');

            this.trigger('coral-table:change', {
              selection: rows,
              oldSelection: this._oldSelection
            });

            // Sync used collection
            this._oldSelection = rows;
            this._lastSelectedItems.items = rows;
          }
          else {
            // Only select last item
            var lastItem = rows[rows.length - 1];
            lastItem.selected = !lastItem.selected;
          }
        }
      }
    },

    _triggerChangeEvent: function() {
      if (!this._preventTriggeringEvents) {
        var selectedItems = this.selectedItems;
        this.trigger('coral-table:change', {
          oldSelection: this._oldSelection,
          selection: selectedItems
        });

        this._oldSelection = selectedItems;
      }
    },

    /** @private */
    _onRowOrder: function(event) {
      var table = this;
      var row = event.target.closest('tr[is="coral-table-row"]');

      if (row && table.orderable) {
        var head = table._elements.head;
        var body = table._elements.body;
        var sticky = head && head.sticky;
        var style = row.getAttribute('style');
        var index = getIndexOf(row);
        var oldBefore = row.nextElementSibling;
        var dragAction = new Coral.DragAction(row);
        var items = table.items.getAll();
        var tableBoundingClientRect = table.getBoundingClientRect();
        var rowBoundingClientRect = row.getBoundingClientRect();

        if (row === items[0]) {
          table.classList.add(IS_FIRST_ITEM_DRAGGED);
        }
        else if (row === items[items.length - 1]) {
          table.classList.add(IS_LAST_ITEM_DRAGGED);
        }

        dragAction.axis = 'vertical';
        // Handle the scroll in table
        dragAction.scroll = false;
        // Specify selection handle directly on the row if none found
        dragAction.handle = row.querySelector('[coral-table-roworder]');

        // The row placeholder indicating where the dragged element will be dropped
        var placeholder = row.cloneNode(true);
        placeholder.classList.add(placeholder._className + '--placeholder');

        // Prepare the row position before inserting its placeholder
        row.style.top = (rowBoundingClientRect.top - tableBoundingClientRect.top) + 'px';

        // Prevent change event from triggering if the cloned node is selected
        table._preventTriggeringEvents = true;
        body.insertBefore(placeholder, row.nextElementSibling);
        Coral.commons.nextFrame(function() {
          table._preventTriggeringEvents = false;
        });

        // Store the data to avoid re-reading the layout on drag events
        var dragData = {
          placeholder: placeholder,
          index: index,
          oldBefore: oldBefore,
          // Backup styles to restore them later
          style: {
            row: style
          }
        };

        // Required to handle the scrolling of the sticky table on drag events
        if (sticky) {
          dragData.sticky = sticky;
          dragData.tableTop = tableBoundingClientRect.top;
          dragData.tableSize = tableBoundingClientRect.height;
          dragData.headSize = parseFloat(table._elements.container.style.marginTop);
          dragData.dragElementSize = rowBoundingClientRect.height;
        }

        row.dragAction._dragData = dragData;
      }
    },

    /** @private */
    _onHeaderCellSort: function(event) {
      var table = this;
      var matchedTarget = event.matchedTarget;

      // Don't sort if the column was dragged
      if (!matchedTarget._isDragging) {
        var column = table._getColumn(matchedTarget);
        // Only sort if actually sortable and event not defaultPrevented
        if (column && column.sortable) {
          event.preventDefault();
          column._sort();

          // Restore focus on the header cell in any case
          matchedTarget.focus();
        }
      }
    },

    /** @private */
    _onHeaderCellDragStart: function(event) {
      var table = this;
      var matchedTarget = event.matchedTarget;
      var dragElement = event.detail.dragElement;
      var siblingHeaderCellSelector = matchedTarget === dragElement ? 'th[is="coral-table-headercell"]' : 'th[is="coral-table-headercell"] coral-table-headercell-content';
      var tableBoundingClientRect = table.getBoundingClientRect();

      // Store the data to be used on drag events
      dragElement.dragAction._dragData = {
        draggedColumnIndex: getIndexOf(matchedTarget),
        tableLeft: tableBoundingClientRect.left,
        tableSize: tableBoundingClientRect.width,
        dragElementSize: matchedTarget.getBoundingClientRect().width,
        tableScrollWidth: table._elements.container.scrollWidth
      };

      getSiblingsOf(matchedTarget, siblingHeaderCellSelector, 'prevAll').forEach(function(item) {
        item.classList.add(IS_BEFORE_CLASS);
      });

      getSiblingsOf(matchedTarget, siblingHeaderCellSelector, 'nextAll').forEach(function(item) {
        item.classList.add(IS_AFTER_CLASS);
      });
    },

    /** @private */
    _onHeaderCellDrag: function(event) {
      var table = this;
      var container = table._elements.container;
      var matchedTarget = event.matchedTarget;
      var dragElement = event.detail.dragElement;
      var dragData = dragElement.dragAction._dragData;
      var row = matchedTarget.parentElement;
      var isHeaderCellDragged = matchedTarget === dragElement;
      var containerScrollLeft = container.scrollLeft;
      var documentScrollLeft = document.body.scrollLeft;

      // Prevent sorting on header cell click if the header cell is being dragged
      matchedTarget._isDragging = true;

      // Scroll left/right if table edge is reached
      var position = dragElement.getBoundingClientRect().left - dragData.tableLeft;
      var leftScrollLimit = 0;
      var rightScrollLimit =  dragData.tableSize - dragData.dragElementSize;
      var scrollOffset = 10;

      if (position < leftScrollLimit) {
        container.scrollLeft -= scrollOffset;
      }
      // 2nd condition is required to avoid increasing the container scroll width
      else if (position > rightScrollLimit && (containerScrollLeft + dragData.tableSize < dragData.tableScrollWidth)) {
        container.scrollLeft += scrollOffset;
      }

      // Position sibling header cells based on the dragged element
      row._getCells(['headerCells']).forEach(function(headerCell) {
        var draggedHeaderCell = isHeaderCellDragged ? headerCell : headerCell.content;

        if (!draggedHeaderCell.classList.contains(IS_DRAGGING_CLASS)) {

          var offsetLeft = draggedHeaderCell.getBoundingClientRect().left + documentScrollLeft;
          var isAfter = event.detail.pageX < (offsetLeft + draggedHeaderCell.offsetWidth / 3);

          draggedHeaderCell.classList.toggle(IS_AFTER_CLASS, isAfter);
          draggedHeaderCell.classList.toggle(IS_BEFORE_CLASS, !isAfter);

          var columnIndex = getIndexOf(headerCell);
          var dragElementIndex = getIndexOf(matchedTarget);

          // Place headercell after
          if (draggedHeaderCell.classList.contains(IS_AFTER_CLASS)) {
            if (columnIndex < dragElementIndex) {
              var draggedHeaderCellComputedStyle = window.getComputedStyle(draggedHeaderCell);
              var nextHeaderCellPadding = parseFloat(draggedHeaderCellComputedStyle.paddingLeft) + parseFloat(draggedHeaderCellComputedStyle.paddingRight);

              // Position the header cells based on their siblings position
              if (isHeaderCellDragged) {
                var nextHeaderCellWidth = parseFloat(draggedHeaderCellComputedStyle.width);
                draggedHeaderCell.style.left = (nextHeaderCellWidth + nextHeaderCellPadding) + 'px';
              }
              else {
                var nextHeaderCell = getSiblingsOf(headerCell, 'th[is="coral-table-headercell"]', 'next');
                var nextHeaderCellLeftOffset = nextHeaderCell.getBoundingClientRect().left + documentScrollLeft;
                draggedHeaderCell.style.left = nextHeaderCellLeftOffset - nextHeaderCellPadding + containerScrollLeft + 'px';
              }
            }
            else {
              draggedHeaderCell.style.left = '';
            }
          }

          // Place headerCell before
          if (draggedHeaderCell.classList.contains(IS_BEFORE_CLASS)) {
            if (columnIndex > dragElementIndex) {
              var prev = getSiblingsOf(headerCell, 'th[is="coral-table-headercell"]', 'prev');
              var prevHeaderCellComputedStyle = window.getComputedStyle(prev);
              var beforeHeaderCellPadding = parseFloat(prevHeaderCellComputedStyle.paddingLeft) + parseFloat(prevHeaderCellComputedStyle.paddingRight);

              // Position the header cells based on their siblings position
              if (isHeaderCellDragged) {
                var beforeHeaderCellWidth = parseFloat(prevHeaderCellComputedStyle.width);
                draggedHeaderCell.style.left = - (beforeHeaderCellWidth + beforeHeaderCellPadding) + 'px';
              }
              else {
                var beforeHeaderCellLeftOffset = prev.getBoundingClientRect().left + documentScrollLeft;
                draggedHeaderCell.style.left = beforeHeaderCellLeftOffset - beforeHeaderCellPadding + containerScrollLeft + 'px';
              }
            }
            else {
              draggedHeaderCell.style.left = '';
            }
          }
        }
      });
    },

    /** @private */
    _onHeaderCellDragEnd: function(event) {
      var table = this;
      var matchedTarget = event.matchedTarget;
      var dragElement = event.detail.dragElement;
      var colGroup = table.columns;
      var dragData = dragElement.dragAction._dragData;
      var column = table._getColumn(matchedTarget);
      var headRows = table._getRows(['head']);
      var isHeaderCellDragged = matchedTarget === dragElement;
      var row = matchedTarget.parentElement;

      // Select all cells in table body and foot given the index
      var getCellsByIndex = function(cellIndex) {
        var cells = [];
        table._getRows(['body', 'foot']).forEach(function(row) {
          var cell = row._getCellByIndex(cellIndex);
          if (cell) {
            cells.push(cell);
          }
        });
        return cells;
      };

      var cells = getCellsByIndex(getIndexOf(matchedTarget));
      var before = null;
      var after = null;

      // Siblings are either header cell or header cell content based on the current sticky state
      if (isHeaderCellDragged) {
        before = row.querySelector('th[is="coral-table-headercell"]' + '.' + IS_AFTER_CLASS);

        after = row.querySelectorAll('th[is="coral-table-headercell"]' + '.' + IS_BEFORE_CLASS);
        after = after.length ? after[after.length - 1] : null;
      }
      else {
        before = row.querySelector('th[is="coral-table-headercell"] > coral-table-headercell-content' + '.' + IS_AFTER_CLASS);
        before = before ? before.parentNode : null;

        after = row.querySelectorAll('th[is="coral-table-headercell"] > coral-table-headercell-content' + '.' + IS_BEFORE_CLASS);
        after = after.length ? after[after.length - 1].parentNode : null;
      }

      // Did header cell order change ?
      var swapped = !((before && before.previousElementSibling === matchedTarget) || (after && after.nextElementSibling === matchedTarget));

      // Switch whole columns based on the new position of the dragged element
      if (swapped) {
        var beforeColumn = before ? table._getColumn(before) : null;

        // Trigger the event on table
        var beforeEvent = table.trigger('coral-table:beforecolumndrag', {
          column: column,
          before: beforeColumn
        });

        var oldBefore = column.nextElementSibling;

        if (!beforeEvent.defaultPrevented) {
          // Insert the headercell at the new position
          if (before) {
            var beforeIndex = getIndexOf(before);
            var beforeCells = getCellsByIndex(beforeIndex);
            cells.forEach(function(cell, i) {
              cell.parentNode.insertBefore(cell, beforeCells[i]);
            });

            // Sync <coral-table-column> by reordering it too
            var beforeCol = table._getColumns()[beforeIndex];
            if (beforeCol && column) {
              colGroup.insertBefore(column, beforeCol);
            }

            row.insertBefore(matchedTarget, before);
          }
          if (after) {
            var afterIndex = getIndexOf(after);
            var afterCells = getCellsByIndex(afterIndex);
            cells.forEach(function(cell, i) {
              cell.parentNode.insertBefore(cell, afterCells[i].nextElementSibling);
            });

            // Sync <coral-table-column> by reordering it too
            var afterCol = table._getColumns()[afterIndex];
            if (afterCol && column) {
              colGroup.insertBefore(column, afterCol.nextElementSibling);
            }

            row.insertBefore(matchedTarget, after.nextElementSibling);
          }

          // Trigger the order event if the column position changed
          if (dragData.draggedColumnIndex !== getIndexOf(matchedTarget)) {
            var newBefore = table._getColumns()[getIndexOf(column) + 1];
            table.trigger('coral-table:columndrag', {
              column: column,
              oldBefore: oldBefore,
              before: newBefore || null
            });
          }
        }
      }

      // Restoring default header cells styling
      headRows.forEach(function(row) {
        row._getCells(['headerCells']).forEach(function(headerCell) {
          headerCell = isHeaderCellDragged ? headerCell :  headerCell.content;
          headerCell.classList.remove(IS_AFTER_CLASS);
          headerCell.classList.remove(IS_BEFORE_CLASS);
          headerCell.style.left = '';
        });
      });

      // Trigger a relayout
      table._resetLayout();

      Coral.commons.nextFrame(function() {
        // Allows sorting again after dragging completed
        matchedTarget._isDragging = undefined;
        // Refocus the dragged element manually
        table._toggleElementTabIndex(dragElement, null, true);
      });
    },

    /** @private */
    _onCellSelect: function(event) {
      var cell = event.target.closest('td[is="coral-table-cell"]');

      if (cell) {
        cell.selected = !cell.selected;
      }
    },

    /** @private */
    _onRowSelect: function(event) {
      var table = this;
      var row = event.target.closest('tr[is="coral-table-row"]');

      if (row) {
        // Restore text-selection
        table.classList.remove(IS_UNSELECTABLE);

        // Prevent row selection when it's the selection handle and the target is an input
        if (table.selectable && (Coral.Keys.filterInputs(event) || !row.hasAttribute('coral-table-rowselect'))) {
          // Pressing space scrolls the sticky table to the bottom if scrollable
          if (event.keyCode === KEY_SPACE) {
            event.preventDefault();
          }

          if (event.shiftKey) {
            var lastSelectedItem = table._lastSelectedItems.items[table._lastSelectedItems.items.length - 1];
            var lastSelectedDirection = table._lastSelectedItems.direction;

            // If no selected items, by default set the first item as last selected item
            if (!table.selectedItem) {
              var rows = table._elements.body._elements.rows;
              if (rows.length) {
                lastSelectedItem = rows[0];
                lastSelectedItem.selected = true;
              }
            }

            // Don't continue if table has no items or if the last selected item is the clicked item
            if (lastSelectedItem && getIndexOf(row) !== getIndexOf(lastSelectedItem)) {

              // Range selection direction
              var before = getIndexOf(row) < getIndexOf(lastSelectedItem);
              var rangeQuery = before ? 'prevUntil' : 'nextUntil';

              // Store direction
              table._lastSelectedItems.direction = before ? 'up' : 'down';

              if (!row.selected) {

                // Store selection range
                var selectionRange = getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]:not([selected])', rangeQuery);
                selectionRange[before ? 'push' : 'unshift'](lastSelectedItem);

                // Direction change
                if (!before && lastSelectedDirection === 'up' || before && lastSelectedDirection === 'down') {
                  selectionRange.forEach(function(item) {
                    item.selected = false;
                  });
                }

                // Select item
                var selectionRangeRow = selectionRange[before ? 0 : selectionRange.length - 1];
                selectionRangeRow.selected = true;
                getSiblingsOf(selectionRangeRow, row, rangeQuery).forEach(function(item) {
                  item.selected = true;
                });
              }
              else {
                var selection = getSiblingsOf(lastSelectedItem, row, rangeQuery);

                // If some items are not selected
                if (selection.some(function(item) {
                  return (!item.hasAttribute('selected'));
                })) {
                  // Select all items in between
                  selection.forEach(function(item) {
                    item.selected = true;
                  });

                  // Deselect selected item right before/after the selection range
                  getSiblingsOf(row, 'tr[is="coral-table-row"]:not([selected])', rangeQuery).forEach(function(item) {
                    item.selected = false;
                  });
                }
                else {
                  // Deselect items
                  selection[before ? 'push' : 'unshift'](lastSelectedItem);
                  selection.forEach(function(item) {
                    item.selected = false;
                  });
                }
              }
            }
          }
          else {
            // Remove direction if simple click without shift key pressed
            table._lastSelectedItems.direction = null;
          }

          // Select the row that was clicked and keep the row selected if shift key was pressed
          row.selected = event.shiftKey ? true : !row.selected;

          // Don't focus the row if the target isn't the row and focusable
          table._focusItem(row, event.target === event.matchedTarget || event.target.tabIndex < 0);
        }
      }
    },

    /** @private */
    _onRowLock: function(event) {
      var table = this;

      if (table.lockable) {
        var row = event.target.closest('tr[is="coral-table-row"]');
        if (row) {
          event.preventDefault();
          event.stopPropagation();
          row.locked = !row.locked;

          // Refocus the locked/unlocked item manually
          Coral.commons.nextFrame(function() {
            table._focusItem(row, true);
          });
        }
      }
    },

    /** @private */
    _onRowDown: function(event) {
      var table = this;

      // Prevent text-selection
      if (table.selectedItem && event.shiftKey) {
        table.classList.add(IS_UNSELECTABLE);

        // @polyfill IE
        // Store text selection feature
        var onSelectStart = document.onselectstart;
        // Kill text selection feature
        document.onselectstart = function() { return false; };
        // Restore text selection feature
        Coral.commons.nextFrame(function() {
          document.onselectstart = onSelectStart;
        });
      }
    },

    /** @private */
    _onRowDragStart: function(event) {
      var table = this;
      var body = table._elements.body;
      var dragElement = event.detail.dragElement;
      var dragData = dragElement.dragAction._dragData;

      dragData.style.cells = [];
      dragElement._getCells().forEach(function(cell) {
        // Backup styles to restore them later
        dragData.style.cells.push(cell.content.getAttribute('style'));
        // Cells will shrink otherwise
        cell.content.style.width = window.getComputedStyle(cell).width;
      });

      dragElement.style.position = 'absolute';

      // Setting drop zones allows to listen for coral-dragaction:dragover event
      dragElement.dragAction.dropZone = body.querySelectorAll('tr[is="coral-table-row"]:not(.'+ IS_DRAGGING_CLASS +')');

      // We cannot rely on :focus since the row is being moved in the dom while dnd
      dragElement.classList.add('is-focused');
    },

    /** @private */
    _onRowDrag: function(event) {
      var table = this;
      var body = table._elements.body;
      var dragElement = event.detail.dragElement;
      var dragData = dragElement.dragAction._dragData;
      var firstRow = body._elements.rows[0];

      // Insert the placeholder at the top
      if (dragElement.getBoundingClientRect().top <= firstRow.getBoundingClientRect().top) {
        table._preventTriggeringEvents = true;
        body.insertBefore(dragData.placeholder, firstRow);
        Coral.commons.nextFrame(function() {
          table._preventTriggeringEvents = false;
        });
      }

      // Scroll up/down if table edge is reached
      if (dragData.sticky) {
        var dragElementTop = dragElement.getBoundingClientRect().top;
        var position = dragElementTop - dragData.tableTop - dragData.headSize;
        var topScrollLimit = 0;
        var bottomScrollTimit =  dragData.tableSize - dragData.dragElementSize - dragData.headSize;
        var scrollOffset = 10;

        // Handle the scrollbar position based on the dragged element position.
        // nextFrame is required else Chrome wouldn't take scrollTop changes in account when dragging the first row down
        Coral.commons.nextFrame(function() {
          if (position < topScrollLimit) {
            table._elements.container.scrollTop -= scrollOffset;
          }
          else if (position > bottomScrollTimit) {
            table._elements.container.scrollTop += scrollOffset;
          }
        });
      }
    },

    /** @private */
    _onRowDragOver: function(event) {
      var table = this;
      var body = table._elements.body;
      var dragElement = event.detail.dragElement;
      var dropElement = event.detail.dropElement;
      var dragData = dragElement.dragAction._dragData;

      // Swap the placeholder
      if (dragElement.getBoundingClientRect().top >= dropElement.getBoundingClientRect().top) {
        table._preventTriggeringEvents = true;
        body.insertBefore(dragData.placeholder, dropElement.nextElementSibling);
        Coral.commons.nextFrame(function() {
          table._preventTriggeringEvents = false;
        });
      }
    },

    /** @private */
    _onRowDragEnd: function(event) {
      var table = this;
      var body = table._elements.body;
      var dragElement = event.detail.dragElement;

      var dragData = dragElement.dragAction._dragData;
      var before = dragData.placeholder.nextElementSibling;

      // Clean up
      table.classList.remove(IS_FIRST_ITEM_DRAGGED);
      table.classList.remove(IS_LAST_ITEM_DRAGGED);

      body.removeChild(dragData.placeholder);
      dragElement.dragAction.destroy();

      // Restore specific styling
      dragElement.setAttribute('style', dragData.style.row);
      dragElement._getCells().forEach(function(cell, i) {
        cell.content.setAttribute('style', dragData.style.cells[i]);
      });

      // Trigger the event on table
      var beforeEvent = table.trigger('coral-table:beforeroworder', {
        row: dragElement,
        before: before
      });

      if (!beforeEvent.defaultPrevented) {
        // Did row order change ?
        var rows = table._getRows(['body']).filter(function(item) {
          return (item !== dragElement);
        });

        if (dragData.index !== rows.indexOf(dragData.placeholder)) {
          // Insert the row at the new position and prevent change event from triggering
          table._preventTriggeringEvents = true;
          body.insertBefore(dragElement, before);
          Coral.commons.nextFrame(function() {
            table._preventTriggeringEvents = false;
          });

          // Trigger the order event if the row position changed
          table.trigger('coral-table:roworder', {
            row: dragElement,
            oldBefore: dragData.oldBefore,
            before: before
          });
        }
      }

      // Refocus the dragged element manually
      Coral.commons.nextFrame(function() {
        dragElement.classList.remove('is-focused');
        table._focusItem(dragElement, true);
      });
    },

    /** @private */
    _onRowMultipleChanged: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var row = event.target;

      // Deselect all except last
      if (!row.multiple) {
        var selectedItems = row.selectedItems;
        table._preventTriggeringEvents = true;
        selectedItems.forEach(function(cell, i) {
          cell.selected = (i === selectedItems.length - 1);
        });

        Coral.commons.nextFrame(function() {
          table._preventTriggeringEvents = false;

          table.trigger('coral-table:rowchange', {
            oldSelection: selectedItems,
            selection: row.selectedItems,
            row: row
          });
        });
      }
    },

    /** @private */
    _onBeforeRowSelectionChanged: function(event) {
      event.stopImmediatePropagation();

      // In single selection, if the added item is selected, the rest should be deselected
      var selectedItem = this.selectedItem;
      if (!this.multiple && selectedItem && !event.target.selected) {
        selectedItem.set('selected', false, true);
        this._removeLastSelectedItem(selectedItem);
      }
    },

    /** @private */
    _syncSelectAllHandle: function(selectedItems, items) {
      if (items.length && selectedItems.length === items.length) {
        this._setSelectAllHandleState('checked');
      }
      else if (!selectedItems.length) {
        this._setSelectAllHandleState('unchecked');
      }
      else {
        this._setSelectAllHandleState('indeterminate');
      }
    },

    /** @private */
    _setSelectAllHandleState: function(state) {
      var handle = this.querySelector('[coral-table-select]');

      if (handle) {
        if (state === 'checked') {
          if (typeof handle.indeterminate !== 'undefined') {
            handle.indeterminate = false;
          }

          if (typeof handle.checked !== 'undefined') {
            handle.checked = true;
          }
        }
        else if (state === 'unchecked') {
          if (typeof handle.indeterminate !== 'undefined') {
            handle.indeterminate = false;
          }

          if (typeof handle.checked !== 'undefined') {
            handle.checked = false;
          }
        }
        else if (state === 'indeterminate') {
          if (typeof handle.indeterminate !== 'undefined') {
            handle.indeterminate = true;
          }
        }
      }
    },

    /** @private */
    _onRowSelectionChanged: function(event) {
      event.stopImmediatePropagation();

      this._triggerChangeEvent();

      var table = this;
      var row = event.target;
      Coral.commons.nextFrame(function() {
        // Synchronise the table select handle
        var body = table._elements.body;
        if (body && body.contains(row)) {
          var selection = table.selectedItems;
          var rows = body._elements.rows;

          // Sync select all handle
          table._syncSelectAllHandle(selection, rows);

          // Store or remove the row reference
          table[row.selected ? '_addLastSelectedItem' : '_removeLastSelectedItem'](row);

          // Store selected items range
          var lastSelectedItem = table._lastSelectedItems.items[table._lastSelectedItems.items.length - 1];
          var next = table._lastSelectedItems.direction === 'down';
          if (row.selected && lastSelectedItem && lastSelectedItem.selected && getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"][selected]', next ? 'next' : 'prev')) {
            getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]:not([selected])', next ? 'nextUntil' : 'prevUntil').forEach(function(item) {
              table._addLastSelectedItem(item);
            });
          }
        }
      });
    },

    _onRowLockedChanged: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var body = this._elements.body;
      var row = event.target;

      if (body && body.contains(row)) {
        if (row.locked) {
          // Store the row index as reference to place it back if unlocked and its selection state
          row._rowIndex = getIndexOf(row);

          // Insert row at first position of its tbody
          table._preventTriggeringEvents = true;
          body.insertBefore(row, body._elements.rows[0] || null);
          Coral.commons.nextFrame(function() {
            table._preventTriggeringEvents = false;
          });

          // Trigger event on table
          table.trigger('coral-table:rowlock', {
            row: row
          });
        }
        else {
          // Put the row back to its initial position
          if (row._rowIndex >= 0) {
            var beforeRow = body._elements.rows[row._rowIndex];
            if (beforeRow) {
              // Insert row at its initial position
              table._preventTriggeringEvents = true;
              body.insertBefore(row, beforeRow.nextElementSibling);
              Coral.commons.nextFrame(function() {
                table._preventTriggeringEvents = false;
              });
            }
          }

          // Trigger event on table
          table.trigger('coral-table:rowunlock', {
            row: row
          });
        }
      }
    },

    _onHeadContentChanged: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var head = table._elements.head;
      var addedNodes = event.detail.addedNodes;

      for (var i = 0; i < addedNodes.length; i++) {
        var node = addedNodes[i];

        // Sync header cell whether sticky or not
        if (node instanceof Coral.Table.HeaderCell) {
          table._toggleStickyHeaderCell(node, head.sticky);
        }
      }
    },

    /** @private */
    _onBodyContentChanged: function(event) {
      if (event.stopImmediatePropagation) {
        event.stopImmediatePropagation();
      }

      var table = this;
      var body = event.target;
      var addedNodes = event.detail.addedNodes;
      var removedNodes = event.detail.removedNodes;
      var addedNode = null;
      var selectItem = function(item) {
        item.selected = item === addedNode;
      };
      var changed = false;

      // Sync added nodes
      for (var i = 0; i < addedNodes.length; i++) {
        addedNode = addedNodes[i];

        // Sync row state with table properties
        if (addedNode instanceof Coral.Table.Row) {
          changed = true;

          addedNode._toggleSelectable(table.selectable);
          addedNode._toggleOrderable(table.orderable);
          addedNode._toggleLockable(table.lockable);

          var selectedItems = table.selectedItems;
          if (addedNode.selected) {
            // In single selection, if the added item is selected, the rest should be deselected
            if (!table.multiple && selectedItems.length > 1) {
              selectedItems.forEach(selectItem);
            }

            table._triggerChangeEvent();
            addedNode._syncProp('selected');
          }

          // Cells are selectable too
          if (addedNode.selectable) {
            addedNode.trigger('coral-table-row:_contentchanged', {
              addedNodes: addedNode._elements.cells,
              removedNodes: []
            });
          }

          // Trigger collection event
          if (!table._preventTriggeringEvents) {
            table.trigger('coral-collection:add', {
              item: addedNode
            });
          }
  
          // a11y
          table._toggleFocusable();
        }
      }

      // Sync removed nodes
      for (var k = 0; k < removedNodes.length; k++) {
        var removedNode = removedNodes[k];

        if (removedNode instanceof Coral.Table.Row) {
          changed = true;

          // If the focusable item is removed, the first item becomes the new focusable item
          if (removedNode.getAttribute('tabindex') === '0') {
            var firstItem = body._elements.rows[0];
            if (firstItem) {
              table._focusItem(firstItem);
            }
          }

          if (removedNode.selected) {
            table._triggerChangeEvent();
          }

          // Sync _lastSelectedItems array
          var removedItemIndex = table._lastSelectedItems.items.indexOf(removedNode);
          if (removedItemIndex !== -1) {
            table._lastSelectedItems.items = table._lastSelectedItems.items.splice(removedItemIndex, 1);
          }

          // Trigger collection event
          if (!table._preventTriggeringEvents) {
            table.trigger('coral-collection:remove', {
              item: removedNode
            });
          }
        }
      }
      
      if (changed) {
        var items = table.items.getAll();
        // Sync select all handle if any.
        table._syncSelectAllHandle(table.selectedItems, items);
        // Disable table features if no items.
        table._toggleInteractivity(items.length === 0);
      }
    },

    /** @private */
    _onBodyEmpty: function(event) {
      event.stopImmediatePropagation();
      this._toggleInteractivity(true);
    },

    /** @private */
    _onRowChange: function(event) {
      event.stopImmediatePropagation();

      if (!this._preventTriggeringEvents) {
        this.trigger('coral-table:rowchange', {
          oldSelection: event.detail.oldSelection,
          selection: event.detail.selection,
          row: event.target
        });
      }
    },

    /** @private */
    _onRowContentChanged: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var row = event.target;
      var addedNodes = event.detail.addedNodes;
      var addedNode = null;
      var removedNodes = event.detail.removedNodes;
      var selectItem = function(item) {
        item.selected = item === addedNode;
      };

      // Sync added nodes
      for (var i = 0; i < addedNodes.length; i++) {
        addedNode = addedNodes[i];

        // Sync row state with table properties
        if (addedNode instanceof Coral.Table.Cell) {
          addedNode._toggleSelectable(row.selectable);

          var selectedItems = row.selectedItems;
          if (addedNode.selected) {
            // In single selection, if the added item is selected, the rest should be deselected
            if (!row.multiple && selectedItems.length > 1) {
              selectedItems.forEach(selectItem);
            }

            row._triggerChangeEvent();
            addedNode._syncProp('selected');
          }

          // Trigger collection event
          if (!table._preventTriggeringEvents) {
            row.trigger('coral-collection:add', {
              item: addedNode
            });
          }
        }
        // Add appropriate scope depending on whether headercell is in THEAD or TBODY
        else if (addedNode instanceof Coral.Table.HeaderCell) {
          table._setHeaderCellScope(addedNode, row.parentNode);
        }
      }

      // Sync removed nodes
      for (var k = 0; k < removedNodes.length; k++) {
        var removedNode = removedNodes[k];

        if (removedNode instanceof Coral.Table.Cell) {

          if (removedNode.selected) {
            row._triggerChangeEvent();
          }

          // Trigger collection event
          if (!table._preventTriggeringEvents) {
            row.trigger('coral-collection:remove', {
              item: removedNode
            });
          }
        }
      }
    },

    /** @private */
    _toggleInteractivity: function(disable) {
      var table = this;
      var selectAll = table.querySelector('[coral-table-select]');

      if (selectAll) {
        selectAll.disabled = disable;
      }

      table.classList.toggle(IS_DISABLED, disable);
    },

    /** @private */
    _onFixedWidthSync: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var head = table._elements.head;
      var column = event.target;

      if (head && head._elements) {
        var headRows = head._elements.rows;
        var columnIndex = getIndexOf(event.target);

        Array.prototype.forEach.call(headRows, function(row) {
          var headerCell = row._getCellByIndex(columnIndex, ['headerCell']);
          if (headerCell) {
            headerCell[column.fixedWidth ? 'setAttribute' : 'removeAttribute']('fixedwidth', '');
          }
        });
      }
    },

    /** @private */
    _onColumnOrderableSync: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var head = this._elements.head;
      var column = event.target;
      var headerCell = table._getColumnHeaderCell(column);

      if (headerCell) {
        // Move the drag handle
        table._toggleDragActionHandle(headerCell, (head && head.sticky));

        table._resetLayout();
      }
    },

    /** @private */
    _onColumnSortableSync: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var head = this._elements.head;
      var column = event.target;
      var headerCell = table._getColumnHeaderCell(column);

      if (headerCell) {
        // For icons (chevron up/down) styling
        headerCell[column.sortable ? 'setAttribute' : 'removeAttribute']('sortable', '');

        // Toggle tab index. Sortable headercells are focusable.
        table._toggleHeaderCellTabIndex(headerCell, (head && head.sticky));

        table._resetLayout();
      }
    },

    _onColumnSortableDirectionSync: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var column = event.target;
      var sortableDirection = Coral.Table.Column.sortableDirection;

      // Hide coral-table-roworder handles if table is sorted
      table.classList.toggle(IS_SORTED, table._isSorted());

      var headerCell = table._getColumnHeaderCell(column);
      if (headerCell) {
        // For icons (chevron up/down) styling
        headerCell.setAttribute('sortabledirection', column.sortableDirection);
        headerCell.setAttribute('aria-sort',
                                column.sortableDirection === sortableDirection.DEFAULT ? 'none' : column.sortableDirection);
      }
    },

    _onColumnHiddenSync: function(event) {
      event.stopImmediatePropagation();

      this._syncHiddenColumn(event.target, true);
    },

    _onBeforeColumnSort: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var column = event.target;
      var newSortableDirection = event.detail.newSortableDirection;

      var beforeEvent = table.trigger('coral-table:beforecolumnsort', {
        column: column,
        direction: newSortableDirection
      });

      if (!beforeEvent.defaultPrevented) {
        column.sortableDirection = newSortableDirection;
      }
    },

    _onColumnSort: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var body = table._elements.body;
      var column = event.target;
      var columnIndex = getIndexOf(column);
      var colHeaderCell = table._getColumnHeaderCell(column);
      var onInitialization = event.detail.onInitialization;
      var sortableDirection = event.detail.sortableDirection;
      var sortableType = event.detail.sortableType;

      var rows = table._getRows(['body']);
      var cells = [];

      // Prevent change event from triggering when sorting
      if (table) {
        table._preventTriggeringEvents = true;
      }

      // Store a reference of the default row index for default sortable direction
      rows.forEach(function(row, i) {
        if (typeof row._defaultRowIndex === 'undefined') {
          row._defaultRowIndex = i;
        }

        var cell = row._getCellByIndex(columnIndex);
        if (cell) {
          cells.push(cell);
        }
      });

      if (column.sortableDirection === sortableDirection.ASCENDING) {
        // Remove sortable direction on sibling columns
        getSiblingsOf(column, 'col[is="coral-table-column"]').forEach(function(col) {
          col._preventSort = true;
          col.sortableDirection = sortableDirection.DEFAULT;
          col._preventSort = false;
        });

        if (colHeaderCell) {
          // For icons (chevron up/down) styling
          getSiblingsOf(colHeaderCell, 'th[is="coral-table-headercell"]').forEach(function(headerCell) {
            headerCell.setAttribute('sortabledirection', sortableDirection.DEFAULT);
            headerCell.setAttribute('aria-sort', 'none');
          });
        }

        // Use cell value to sort and fallback if not specified
        cells.sort(function(a, b) {
          if (column.sortableType === sortableType.ALPHANUMERIC) {
            var aText = a.value ? a.value : a.textContent;
            var bText = b.value ? b.value : b.textContent;
            return aText.localeCompare(bText);
          }
          else if (column.sortableType === sortableType.NUMBER) {
            // Remove all spaces and replace commas with dots for decimal values
            var aNumber = parseFloat(a.value ? a.value : a.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
            var bNumber = parseFloat(b.value ? b.value : b.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
            return aNumber > bNumber ? 1 : -1;
          }
          else if (column.sortableType === sortableType.DATE) {
            var aDate = a.value ? new Date(parseInt(a.value, 10)) : new Date(a.textContent);
            var bDate = b.value ? new Date(parseInt(b.value, 10)) : new Date(b.textContent);
            return aDate > bDate ? 1 : -1;
          }
        });

        // Only sort if not custom sorting
        if (column.sortableType !== sortableType.CUSTOM) {
          if (body) {
            // Insert the row at the new position if actually sorted
            cells.forEach(function(cell) {
              var row = cell.parentElement;
              // Prevent locked row to be sorted
              if (!row.locked) {
                body.appendChild(row);
              }
            });
          }

          // Trigger on table
          table.trigger('coral-table:columnsort', {
            column: column
          });
        }

        // Table is in a sorted state. Disable orderable actions
        rows.forEach(function(row) {
          if (row.dragAction) {
            row.dragAction.destroy();
          }
        });
      }
      else if (column.sortableDirection === sortableDirection.DESCENDING) {
        getSiblingsOf(column, 'col[is="coral-table-column"]').forEach(function(col) {
          col._preventSort = true;
          col.sortableDirection = sortableDirection.DEFAULT;
          col._preventSort = false;
        });

        if (colHeaderCell) {
          getSiblingsOf(colHeaderCell, 'th[is="coral-table-headercell"]').forEach(function(headerCell) {
            headerCell.setAttribute('sortabledirection', sortableDirection.DEFAULT);
            headerCell.setAttribute('aria-sort', 'none');
          });
        }

        cells.sort(function(a, b) {
          if (column.sortableType === sortableType.ALPHANUMERIC) {
            var aText = a.value ? a.value : a.textContent;
            var bText = b.value ? b.value : b.textContent;
            return bText.localeCompare(aText);
          }
          else if (column.sortableType === sortableType.NUMBER) {
            // Remove all spaces and replace commas with dots for decimal values
            var aNumber = parseFloat(a.value ? a.value : a.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
            var bNumber = parseFloat(b.value ? b.value : b.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
            return aNumber < bNumber ? 1 : -1;
          }
          else if (column.sortableType === sortableType.DATE) {
            var aDate = a.value ? new Date(parseInt(a.value, 10)) : new Date(a.textContent);
            var bDate = b.value ? new Date(parseInt(b.value, 10)) : new Date(b.textContent);
            return aDate < bDate ? 1 : -1;
          }
        });

        // Only sort if not custom sorting
        if (column.sortableType !== sortableType.CUSTOM) {
          if (body) {
            // Insert the row at the new position if actually sorted
            cells.forEach(function(cell) {
              var row = cell.parentElement;
              // Prevent locked row to be sorted
              if (!row.locked) {
                body.appendChild(row);
              }
            });
          }

          // Trigger on table
          table.trigger('coral-table:columnsort', {
            column: column
          });
        }

        // Table is in a sorted state. Disable orderable actions
        rows.forEach(function(row) {
          if (row.dragAction) {
            row.dragAction.destroy();
          }
        });
      }
      else if (column.sortableDirection === sortableDirection.DEFAULT && !onInitialization) {

        // Only sort if not custom sorting
        if (column.sortableType !== sortableType.CUSTOM) {
          // Put rows back to their initial position
          rows.sort(function(a, b) {
            return a._defaultRowIndex > b._defaultRowIndex ? 1 : -1;
          });

          rows.forEach(function(row) {
            // Prevent locked row to be sorted
            if (body && !row.locked) {
              body.appendChild(row);
            }
          });

          // Trigger on table
          table.trigger('coral-table:columnsort', {
            column: column
          });
        }
      }

      // Allow triggering change events again after sorting
      Coral.commons.nextFrame(function() {
        table._preventTriggeringEvents = false;
      });
    },

    _onHeadStickySync: function(event) {
      event.stopImmediatePropagation();

      var table = this;
      var head = event.target;

      // Hide the sticky table head until it is properly positioned
      head.classList.toggle(IS_HIDDEN, head.sticky);

      // Defines the head height
      table._resetContainerLayout(head.sticky ? head.getBoundingClientRect().height + 'px' : null);

      table._getRows(['head']).forEach(function(row) {
        row._getCells(['headerCells']).forEach(function(headerCell) {
          table._toggleStickyHeaderCell(headerCell, head.sticky);
        });
      });

      // Make sure sticky styling is applied
      table.classList.toggle(CLASSNAME + '--sticky', head.sticky);

      // Layout sticky head
      table._resetLayout();
    },

    /** @private */
    _getColumnHeaderCell: function(column) {
      var table = this;
      var headerCell = null;
      var head = table._elements.head;

      if (head && head._elements) {
        var headRows = head._elements.rows;
        var columnIndex = getIndexOf(column);
        if (headRows.length) {
          headerCell = headRows[headRows.length - 1]._getCellByIndex(columnIndex, ['headerCell']);
        }
      }

      return headerCell;
    },

    /** @private */
    _getColumn: function(headerCell) {
      // Get the corresponding column
      return this._getColumns()[getIndexOf(headerCell)] || null;
    },

    /** @private */
    _toggleStickyHeaderCell: function(headerCell, sticky) {
      // Set the size
      this._layoutStickyCell(headerCell, sticky);

      // Define DragAction on the sticky cell instead of the headercell
      this._toggleDragActionHandle(headerCell, sticky);

      // Toggle tab index. Sortable headercells are focusable.
      this._toggleHeaderCellTabIndex(headerCell, sticky);
    },

    _layoutStickyCell: function(headerCell, sticky) {
      if (sticky) {
        var computedStyle = window.getComputedStyle(headerCell);

        // Don't allow the column to shrink less than its minimum allowed
        if (!headerCell.style.minWidth) {
          var width = headerCell.content.getBoundingClientRect().width;
          // Don't set the width if the header cell is hidden
          if (width > 0) {
            headerCell.style.minWidth = width + 'px';
          }
        }

        var cellWidth = parseFloat(computedStyle.width);
        var cellPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
        var borderRightWidth = parseFloat(computedStyle.borderRightWidth);

        // Reflect headercell size on sticky cell
        headerCell.content.style.width = (cellWidth + cellPadding + borderRightWidth) + 'px';
      }
      else {
        // Restore headercell style
        headerCell.style.minWidth = '';
        headerCell.content.style.width = '';
        headerCell.content.style.height = '';
        headerCell.content.style.top = '';
        headerCell.content.style.marginLeft = '';

        // @polyfill ie/edge/firefox
        if (IS_IE_OR_EDGE || IS_FIREFOX) {
          headerCell.content.style.paddingTop = '';
        }
      }
    },

    /** @private */
    _toggleDragActionHandle: function(headerCell, sticky) {
      var column = this._getColumn(headerCell);

      if (headerCell.dragAction) {
        headerCell.dragAction.destroy();
      }
      if (headerCell.content.dragAction) {
        headerCell.content.dragAction.destroy();
      }

      if (column && column.orderable) {
        var dragAction = new Coral.DragAction(sticky ? headerCell.content : headerCell);
        dragAction.axis = 'horizontal';
        // Handle the scroll in table
        dragAction.scroll = false;
        headerCell.setAttribute('orderable', '');
      }
      else {
        headerCell.removeAttribute('orderable');
      }
    },

    /** @private */
    _toggleFocusable: function() {
      var firstItem = this._getRows(['body'])[0];
      if (!firstItem) {
        return;
      }
  
      var focusableItem = this._getFocusableItem();
      if (this.selectable || this.lockable || this.orderable) {
        // First item is focusable by default but don't remove the tabindex of the existing focusable item
        if (!focusableItem) {
          this._toggleElementTabIndex(firstItem);
        }
      }
      else if (focusableItem) {
        // Basic table is not focusable
        focusableItem.removeAttribute('tabindex');
      }
    },

    /** @private */
    _toggleElementTabIndex: function(element, oldFocusable, forceFocus) {
      if (oldFocusable) {
        oldFocusable.removeAttribute('tabindex');
      }

      element.setAttribute('tabindex', '0');
      if (forceFocus) {
        element.focus();
      }
    },

    /** @private */
    _toggleHeaderCellTabIndex: function(headerCell, sticky) {
      var column = this._getColumn(headerCell);
      var sortable = column && (column.sortable || column.orderable);
      headerCell[sortable && !sticky ? 'setAttribute' : 'removeAttribute']('tabindex', '0');
      headerCell.content[sortable && sticky ? 'setAttribute' : 'removeAttribute']('tabindex', '0');
    },

    /** @private */
    _syncHiddenColumn: function(column, resetLayout) {
      var table = this;
      var columnIndex = getIndexOf(column);

      if (columnIndex !== -1) {
        // Apply hidden on all cells in the column
        table._getRows().forEach(function(row) {
          var cell = row._getCellByIndex(columnIndex);
          if (cell) {
            cell.hidden = column.hidden;
          }
        });

        if (resetLayout) {
          table._resetLayout();
        }
      }
    },

    /** @private */
    _isSorted: function(event) {
      return this._getColumns().some(function(col) {
        return col.sortableDirection !== Coral.Table.Column.sortableDirection.DEFAULT;
      });
    },

    /** @private */
    _focusEdgeItem: function(event, first) {
      var items = this._elements.body._elements.rows;
      if (items.length) {
        event.preventDefault();

        var item = this._getFocusableItem();
        if (item) {
          item.removeAttribute('tabindex');
        }

        item = items[first ? 0 : items.length - 1];
        item.setAttribute('tabindex', '0');
        item.focus();
      }
    },

    /** @private */
    _focusSiblingItem: function(event, next) {
      var item = this._getFocusableItem();
      if (item) {
        event.preventDefault();

        var siblingItem = getSiblingsOf(item, 'tr[is="coral-table-row"]', next ? 'next' : 'prev');
        if (siblingItem) {
          item.removeAttribute('tabindex');
          siblingItem.setAttribute('tabindex', '0');
          siblingItem.focus();
        }
      }
    },

    /** @private */
    _selectSiblingItem: function(next) {
      if (this.selectable && this.multiple) {
        var selectedItems = this.selectedItems;
        var lastSelectedItem = this._lastSelectedItems.items[this._lastSelectedItems.items.length - 1];

        if (selectedItems.length) {
          // Prevent selection if we reached the edge
          if (next && lastSelectedItem.matches(':last-of-type') || !next && lastSelectedItem.matches(':first-of-type')) {
            return;
          }

          //Target sibling item
          var sibling = getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]', next ? 'next' : 'prev');
          if (!sibling.hasAttribute('selected')) {
            lastSelectedItem = sibling;
          }

          // Store last selection
          this._lastSelectedItems.direction = next ? 'down' : 'up';

          // Toggle selection
          lastSelectedItem.selected = !lastSelectedItem.selected;
        }
        else {
          if (this._elements.body && this._elements.body._elements.rows.length) {
            var focusableItem = this._getFocusableItem();

            // Store last selection
            this._lastSelectedItems.direction = next ? 'down' : 'up';

            // Select focusable item by default if no items selected
            focusableItem.selected = true;
          }
        }
      }

      // Focus last selected item
      Coral.commons.nextFrame(function() {
        var itemToFocus = this._lastSelectedItems.items[this._lastSelectedItems.items.length - 1];
        if (itemToFocus) {
          this._focusItem(itemToFocus, true);
        }
      }.bind(this));
    },

    /** @private */
    _getFocusableItem: function() {
      return this._elements.body && this._elements.body.querySelector('tr[is="coral-table-row"][tabindex="0"]');
    },

    /** @private */
    _getFocusableHeaderCell: function() {
      return this._elements.head && this._elements.head.querySelector('th[is="coral-table-headercell"][tabindex="0"], coral-table-headercell-label[tabindex="0"]');
    },

    /** @private */
    _addLastSelectedItem: function(item) {
      if (this._lastSelectedItems.items.indexOf(item) === -1) {
        this._lastSelectedItems.items.push(item);
      }
      else {
        // Push it at the end
        this._removeLastSelectedItem(item);
        this._addLastSelectedItem(item);
      }
    },

    /** @private */
    _removeLastSelectedItem: function(item) {
      this._lastSelectedItems.items.splice(this._lastSelectedItems.items.indexOf(item), 1);
    },

    /** @private */
    _focusItem: function(item, forceFocus) {
      this._toggleElementTabIndex(item, this._getFocusableItem(), forceFocus);
    },

    /** @private */
    _onFocusFirstItem: function(event) {
      this._focusEdgeItem(event, true);
    },

    /** @private */
    _onFocusLastItem: function(event) {
      this._focusEdgeItem(event, false);
    },

    /** @private */
    _onFocusNextItem: function(event) {
      this._focusSiblingItem(event, true);
    },

    /** @private */
    _onFocusPreviousItem: function(event) {
      this._focusSiblingItem(event, false);
    },

    /** @private */
    _onSelectNextItem: function(event) {
      this._selectSiblingItem(true);
    },

    /** @private */
    _onSelectPreviousItem: function(event) {
      this._selectSiblingItem(false);
    },

    /** @private */
    _setContentZone: function(value, property, expected, type, replace) {
      if (!(value instanceof expected)) {
        throw new Error('DOMException: Failed to set the \'' + property + '\' property on \'' + this.toString() +
          '\': The provided value is not of type \'' + type + '\'.');
      }

      // Replace new node
      replace.call(this, value);
    },

    /** @private */
    _render: function() {
      var self = this;
      var frag = document.createDocumentFragment();

      // @polyfill ie/edge/firefox
      if (IS_IE_OR_EDGE || IS_FIREFOX) {
        self.classList.add(self._className + '--IE');
      }

      // Add the container and inner table
      frag.appendChild(Coral.templates.Table.base.call(self._elements));
      
      // Move the content zones
      for (var property in self._properties) {
        var descriptor = self._properties[property];
        if (descriptor.contentZone) {
          var tagName = descriptor.tagName;
          var selector = tagName !== 'colgroup' ? tagName +'[is="coral-table-'+ tagName.slice(1) +'"]' : 'colgroup';
          var contentZone = self._elements[descriptor.handle] = self.querySelector(selector);
          
          // Support row only content
          if (property === 'body' && !contentZone) {
            contentZone = self._elements.body = document.createElement('tbody', 'coral-table-body');
            
            // Look for the table auto generated table body
            var tableAutoCreatedBody = self.querySelector('tbody');
            if (tableAutoCreatedBody) {
              // Move the rows inside the coral table body
              while (tableAutoCreatedBody.firstChild) {
                contentZone.appendChild(tableAutoCreatedBody.firstChild);
              }
              // Remove the auto generated table body
              tableAutoCreatedBody.parentNode.removeChild(tableAutoCreatedBody);
            }
          }
          
          // Check if the table section exist and if yes, move it to the inner table
          if (contentZone) {
            descriptor.insert.call(self, contentZone);
          }
        }
      }
  
      self.appendChild(frag);
    },

    /** @private */
    _resetLayout: function() {
      var self = this;

      if (self._preventResetLayout) {
        return;
      }

      // Debounce
      if (self._timeout !== null) {
        window.clearTimeout(self._timeout);
      }
      self._timeout = window.setTimeout(function() {
        self._timeout = null;
        self._resizeStickyHead();
        self._resizeContainer();
      }, self._wait);
    },

    /** @private */
    _resizeStickyHead: function() {
      var table = this;
      var head = table._elements.head;
      if (head && head.sticky) {
        table._getRows(['head']).forEach(function(row) {
          row._getCells(['headerCells']).forEach(function(headerCell) {
            table._layoutStickyCell(headerCell, true);
          });
        });
      }
    },

    /** @private */
    _resizeContainer: function() {
      var table = this;
      var head = table._elements.head;

      if (head && head.sticky) {
        var calculatedHeadSize = 0;
        var previousRowHeight = 0;

        // Reset head layout
        this._getRows(['head']).forEach(function(row, i) {
          var headerCells = row._getCells(['headerCells']);

          if (headerCells.length) {
            var computedStyle = window.getComputedStyle(headerCells[0].content);
            var rowHeight = 0;
            // Default min-height is 37px
            var stickyHeaderCellMinHeight = parseFloat(computedStyle.minHeight);
            // Divider 'row' or 'cell'  adds a border top
            var borderTopWidth = parseFloat(computedStyle.borderTopWidth);

            headerCells.forEach(function(headerCell) {
              // Reset to default
              headerCell.content.style.height = '';
              // The highest header cell defines the row height
              rowHeight = Math.max(rowHeight, headerCell.content.getBoundingClientRect().height);
            });

            // Add the row height to the table head height
            calculatedHeadSize += rowHeight;

            headerCells.forEach(function(headerCell) {
              // Expand the header cell height to the row height
              if ((rowHeight - borderTopWidth) !== stickyHeaderCellMinHeight) {
                headerCell.content.style.height = rowHeight + 'px';
              }

              // @polyfill ie/edge/firefox
              // Vertically align text in sticky cell by getting the label height
              if ((IS_IE_OR_EDGE || IS_FIREFOX) && headerCell.content.textContent.trim().length) {
                var stickyHeaderCellHeight = headerCell.content.getBoundingClientRect().height;
                var span = document.createElement('span');

                // Prevents a recursive table relayout that is triggered from changing the header cell content
                table._preventResetLayout = true;

                while (headerCell.content.firstChild) {
                  span.appendChild(headerCell.content.firstChild);
                }
                headerCell.content.appendChild(span);

                var labelHeight = span.getBoundingClientRect().height;
                var paddingTop = (stickyHeaderCellHeight - labelHeight) / 2;

                while (span.firstChild) {
                  headerCell.content.appendChild(span.firstChild);
                }
                headerCell.content.removeChild(span);

                headerCell.content.style.paddingTop = paddingTop + 'px';

                Coral.commons.nextFrame(function() {
                  table._preventResetLayout = false;
                });
              }

              // Position the sticky cell
              previousRowHeight = previousRowHeight || rowHeight;
              headerCell.content.style.top = (i > 0 ? (previousRowHeight * i) + (borderTopWidth * (i - 1)) : 0) + 'px';
            });
          }
        });

        var containerComputedStyle = window.getComputedStyle(this._elements.container);
        var borderTopWidth = parseFloat(containerComputedStyle.borderTopWidth);
        var borderBottomWidth = parseFloat(containerComputedStyle.borderBottomWidth);

        var containerBorderSize = borderTopWidth + borderBottomWidth;
        var containerMarginTop = calculatedHeadSize + 'px';
        var containerHeight = 'calc(100% - ' + (calculatedHeadSize + containerBorderSize) + 'px)';
        this._resetContainerLayout(containerMarginTop, containerHeight);

        // Once the sticky table head is properly positioned, we don't need to hide it anymore
        head.classList.remove(IS_HIDDEN);
      }
      else {
        this._resetContainerLayout();
      }
    },

    /** @private */
    _resetContainerLayout: function(marginTop, height) {
      this._elements.container.style.marginTop = marginTop ? marginTop : '';
      this._elements.container.style.height = height ? height : '';
    },

    /** @private */
    _resetHiddenColumns: function() {
      var table = this;
      table._getColumns().forEach(function(column) {
        table._syncHiddenColumn(column);
      });
    },

    /** @private */
    _onScroll: function(event) {
      var table = this;

      // Ignore if only vertical scroll
      var scrollLeft = table._elements.container.scrollLeft;
      if (table._lastScrollLeft === scrollLeft) {
        return;
      }
      table._lastScrollLeft = scrollLeft;

      var head = table._elements.head;
      if (head && head.sticky) {
        // Trigger a reflow that will reposition the sticky cells for FF only.
        head.style.margin = '1px';
        Coral.commons.nextFrame(function() {
          head.style.margin = '';

          // In other browsers e.g Chrome or IE, we need to adjust the position of the sticky cells manually
          if (!table._preventLayoutStickyCellOnScroll) {
            var firstHeaderCell = head.querySelector('tr[is="coral-table-row"] th[is="coral-table-headercell"]');

            if (firstHeaderCell) {
              // Verify if the sticky cells need to be adjusted. If the first one didn't move, we can assume that they
              // all need to be adjusted. By default, the left offset is 1px because of the table border.
              if (table._layoutStickyCellOnScroll || firstHeaderCell.content.offsetLeft === 1) {
                table._layoutStickyCellOnScroll = true;

                table._getRows(['head']).forEach(function(row) {
                  row._getCells(['headerCells']).forEach(function(headerCell) {
                    var paddingLeft = parseFloat(window.getComputedStyle(headerCell).paddingLeft);
                    headerCell.content.style.marginLeft = '-' + (scrollLeft + paddingLeft) + 'px';
                  });
                });
              }
              else {
                // We don't need to layout the sticky cells manually
                table._preventLayoutStickyCellOnScroll = true;
              }
            }
          }
        });
      }
    },

    /** @private */
    _setHeaderCellScope: function(headerCell, tableSection) {
      // Add appropriate scope depending on whether header cell is in THEAD or TBODY
      var scope = (tableSection.nodeName === 'THEAD' || tableSection.nodeName === 'TFOOT') ? 'col' : 'row';
      var ariaRole = scope === 'col' ? 'columnheader' : 'rowheader';
      headerCell.setAttribute('role', ariaRole);
      headerCell.setAttribute('scope', scope);
    },

    /** @private */
    _getRows: function(options) {
      // Get all rows if no options provided
      options = options ? options : ['head', 'body', 'foot'];
      var rows = [];

      options.forEach(function(option) {
        var section = this._elements[option];
        if (section && section._elements) {
          rows.push.apply(rows, Array.prototype.slice.call(section._elements.rows));
        }
      }.bind(this));

      return rows;
    },

    /** @private */
    _getColumns: function() {
      return Array.prototype.slice.call(this.querySelectorAll('col[is="coral-table-column"]'));
    },

    /** @private */
    _initialize: function() {
      var table = this;

      // Wrapper should have role="presentation" because it wraps another table
      table.setAttribute('role', 'presentation');

      // Required for coral-table:change event
      table._oldSelection = [];
      // References selected items in their selection order and is only used for keyboard selection
      table._lastSelectedItems = {
        items: [],
        direction: null
      };

      // Debounce timer
      table._timeout = null;
      // Debounce wait in milliseconds
      table._wait = 50;

      // Detect table size changes
      Coral.commons.addResizeListener(table, table._resetLayout);

      // Replacement for attachedCallbacks
      table._observer = new MutationObserver(function(mutations) {
        var resetHiddenColumns = false;

        mutations.forEach(function(mutation) {
          // Sync added nodes
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];

            // Upgrading the element to guarantee custom elements properties and methods are available.
            // Upgrading is not needed for Chrome as it is already upgraded during parsing but doing it is harmless.
            // Non custom-elements will be ignored.
            window.CustomElements.upgrade(addedNode);

            // Below instanceof conditions wouldn't work if the element is not upgraded.
            if (addedNode instanceof Coral.Table.Head) {
              addedNode.trigger('coral-table-head:_contentchanged', {
                addedNodes: addedNode._elements.rows,
                removedNodes: []
              });
            }

            if (addedNode instanceof Coral.Table.Body) {
              table._syncProp('multiple');
              addedNode.trigger('coral-table-body:_contentchanged', {
                addedNodes: addedNode._elements.rows,
                removedNodes: []
              });
            }

            resetHiddenColumns = resetHiddenColumns || (addedNode instanceof Coral.Table.HeaderCell ||
              addedNode instanceof Coral.Table.Cell ||
              addedNode instanceof Coral.Table.Row ||
              addedNode instanceof Coral.Table.Head ||
              addedNode instanceof Coral.Table.Body ||
              addedNode instanceof Coral.Table.Foot);
          }

          // Sync removed nodes
          for (var k = 0; k < mutation.removedNodes.length; k++) {
            var removedNode = mutation.removedNodes[k];

            if (removedNode instanceof Coral.Table.Body) {
              table._onBodyContentChanged({
                target: removedNode,
                detail: {
                  addedNodes: [],
                  removedNodes: removedNode._elements.rows
                }
              });
            }
          }
        });

        // Sync hidden columns
        if (resetHiddenColumns) {
          table._resetHiddenColumns();
        }

        table._resetLayout();
      });

      table._observer.observe(table, {
        childList: true,
        subtree: true
      });

      // Disable table features if no items.
      table._toggleInteractivity(!table._elements.body);

      Coral.commons.ready(table, function() {
        // Sync selection state
        if (table.selectable) {
          var selectedItems = table.selectedItems;
          var items = table.items.getAll();

          // Sync select all handle if any
          table._syncSelectAllHandle(selectedItems, items);

          // Sync used collections
          if (selectedItems.length) {
            table._oldSelection = selectedItems;
            table._lastSelectedItems.items = selectedItems;
          }
        }

        // Set header cell scope
        table._getRows().forEach(function(row) {
          row._getCells(['headerCells']).forEach(function(headerCell) {
            table._setHeaderCellScope(headerCell, row.parentNode);
          });
        });
      });
    }

    /**
      Triggered before a column gets sorted by user interaction. Can be used to cancel column sorting and define
      custom sorting.

      @event Coral.Table#coral-table:beforecolumnsort

      @param {Object} event
        Event object
      @param {Coral.Table.Column} event.detail.column
        The column to be sorted.
      @param {Coral.Table.Column.sortableDirection} event.detail.direction
        The requested sorting direction for the column.
    */

    /**
      Triggered when a column is sorted.

      @event Coral.Table#coral-table:columnsort

      @param {Object} event
        Event object
      @param {Coral.Table.Column} event.detail.column
        The sorted column.
    */

    /**
      Triggered before a column is dragged. Can be used to cancel column dragging.

      @event Coral.Table#coral-table:beforecolumndrag

      @param {Object} event
        Event object
      @param {Coral.Table.Column} event.detail.column
        The dragged column.
      @param {Coral.Table.Column} event.detail.before
        The column will be inserted before this sibling column.
        If <code>null</code>, the column is inserted at the end.
    */

    /**
      Triggered when a column is dragged.

      @event Coral.Table#coral-table:columndrag

      @param {Object} event
        Event object
      @param {Coral.Table.Column} event.detail.column
        The dragged column.
      @param {Coral.Table.Column} event.detail.oldBefore
        The column next sibling before the swap.
        If <code>null</code>, the column was the last item.
      @param {Coral.Table.Column} event.detail.before
        The column is inserted before this sibling column.
        If <code>null</code>, the column is inserted at the end.
    */

    /**
      Triggered before a row is ordered. Can be used to cancel row ordering.

      @event Coral.Table#coral-table:beforeroworder

      @param {Object} event
        Event object
      @param {Coral.Table.Row} event.detail.row
        The row to be ordered.
      @param {Coral.Table.Row} event.detail.before
        The row will be inserted before this sibling row.
        If <code>null</code>, the row is inserted at the end.
    */

    /**
      Triggered when a row is ordered.

      @event Coral.Table#coral-table:roworder

      @param {Object} event
        Event object
      @param {Coral.Table.Row} event.detail.row
        The ordered row.
      @param {Coral.Table.Row} event.detail.oldBefore
        The row next sibling before the swap.
        If <code>null</code>, the row was the last item.
      @param {Coral.Table.Row} event.detail.before
        The row is inserted before this sibling row.
        If <code>null</code>, the row is inserted at the end.
    */

    /**
      Triggered when a row is locked.

      @event Coral.Table#coral-table:rowlock

      @param {Object} event
        Event object
      @param {Coral.Table.Row} event.detail.row
        The locked row.
    */

    /**
      Triggered when a row is locked.

      @event Coral.Table#coral-table:rowunlock

      @param {Object} event
        Event object
      @param {Coral.Table.Row} event.detail.row
        The unlocked row.
    */

    /**
      Triggered when a table row selection changed.

      @event Coral.Table#coral-table:rowchange

      @param {Object} event
        Event object
      @param {Array.<HTMLElement>} event.detail.oldSelection
        The old item selection. When {@link Coral.Table.Row#multiple}, it includes an Array.
      @param {Array.<HTMLElement>} event.detail.selection
        The item selection. When {@link Coral.Table.Row#multiple}, it includes an Array.
      @param {HTMLElement} event.detail.row
        The targeted row.
    */

    /**
      Triggered when the selection changed.

      @event Coral.Table#coral-table:change

      @param {Object} event
        Event object
      @param {Array.<HTMLElement>} event.detail.oldSelection
        The old item selection. When {@link Coral.Table#multiple}, it includes an Array.
      @param {Array.<HTMLElement>} event.detail.selection
        The item selection. When {@link Coral.Table#multiple}, it includes an Array.
    */
  });

  Coral.Table.variant = variant;
  Coral.Table.divider = divider;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';
  // Builds a string containing all possible divider classnames. This will be used to remove classnames when the
  // divider changes
  var ALL_DIVIDER_CLASSES = [];
  for (var dividerValue in Coral.Table.divider) {
    ALL_DIVIDER_CLASSES.push('coral-Table-divider' + '--' + Coral.Table.divider[dividerValue]);
  }

  var properties = {
    /**
      The table section divider.

      @type {Coral.Table.divider}
      @default Coral.Table.divider.ROW
      @htmlattributereflected
      @htmlattribute divider
      @memberof Coral.mixin.tableSection#
    */
    'divider': {
      default: Coral.Table.divider.ROW,
      reflectAttribute: true,
      validate: [
        Coral.validate.valueMustChange,
        Coral.validate.enumeration(Coral.Table.divider)
      ],
      sync: function() {
        this.classList.remove.apply(this.classList, ALL_DIVIDER_CLASSES);
        this.classList.add('coral-Table-divider' + '--' + this.divider);
      }
    }
  };

  // Methods to add
  var methods = {
    /** @private */
    _initialize: function() {
      this.setAttribute('role', 'rowgroup');
    },

    /** @private */
    _render: function() {
      var self = this;
      Object.defineProperty(self._elements, 'rows', {
        get: function() {
          return self.querySelectorAll('tr[is="coral-table-row"]');
        }
      });
    }
  };

  /**
    Configure a component to have the basic properties that are expected from a table section.

    @mixin
  */
  Coral.mixin.tableSection = function(prototype, options) {
    // Add methods
    Coral.commons.augment(prototype, methods, function(objectMethod, mixinMethod, propName) {
      return Coral.commons.callAll(mixinMethod, objectMethod);
    });

    // Augment property descriptors
    Coral.register.augmentProperties(options.properties, properties);
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Table.Head */ {
    /**
      @class Coral.Table.Head
      @classdesc A Table Head component
      @extends Coral.Component
      @extends Coral.mixin.tableSection
      @htmltag coral-table-head
      @htmlbasetag thead
    */
    name: 'Table.Head',
    tagName: 'coral-table-head',
    className: 'coral-Table-head',
    baseTagName: 'thead',
    extend: HTMLTableSectionElement,

    mixins: [
      Coral.mixin.tableSection
    ],

    properties: {
      /**
        Whether the table head is sticky. The table content becomes automatically scrollable if the table wrapper height
        is smaller than its content.

        @type {Boolean}
        @default false
        @htmlattribute sticky
        @htmlattributereflected
        @memberof Coral.Table.Head#
      */
      'sticky': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.trigger('coral-table-head:_stickysync');
        }
      }
    },

    /** @private */
    _initialize: function() {
      var self = this;

      self.setAttribute('role', 'rowgroup');

      // Replacement for attachedCallbacks
      self._observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          self.trigger('coral-table-head:_contentchanged', {
            addedNodes: mutation.addedNodes,
            removedNodes: mutation.removedNodes
          });
        });
      });

      self._observer.observe(self, {
        childList: true,
        subtree: true
      });
    }

    /**
      Triggered when the content changed.

      @event Coral.Table.Head#coral-table-head:_contentchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Head#sticky} is synced.

      @event Coral.Table.Head#coral-table-head:_stickysync

      @param {Object} event Event object
      @private
    */
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Table.Body */ {
    /**
      @class Coral.Table.Body
      @classdesc A Table Body component
      @extends Coral.Component
      @extends Coral.mixin.tableSection
      @htmltag coral-table-body
      @htmlbasetag tbody
    */
    name: 'Table.Body',
    tagName: 'coral-table-body',
    className: 'coral-Table-body',
    baseTagName: 'tbody',
    extend: HTMLTableSectionElement,

    mixins: [
      Coral.mixin.tableSection
    ],

    /** @private */
    _initialize: function() {
      var self = this;

      self.setAttribute('role', 'rowgroup');

      // Replacement for attachedCallbacks
      self._observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          self.trigger('coral-table-body:_contentchanged', {
            addedNodes: mutation.addedNodes,
            removedNodes: mutation.removedNodes
          });
        });
      });

      self._observer.observe(self, {
        childList: true,
        subtree: true
      });

      if (self._elements.rows.length === 0) {
        self.trigger('coral-table-body:_empty');
      }
    }

    /**
      Triggered when the content changed.

      @event Coral.Table.Body#coral-table-body:_contentchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when the body is initialized without rows.

      @event Coral.Table.Body#coral-table-body:_empty

      @param {Object} event Event object
      @private
    */
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Table.Foot */ {
    /**
      @class Coral.Table.Foot
      @classdesc A Table Foot component
      @extends Coral.Component
      @extends Coral.mixin.tableSection
      @htmltag coral-table-foot
      @htmlbasetag tfoot
    */
    name: 'Table.Foot',
    tagName: 'coral-table-foot',
    className: 'coral-Table-foot',
    baseTagName: 'tfoot',
    extend: HTMLTableSectionElement,

    mixins: [
      Coral.mixin.tableSection
    ]
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Table.Row */ {
    /**
      @class Coral.Table.Row
      @classdesc A Table Row component
      @extends Coral.Component
      @htmltag coral-table-row
      @htmlbasetag tr
    */
    name: 'Table.Row',
    tagName: 'coral-table-row',
    className: 'coral-Table-row',
    baseTagName: 'tr',
    extend: HTMLTableRowElement,

    events: {
      // Private
      'coral-table-cell:_beforeselectedchanged': '_onBeforeCellSelectionChanged',
      'coral-table-cell:_selectedchanged': '_onCellSelectionChanged'
    },

    properties: {
      /**
        Whether the table row is locked.

        @type {Boolean}
        @default false
        @htmlattribute locked
        @htmlattributereflected
        @memberof Coral.Table.Row#
      */
      'locked': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-table-row:_lockedchanged'
      },

      /**
        Whether the table row is selected.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Table.Row#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        triggerBefore: 'coral-table-row:_beforeselectedchanged',
        trigger: 'coral-table-row:_selectedchanged',
        sync: function() {
          this._syncAriaSelectedState();
          this._syncSelectHandle();
        }
      },

      /**
        Whether the items are selectable.

        @type {Boolean}
        @default false
        @htmlattribute selectable
        @htmlattributereflected
        @memberof Coral.Table.Row#
      */
      'selectable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          var cells = this._getCells(['cells']);

          cells.forEach(function(cell) {
            cell._toggleSelectable(this.selectable);
          }.bind(this));
        }
      },

      /**
        Whether multiple items can be selected.

        @type {Boolean}
        @default false
        @htmlattribute multiple
        @htmlattributereflected
        @memberof Coral.Table.Row#
      */
      'multiple': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-table-row:_multiplechanged'
      },

      /**
        Returns an Array containing the selected items.

        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.Table.Row#
      */
      'selectedItems': {
        get: function() {
          return this._getCells(['cells']).filter(function(cell) {
            return cell.selected;
          });
        },
        set: function() {
          // Read-only
        }
      },

      /**
        Returns the first selected item of the row. The value <code>null</code> is returned if no element is
        selected.

        @type {HTMLElement}
        @readonly
        @memberof Coral.Table.Row#
      */
      'selectedItem': {
        get: function() {
          var selection = this.selectedItems;
          return selection.length ? selection[0] : null;
        },
        set: function() {
          // Read-only
        }
      },

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Table.Row#
      */
      'items': {
        get: function() {
          // Construct the collection on first request
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemBaseTagName: 'td',
              itemTagName: 'coral-table-cell'
            });
          }

          return this._items;
        },
        set: function() {
          // Read-only
        }
      }
    },

    _triggerChangeEvent: function() {
      var selectedItems = this.selectedItems;
      this.trigger('coral-table-row:_change', {
        oldSelection: this._oldSelection,
        selection: selectedItems
      });
      this._oldSelection = selectedItems;
    },

    /** @private */
    _onCellSelectionChanged: function(event) {
      event.stopImmediatePropagation();

      this._triggerChangeEvent();
    },

    /** @private */
    _onBeforeCellSelectionChanged: function(event) {
      event.stopImmediatePropagation();

      // In single selection, if the added item is selected, the rest should be deselected
      var selectedItem = this.selectedItem;
      if (!this.multiple && selectedItem && !event.target.selected) {
        selectedItem.set('selected', false, true);
      }
    },

    /** @private */
    _syncAriaSelectedState: function() {
      this.classList.toggle('is-selected', this.selected);
      this.setAttribute('aria-selected', this.selected);
    },

    /** @private */
    _syncSelectHandle: function() {
      // Check/uncheck the select handle
      var selectHandle = this.querySelector('[coral-table-rowselect]');
      if (selectHandle) {
        if (typeof selectHandle.indeterminate !== 'undefined') {
          selectHandle.indeterminate = false;
        }

        if (typeof selectHandle.checked !== 'undefined') {
          selectHandle.checked = this.selected;
        }
      }
    },

    /** @private */
    _toggleSelectable: function(selectable) {
      if (selectable) {
        this._setHandle('coral-table-rowselect');
      }
      else {
        // Clear selection
        this.set('selected', false, true);
      }
    },

    /** @private */
    _toggleOrderable: function(orderable) {
      if (orderable) {
        this._setHandle('coral-table-roworder');
      }
      else {
        // Remove DragAction instance
        if (this.dragAction) {
          this.dragAction.destroy();
        }
      }
    },

    /** @private */
    _toggleLockable: function(lockable) {
      if (lockable) {
        this._setHandle('coral-table-rowlock');
      }
    },

    /** @private */
    _setHandle: function(handle) {
      // Specify handle directly on the row if none found
      if (!this.querySelector('[' + handle + ']')) {
        this.setAttribute(handle, '');
      }
    },

    /** @private */
    _getCells: function(options) {
      // Get all cells if no options provided
      options = options ? options : ['headerCells', 'cells'];
      var cells = [];

      options.forEach(function(option) {
        cells.push.apply(cells, Array.prototype.slice.call(this._elements[option]));
      }.bind(this));

      return cells;
    },

    /** @private */
    _getCellByIndex: function(index, options) {
      // Get all cells if no options provided
      options = options ? options : ['headerCell', 'cell'];
      var query = [];
      index++;

      if (options.indexOf('headerCell') !== -1) {
        query.push('th[is="coral-table-headercell"]:nth-child(' + index + ')');
      }

      if (options.indexOf('cell') !== -1) {
        query.push('td[is="coral-table-cell"]:nth-child(' + index + ')');
      }

      return this.querySelector(query.join(', '));
    },

    /** @private */
    _initialize: function() {
      var self = this;

      self.setAttribute('role', 'row');

      // Required for coral-table-row:change event
      self._oldSelection = [];

      self._observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          // Sync added nodes
          self.trigger('coral-table-row:_contentchanged', {
            addedNodes: mutation.addedNodes,
            removedNodes: mutation.removedNodes
          });
        });
      });

      self._observer.observe(self, {
        childList: true
      });
    },

    /** @private */
    _render: function() {
      var self = this;
      Object.defineProperty(self._elements, 'headerCells', {
        get: function() {
          return self.querySelectorAll('th[is="coral-table-headercell"]');
        }
      });
      Object.defineProperty(self._elements, 'cells', {
        get: function() {
          return self.querySelectorAll('td[is="coral-table-cell"]');
        }
      });
    }

    /**
      Triggered before {@link Coral.Table.Row#selected} is changed.

      @event Coral.Table.Row#coral-table-row:_beforeselectedchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Row#selected} changed.

      @event Coral.Table.Row#coral-table-row:_selectedchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Row#locked} changed.

      @event Coral.Table.Row#coral-table-row:_lockedchanged

      @param {Object} event Event object
      @private
    */


    /**
      Triggered when {@link Coral.Table.Row#multiple} changed.

      @event Coral.Table.Row#coral-table-row:_multiplechanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when the selection changed.

      @event Coral.Table.Row#coral-table-row:_change

      @param {Object} event
        Event object
      @param {Array.<HTMLElement>} event.detail.oldSelection
        The old item selection. When {@link Coral.Table.Row#multiple}, it includes an Array.
      @param {Array.<HTMLElement>} event.detail.selection
        The item selection. When {@link Coral.Table.Row#multiple}, it includes an Array.
      @private
    */
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Table.Cell */ {
    /**
      @class Coral.Table.Cell
      @classdesc A Table Cell component
      @extends Coral.Component
      @htmltag coral-table-cell
      @htmlbasetag td
    */
    name: 'Table.Cell',
    tagName: 'coral-table-cell',
    className: 'coral-Table-cell',
    baseTagName: 'td',
    extend: HTMLTableCellElement,

    properties: {
      /**
        The cell's content.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Table.Cell#
      */
      'content': {
        contentZone: true,
        set: function() {},
        get: function() {
          return this;
        }
      },

      /**
        Whether the table cell is selected.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Table.Cell#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        triggerBefore: 'coral-table-cell:_beforeselectedchanged',
        trigger: 'coral-table-cell:_selectedchanged',
        sync: function() {
          this._syncAriaSelectedState();
          this._syncSelectHandle();
        }
      },

      /**
        The cell's value.

        @type {String}
        @default ""
        @htmlattribute value
        @htmlattributereflected
        @memberof Coral.Table.Cell#
      */
      'value': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string
      }
    },

    /** @private */
    _setHandle: function(handle) {
      // Specify handle directly on the cell if none found
      if (!this.querySelector('[' + handle + ']')) {
        this.setAttribute(handle, '');
      }
    },

    /** @private */
    _toggleSelectable: function(selectable) {
      if (selectable) {
        this._setHandle('coral-table-cellselect');
      }
      else {
        // Clear selection
        this.selected = false;
      }
    },

    /** @private */
    _syncAriaSelectedState: function() {
      this.classList.toggle('is-selected', this.selected);
      this.setAttribute('aria-selected', this.selected);
    },

    /** @private */
    _syncSelectHandle: function() {
      // Check/uncheck the select handle
      var selectHandle = this.querySelector('[coral-table-cellselect]');
      if (selectHandle) {
        if (typeof selectHandle.indeterminate !== 'undefined') {
          selectHandle.indeterminate = false;
        }

        if (typeof selectHandle.checked !== 'undefined') {
          selectHandle.checked = this.selected;
        }
      }
    },

    /** @private */
    _initialize: function() {
      this.setAttribute('role', 'gridcell');
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Table.HeaderCell */ {
    /**
      @class Coral.Table.HeaderCell
      @classdesc A Table HeaderCell component
      @extends Coral.Component
      @htmltag coral-table-headercell
      @htmlbasetag th
    */
    name: 'Table.HeaderCell',
    tagName: 'coral-table-headercell',
    className: 'coral-Table-headerCell',
    baseTagName: 'th',
    extend: HTMLTableCellElement,

    properties: {
      /**
        The header cell's content.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Table.HeaderCell#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-table-headercell-content',
        insert: function(content) {
          // Add sub elements to the frag
          this.appendChild(content);
        }
      })
    },

    /** @private */
    _render: function() {
      // Fetch or create the content zone element
      var content = this._elements.content = this.querySelector('coral-table-headercell-content');

      if (content === null) {
        content = document.createElement('coral-table-headercell-content');
        // Move component children into the content
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      // Assign the content zone so the insert function will be called
      this.content = content;
    },

    /** @private */
    _initialize: function() {
      // Watch for content changes in sticky header cell
      this._stickyCellObserver = new MutationObserver(function() {
        this.trigger('coral-table-headercell:_contentchanged');
      }.bind(this));

      this._stickyCellObserver.observe(this.content, {
        childList: true,
        subtree: true
      });
    }

    /**
      Triggered when the content changed.

      @event Coral.Table.HeaderCell#coral-table-headercell:_contentchanged

      @param {Object} event Event object
      @private
    */
  });

  /**
    @class Coral.Table.HeaderCell.Content
    @classdesc The Table Header Cell Content
    @htmltag coral-table-headercell-content
    @extends HTMLElement
  */
  Coral.Table.HeaderCell.Content = function() {
    return document.createElement('coral-table-headercell-content');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';


  /**
    Enum for cell sortable directions.

    @enum {String}
    @memberof Coral.Table.Column
  */
  var sortableDirection = {
    /** Default. */
    DEFAULT: 'default',
    /** Ascending sort. */
    ASCENDING: 'ascending',
    /** Descending sort. */
    DESCENDING: 'descending'
  };

  /**
    Enum for sortable type values.

    @enum {String}
    @memberof Coral.Table.Column
  */
  var sortableType = {
    /** Alphanumeric type. If sorting is based on {@link Coral.Table.Cell#value}, use JavaScript String. */
    ALPHANUMERIC: 'alphanumeric',
    /** Number type. If sorting is based on {@link Coral.Table.Cell#value}, use JavaScript Numbers */
    NUMBER: 'number',
    /** Date type. If sorting is based on {@link Coral.Table.Cell#value}, use the date numeric value in milliseconds. */
    DATE: 'date',
    /** Custom type. Sorting is based on user defined sorting. */
    CUSTOM: 'custom'
  };

  Coral.register( /** @lends Coral.Table.Column */ {
    /**
      @class Coral.Table.Column
      @classdesc A Table Column component
      @extends Coral.Component
      @htmltag coral-table-column
      @htmlbasetag col
    */
    name: 'Table.Column',
    tagName: 'coral-table-column',
    className: 'coral-Table-column',
    baseTagName: 'col',
    extend: HTMLTableColElement,

    properties: {
      /**
        Whether the column has a fixed width.

        @type {Boolean}
        @default false
        @htmlattribute fixedwidth
        @htmlattributereflected
        @memberof Coral.Table.Column#
      */
      'fixedWidth': {
        default: false,
        attribute: 'fixedwidth',
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-table-column:_fixedwidthchanged',
        sync: function() {
          this.trigger('coral-table-column:_fixedwidthsync');
        }
      },

      /**
        Whether the column is hidden.

        @type {Boolean}
        @default false
        @htmlattribute hidden
        @htmlattributereflected
        @memberof Coral.Table.Column#
      */
      'hidden': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.trigger('coral-table-column:_hiddensync');
        }
      },

      /**
        Whether the table column is orderable.
        Note that this does not affect the underlying data, only presentation.

        @type {Boolean}
        @default false
        @htmlattribute orderable
        @htmlattributereflected
        @memberof Coral.Table.Column#
      */
      'orderable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.trigger('coral-table-column:_orderablesync');
        }
      },

      /**
        Whether the column is sortable by user interaction.

        @type {Boolean}
        @default false
        @htmlattribute sortable
        @htmlattributereflected
        @memberof Coral.Table.Column#
      */
      'sortable': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.trigger('coral-table-column:_sortablesync');
        }
      },

      /**
        The sorting type.

        @type {Coral.Table.Column.sortableType}
        @default {Coral.Table.Column.sortableType.ALPHANUMERIC}
        @htmlattribute sortabletype
        @htmlattributereflected
        @memberof Coral.Table.Column#
      */
      'sortableType': {
        default: sortableType.ALPHANUMERIC,
        attribute: 'sortabletype',
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(sortableType)
        ]
      },

      /**
        The sorting direction. Sorts the column cells based on {@link Coral.Table.Cell#value}.
        If not present, the sort is based on the cell text content.

        @type {Coral.Table.Column.sortableDirection}
        @default {Coral.Table.Column.sortableDirection.DEFAULT}
        @htmlattribute sortabledirection
        @htmlattributereflected
        @memberof Coral.Table.Column#
      */
      'sortableDirection': {
        attribute: 'sortabledirection',
        default: sortableDirection.DEFAULT,
        reflectAttribute: true,
        validate: [
          Coral.validate.enumeration(sortableDirection)
        ],
        set: function(value) {
          var newSort = Coral.transform.boolean(this._sortableDirection);
          this._sortableDirection = value;
          // Prevent sorting if unnecessary
          if (newSort && !this._preventSort) {
            this._doSort();
          }
        },
        sync: function() {
          this.trigger('coral-table-column:_sortabledirectionsync');
        }
      }
    },

    /** @private */
    _sort: function() {
      var newSortableDirection;
      if (this.sortableDirection === sortableDirection.DEFAULT) {
        newSortableDirection = sortableDirection.ASCENDING;
      }
      else if (this.sortableDirection === sortableDirection.ASCENDING) {
        newSortableDirection = sortableDirection.DESCENDING;
      }
      else if (this.sortableDirection === sortableDirection.DESCENDING) {
        newSortableDirection = sortableDirection.DEFAULT;
      }

      this.trigger('coral-table-column:_beforecolumnsort', {
        newSortableDirection: newSortableDirection
      });
    },

    /** @private */
    _doSort: function(onInitialization) {
      this.trigger('coral-table-column:_sort', {
        onInitialization: onInitialization,
        sortableDirection: sortableDirection,
        sortableType: sortableType
      });
    },

    /** @private */
    _initialize: function() {
      // Sort column cells on initialization and make sure the value property is ready by waiting one more frame
      Coral.commons.nextFrame(function() {
        if (this.sortable) {
          this._doSort(true);
        }
      }.bind(this));
    }

    /**
      Triggered when {@link Coral.Table.Column#fixedWidth} changed.

      @event Coral.Table.Column#coral-table-column:_fixedwidthchanged

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Column#orderable} is synced.

      @event Coral.Table.Column#coral-table-column:_orderablesync

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Column#sortable} is synced.

      @event Coral.Table.Column#coral-table-column:_sortablesync

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Column#sortableDirection} is synced.

      @event Coral.Table.Column#coral-table-column:_sortabledirectionsync

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Column#hidden} is synced.

      @event Coral.Table.Column#coral-table-column:_hiddensync

      @param {Object} event Event object
      @private
    */

    /**
      Triggered before {@link Coral.Table.Column#sortableDirection} is changed.

      @event Coral.Table.Column#coral-table-column:_beforecolumnsort

      @param {Object} event Event object
      @private
    */

    /**
      Triggered when {@link Coral.Table.Column#sortableDirection} changed.

      @event Coral.Table.Column#coral-table-column:_sort

      @param {Object} event Event object
      @private
    */
  });

  // Exports the enumerations
  Coral.Table.Column.sortableDirection = sortableDirection;
  Coral.Table.Column.sortableType = sortableType;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    Enumeration representing the TabList size.

    @memberof Coral.TabList
    @enum {String}
  */
  var size = {
    /** A medium-sized tablist. This is the default. */
    MEDIUM: 'M',
    /** A large-sized tablist, typically used for headers. */
    LARGE: 'L'
  };

  /**
    TabList orientations.

    @enum {String}
    @memberof Coral.TabList
  */
  var orientation = {
    /** Horizontal TabList, this is the default value. */
    HORIZONTAL: 'horizontal',
    /** Vertical TabList. */
    VERTICAL: 'vertical'
  };

  /**
    Gets the target panel of the item.

    @private
    @param {HTMLElement|String} [targetValue]
      A specific target value to use.
    @memberof Coral.Tab#

    @returns {?HTMLElement}
  */
  function getTarget(targetValue) {

    if (targetValue instanceof Node) {
      // Just return the provided Node
      return targetValue;
    }

    // Dynamically get the target node based on target
    var newTarget = null;
    if (typeof targetValue === 'string' && targetValue.trim() !== '') {
      newTarget = document.querySelector(targetValue);
    }

    return newTarget;
  }

  // the tablist's base classname
  var CLASSNAME = 'coral3-TabList';

  Coral.register( /** @lends Coral.TabList# */ {

    /**
      @class Coral.TabList
      @classdesc A TabList component
      @htmltag coral-tablist
      @extends Coral.Component
      @mixes Coral.mixin.selectionList
      @borrows Coral.mixin.selectionList#items as Coral.TabList#items
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:add as Coral.TabList#coral-collection:add
      @borrows Coral.mixin.selectionList.Collection#event:coral-collection:remove as
        Coral.TabList#coral-collection:remove
    */
    name: 'TabList',
    tagName: 'coral-tablist',
    className: CLASSNAME,
    mixins: [
      Coral.mixin.selectionList({
        itemTagName: 'coral-tab',
        supportMultiple: false,
        forceSelection: true,
        role: 'tablist'
      })
    ],

    events: {
      'click > coral-tab': '_onTabClick',
      'key:home > coral-tab': '_onHomeKey',
      'key:end > coral-tab': '_onEndKey',
      'key:pagedown > coral-tab': '_selectNextItem',
      'key:right > coral-tab': '_selectNextItem',
      'key:down > coral-tab': '_selectNextItem',
      'key:pageup > coral-tab': '_selectPreviousItem',
      'key:left > coral-tab': '_selectPreviousItem',
      'key:up > coral-tab': '_selectPreviousItem'
    },

    properties: {

      /**
        The selected item in the TabList.

        @type {HTMLElement}
        @readonly
        @memberof Coral.TabList#
      */
      'selectedItem': {
        get: function() {
          return this.items.getLastSelected();
        },
        set: function() {}
      },

      /**
        The target component that will be linked to the TabList. It accepts either a CSS selector or a DOM element. If a
        CSS Selector is provided, the first matching element will be used. Items will be selected based on the index. If
        both target and {@link Coral.Tab#target} are set, the second will have higher priority.

        @type {?HTMLElement|String}
        @default null
        @htmlattribute target
        @memberof Coral.TabList#
      */
      'target': {
        default: null,
        validate: function(value) {
          return value === null || typeof value === 'string' || value instanceof Node;
        },
        sync: function() {
          // we do this in the sync in case the target was not yet in the DOM
          var realTarget = getTarget(this.target);

          // we add proper accessibility if available
          if (realTarget) {

            var tabItems = this.items.getAll();
            var panelItems = realTarget.items ? realTarget.items.getAll() : realTarget.children;

            // we need to add a11y to all component, no matter if they can be perfectly paired
            var maxItems = Math.max(tabItems.length, panelItems.length);

            var tab;
            var panel;
            for (var i = 0; i < maxItems; i++) {

              tab = tabItems[i];
              panel = panelItems[i];

              // if the tab has its own target, we assume the target component will handle its own accessibility. if the
              // target is an empty string we simply ignore it
              if (tab && tab.target && tab.target.trim() !== '') {
                continue;
              }

              if (tab && panel) {
                // sets the required ids
                tab.id = tab.id || Coral.commons.getUID();
                panel.id = panel.id || Coral.commons.getUID();

                // creates a 2 way binding for accessibility
                tab.setAttribute('aria-controls', panel.id);
                panel.setAttribute('aria-labelledby', tab.id);
              }
              else if (tab) {
                // cleans the aria since there is no matching panel
                tab.removeAttribute('aria-controls');
              }
              else {
                // cleans the aria since there is no matching tab
                panel.removeAttribute('aria-labelledby');
              }
            }
          }
        }
      },

      /**
        The size of the TabList. It accepts both lower and upper case sizes. Currently only "M" (the default) and "L"
        are available.

        @type {Coral.TabList.size}
        @default Coral.TabList.size.MEDIUM
        @htmlattribute size
        @memberof Coral.TabList#
      */
      'size': {
        default: size.MEDIUM,
        transform: function(value) {
          return typeof value === 'string' ? value.toUpperCase() : value;
        },
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(size)
        ],
        sync: function() {
          this.classList[this.size === size.LARGE ? 'add' : 'remove'](CLASSNAME + '--large');
        }
      },

      /**
        Orientation of the TabList.

        @type {Coral.TabList.orientation}
        @default Coral.TabList.orientation.HORIZONTAL
        @htmlattribute orientation
        @htmlattributereflected
        @memberof Coral.TabList#
      */
      'orientation': {
        default: orientation.HORIZONTAL,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(orientation)
        ],
        sync: function() {
          this.classList[this.orientation === orientation.VERTICAL ? 'add' : 'remove'](CLASSNAME + '--vertical');
        }
      }
    },

    /** @private */
    _onTabClick: function(event) {
      event.preventDefault();

      var item = event.matchedTarget;
      this._selectAndFocusItem(item);
    },

    /** @private */
    _onHomeKey: function(event) {

      event.preventDefault();

      var item = this.items.getFirstSelectable();
      this._selectAndFocusItem(item);
    },

    /** @private */
    _onEndKey: function(event) {
      event.preventDefault();

      var item = this.items.getLastSelectable();
      this._selectAndFocusItem(item);
    },

    /** @private */
    _selectNextItem: function(event) {
      event.preventDefault();

      var item = this.selectedItem;
      if (item) {
        item = this.items.getNextSelectable(item);
        this._selectAndFocusItem(item);
      }
    },

    /** @private */
    _selectPreviousItem: function(event) {
      event.preventDefault();

      var item = this.selectedItem;
      if (item) {
        item = this.items.getPreviousSelectable(item);
        this._selectItem(item);
        item.focus();
      }
    },

    /** @private */
    _selectAndFocusItem: function(item) {
      if (item) {
        this._selectItem(item);
        item.focus();
      }
    },

    /** @private */
    _initialize: function() {
      this.setAttribute('aria-multiselectable', 'false');
    },

    /** @ignore */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      this._syncProp('target');
    }

    /**
      Triggered when the selected TabList item has changed.

      @event Coral.TabList#coral-tablist:change

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.selection
        The newly selected TabList item.
      @param {HTMLElement} event.detail.oldSelection
        The previously selected TabList item.
    */
  });

  // exports the enumerations
  Coral.TabList.orientation = orientation;
  Coral.TabList.size = size;

  Coral.register( /** @lends Coral.Tab */ {
    /**
      @class Coral.Tab
      @classdesc An Item in the TabList
      @htmltag coral-tab
      @extends Coral.Component
      @mixes Coral.mixin.selectionList.Item
    */
    name: 'Tab',
    tagName: 'coral-tab',
    className: 'coral3-Tab',
    mixins: [
      Coral.mixin.selectionList.Item({
        listSelector: 'coral-tablist',
        role: 'tab'
      })
    ],

    properties: {

      /**
        The Tab's label element.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Tab#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-tab-label',
        defaultContentZone: true,
        insert: function(label) {
          this.appendChild(label);
        }
      }),

      /**
        Specifies the name of the icon used inside the Tab. See {@link Coral.Icon} for valid icon names.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Tab#

        @see {@link Coral.Icon}
      */
      'icon': {
        get: function() {
          var iconElement = this._elements.icon;
          if (iconElement) {
            return iconElement.icon;
          }
          else {
            return '';
          }
        },
        set: function(value) {
          var iconElement = this._getOrCreateIconElement();
          iconElement.icon = value;

          // removes the icon element from the DOM.
          if (this.icon === '') {
            iconElement.remove();
          }
          // adds the icon back since it was blown away by textContent
          else if (!iconElement.parentNode) {
            this.insertBefore(iconElement, this.firstChild);
          }
        }
      },

      /**
        Whether the current Tab is invalid.

        @type {Boolean}
        @default false
        @htmlattribute invalid
        @htmlattributereflected
        @memberof Coral.Tab#
      */
      'invalid': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
          this.setAttribute('aria-invalid', this.invalid);
        }
      },

      /**
        Whether this Tab is disabled. When set to true, this will prevent every user interacting with the Tab. If
        disabled is set to true for a selected Tab it will be deselected.

        @type {Boolean}
        @default false
        @htmlattribute disabled
        @memberof Coral.Tab#
      */
      'disabled': {
        alsoSync: 'selected',
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this.setAttribute('aria-disabled', this.disabled);
        }
      },

      /**
        Whether the Tab is selected. When true, the Tab will appear as the active element in the TabList. The Tab
        must be a child of a TabList before this property is set to true. This property cannot be programmatically set
        to false.

        @type {Boolean}
        @default false
        @htmlattribute selected
        @memberof Coral.Tab#
      */
      'selected': {
        set: function(value) {
          this._selected = value;

          // in case the tab is selected, we need to communicate it to the panels.
          if (this._selected) {
            this._selectTarget();
          }
        },
        sync: function() {
          this.classList.toggle('is-selected', this.selected);
          this.setAttribute('tabindex', this.selected ? '0' : '-1');
          this.setAttribute('aria-selected', this.selected);
        }
      },

      /**
        The target element that will be selected when this Tab is selected. It accepts a CSS selector or a DOM element.
        If a CSS Selector is provided, the first matching element will be used.

        @type {?HTMLElement|String}
        @default null
        @htmlattribute target
        @memberof Coral.Tab#
      */
      'target': {
        default: null,
        validate: function(value) {
          return value === null || typeof value === 'string' || value instanceof Node;
        },
        sync: function() {

          var realTarget = getTarget(this.target);

          // we add proper accessibility if available
          if (realTarget) {
            // creates a 2 way binding for accessibility
            this.setAttribute('aria-controls', realTarget.id);
            realTarget.setAttribute('aria-labelledby', this.id);
          }
        }
      }
    },

    /**
      Creates the icon element and stores it in the elements cache.

      @ignore
      @returns {HTMLElement} the HTMLElement that represents the icon.
    */
    _getOrCreateIconElement: function() {
      if (!this._elements.icon) {
        this._elements.icon = document.createElement('coral-icon');
        this._elements.icon.setAttribute('size', Coral.Icon.size.SMALL);
      }

      return this._elements.icon;
    },

    /**
      Selects the target item

      @ignore
    */
    _selectTarget: function() {
      var realTarget = getTarget(this.target);
      // if the target was define at the tab level, it has precedence over everything
      if (realTarget) {
        realTarget.setAttribute('selected', '');
      }
      // otherwise, we use the target defined at the tablist level
      else {
        var tabList = this.parentNode;

        if (tabList && tabList.target) {
          realTarget = getTarget(tabList.target);

          if (realTarget) {
            // we get the position of this tab inside the tablist
            var currentIndex = tabList.items.getAll().indexOf(this);

            // we select the item with the same index
            var targetItem = (realTarget.items ? realTarget.items.getAll() : realTarget.children)[currentIndex];

            // we select the item if it exists
            if (targetItem) {
              targetItem.setAttribute('selected', '');
            }
          }
        }
      }
    },

    /** @private */
    _render: function() {
      // Try to find the label content zone
      var foundLabel = this.querySelector('coral-tab-label');

      // Create the label content zone if necessary
      var label = foundLabel || document.createElement('coral-tab-label');

      // Add all children into the label content zone,
      // only if the label has not been provided.
      if (!foundLabel) {
        while (this.firstChild) {
          label.appendChild(this.firstChild);
        }
      }

      // Assign the content zone so the insert function will be called
      this.label = label;
    },

    /** @private */
    _initialize: function() {
      // Generate a unique ID for the tab panel if one isn't already present
      // This will be used for accessibility purposes
      this.id = this.id || Coral.commons.getUID();
    },

    /** @ignore */
    attachedCallback: function() {
      Coral.Component.prototype.attachedCallback.call(this);

      // Query the tab target once the tab item is inserted in the DOM
      if (this.selected) {
        this._selectTarget();
        this._syncProp('target');
      }
    }
  });

  /**
    @class Coral.Tab.Label
    @classdesc A TabList Tab Label component
    @extends Coral.Component
    @extends HTMLElement
  */
  Coral.Tab.Label = function() {
    return document.createElement('coral-tab-label');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  /**
    TabView orientations.

    @enum {String}
    @memberof Coral.TabView
  */
  var orientation = {
    /** Tabs on top of the panels. This is the default. */
    HORIZONTAL: 'horizontal',
    /** Tabs are rendered on the side and match the height of the panels. */
    VERTICAL: 'vertical'
  };

  // the tabview's base classname
  var CLASSNAME = 'coral3-TabView';

  Coral.register( /** @lends Coral.TabView# */ {

    /**
      @class Coral.TabView
      @classdesc An TabView component
      @htmltag coral-tabview
      @extends Coral.Component
    */
    name: 'TabView',
    tagName: 'coral-tabview',
    className: CLASSNAME,

    events: {
      'coral-tablist:change > coral-tablist': '_onTabListChange',
      'coral-panelstack:change > coral-panelstack': '_onPanelStackChange',
      'coral-collection:add > coral-tablist': '_syncTabListAndPanelStack',
      'coral-collection:remove > coral-tablist': '_syncTabListAndPanelStack',
      'coral-collection:add > coral-panelstack': '_syncTabListAndPanelStack',
      'coral-collection:remove > coral-panelstack': '_syncTabListAndPanelStack'
    },

    properties: {

      /**
        The TabView's orientation.

        @type {Coral.TabView.orientation}
        @default Coral.TabView.orientation.HORIZONTAL
        @htmlattribute orientation
        @htmlattributereflected
        @memberof Coral.TabView#
      */
      'orientation': {
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(orientation)
        ],
        get: function() {
          return this.tabList.getAttribute('orientation');
        },
        set: function(value) {
          this.tabList.setAttribute('orientation', value);
        },
        sync: function() {
          if (this.orientation === orientation.VERTICAL) {
            this.classList.add(CLASSNAME + '--vertical');
          }
          else {
            this.classList.remove(CLASSNAME + '--vertical');
          }
        }
      },

      /**
        The TabList which handles all the tabs.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.TabView#
      */
      'tabList': Coral.property.contentZone({
        handle: 'tabList',
        tagName: 'coral-tablist',
        insert: function(tabs) {
          this.insertBefore(tabs, this.panelStack || null);
        }
      }),

      /**
        The PanelStack which contains all the panels.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.TabView#
      */
      'panelStack': Coral.property.contentZone({
        handle: 'panelStack',
        tagName: 'coral-panelstack',
        insert: function(panels) {
          this.appendChild(panels);
        }
      })
    },

    /**
      Detects a change in the TabList and triggers an event.

      @private
    */
    _onTabListChange: function(event) {
      this.trigger('coral-tabview:change', {
        'selection': event.detail.selection,
        'oldSelection': event.detail.oldSelection
      });
    },

    /** @private */
    _onPanelStackChange: function(event) {
      // everytime the panelstack changes, we verify that the tablist and panelstack are up to date
      if (event.detail.selection) {

        var tabSelector = event.detail.selection.getAttribute('aria-labelledby');
        var tab = document.getElementById(tabSelector);

        // we select the tab if this was not the case
        if (tab && tab.getAttribute('selected') === null) {
          tab.setAttribute('selected', '');
        }
      }
    },

    /** @private */
    _syncTabListAndPanelStack: function(event) {
      this.tabList._queueSync(['target']);
    },

    /** @private */
    _render: function() {
      // Fetch or create the content zone elements
      var tabs = this.querySelector('coral-tablist') || document.createElement('coral-tablist');
      var panels = this.querySelector('coral-panelstack') || document.createElement('coral-panelstack');

      // Bind the tablist and panel stack together, using the panel id
      panels.id = panels.id || Coral.commons.getUID();
      tabs.setAttribute('target', '#' + panels.id);

      // Assign the content zones.
      this.panelStack = panels;
      this.tabList = tabs;
    }

  /**
    Triggered when the selected tab panel item has changed.

    @event Coral.TabView#coral-tabview:change

    @param {Object} event
      Event object.
    @param {HTMLElement} event.detail.selection
      The new selected tab panel item.
    @param {HTMLElement} event.detail.oldSelection
      The prior selected tab panel item.
  */
  });

  // exports the enumeration
  Coral.TabView.orientation = orientation;
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Tree"] = window["Coral"]["templates"]["Tree"] || {};
window["Coral"]["templates"]["Tree"]["item"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["header"] = document.createElement("div");
  el0.className += " coral3-Tree-header";
  el0.setAttribute("tabindex", "-1");
  el0.setAttribute("role", "tab");
  el0.id = Coral["commons"]["getUID"]();
  el0.setAttribute("handle", "header");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["icon"] = document.createElement("coral-icon");
  el2.className += " coral3-Tree-collapseExpand";
  el2.setAttribute("size", "xs");
  el2.setAttribute("handle", "icon");
  el2.setAttribute("role", "img");
  el2.setAttribute("icon", "chevronRight");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n  ");
  el0.appendChild(el3);
  var el4 = this["contentContainer"] = document.createElement("div");
  el4.className += " coral3-Tree-contentContainer";
  el4.setAttribute("handle", "contentContainer");
  el0.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el0.appendChild(el5);
  frag.appendChild(el0);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = this["subTreeContainer"] = document.createElement("div");
  el7.className += " coral3-Tree-subTree";
  el7.setAttribute("handle", "subTreeContainer");
  el7.id = Coral["commons"]["getUID"]();
  el7.setAttribute("role", "tabpanel");
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["Tree"]["itemspacer"] = (function anonymous(data_0
/**/) {
    var data = data_0;
    var el0 = document.createElement("span");
    el0.className += " coral3-Tree-item-spacer";
    return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Tree# */ {
    /**
      @class Coral.Tree
      @classdesc A Coral.Tree component
      @htmltag coral-tree
      @extends Coral.Component
    */
    name: 'Tree',
    tagName: 'coral-tree',
    className: 'coral3-Tree',

    events: {
      'click .coral3-Tree-header': '_onItemClick',
      'click .coral3-Tree-collapseExpand': '_onExpandCollapseClick',
      'coral-collection:add coral-tree-item': '_onCollectionChange',
      'coral-collection:remove coral-tree-item': '_onCollectionChange',
      // a11y
      'key:space .coral3-Tree-header': '_onItemClick',
      'key:enter .coral3-Tree-header': '_onExpandCollapseClick',
      'key:pageup .coral3-Tree-header': '_onFocusPreviousItem',
      'key:left .coral3-Tree-header': '_onFocusPreviousItem',
      'key:up .coral3-Tree-header': '_onFocusPreviousItem',
      'key:pagedown .coral3-Tree-header': '_onFocusNextItem',
      'key:right .coral3-Tree-header': '_onFocusNextItem',
      'key:down .coral3-Tree-header': '_onFocusNextItem',
      'key:home .coral3-Tree-header': '_onFocusFirstItem',
      'key:end .coral3-Tree-header': '_onFocusLastItem',
      // private
      'coral-tree-item:_beforeselectedchanged': '_onBeforeItemSelectionChanged',
      'coral-tree-item:_selectedchanged': '_onItemSelectionChanged',
      'coral-tree-item:_disabledchanged': '_onFocusableChanged',
      'coral-tree-item:_expandedchanged': '_onFocusableChanged',
      'coral-tree-item:_afterexpandedchanged': '_onExpandedChanged',
      'coral-tree-item:_hiddenchanged': '_onFocusableChanged'
    },
    
    properties: {
      /**
        Whether multiple items can be selected.
       
        @type {Boolean}
        @default false
        @htmlattribute multiple
        @memberof Coral.Tree#
      */
      'multiple': {
        default: false,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.setAttribute('aria-multiselectable', this.multiple);
          
          if (!this.multiple && this.selectedItems.length > 1) {
            this._preventTriggeringEvents = true;
            this.items._deselectAllExceptLast();
            Coral.commons.nextFrame(function() {
              this._preventTriggeringEvents = false;
              this._triggerChangeEvent();
            }.bind(this));
          }
        }
      },
      
      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.
       
        @type {Coral.Collection}
        @readonly
        @memberof Coral.Tree#
      */
      'items': {
        get: function() {
          // we do lazy initialization of the collection
          if (!this._items) {
            this._items = new Coral.SelectableCollection({
              host: this,
              itemTagName: 'coral-tree-item'
            });
          }
      
          return this._items;
        },
        // read-only
        set: function() {}
      },
  
      /**
        First selected item in the Tree. The value <code>null</code> is returned if no item is selected.
        
        @type {HTMLElement}
        @readonly
        @memberof Coral.Tree#
      */
      'selectedItem': {
        get: function() {
          return this.selectedItems[0] || null;
        },
        set: function() {
          // Read-only
        }
      },
  
      /**
        Array containing the set selected items.
        
        @type {Array.<HTMLElement>}
        @readonly
        @memberof Coral.Tree#
      */
      'selectedItems': {
        get: function() {
          return this.items._getAllSelected();
        },
        set: function() {
          // Read-only
        }
      }
    },
  
    /** @private */
    _onBeforeItemSelectionChanged: function(event) {
      event.stopImmediatePropagation();
    
      // In single selection, if the added item is selected, the rest should be deselected
      var selectedItem = this.selectedItem;
      if (!this.multiple && selectedItem && !event.target.selected) {
        selectedItem.set('selected', false, true);
      }
    },
  
    /** @private */
    _onItemSelectionChanged: function(event) {
      event.stopImmediatePropagation();
  
      this._triggerChangeEvent();
    },
  
    /** @private */
    _triggerChangeEvent: function() {
      if (!this._preventTriggeringEvents) {
        var selectedItems = this.selectedItems;
        this.trigger('coral-tree:change', {
          oldSelection: this._oldSelection,
          selection: selectedItems
        });
    
        this._oldSelection = selectedItems;
      }
    },
  
    /** @private */
    _onCollectionChange: function(event) {
      // Prevent triggering collection event twice. Only coral-tree collection events are propagated.
      event.stopImmediatePropagation();
    },

    /** @private */
    _onItemClick: function(event) {
      // Clickable item inside Tree Item should not trigger selection of item
      if (event.target.hasAttribute('coral-interactive') || event.target.closest('[coral-interactive]')) {
        return;
      }

      // The click was performed on the header so we select the item (parentNode) the selection is toggled
      var item = event.target.closest('coral-tree-item');
      if (item && !item.disabled) {
        event.preventDefault();
        event.stopPropagation();
  
        // We ignore the selection if the item is disabled
        item.selected = !item.selected;
        var focusable = this._getFocusable();
        if (focusable) {
          focusable.setAttribute('tabindex', '-1');
        }
        item._elements.header.setAttribute('tabindex', '0');
        item._elements.header.focus();
      }
    },

    /** @private */
    _onExpandCollapseClick: function(event) {
      event.preventDefault();
      event.stopPropagation();
      
      // The click was performed on the icon to expand/collapse  the sub tree
      var item = event.target.closest('coral-tree-item');
      if (item) {
        // We ignore the expand/collapse if the item is disabled
        if (item.disabled) {
          return;
        }

        // Toggle the expanded of the item:
        item.expanded = !item.expanded;
      }
    },
  
    /** @private */
    _focusSiblingItem: function(item, next) {
      var focusableItems = this._getFocusableItems();
  
      // There's not enough items to change focus
      if (focusableItems.length < 2) {
        return;
      }
      
      var index = focusableItems.indexOf(item) + (next ? 1 : -1);
      var siblingItem = null;
      
      // If we reached the edge, target the other edge
      if (index > focusableItems.length - 1) {
        siblingItem = focusableItems[0];
      }
      else if (index < 0) {
        siblingItem = focusableItems[focusableItems.length - 1];
      }
      
      // Find the sibling item
      while (!siblingItem) {
        siblingItem = focusableItems[index];
        // The item might be hidden because a parent is collapsed
        if (siblingItem.parentNode.closest('coral-tree-item.is-collapsed')) {
          if (next) {
            index++;
            siblingItem = (index > focusableItems.length - 1) ? item : null;
          }
          else {
            index--;
            siblingItem = (index < 0) ? item : null;
          }
        }
      }
  
      // Change focus
      if (siblingItem !== item) {
        item._elements.header.setAttribute('tabindex', '-1');
        siblingItem._elements.header.setAttribute('tabindex', '0');
        siblingItem._elements.header.focus();
      }
    },
    
    /** @private */
    _focusEdgeItem: function(last) {
      // Query the focusable item
      var focusable = this._getFocusable();
      if (focusable) {
        var focusableItems = this._getFocusableItems();
        var edgeItem = focusableItems[last ? focusableItems.length - 1 : 0];
        
        // Change focus
        if (edgeItem !== focusable) {
          focusable.setAttribute('tabindex', '-1');
          edgeItem._elements.header.setAttribute('tabindex', '0');
          edgeItem._elements.header.focus();
        }
      }
    },
    
    /** @private */
    _onFocusNextItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      
      var item = event.target.closest('coral-tree-item');
      if (item) {
        this._focusSiblingItem(item, true);
      }
    },
  
    /** @private */
    _onFocusPreviousItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      
      var item = event.target.closest('coral-tree-item');
      if (item) {
        this._focusSiblingItem(item, false);
      }
    },
  
    /** @private */
    _onFocusFirstItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      
      this._focusEdgeItem(false);
    },
  
    /** @private */
    _onFocusLastItem: function(event) {
      event.preventDefault();
      event.stopPropagation();
      
      this._focusEdgeItem(true);
    },
  
    /** @private */
    _onFocusableChanged: function(event) {
      event.preventDefault();
      event.stopPropagation();
  
      if (event.target.contains(this._getFocusable())) {
        this._resetFocusableItem();
      }
    },
  
    /** @private */
    _onExpandedChanged: function(event) {
      event.stopImmediatePropagation();
      
      var item = event.target;
      this.trigger('coral-tree:' + (item.expanded ? 'expand' : 'collapse'), {
        item: item
      });
    },
  
    /** @private */
    _getFocusable: function() {
      return this.querySelector('coral-tree-item > .coral3-Tree-header[tabindex="0"]');
    },
  
    /** @private */
    _getFocusableItems: function() {
      return this.items.getAll().filter(function(item) {
        return !item.closest('coral-tree-item[disabled]') && !item.closest('coral-tree-item[hidden]');
      });
    },
  
    /** @private */
    _resetFocusableItem: function(item) {
      // This is called on initialization so make sure the tree items are ready
      Coral.commons.ready(this, function() {
        // Old focusable becomes unfocusable
        var focusable = this._getFocusable();
        if (focusable) {
          focusable.setAttribute('tabindex', '-1');
        }
        
        // Defined item or first item by default gets the focus
        item = item || this._getFocusableItems()[0];
        if (item) {
          item._elements.header.setAttribute('tabindex', '0');
        }
      }.bind(this));
    },
    
    /** @private */
    _initialize: function() {
      // a11y
      this.setAttribute('role', 'tree');
      // Enable keyboard interaction
      this._resetFocusableItem();
      // Required for coral-tree:change events
      this._oldSelection = this.selectedItems;
      
      // Handles triggering coral-collection events
      this.items._startHandlingItems();
    },
    /**
      Expand all the Tree Items
    */
    expandAll: function() {
      this._expandCollapseAll(true);
    },
    /**
      Collapse all the Tree Items
    */
    collapseAll: function() {
      this._expandCollapseAll(false);
    },

    /** @private */
    _expandCollapseAll: function(expand) {
      var coralTreeItems = this.querySelectorAll('coral-tree-item');
      if (coralTreeItems) {
        var item;
        var length = coralTreeItems.length;
        if (length > 0) {
          for (var index = 0; index < length; index++) {
            item = coralTreeItems[index];
            if (item) {
              item.expanded = expand;
            }
          }
        }
      }
    }
  });
  
  /**
    Triggered when the selection changed.
    
    @event Coral.Tree#coral-tree:change
   
    @param {Object} event
      Event object
    @param {Array.<HTMLElement>} event.detail.oldSelection
      The old selected item.
    @param {Array.<HTMLElement>} event.detail.selection
      The selected items.
  */
  
  /**
    Triggered when an item expanded.
    
    @event Coral.Tree#coral-tree:expand
    
    @param {Object} event
      Event object
    @param {HTMLElement} event.detail.item
      The expanded item.
   */
  
  /**
    Triggered when an item collapsed.
    
    @event Coral.Tree#coral-tree:collapse
    
    @param {Object} event
      Event object
    @param {HTMLElement} event.detail.item
      The collapsed item.
   */
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Chevron classes for expanded/collapse states
  var CHEVRON_CLASSES = {
    'true': 'chevronDown',
    'false': 'chevronRight'
  };

  var variant = {
    /* Default Item variant for leaf nodes. Icon to expand/collapse subtree not shown */
    LEAF: 'leaf',
    /* Variant for tree items with icon to expand/collapse subtree */
    DRILLDOWN: 'drilldown'
  };

  var CLASSNAME = 'coral3-Tree-item';
  var ALL_VARIANT_CLASSES = [];
  
  for (var variantValue in variant) {
    if (variant.hasOwnProperty(variantValue)) {
      ALL_VARIANT_CLASSES.push(CLASSNAME + '--' + variant[variantValue]);
    }
  }

  var addTreeItemSpacer = function(item) {
    if (item) {
      var parentItem = item._parent;
      while (parentItem) {
        var headerNode = item._elements.header;
        if (headerNode) {
          headerNode.insertBefore(Coral.templates.Tree.itemspacer.call(), headerNode.firstChild);
        }
        parentItem = parentItem._parent;
      }
    }
  };

  Coral.register( /** @lends Coral.Tree.Item# */ {
    /**
      @class Coral.Tree.Item
      @classdesc A Coral.Tree.Item component
      @htmltag coral-tree-item
      @extends Coral.Component
    */
    name: 'Tree.Item',
    tagName: 'coral-tree-item',
    className: CLASSNAME,
    
    properties: {
      /**
        The content of this tree item.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Tree.Item#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-tree-item-content',
        insert: function(content) {
          this._elements.contentContainer.appendChild(content);
        }
      }),
  
      /**
         The parent tree. Returns <code>null</code> if item is the root.
     
         @type {HTMLElement}
         @readonly
         @memberof Coral.Tree.Item#
       */
      'parent': {
        get: function() {
          return this._parent || null;
        },
        set: function() {
          // read only
        }
      },

      /**
        The Collection Interface that allows interacting with the items that the component contains. See
        {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Tree.Item#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemTagName: 'coral-tree-item',
              itemSelector: ':scope > coral-tree-item',
              container: this._elements.subTreeContainer,
              filter: this._filterItem.bind(this),
              onItemAdded: this._onItemAdded,
              onItemRemoved: this._onItemRemoved
            });
          }

          return this._items;
        },
        set: function() {}
      },

      /**
        Whether the item is expanded. Expanded cannot be set to <code>true</code> if the item is disabled.

        @type {Boolean}
        @default false
        @htmlattribute expanded
        @htmlattributereflected
        @memberof Coral.Tree.Item#
      */
      'expanded': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-tree-item:_expandedchanged',
        sync: function() {
          var self = this;
          var header = self._elements.header;
          var chevron = self._elements.icon;
          var subTreeContainer = self._elements.subTreeContainer;
    
          self.classList.toggle('is-expanded', self.expanded);
          self.classList.toggle('is-collapsed', !self.expanded);
          header.setAttribute('aria-expanded', self.expanded);
          subTreeContainer.setAttribute('aria-hidden', !self.expanded);
    
          chevron.icon = CHEVRON_CLASSES[self.expanded];
    
          // Don't animate on initialization
          if (this._animate) {
            // Remove height as we want the drawer to naturally grow if content is added later
            Coral.commons.transitionEnd(subTreeContainer, function() {
              if (self.expanded) {
                subTreeContainer.style.height = '';
              }
              else {
                subTreeContainer.hidden = true;
              }
  
              // Trigger once the animation is over to inform coral-tree
              self.trigger('coral-tree-item:_afterexpandedchanged');
            });
      
            // Force height to enable transition
            if (!self.expanded) {
              subTreeContainer.style.height = subTreeContainer.scrollHeight + 'px';
            }
            else {
              subTreeContainer.hidden = false;
            }
      
            // Do transition in next frame as browser might batch up the height property change before painting
            Coral.commons.nextFrame(function() {
              subTreeContainer.style.height = self.expanded ? subTreeContainer.scrollHeight + 'px' : 0;
            });
          }
          else {
            // Make sure it's animated next time
            self._animate = true;
      
            // Hide it on initialization if closed
            if (!self.expanded) {
              subTreeContainer.style.height = 0;
              subTreeContainer.hidden = true;
            }
          }
        }
      },

      /**
       The item's variant.
       
       @type {Coral.Tree.Item.variant}
       @default Coral.Tree.Item.variant.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       @memberof Coral.Tree.Item#
      */
      'variant': {
        default: variant.DRILLDOWN,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // removes every existing variant
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);
          this.classList.add(this._className + '--' + this.variant);
        }
      },
  
      /**
        Whether the item is selected.
        
        @type {Boolean}
        @default false
        @htmlattribute selected
        @htmlattributereflected
        @memberof Coral.Tree.Item#
      */
      'selected': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        triggerBefore: 'coral-tree-item:_beforeselectedchanged',
        trigger: 'coral-tree-item:_selectedchanged',
        sync: function() {
          this.classList.toggle('is-selected', this.selected);
          this.setAttribute('aria-selected', this.selected);
        }
      },
      
      /**
        Whether this item is disabled.
        
        @type {Boolean}
        @default false
        @htmlattribute disabled
        @htmlattributereflected
        @memberof Coral.Tree.Item#
      */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-tree-item:_disabledchanged',
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this._elements.header.setAttribute('aria-disabled', this.disabled);
        }
      },
  
      /** @ignore */
      'hidden': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        trigger: 'coral-tree-item:_hiddenchanged'
      }
    },

    /**
      Handles the focus of the item.

      @ignore
    */
    focus: function() {
      this._elements.header.focus();
    },
  
    /** @private */
    _filterItem: function(item) {
      // Handle nesting check for parent tree item
      // Use parentNode for added items
      // Use _parent for removed items
      return (item.parentNode && item.parentNode.parentNode === this) || (item._parent === this);
    },
    
    /** @private */
    _onItemAdded: function(item) {
      item._parent = this;
      addTreeItemSpacer(item);
    },
  
    /** @private */
    _onItemRemoved: function(item) {
      item._parent = undefined;
    },
    
    /** @private */
    _initialize: function() {
      var self = this;
      self.setAttribute('role', 'treeitem');
      
      var header = self._elements.header;
      header.setAttribute('aria-controls', self._elements.subTreeContainer.id);
      self._elements.subTreeContainer.setAttribute('aria-labelledby', header.id);
  
      // Listen for mutations
      var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];
            if (addedNode.tagName === 'CORAL-TREE-ITEM') {
              // Move tree items to their container
              if (addedNode.parentNode.tagName === addedNode.tagName) {
                self._elements.subTreeContainer.appendChild(addedNode);
              }
            }
          }
        });
      });

      observer.observe(self, {
        childList: true,
        subtree: true
      });
  
      // Tells the collection to automatically detect the items and handle the events
      this.items._startHandlingItems();
    },

    _templateHandleNames: ['header', 'icon', 'contentContainer', 'subTreeContainer'],

    /** @private */
    _render: function() {
      // Render the template and set element references
      var itemFragment = Coral.templates.Tree.item.call(this._elements);

      // Fetch or create the content
      var content = this._elements.content = this.querySelector('coral-tree-item-content') ||
        document.createElement('coral-tree-item-content');

      // Move the content sub-component into contentContainer
      this._elements.contentContainer.appendChild(content);

      // Fetch or create sub tree (coral-tree-item) and move any remaining elements into the content sub-component
      var child;
      while (this.firstChild) {
        child = this.firstChild;
        if (child.nodeName === this.tagName) {
          child._parent = this; // Adding parent attribute to access the parent directly
          this._elements.subTreeContainer.appendChild(child);
        }
        else if (child.nodeType === Node.TEXT_NODE ||
          this._templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
          // Add non-template elements to the content
          content.appendChild(child);
        }
        else {
          // Remove anything else element
          this.removeChild(child);
        }
      }
      
      // Lastly, add the fragment into the container
      this.appendChild(itemFragment);
    }
  
    /**
      Triggered before {@link Coral.Tree.Item#selected} changed.
      
      @event Coral.Tree.Item#coral-tree-item:_beforeselectedchanged
      @param {Object} event Event object
      @private
    */
    
    /**
      Triggered when {@link Coral.Tree.Item#selected} changed.
      
      @event Coral.Tree.Item#coral-tree-item:_selectedchanged
      @param {Object} event Event object
      @private
    */
    
    /**
      Triggered when {@link Coral.Tree.Item#expanded} changed.
      
      @event Coral.Tree.Item#coral-tree-item:_expandedchanged
      @param {Object} event Event object
      @private
    */
    
    /**
      Triggered when {@link Coral.Tree.Item#hidden} changed.
      
      @event Coral.Tree.Item#coral-tree-item:_hiddenchanged
      @param {Object} event Event object
      @private
    */
    
    /**
      Triggered when {@link Coral.Tree.Item#disabled} changed.
      
      @event Coral.Tree.Item#coral-tree-item:_disabledchanged
      @param {Object} event Event object
      @private
    */
  });

  Coral.Tree.Item.variant = variant;

  /**
    @class Coral.Tree.Item.Content
    @classdesc The Tree Item Content
    @htmltag coral-tree-item-content
    @extends Coral.Component
  */
  Coral.Tree.Item.Content = function() {
    return document.createElement('coral-tree-item-content');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.WizardView# */ {

    /**
      @class Coral.WizardView
      @classdesc An WizardView component
      @htmltag coral-wizardview
      @extends Coral.Component
    */
    name: 'WizardView',
    tagName: 'coral-wizardview',
    className: 'coral3-WizardView',

    events: {
      'coral-component:attached coral-panelstack[coral-wizardview-panelstack]': '_onComponentAttached',
      'coral-component:attached coral-steplist[coral-wizardview-steplist]': '_onComponentAttached',
      'coral-steplist:change coral-steplist[coral-wizardview-steplist]': '_onStepListChange',
      'click [coral-wizardview-previous]': '_onPreviousClick',
      'click [coral-wizardview-next]': '_onNextClick'
    },

    properties: {
      /**
        The set of controlled PanelStacks. Each PanelStack must have the
        <code>coral-wizardview-panelstack</code> attribute.

        See {@link Coral.Collection} for more details regarding collection APIs.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.WizardView#
      */
      'panelStacks': {
        attribute: null,
        get: function() {
          // Construct the collection on first request:
          if (!this._panelStacks) {
            this._panelStacks = new Coral.Collection({
              host: this,
              itemTagName: 'coral-panelstack',
              itemSelector: 'coral-panelstack[coral-wizardview-panelstack]',
              filter: this._isControlledByThisComponent.bind(this),
              onItemAdded: this._onItemAdded
            });
          }

          return this._panelStacks;
        },
        set: function() {}
      },

      /**
        The set of controlling StepLists. Each StepList must have the <code>coral-wizardview-steplist</code> attribute.

        See {@link Coral.Collection} for more details regarding collection APIs.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.WizardView#
      */
      'stepLists': {
        attribute: null,
        get: function() {
          // Construct the collection on first request:
          if (!this._stepLists) {
            this._stepLists = new Coral.Collection({
              host: this,
              itemTagName: 'coral-steplist',
              itemSelector: 'coral-steplist[coral-wizardview-steplist]',
              filter: this._isControlledByThisComponent.bind(this),
              onItemAdded: this._onItemAdded
            });
          }

          return this._stepLists;
        },
        set: function() {}
      }
    },

    /**
      Called by event handlers when a component is attached.

      @private
    */
    _onComponentAttached: function(event) {
      // Do not catch attached events for steps/panels
      if (event.target !== event.matchedTarget) {
        return;
      }

      // Do not catch attached events for StepLists and PanelStacks we do not control
      if (!this._isControlledByThisComponent(event.target)) {
        return;
      }

      this._selectItemByIndex(event.target, this._getSelectedIndex());
    },

    /**
      Called by the Collection when an item is added with the add() API.

      @private
    */
    _onItemAdded: function(component) {
      this._selectItemByIndex(component, this._getSelectedIndex());
    },

    /**
      Handles the next button click.

      @private
    */
    _onNextClick: function(event) {
      // we stop propagation in case the wizard views are nested
      event.stopPropagation();

      this.next();
    },

    /**
      Handles the previous button click.

      @private
    */
    _onPreviousClick: function(event) {
      // we stop propagation in case the wizard views are nested
      event.stopPropagation();

      this.previous();
    },

    /**
      Detects a change in the StepList and triggers an event.

      @private
    */
    _onStepListChange: function(event) {
      if (!this._isControlledByThisComponent(event.target)) {
        return;
      }

      // Stop propagation of the events to support nested panels
      event.stopPropagation();

      // Get the step number
      var index = event.target.items.getAll().indexOf(event.detail.selection);

      // Sync the other StepLists
      this._selectStep(index);

      this.trigger('coral-wizardview:change', {
        'selection': event.detail.selection,
        'oldSelection': event.detail.oldSelection
      });
    },

    /** @private */
    _getSelectedIndex: function() {
      var stepList = this.stepLists.first();
      if (!stepList) {
        return -1;
      }

      var stepIndex = -1;
      if (stepList.items) {
        stepIndex = stepList.items.getAll().indexOf(stepList.selectedItem);
      }
      else {
        // Manually get the selected step
        var steps = stepList.querySelectorAll('coral-step');

        // Find the last selected step
        for (var i = steps.length - 1; i >= 0; i--) {
          if (steps[i].hasAttribute('selected')) {
            stepIndex = i;
            break;
          }
        }
      }

      return stepIndex;
    },

    /**
      Helper method used to indicate if the given panel should be controller by WizardView.

      @param {HTMLElement} panel
        panel to check whether it is controlled by the current WizardView.

      @private
    */
    _isControlledByThisComponent: function(panel) {
      return panel.closest('coral-wizardview') === this;
    },

    /**
      Select the step according to the provided index.

      @param {*} component
        The StepList or PanelStack to select the step on.
      @param {Number} index
        The index of the step that should be selected.

      @private
    */
    _selectItemByIndex: function(component, index) {
      var item = null;

      // we need to set an id to be able to find direct children
      component.id = component.id || Coral.commons.getUID();

      // if collection api is available we use it to find the correct item
      if (component.items) {
        // Get the corresponding item
        item = component.items.getAll()[index];
      }
      else {
        // Resort to querying manually on immediately children
        if (component.tagName === 'CORAL-STEPLIST') {
          // @polyfill IE - we use id since :scope is not supported
          item = component.querySelectorAll('#' + component.id + ' > coral-step')[index];
        }
        else if (component.tagName === 'CORAL-PANELSTACK') {
          // @polyfill IE - we use id since :scope is not supported
          item = component.querySelectorAll('#' + component.id + ' > coral-panel')[index];
        }
      }

      if (item) {
        // we only select if not select to avoid mutations
        if (!item.hasAttribute('selected')) {
          item.setAttribute('selected', '');
        }
      }
      // if we did not find an item to select, it means that the "index" is not available in the component, therefore we
      // need to deselect all items
      else {
        // we use the component id to be able to find direct children
        if (component.tagName === 'CORAL-STEPLIST') {
          // @polyfill IE - we use id since :scope is not supported
          item = component.querySelector('#' + component.id + ' > coral-step[selected]');
        }
        else if (component.tagName === 'CORAL-PANELSTACK') {
          // @polyfill IE - we use id since :scope is not supported
          item = component.querySelector('#' + component.id + ' > coral-panel[selected]');
        }

        if (item) {
          item.removeAttribute('selected');
        }
      }
    },

    /** @private */
    _selectStep: function(index) {
      var self = this;

      // we apply the selection to all available steplists
      this.stepLists.getAll().forEach(function(stepList) {
        self._selectItemByIndex(stepList, index);
      });

      // we apply the selection to all available panelstacks
      this.panelStacks.getAll().forEach(function(panelStack) {
        self._selectItemByIndex(panelStack, index);
      });
    },

    /**
      Sets the correct selected item in every PanelStack.

      @private
    */
    _syncPanelStackSelection: function() {
      // Find out which step we're on by checking the first StepList
      var index = this._getSelectedIndex();

      if (index === -1) {
        // No step selected
        return;
      }

      var self = this;
      this.panelStacks.getAll().forEach(function(panelStack) {
        self._selectItemByIndex(panelStack, index);
      });
    },

    /**
      Selects the correct step in every StepList.

      @private
    */
    _syncStepListSelection: function() {
      // Find out which step we're on by checking the first StepList
      var index = this._getSelectedIndex();

      if (index === -1) {
        // No step selected
        return;
      }

      var self = this;
      this.stepLists.getAll().forEach(function(stepList) {
        self._selectItemByIndex(stepList, index);
      });
    },

    /** @private */
    _initialize: function() {
      this._syncStepListSelection();
      this._syncPanelStackSelection();
    },

    /**
      Shows the next step. If the WizardView is already in the last step nothing will happen.

      @fires Coral.WizardView#coral-wizardview:change
    */
    next: function() {
      var stepList = this.stepLists.first();
      if (!stepList) {
        return;
      }

      // Change to the next step
      stepList.next();

      // Select the step everywhere
      this._selectStep(stepList.items.getAll().indexOf(stepList.selectedItem));
    },

    /**
      Shows the previous step. If the WizardView is already in the first step nothing will happen.

      @fires Coral.WizardView#coral-wizardview:change
    */
    previous: function() {
      var stepList = this.stepLists.first();
      if (!stepList) {
        return;
      }

      // Change to the previous step
      stepList.previous();

      // Select the step everywhere
      this._selectStep(stepList.items.getAll().indexOf(stepList.selectedItem));
    }

    /**
      Triggered when the selected step list item has changed.

      @event Coral.WizardView#coral-wizardview:change

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.selection
        The new selected step list item.
      @param {HTMLElement} event.detail.oldSelection
        The prior selected step list item.
    */
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Shell */ {
    /**
      @class Coral.Shell
      @classdesc The outer shell component
      @extends Coral.Component
      @htmltag coral-shell
    */
    name: 'Shell',
    tagName: 'coral-shell',
    className: 'coral3-Shell',

    properties: {
      /**
        The outer shell content zone.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-shell-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      })
    },

    /** @ignore */
    _render: function() {
      Coral.commons.ready(this, function(shell) {
        // we need to search for an existing content zone
        var content = shell._elements.content = shell.querySelector('coral-shell-content');

        // when the content zone was not created, we need to make sure that everyhing is added inside it as a content
        if (content === null) {
          var fragment = document.createDocumentFragment();

          // since it was not provided we need to create it
          content = shell._elements.content = document.createElement('coral-shell-content');

          fragment.appendChild(content);

          // move the contents of the item into the content zone
          while (shell.firstChild) {
            content.appendChild(shell.firstChild);
          }

          shell.appendChild(fragment);
        }
      });
    }
  });

  /**
    @class Coral.Shell.Content
    @classdesc The Shell content
    @htmltag coral-shell-content
    @extends HTMLElement
  */
  Coral.Shell.Content = function() {
    return document.createElement('coral-shell-content');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Shell"] = window["Coral"]["templates"]["Shell"] || {};
window["Coral"]["templates"]["Shell"]["menubaritem"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["shellMenuButton"] = document.createElement("button","coral-button");
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("variant", "minimal");
  el0.setAttribute("iconsize", "S");
  el0.className += " coral3-Shell-menu-button";
  el0.setAttribute("handle", "shellMenuButton");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["shellMenuButtonLabel"] = document.createElement("coral-button-label");
  el2.setAttribute("handle", "shellMenuButtonLabel");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Shell.MenuBar */ {
    /**
      @class Coral.Shell.MenuBar
      @classdesc Shell menubar
      @extends Coral.Component
      @htmltag coral-shell-menubar
    */
    name: 'Shell.MenuBar',
    tagName: 'coral-shell-menubar',
    className: 'coral3-Shell-menubar',

    properties: {
      /**
        The item collection.

        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Shell.MenuBar#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemTagName: 'coral-shell-menubar-item'
            });
          }

          return this._items;
        },
        set: function() {}
      }
    },

    /** @ignore */
    _initialize: function() {
      // @todo watch for added items, reset open status
    }
  });

  /**
    Enum for menubar item iconVariant.
    @enum {String}
    @memberof Coral.Shell.MenuBar.Item
  */
  var iconVariant = {
    /** A default menubar item */
    DEFAULT: 'default',
    /** A round image as menubar item */
    CIRCLE: 'circle'
  };

  // the Menubar Item's base classname
  var CLASSNAME = 'coral3-Shell-menubar-item';

  // Builds a string containing all possible iconVariant classnames. This will be used to remove classnames when the variant
  // changes
  var ALL_ICON_VARIANT_CLASSES = [];
  for (var variantValue in iconVariant) {
    ALL_ICON_VARIANT_CLASSES.push(CLASSNAME + '--' + iconVariant[variantValue]);
  }

  Coral.register( /** @lends Coral.Shell.MenuBar.Item */ {
    /**
      @class Coral.Shell.MenuBar.Item
      @classdesc Shell menubar item
      @extends Coral.Component
      @htmltag coral-shell-menubar-item
    */
    name: 'Shell.MenuBar.Item',
    tagName: 'coral-shell-menubar-item',
    className: CLASSNAME,

    events: {
      'click [handle="shellMenuButton"]': '_handleButtonClick',

      // it has to be global because the menus are not direct children
      'global:coral-overlay:close': '_handleOverlayEvent',
      'global:coral-overlay:open': '_handleOverlayEvent'
    },

    properties: {
      /**
        Specifies the icon name used inside the menu item.
        See {@link Coral.Icon} for valid icon names.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Shell.MenuBar.Item#

        @see {@link Coral.Icon}
      */
      'icon': {
        set: function(value) {
          this._elements.shellMenuButton.icon = value;
        },
        get: function() {
          return this._elements.shellMenuButton.icon;
        }
      },

      /**
        Size of the icon. It accepts both lower and upper case sizes.

        @type {Coral.Icon.size}
        @default Coral.Icon.size.SMALL
        @htmlattribute iconsize
        @memberof Coral.Shell.MenuBar.Item#

        @see {@link Coral.Icon#size}
      */
      'iconSize': {
        attribute: 'iconsize',
        set: function(value) {
          this._elements.shellMenuButton.iconSize = value;
        },
        get: function() {
          return this._elements.shellMenuButton.iconSize;
        }
      },

      /**
        The menubar item's iconVariant.
        @type {Coral.Shell.MenuBar.Item.iconVariant}
        @default Coral.Shell.MenuBar.Item.iconVariant.DEFAULT
        @htmlattribute iconvariant
        @memberof Coral.Shell.MenuBar.Item#
      */
      'iconVariant': {
        default: iconVariant.DEFAULT,
        attribute: 'iconvariant',
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(iconVariant)
        ],
        sync: function() {
          // removes all the existing variants
          this.classList.remove.apply(this.classList, ALL_ICON_VARIANT_CLASSES);
          // adds the new variant
          if (this.variant !== Coral.Shell.MenuBar.Item.iconVariant.DEFAULT) {
            this.classList.add(CLASSNAME + '--' + this.iconVariant);
          }
        }
      },

      /**
        The notification badge content.

        @type {String}
        @default ""
        @htmlattribute badge
        @memberof Coral.Shell.MenuBar.Item#
      */
      'badge': {
        set: function(value) {
          if (!value || value === '0') {
            // Non-truthy values shouldn't show
            // null, empty string, 0, etc
            this._elements.shellMenuButton.removeAttribute('badge', value);
          }
          else {
            this._elements.shellMenuButton.setAttribute('badge', value);
          }
        },
        get: function() {
          return this._elements.shellMenuButton.getAttribute('badge');
        }
      },

      /**
        Whether the menu is open or not.

        @type {Boolean}
        @default false
        @htmlattribute open
        @htmlattributereflected
        @memberof Coral.Shell.MenuBar.Item#

        @fires Coral.Shell.MenuBar.Item#coral-shell-menubar-item:open
        @fires Coral.Shell.MenuBar.Item#coral-shell-menubar-item:close
      */
      'open': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        validate: [
          Coral.validate.valueMustChange,
          function(newValue, oldValue) {
            // if we want to open the dialog we need to make sure there is a valid menu
            return !newValue || this._getMenu() !== null;
          }
        ],
        trigger: function(newValue, oldValue) {
          return this.trigger(newValue ? 'coral-shell-menubar-item:open' : 'coral-shell-menubar-item:close');
        },
        set: function(value) {
          this._open = value;

          // Open the target menu
          var menu = this._getMenu();
          if (menu) {
            menu.open = this.open;
          }
        }
      },

      /**
        The menubar item's label content zone.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.MenuBar.Item#
      */
      'label': Coral.property.contentZone({
        handle: 'shellMenuButtonLabel',
        tagName: 'coral-button-label',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.shellMenuButtonLabel.appendChild(content);
        }
      }),

      /**
        The menu that this menu item should show. If a CSS selector is provided, the first matching element will be
        used.

        @type {?HTMLElement|String}
        @default null
        @htmlattribute menu
        @memberof Coral.Shell.MenuBar.Item#
      */
      'menu': {
        default: null
      }
    },

    /** @private */
    _handleOverlayEvent: function(event) {
      var target = event.target;

      // matches the open state of the target in case it was open separately
      if (target === this._getMenu()) {
        this.open = target.open;
      }
    },

    /** @ignore */
    _handleButtonClick: function(event) {
      this.open = !this.open;
    },

    /** @ignore */
    _getMenu: function(targetValue) {
      // Use passed target
      targetValue = targetValue || this.menu;

      if (targetValue instanceof Node) {
        // Just return the provided Node
        return targetValue;
      }

      // Dynamically get the target node based on target
      var newTarget = null;
      if (typeof targetValue === 'string') {
        newTarget = document.querySelector(targetValue);
      }

      return newTarget;
    },

    /** @ignore */
    _render: function() {
      // Move everything into the button
      var fragment = Coral.templates.Shell.menubaritem.call(this._elements);

      // Move component content into the content
      while (this.firstChild) {
        // @todo this copies line break text nodes, which is ugly
        this.label.appendChild(this.firstChild);
      }

      this.appendChild(fragment);
    }

    /**
      Triggerred after the overlay is opened with <code>show()</code> or <code>instance.open = true</code>

      @event Coral.Shell.MenuBar.Item#coral-shell-menubar-item:open

      @param {Object} event
        Event object.
    */

    /**
      Triggerred after the component is closed with <code>hide()</code> or <code>instance.open = false</code>

      @event Coral.Shell.MenuBar.Item#coral-shell-menubar-item:close

      @param {Object} event
        Event object.
    */
  });

  // exports the variants enumeration
  Coral.Shell.MenuBar.Item.iconVariant = iconVariant;

}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  var CLASSNAME = 'coral3-Shell-menu';

  /**
    Overlay placement values.

    @enum {Object}
    @memberof Coral.Shell.Menu
  */
  var placement = {
    /** Anchor to the right of the page. */
    RIGHT: 'right',
    /** Anchor at the top of the page. */
    TOP: 'top'
  };

  var ALL_PLACEMENT_CLASSES = [];
  for (var placementValue in placement) {
    ALL_PLACEMENT_CLASSES.push(CLASSNAME + '--' + placement[placementValue]);
  }

  /**
    Overlay animation directions.

    @enum {Object}
    @memberof Coral.Shell.Menu
  */
  var from = {
    /** Animate in from the right. */
    RIGHT: 'right',
    /** Animate in from the top. */
    TOP: 'top'
  };

  var ALL_FROM_CLASSES = [];
  for (var fromValue in from) {
    ALL_FROM_CLASSES.push(CLASSNAME + '--' + from[fromValue]);
  }

  /**
    Lowercase the passed string if it's a string, passthrough if not.

    @ignore
  */
  function transformLowercase(alignment) {
    // Just pass through non-strings
    return typeof alignment === 'string' ? alignment.toLowerCase() : alignment;
  }

  Coral.register( /** @lends Coral.Shell.Menu# */ {
    /**
      @class Coral.Shell.Menu
      @classdesc Shell menu
      @extends Coral.Component
      @extends Coral.mixin.overlay
      @htmltag coral-shell-menu
    */
    name: 'Shell.Menu',
    tagName: 'coral-shell-menu',
    className: CLASSNAME,

    mixins: [
      Coral.mixin.overlay
    ],

    events: {
      'click [coral-close]': '_handleCloseClick',
      'global:key:escape': '_handleGlobalEscape',
      'global:capture:click': '_handleGlobalClick'
    },

    properties: {
      /**
        The side of the page the overlay should be anchored to.

        @type {Coral.Shell.Menu.placement}
        @default Coral.Shell.Menu.placement.RIGHT
        @htmlattribute placement
        @memberof Coral.Shell.Menu#
      */
      'placement': {
        default: placement.RIGHT,
        transform: transformLowercase,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(placement)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_PLACEMENT_CLASSES);
          this.classList.add(this._className + '--placement-' + this.placement);
        }
      },

      /**
        The direction the overlay should animate from.

        @type {Coral.Shell.Menu.from}
        @default Coral.Shell.Menu.from.TOP
        @htmlattribute from
        @memberof Coral.Shell.Menu#
      */
      'from': {
        default: from.TOP,
        transform: transformLowercase,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(from)
        ],
        sync: function() {
          this.classList.remove.apply(this.classList, ALL_FROM_CLASSES);
          this.classList.add(this._className + '--from-' + this.from);
        }
      },

      /**
        Whether the overlay should use all available space.

        @type {Boolean}
        @default false
        @htmlattribute full
        @memberof Coral.Shell.Menu#
      */
      'full': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(this._className + '--full', this.full);
        }
      },

      /**
        Whether the overlay should always be on top.

        @type {Boolean}
        @default false
        @htmlattribute full
        @memberof Coral.Shell.Menu#
      */
      'top': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr
      },

      // JSDoc inherited
      'focusOnShow': {
        default: 'on'
      },

      // JSDoc inherited
      'returnFocus': {
        default: 'on'
      },

      // JSDoc inherited
      'open': {
        set: function() {
          if (this.top) {
            // Be higher than the next highest overlay
            this.style.zIndex = parseInt(this.style.zIndex, 10) + 20;
          }
        }
      }
    },

    // This must match the CSS transition time
    _overlayAnimationTime: 400,

    /** @ignore */
    _handleGlobalEscape: function() {
      // checks that it is the top most overlay before closing
      if (this.open && this._isTopOverlay()) {
        this.open = false;
      }
    },

    /**
      @todo this is duplicated between ovelay components, maybe this should be in a mixin

      @ignore
    */
    _handleCloseClick: function(event) {
      var dismissTarget = event.matchedTarget;
      var dismissValue = dismissTarget.getAttribute('coral-close');
      if (!dismissValue || this.matches(dismissValue)) {
        this.hide();
        event.stopPropagation();
      }
    },

    /**
      Makes sure that the menu is closed when outside is clicked.

      @private
    */
    _handleGlobalClick: function(event) {
      var eventTarget = event.target;

      // since this component does not have a target property like most overlays, we need to figure it if
      // @todo: introduce target to be able to remove this behavior
      var item = eventTarget.closest('coral-shell-menubar-item');

      // in case the target was clicked, we need to ignore the event
      if (item && this === item._getMenu()) {
        return;
      }
      else if (this.open && !this.contains(eventTarget)) {
        // Close if we are open and the click was outside of the target and outside of the popover
        this.hide();
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Shell.Header */ {
    /**
      @class Coral.Shell.Header
      @classdesc The shell header component
      @extends Coral.Component
      @htmltag coral-shell-header
    */
    name: 'Shell.Header',
    tagName: 'coral-shell-header',
    className: 'coral3-Shell-header',

    events: {
      'global:coral-overlay:beforeopen': '_handleMenuBeforeOpenOrClose',
      'global:coral-overlay:beforeclose': '_handleMenuBeforeOpenOrClose',
      'global:coral-overlay:close': '_handleMenuClose'
    },

    properties: {
      /**
        The label of the panel.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.Header#
      */
      'home': Coral.property.contentZone({
        handle: 'home',
        tagName: 'coral-shell-header-home',
        insert: function(content) {
          // a11y
          this._enableHomeAccessibility(content);
          this.appendChild(content);
        }
      }),

      /**
        The main content zone of the panel.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.Header#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-shell-header-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        The content zone where the actions are placed.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.Header#
      */
      'actions': Coral.property.contentZone({
        handle: 'actions',
        tagName: 'coral-shell-header-actions',
        insert: function(content) {
          this.appendChild(content);
        }
      })
    },

    /**
      Just before a menu is open or closed, we check that the zIndex of the Header is correct so that it animates
      below the header.

      @ignore
    */
    _handleMenuBeforeOpenOrClose: function(event) {
      var target = event.target;

      // header only changes zIndex due to menus
      if (target.tagName === 'CORAL-SHELL-MENU') {
        var self = this;
        // we need one frame to make sure the zIndex is already set
        Coral.commons.nextFrame(function() {
          self.style.zIndex = parseInt(target.style.zIndex, 10) + 100;
          window.clearTimeout(self._zIndexTimeout);
        });
      }
    },

    /**
     Cleanup after _handleMenuBeforeOpenOrClose() to make sure
     we do not leave high zIndex behind that overlay other element on the page

     @ignore
     */
    _handleMenuClose: function(event){
      var target = event.target;

      // header only changes zIndex due to menus
      if (target.tagName === 'CORAL-SHELL-MENU') {
        var self = this;
        // we need one frame to make sure the zIndex is already set
        self._zIndexTimeout = setTimeout(function() {
          self.style.zIndex = null;
        }, 200);
      }
    },

    /** @private */
    _enableHomeAccessibility: function(home) {
      home.setAttribute('role', 'heading');
      home.setAttribute('aria-level', '2');
    },

    /** @ignore */
    _render: function() {
      var fragment = document.createDocumentFragment();

      // fetches or creates the sub-elements
      var home = this._elements.home = this.querySelector('coral-shell-header-home') ||
        document.createElement('coral-shell-header-home');
      var actions = this._elements.actions = this.querySelector('coral-shell-header-actions') ||
        document.createElement('coral-shell-header-actions');
      var content = this._elements.content = this.querySelector('coral-shell-header-content') ||
        document.createElement('coral-shell-header-content');

      // a11y
      this._enableHomeAccessibility(home);

      fragment.appendChild(home);
      fragment.appendChild(actions);
      fragment.appendChild(content);

      // moves everything to the main content zone
      while (this.firstChild) {
        content.appendChild(this.firstChild);
      }

      this.appendChild(fragment);
    },

    /** @ignore */
    _initialize: function() {
      // appheader only exists on dark theme
      this.classList.add('coral--dark');
    }
  });

  /**
    @class Coral.Shell.Header.Home
    @classdesc The Shell Header home
    @htmltag coral-shell-header-home
    @extends HTMLElement
  */
  Coral.Shell.Header.Home = function() {
    return document.createElement('coral-shell-header-home');
  };

  /**
    @class Coral.Shell.Header.Actions
    @classdesc The Shell Header actions
    @htmltag coral-shell-header-actions
    @extends HTMLElement
  */
  Coral.Shell.Header.Actions = function() {
    return document.createElement('coral-shell-header-actions');
  };

  /**
    @class Coral.Shell.Header.Content
    @classdesc The Shell Header content
    @htmltag coral-shell-header-content
    @extends HTMLElement
  */
  Coral.Shell.Header.Content = function() {
    return document.createElement('coral-shell-header-content');
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Shell.HomeAnchor */ {
    /**
      @class Coral.Shell.HomeAnchor
      @classdesc The home anchor button for the shell
      @extends HTMLAnchorElement
      @htmltag coral-shell-homeanchor
    */
    name: 'Shell.HomeAnchor',
    tagName: 'coral-shell-homeanchor',
    baseTagName: 'a',
    extend: HTMLAnchorElement,
    className: 'coral3-Shell-homeAnchor',

    properties: {
      /**
        The label of the anchor.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.HomeAnchor#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-shell-homeanchor-label',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        Specifies the icon name used in the anchor. See {@link Coral.Icon} for valid icon names.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Shell.HomeAnchor#
      */
      'icon': {
        get: function() {
          return this._elements.icon.icon;
        },
        set: function(value) {
          this._elements.icon.icon = value;
        },
        sync: function() {
          // removes the icon element from the DOM.
          if (this.icon === '') {
            this._elements.icon.remove();
          }
          // adds the icon back since it was blown away by textContent
          else if (!this._elements.icon.parentNode) {
            this.insertBefore(this._elements.icon, this.firstChild);
          }
        }
      }
    },

    /** @ignore */
    _render: function() {
      var fragment = document.createDocumentFragment();

      // Label
      var label = this._elements.label = this.querySelector('coral-shell-homeanchor-label') ||
        document.createElement('coral-shell-homeanchor-label');

      // Move any remaining elements into the label
      while (this.firstChild) {
        var child = this.firstChild;

        if (child.nodeType === Node.TEXT_NODE) {
          // Move text elements to the label
          label.appendChild(child);
        }
        else if (child.tagName === 'CORAL-ICON') {
          // Conserve existing icon element to content
          this._elements.icon = child;
          fragment.appendChild(child);
        }
        else {
          // Remove anything else
          this.removeChild(child);
        }
      }

      if (!this._elements.icon) {
        // creates the icon. it is not added to the DOM
        this._elements.icon = document.createElement('coral-icon');
        // all icons are medium by default
        this._elements.icon.size = Coral.Icon.size.MEDIUM;
        // add className, that is owned by this component
        this._elements.icon.className += ' coral3-Shell-homeAnchor-icon';
      }

      fragment.appendChild(label);
      this.appendChild(fragment);
    }
  });

  /**
    @class Coral.Shell.HomeAnchor.Label
    @classdesc The Shell HomeAnchor label content
    @htmltag coral-shell-homeanchor-label
    @extends HTMLElement
  */
  Coral.Shell.HomeAnchor.Label = function() {
    return document.createElement('coral-shell-homeanchor-label');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-shell-help"] = {"en-US":{"Search for Help":"Search for Help","Searching Help…":"Searching Help…","Error fetching results":"Error fetching results","No results found":"No results found","See all {0} results":"See all {0} results"},"fr-FR":{"Search for Help":"Rechercher de l’aide","Searching Help…":"Recherche dans l’aide…","Error fetching results":"Erreur lors de la récupération des résultats","No results found":"Aucun résultat trouvé","See all {0} results":"Voir les {0} résultats"},"de-DE":{"Search for Help":"Nach Hilfe suchen","Searching Help…":"Suche nach Hilfe …","Error fetching results":"Fehler beim Abruf von Ergebnissen","No results found":"Keine Ergebnisse gefunden","See all {0} results":"Alle {0} Ergebnisse anzeigen"},"it-IT":{"Search for Help":"Cerca informazioni nell'Aiuto","Searching Help…":"Ricerca aiuto…","Error fetching results":"Errore durante il recupero dei risultati","No results found":"Nessun risultato trovato","See all {0} results":"Visualizza tutti i {0} risultati"},"es-ES":{"Search for Help":"Buscar ayuda","Searching Help…":"Buscando ayuda…","Error fetching results":"Error al obtener los resultados","No results found":"No se han encontrado resultados","See all {0} results":"Ver los {0} resultados"},"pt-BR":{"Search for Help":"Procurar nas seções de Ajuda","Searching Help…":"Procurando ajuda…","Error fetching results":"Erro ao obter resultados","No results found":"Nenhum resultado encontrado","See all {0} results":"Ver todos os resultados de {0}"},"ja-JP":{"Search for Help":"ヘルプを検索","Searching Help…":"ヘルプを検索中…","Error fetching results":"結果を取得中にエラーが発生しました","No results found":"結果が見つかりませんでした","See all {0} results":"すべての {0} 結果を確認"},"ko-KR":{"Search for Help":"도움말 검색","Searching Help…":"도움말 검색 중…","Error fetching results":"결과를 가져오는 중 오류 발생","No results found":"결과를 찾을 수 없습니다","See all {0} results":"총 {0}개 결과 보기"},"zh-CN":{"Search for Help":"搜索帮助","Searching Help…":"正在搜索帮助…","Error fetching results":"获取结果时出错","No results found":"找不到任何结果","See all {0} results":"查看全部 {0} 个结果"},"zh-TW":{"Search for Help":"搜尋說明","Searching Help…":"正在搜尋說明…","Error fetching results":"擷取結果時發生錯誤","No results found":"找不到結果","See all {0} results":"查看全部 {0} 個結果"},"nl-NL":{"Search for Help":"Zoeken naar hulp","Searching Help…":"Hulp zoeken…","Error fetching results":"Fout bij ophalen resultaten","No results found":"Geen resultaten gevonden","See all {0} results":"Alle {0} resultaten bekijken"},"da-DK":{"Search for Help":"Søg efter Hjælp...","Searching Help…":"Søger i Hjælp...","Error fetching results":"Fejl ved hentning af resultater","No results found":"Ingen resultater fundet","See all {0} results":"Se alle {0} resultater"},"fi-FI":{"Search for Help":"Hae ohjeita","Searching Help…":"Haun ohje…","Error fetching results":"Tuloksia haettaessa tapahtui virhe.","No results found":"Tuloksia ei löytynyt.","See all {0} results":"Näytä kaikki {0} tulosta"},"nb-NO":{"Search for Help":"Søk etter hjelp","Searching Help…":"Søker i Hjelp …","Error fetching results":"Kan ikke hente resultater","No results found":"Finner ingen resultater","See all {0} results":"Vis alle de {0} resultatene"},"sv-SE":{"Search for Help":"Sök efter hjälp","Searching Help…":"Sökhjälp…","Error fetching results":"Det gick inte att hämta resultat","No results found":"Inga resultat funna","See all {0} results":"Se alla {0} resultat"},"cs-CZ":{"Search for Help":"Vyhledat nápovědu","Searching Help…":"Nápověda hledání…","Error fetching results":"Při shromažďování výsledků došlo k chybě","No results found":"Nebyly nalezeny žádné výsledky","See all {0} results":"Zobrazit všechny výsledky: {0}"},"pl-PL":{"Search for Help":"Szukaj pomocy","Searching Help…":"Trwa przeszukiwanie Pomocy...","Error fetching results":"Błąd pobierania wyników","No results found":"Nie znaleziono żadnych wyników","See all {0} results":"Zobacz wszystkie {0} wyników"},"ru-RU":{"Search for Help":"Поиск справки","Searching Help…":"Поиск по справке…","Error fetching results":"Ошибка получения результатов","No results found":"Результаты не найдены","See all {0} results":"Посмотреть все результаты ({0})"},"tr-TR":{"Search for Help":"Yardım Ara","Searching Help…":"Yardım Aranıyor...","Error fetching results":"Sonuçlar alınırken hata oluştu","No results found":"Sonuç bulunamadı","See all {0} results":"Tüm {0} sonuçlarını gör"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Shell"] = window["Coral"]["templates"]["Shell"] || {};
window["Coral"]["templates"]["Shell"]["help"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  data = data_0;
  
var labelId = Coral.commons.getUID();

  data_0 = data;
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("label");
  el2.className += " u-coral-screenReaderOnly";
  el2.id = labelId;
  el2.textContent = Coral["i18n"]["get"]('Search for Help');
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["search"] = document.createElement("coral-search");
  el4.className += " coral3-Shell-help-search";
  el4.setAttribute("handle", "search");
  el4.setAttribute("placeholder", Coral["i18n"]["get"]('Search for Help'));
  el4.setAttribute("labelledby", labelId);
  frag.appendChild(el4);
  var el5 = document.createTextNode("\n");
  frag.appendChild(el5);
  var el6 = this["items"] = document.createElement("div");
  el6.className += " coral3-Shell-help-items";
  el6.setAttribute("handle", "items");
  frag.appendChild(el6);
  var el7 = document.createTextNode("\n");
  frag.appendChild(el7);
  var el8 = this["results"] = document.createElement("coral-anchorlist");
  el8.className += " coral3-Shell-help-results";
  el8.setAttribute("handle", "results");
  el8.setAttribute("hidden", "");
  frag.appendChild(el8);
  var el9 = document.createTextNode("\n");
  frag.appendChild(el9);
  var el10 = this["resultMessage"] = document.createElement("div");
  el10.className += " coral3-Shell-help-resultMessage";
  el10.setAttribute("handle", "resultMessage");
  el10.setAttribute("hidden", "");
  frag.appendChild(el10);
  var el11 = document.createTextNode("\n");
  frag.appendChild(el11);
  var el12 = this["loading"] = document.createElement("div");
  el12.className += " coral3-Shell-help-loading";
  el12.setAttribute("handle", "loading");
  el12.setAttribute("hidden", "");
  var el13 = document.createTextNode("\n  ");
  el12.appendChild(el13);
  var el14 = document.createElement("coral-wait");
  el14.setAttribute("size", "S");
  el14.className += " coral3-Shell-help-loading-wait";
  el12.appendChild(el14);
  var el15 = document.createTextNode("\n  ");
  el12.appendChild(el15);
  var el16 = document.createElement("span");
  el16.className += " coral-Heading--2 coral3-Shell-help-loading-info";
  el16.textContent = Coral["i18n"]["get"]('Searching Help…');
  el12.appendChild(el16);
  var el17 = document.createTextNode("\n");
  el12.appendChild(el17);
  frag.appendChild(el12);
  return frag;
});

window["Coral"]["templates"]["Shell"]["helpResult"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = document.createElement("coral-list-item-content");
  var el1 = document.createTextNode(data_0["title"]+"\n");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral3-Shell-help-result-description";
  el2.textContent = data_0["description"];
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  return el0;
});

window["Coral"]["templates"]["Shell"]["helpSearchError"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " coral3-Shell-help-resultMessage-container";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral-Heading--1 coral3-Shell-help-resultMessage-heading";
  el2.textContent = Coral["i18n"]["get"]('Error fetching results');
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  return el0;
});

window["Coral"]["templates"]["Shell"]["noHelpResults"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " coral3-Shell-help-resultMessage-container";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral-Heading--1 coral3-Shell-help-resultMessage-heading";
  el2.textContent = Coral["i18n"]["get"]('No results found');
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Shell.Help */ {
    /**
      @class Coral.Shell.Help
      @classdesc The Shell's help component
      @extends Coral.AnchorList
      @htmltag coral-shell-help
    */
    name: 'Shell.Help',
    tagName: 'coral-shell-help',
    className: 'coral3-BasicList coral3-AnchorList coral3-Shell-help',
    extend: Coral.AnchorList,

    events: {
      'coral-search:clear': '_showItems',
      'coral-search:submit': '_performSearch'
    },

    properties: {
      /**
        The item collection.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Shell.Help#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemTagName: 'coral-shell-help-item',
              itemBaseTagName: 'a',
              container: this._elements.items
            });
          }

          return this._items;
        },
        set: function() {}
      },

      /**
        The search field placeholder.

        @type {String}
        @default ""
        @htmlattribute placeholder
        @memberof Coral.Shell.Help#
      */
      'placeholder': {
        set: function(value) {
          this._elements.search.placeholder = value;
        },
        get: function() {
          return this._elements.search.placeholder;
        }
      }
    },

    /** @private */
    _moveItems: function() {
      var self = this;
      self.id = self.id || Coral.commons.getUID();
      Array.prototype.forEach.call(self.querySelectorAll('#' + self.id + ' > a[is="coral-shell-help-item"]'), function(item) {
        self._elements.items.appendChild(item);
      });
    },

    /** @private */
    _performSearch: function(event) {
      event.stopPropagation();

      // Show loading
      this._elements.items.hidden = true;
      this._elements.loading.hidden = false;
      this._elements.resultMessage.hidden = true;
      this._elements.results.hidden = true;

      // Trigger event
      var searchTerm = this._elements.search.value;
      this.trigger('coral-shell-help:search', {
        value: searchTerm
      });
    },

    /** @private */
    _showItems: function(event) {
      event.stopPropagation();

      // Hide search results
      this._elements.results.hidden = true;

      // Hide loading
      this._elements.loading.hidden = true;

      // Hide no-results
      this._elements.resultMessage.hidden = true;

      // Show items
      this._elements.items.hidden = false;
    },

    /** @ignore */
    _render: function() {
      var fragment = Coral.templates.Shell.help.call(this._elements);

      // Move the stuff into the right place
      this._moveItems();

      this.appendChild(fragment);
    },

    /**
      Indicate to the user that an error has occurred
    */
    showError: function() {
      // Hide loading
      this._elements.loading.hidden = true;

      this._elements.resultMessage.innerHTML = '';

      this._elements.resultMessage.appendChild(Coral.templates.Shell.helpSearchError());

      this._elements.resultMessage.hidden = false;
    },

    /**
      Show a set of search results.

      @param {Array.<Coral.Shell.Help~result>} results
        A set of search result objects.
      @param {Number} total
        The total number of results.
      @param {String} allResultsURL
        The URL at which all results will be displayed.
    */
    showResults: function(results, total, allResultsURL) {
      var self = this;

      // Hide loading
      this._elements.loading.hidden = true;

      if (!results || total === 0) {
        // Clear existing result message
        this._elements.resultMessage.innerHTML = '';
        // Indicate to the user that no results were found
        this._elements.resultMessage.appendChild(Coral.templates.Shell.noHelpResults());
        // Show result message
        this._elements.resultMessage.hidden = false;
      }
      else {
        // Clear existing results
        this._elements.results.innerHTML = '';
         // Populate results
        results.forEach(function(result) {
          // Tweak: make the space between bullets larger with a non-breaking space
          var separator = '&nbsp; &bull; &nbsp;';
          var description = result.tags.join(separator);

          var item = new Coral.AnchorList.Item().set({
            href: result.href,
            target: result.target
          });

          // @todo move to set() above when CUI-4391 fixed
          item.content = Coral.templates.Shell.helpResult({
            title: result.title,
            description: description
          });

          self._elements.results.appendChild(item);
        });

        // Show results
        this._elements.results.hidden = false;

        // Show total
        if (total > 1) {
          var seeAllItem = new Coral.AnchorList.Item().set({
            href: allResultsURL,
            content: {
              innerHTML: Coral.i18n.get('See all {0} results', total)
            },
            target: '_blank'
          });

          seeAllItem.classList.add('coral-Link', 'coral3-Shell-help-allResults');

          this._elements.results.appendChild(seeAllItem);
        }
      }
    }

    /**
      A search result object.

      @typedef {Object} Coral.Shell.Help~result

      @property {String} title
        The title of the search result.
      @property {String} href
        The URL of the search result.
      @property {String} target
        This property specifies where to display the search result. Use this property only if the href property is present.
      @property {Array.<String>} tags
        A set of tags associated with the search result.
    */

    /**
      Triggered when the user submits a search term

      @event Coral.Shell.Help#coral-shell-help:search

      @param {Object} event
        Event object.
      @param {HTMLElement} event.detail.value
        The user-provided input value aka the search-term
    */
  });

  Coral.register( /** @lends Coral.Shell.Help.Item */ {
    /**
      @class Coral.Shell.Help.Item
      @classdesc The Shell's help item component
      @extends Coral.AnchorList.Item
      @htmltag coral-shell-help-item
    */
    name: 'Shell.Help.Item',
    tagName: 'coral-shell-help-item',
    className: 'coral3-BasicList-item coral3-AnchorList-item coral3-Shell-help-item',
    baseTagName: 'a',
    extend: Coral.AnchorList.Item
  });
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Shell"] = window["Coral"]["templates"]["Shell"] || {};
window["Coral"]["templates"]["Shell"]["solutionSwitcher"] = (function anonymous(data_0
/*``*/) {
  var data = data_0;
  var el0 = this["icon"] = document.createElement("coral-icon");
  el0.setAttribute("size", "L");
  el0.setAttribute("handle", "icon");
  el0.className += " coral3-Shell-solution-icon";
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or resolutionion of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  Coral.register( /** @lends Coral.Shell.SolutionSwitcher */ {
    /**
      @class Coral.Shell.SolutionSwitcher
      @classdesc The Shell's solution switcher component
      @extends Coral.Component
      @htmltag coral-shell-solutionswitcher
    */
    name: 'Shell.SolutionSwitcher',
    tagName: 'coral-shell-solutionswitcher',
    className: 'coral3-Shell-solutionSwitcher',

    properties: {
      /**
        The item collection.
        See {@link Coral.Collection} for more details.
        
        @type {Coral.Collection}
        @readonly
        @memberof Coral.Shell.SolutionsSwitcher#
      */
      'items': {
        get: function() {
          // Construct the collection on first request
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemTagName: 'coral-shell-solutions'
            });
          }
      
          return this._items;
        },
        set: function() {}
      }
    },
  
    /** @private */
    _initialize: function() {
      var self = this;
      
      // force dark theme
      self.classList.add('coral--dark');

      // Listen for mutations
      var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];
            // Move non secondary solutions to the container
            if (addedNode.tagName === 'CORAL-SHELL-SOLUTIONS' && !addedNode.hasAttribute('secondary')) {
              self._elements.container.appendChild(addedNode);
            }
          }
        });
      });
  
      observer.observe(self, {
        // Only care about direct children
        childList: true
      });
    },

    /** @ignore */
    _render: function() {
      var container = this._elements.container = document.createElement('div');
      container.className = 'coral3-Shell-solutions-container';
  
      // Move non secondary solutions to the container
      Array.prototype.forEach.call(this.querySelectorAll('coral-shell-solutions:not([secondary])'), function(item) {
        container.appendChild(item);
      });
  
      // Put the container as first child
      this.insertBefore(container, this.firstChild);
    }
  });

  Coral.register( /** @lends Coral.Shell.Solutions */ {
    /**
      @class Coral.Shell.Solutions
      @classdesc The Shell's solution list
      @extends Coral.Component
      @htmltag coral-shell-solutions
    */
    name: 'Shell.Solutions',
    tagName: 'coral-shell-solutions',
    className: 'coral3-Shell-solutions',

    properties: {
      /**
        The item collection.
        See {@link Coral.Collection} for more details.

        @type {Coral.Collection}
        @readonly
        @memberof Coral.Shell.Solutions#
      */
      'items': {
        get: function() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new Coral.Collection({
              host: this,
              itemTagName: 'coral-shell-solution',
              itemBaseTagName: 'a'
            });
          }

          return this._items;
        },
        set: function() {}
      },

      /**
        Whether the solution list is secondary.

        @type {Boolean}
        @default false
        @memberof Coral.Shell.Solutions#
        @instance
      */
      'secondary': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(this._className + '--secondary', this.secondary);
        }
      }
    }
  });

  /**
    @class Coral.Shell.Solutions.Header
    @classdesc The Shell's solution sub-cloud name
    @htmltag coral-shell-solutions-header
    @extends HTMLElement
  */
  Coral.Shell.Solutions.Header = function() {
    return document.createElement('coral-shell-solutions-header');
  };	

  Coral.register( /** @lends Coral.Shell.Solution */ {
    /**
      @class Coral.Shell.Solution
      @classdesc The Shell's solution item
      @extends Coral.Component
      @htmltag coral-shell-solution
    */
    name: 'Shell.Solution',
    tagName: 'coral-shell-solution',
    className: 'coral3-Shell-solution',
    baseTagName: 'a',
    extend: HTMLAnchorElement,

    properties: {
      /**
        Specifies the icon name used inside the button.

        @type {String}
        @default ""
        @htmlattribute icon
        @memberof Coral.Shell.Solution#

        @see {@link Coral.Icon}
      */
      'icon': {
        set: function(value) {
          this._elements.icon.icon = value;
        },
        get: function() {
          return this._elements.icon.icon;
        }
      },

      /**
        The solution's label content zone.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.Solution#
      */
      'label': Coral.property.contentZone({
        handle: 'label',
        tagName: 'coral-shell-solution-label',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        Whether a solution is linked or not

        @type {Boolean}
        @default false
        @htmlattributereflected
        @memberof Coral.Shell.Solution#
      */
      'linked': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle(this._className + '--linked', this.linked);
        }
      }
    },

    /** @ignore */
    _render: function() {
      var fragment = document.createDocumentFragment();

      fragment.appendChild(Coral.templates.Shell.solutionSwitcher.call(this._elements));

      var label = this._elements.label = this.querySelector('coral-shell-solution-label') ||
        document.createElement('coral-shell-solution-label');
      fragment.appendChild(this._elements.label);

      // Move any remaining elements into the content sub-component
      while (this.firstChild) {
        // @todo this copies line break text nodes, which is ugly
        label.appendChild(this.firstChild);
      }

      this.appendChild(fragment);
    }
  });
  
  /**
    @class Coral.Shell.Solution.Label
    @classdesc The Shell Solution label
    @htmltag coral-shell-solution-label
    @extends HTMLElement
  */
  Coral.Shell.Solution.Label = function() {
    return document.createElement('coral-shell-solution-label');
  };
}());

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Shell"] = window["Coral"]["templates"]["Shell"] || {};
window["Coral"]["templates"]["Shell"]["user"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = this["container"] = document.createElement("div");
  el0.className += " coral3-Shell-user-container";
  el0.setAttribute("handle", "container");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["image"] = document.createElement("div");
  el2.className += " coral3-Shell-user-image";
  el2.setAttribute("handle", "image");
  var el3 = document.createTextNode("\n    ");
  el2.appendChild(el3);
  var el4 = this["avatar"] = document.createElement("coral-icon");
  el4.className += " coral3-Shell-user-avatar";
  el4.setAttribute("size", "L");
  el4.setAttribute("handle", "avatar");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el2.appendChild(el5);
  el0.appendChild(el2);
  var el6 = document.createTextNode("\n");
  el0.appendChild(el6);
  return el0;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function() {
  'use strict';

  // Make sure the namespace exists
  Coral.Shell = Coral.Shell || {};

  /**
    Avatar assets should use one of those provided, when no asset is set

    @enum {String}
    @memberof Coral.Shell.User#
  */
  var avatar = {
    /** Default avatar, show user icon from icon font. */
    DEFAULT: 'user'
  };

  Coral.register( /** @lends Coral.Shell.User */ {
    /**
      @class Coral.Shell.User
      @classdesc The Shell's user component
      @extends Coral.Component
      @htmltag coral-shell-user
    */
    name: 'Shell.User',
    tagName: 'coral-shell-user',
    className: 'coral3-Shell-user',

    properties: {
      /**
        Specifies the asset used inside the avatar view.
        See {@link Coral.Icon} for valid usage and icon names.

        @type {String}
        @default user (Shows a placeholder user icon from the icon font)
        @memberof Coral.Shell.User#
        @htmlattribute avatar

        @see {@link Coral.Icon}
      */
      'avatar': {
        default: avatar.DEFAULT,
        sync: function() {
          // sets the desired asset
          this._elements.avatar.icon = this._avatar;
        }
      },

      /**
        The name content zone of the user-menu.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.User#
      */
      'name': Coral.property.contentZone({
        handle: 'name',
        tagName: 'coral-shell-user-name',
        insert: function(content) {
          this._elements.container.appendChild(content);
        }
      }),

      /**
        The heading content zone of the user-menu.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.User#
      */
      'heading': Coral.property.contentZone({
        handle: 'heading',
        tagName: 'coral-shell-user-heading',
        insert: function(content) {
          this._elements.container.appendChild(content);
        }
      }),

      /**
        The subheading content zone of the user-menu.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.User#
      */
      'subheading': Coral.property.contentZone({
        handle: 'subheading',
        tagName: 'coral-shell-user-subheading',
        insert: function(content) {
          this._elements.container.appendChild(content);
        }
      }),

      /**
        The main content zone of the user-menu.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.User#
      */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'coral-shell-user-content',
        defaultContentZone: true,
        insert: function(content) {
          this.appendChild(content);
        }
      }),

      /**
        The footer content zone of the user-menu.

        @type {HTMLElement}
        @contentzone
        @memberof Coral.Shell.User#
      */
      'footer': Coral.property.contentZone({
        handle: 'footer',
        tagName: 'coral-shell-user-footer',
        insert: function(content) {
          this.appendChild(content);
        }
      })
    },

    /** @ignore */
    _render: function() {
      var fragment = document.createDocumentFragment();
      fragment.appendChild(Coral.templates.Shell.user.call(this._elements));

      var name = this._elements.name = this.querySelector('coral-shell-user-name') ||
        document.createElement('coral-shell-user-name');
      this._elements.container.appendChild(name);

      var heading = this._elements.heading = this.querySelector('coral-shell-user-heading') ||
        document.createElement('coral-shell-user-heading');
      this._elements.container.appendChild(heading);

      var subheading = this._elements.subheading = this.querySelector('coral-shell-user-subheading') ||
        document.createElement('coral-shell-user-subheading');
      this._elements.container.appendChild(subheading);

      var content = this._elements.content = this.querySelector('coral-shell-user-content') ||
        document.createElement('coral-shell-user-content');
      fragment.appendChild(content);

      var footer = this._elements.footer = this.querySelector('coral-shell-user-footer') ||
        document.createElement('coral-shell-user-footer');
      fragment.appendChild(footer);

      this.appendChild(fragment);
    }
  });
  
  /**
    @class Coral.Shell.User.Name
    @classdesc The Shell User name
    @htmltag coral-shell-user-name
    @extends HTMLElement
  */
  Coral.Shell.User.Name = function() {
    return document.createElement('coral-shell-user-name');
  };
  
  /**
    @class Coral.Shell.User.Heading
    @classdesc The Shell User heading
    @htmltag coral-shell-user-heading
    @extends HTMLElement
  */
  Coral.Shell.User.Heading = function() {
    return document.createElement('coral-shell-user-heading');
  };
  
  /**
    @class Coral.Shell.User.Subheading
    @classdesc The Shell User subheading
    @htmltag coral-shell-user-subheading
    @extends HTMLElement
  */
  Coral.Shell.User.Subheading = function() {
    return document.createElement('coral-shell-user-subheading');
  };
  
  /**
    @class Coral.Shell.User.Content
    @classdesc The Shell User content
    @htmltag coral-shell-user-content
    @extends HTMLElement
  */
  Coral.Shell.User.Content = function() {
    return document.createElement('coral-shell-user-content');
  };
  
  /**
    @class Coral.Shell.User.Footer
    @classdesc The Shell User footer
    @htmltag coral-shell-user-footer
    @extends HTMLElement
  */
  Coral.Shell.User.Footer = function() {
    return document.createElement('coral-shell-user-footer');
  };

  // exports the avator enumeration
  Coral.Shell.User.avatar = avatar;
}());

(function($) {
  var uuid = 0;

  CUI.Popover = new Class(/** @lends CUI.Popover# */{
    toString: 'Popover',
    extend: CUI.Widget,
    /**
     @extends CUI.Widget
     @classdesc A box which points at an element or point.

     @desc Creates a new popover
     @constructs

     @param {Object} options                               Component options
     @param {Object} options.pointAt                       The element or coordinate to which the popover should point.
     A coordinate should be provided as an array where the first
     item is the X coordinate and the second item is a Y
     coordinate. The coordinate should be in the document
     coordinate space.
     @param {String} [options.content]                     Content of the popover (HTML).
     @param {String} [options.pointFrom=bottom]            The side of the target element or coordinate the popover
     @param {Object} [options.within=window]               Popover collision detection container
     should be pointing from. Possible values include
     <code>top</code>, <code>right</code>, <code>bottom</code>,
     or <code>left</code>.
     @param {boolean} [options.preventAutoHide=false]      When set to <code>false</code>, the popover will close when
     the user clicks outside the popover. When set to
     <code>true</code>, the popover will only close when the
     target element is clicked or <code>hide()</code> is
     manually called.
     @param {String} [options.alignFrom=left]              When set to left, the popover will be anchored to the left
     side of its offset parent (in other words, it will use the
     <code>left</code> CSS property). When set to right, the
     popover will be anchored to the right side of its offset
     parent (in other words, it will use the <code>right</code>
     CSS property). When the element the popover is pointing at
     is right-aligned, it can be useful to set the value to
     <code>right</code> so the popover will appear to stay
     attached to the element when the user resizes the window
     horizontally.

     */
    construct: function(options) {

      // listens to configuration changes
      this.$element.on('change:content', this._setContent.bind(this));
      this.$element.on('change:pointAt', this._position.bind(this));
      this.$element.on('change:pointFrom', this._position.bind(this));
      this.$element.on('change:alignFrom', this._position.bind(this));

      // main class of the component
      this.$element.addClass('coral-Popover');

      // checks if the content element exists
      if (this._getContentElement(this.$element).length === 0) {
        this._wrapContent(this.$element);
      }

      // gets the content element
      this._$content = this._getContentElement(this.$element);

      // adds the content if the current is blank.
      if(this._$content.html() === '') {
        this._setContent();
      }

      this._popoverOffsets();

      this.uuid = (uuid += 1);
      this.popoverId = this.$element.attr('id');

      this._makeAccessible();
    },

    defaults: {
      pointFrom: 'bottom',
      preventAutoHide: false,
      alignFrom: 'left',
      visible: false
    },

    _directions: [
      'top',
      'bottom',
      'right',
      'left'
    ],

    /**
     * Creates an object that contains the offsets of the popover on every direction.
     *
     * @private
     */
    _popoverOffsets: function() {

      this._popoverOffsets = {};

      // Cache the tail dimensions when the popover is on the left or right of the target.
      this._popoverOffsets.leftRight = {
        width: 5,
        height: 5
      };

      // While it's possible that the dimensions are different depending on whether it's left/right vs top/bottom,
      // it likely (and is currently) just a rotated version of the arrow. To reduce the cost of measuring, we'll
      // just invert the dimensions until more complex tails are introduced.
      this._popoverOffsets.topBottom = {
        width: 5,
        height: 5
      };
    },

    /**
     * Wrapps the content of the popover inside a
     * coral-Popover-content class.
     *
     * @ignore
     */
    _wrapContent: function(el) {
      el.wrapInner('<div class="coral-Popover-content"/>');
    },
    /** @ignore */
    _getContentElement: function(el) {
      return el.find('> .coral-Popover-content');
    },

    /**
     * Positions the popover (if visible). Leverages [jQueryUI's Position utility]{@link http://jqueryui.com/position}.
     *
     * @private
     */
    _position: function() {
      // Let's not use the cycles to position if the popover is not visible. When show() is called, the element will
      // run through positioning again.
      if (!this.options.visible || !this.options.pointAt) {
        return;
      }

      var $popover = this.$element,
        target = this.options.pointAt,
        pointFrom = this.options.pointFrom,
        tailDimensions = this._popoverOffsets,
        instructions;

      if ($.isArray(target)) {
        if (target.length !== 2) {
          return;
        }
        target = this._convertCoordsToEvent(target);
      }

      // Using the 'flip' collision option, jQueryUI's positioning logic will flip the position of the popover to
      // whichever side will expose most of the popover within the window viewport. However, this can sometimes place
      // the popover so that it is cropped by the top or left of the document. While it's great that the user would
      // be able to initially see more of the popover than if it had been placed in the opposite position, the user
      // would not be able to even scroll to see the cropped portion. We would rather show less of the popover and
      // still allow the user to scroll to see the rest of the popover. Here we detect if such cropping is taking
      // place and, if so, we re-run the positioning algorithm while forcing the position to the bottom or right
      // directions.
      // Fixes https://issues.adobe.com/browse/CUI-794
      var validateFinalPosition = function(position, feedback) {
        var offsetParentOffset = $popover.offsetParent().offset(),
          forcePointFrom;

        if ((pointFrom == 'top' || pointFrom == 'bottom') && offsetParentOffset.top + position.top < 0) {
          forcePointFrom = 'bottom';
        } else if ((pointFrom == 'left' || pointFrom == 'right') && offsetParentOffset.left + position.left < 0) {
          forcePointFrom = 'right';
        }

        if (forcePointFrom) {
          instructions = this._instructionFactory[forcePointFrom]({
            target: target,
            tailDimensions: tailDimensions,
            allowFlip: false,
            callback: this._applyFinalPosition.bind(this),
            within: this.options.within || window
          });
          $popover.position(instructions);
        } else {
          this._applyFinalPosition(position, feedback);
        }
      }.bind(this);

      instructions = this._instructionFactory[pointFrom]({
        target: target,
        tailDimensions: tailDimensions,
        allowFlip: true,
        callback: validateFinalPosition,
        within: this.options.within || window
      });

      $popover.position(instructions);
    },

    /**
     * Converts an array containing a coordinate into an event (needed for jQueryUI's Position utility)..
     * @param {Array} pointAt An array where the first item is the x coordinate and the second item is the y coordinate.
     * @returns {Object} A jquery event object with the pageX and pageY properties set.
     * @private
     */
    _convertCoordsToEvent: function(pointAt) {
      // If target is an array, it should contain x and y coords for absolute positioning.
      // Transform coords for jQueryUI Position which requires an event object with pageX and pageY.
      var event = $.Event();
      event.pageX = pointAt[0];
      event.pageY = pointAt[1];
      return event;
    },

    /**
     * Applies the final position to the popover (both bubble and tail).
     * @param position The position to be applied to the bubble.
     * @param feedback Additional information useful for positioning the tail.
     * @private
     */
    _applyFinalPosition: function(position, feedback) {
      var css = {
        top: position.top
      };

      if (this.options.alignFrom === 'right') {
        // Convert the "left" position to a "right" position.

        var offsetParent = this.$element.offsetParent();
        var offsetParentWidth;

        // If the offset parent is the root HTML element, we need to do some finagling. We really need to get the width
        // of the viewpane minus the scrollbar width since the "right" position will be relative to the left of the
        // scrollbar. We do this by getting the outerWidth(true) of body (so it includes any margin, border, and padding).
        if (offsetParent.prop('tagName').toLowerCase() == 'html') {
          offsetParent = $('body');
          offsetParentWidth = offsetParent.outerWidth(true);
        } else {
          offsetParentWidth = offsetParent.innerWidth();
        }

        css.left = 'auto';
        css.right = offsetParentWidth - position.left - this.$element.outerWidth(true);
      } else {
        css.left = position.left;
        css.right = 'auto';
      }

      this.$element.css(css);
    },

    /**
     * Factory for creating instruction objects to be used by jQuery's Position utility.
     * @private
     */
    _instructionFactory: {
      top: function(options) {
        return {
          my: 'left bottom-' + options.tailDimensions.topBottom.height,
          at: 'left top',
          of: options.target,
          collision: 'flipfit ' + (options.allowFlip ? 'flip' : 'none'),
          using: options.callback,
          within: options.within
        };
      },
      right: function(options) {
        return {
          my: 'left+' + options.tailDimensions.leftRight.width + ' top',
          at: 'right top',
          of: options.target,
          collision: (options.allowFlip ? 'flipfit' : 'none') + ' flipfit',
          using: options.callback,
          within: options.within
        };
      },
      bottom: function(options) {
        return {
          my: 'left top+' + options.tailDimensions.topBottom.height,
          at: 'left bottom',
          of: options.target,
          collision: 'flipfit ' + (options.allowFlip ? 'flip' : 'none'),
          using: options.callback,
          within: options.within
        };
      },
      left: function(options) {
        return {
          my: 'right-' + options.tailDimensions.leftRight.width + ' top',
          at: 'left top',
          of: options.target,
          collision: (options.allowFlip ? 'flipfit' : 'none') + ' flipfit',
          using: options.callback,
          within: options.within
        };
      }
    },

    /** @ignore */
    _show: function() {
      var self = this,
          $focusable = $(this._lastFocused),
          $contentElements;
      this.$element.show().attr('aria-hidden', false);

      if (!this.$element.find(':focusable').length && this.$element.is(':not([aria-labelledby]):not([aria-label])')) {
        $contentElements = this._getContentElement(this.$element);
        this.$element.attr('aria-labelledby', $contentElements.first().attr('id'));
      }

      this._position();
      this._previousFocus = $(document.activeElement); //save previously focused element

      // as a way to indicate a link between the popover and its activator we add .is-selected. per SUIT, components
      // can simply override this and define their own behavior
      if (this._previousFocus.length !== 0) {
        // we check if the class was already there, to keep the state as we found it
        this._restoreClass = this._previousFocus.hasClass('is-selected');
        this._previousFocus.addClass('is-selected');
      }

      if (!this.options.preventAutoHide) {
        clearTimeout(this.autoHideInitTimeout);
        this.autoHideInitTimeout = setTimeout(function() {
          // Must watch touchstart because click events don't bubble as expected on iOS Safari.
          $(document).on('touchstart.popover-hide-' + self.uuid, self._clickOutsideHandler.bind(self));
          $(document).on('click.popover-hide-' + self.uuid, self._clickOutsideHandler.bind(self));
          self._moveLastEventToFrontOfQueue(document, 'touchstart');
          self._moveLastEventToFrontOfQueue(document, 'click');
        }, 0);
      }
      if($focusable.length){
        $focusable.focus();
      } else {
        $focusable = this.$element.find(':tabbable').first();
        if ($focusable.length) {
          $focusable.focus();
        } else {
          this.$element.focus();
        }
      }
      $(document).on('keydown.popover-'+this.uuid, this._keyDown.bind(this));
      this._moveLastEventToFrontOfQueue(document, 'keydown');

      // keyboard handling
      this.$element
        .on('keydown.popover-focusLoop', ':focusable', this._tabKeyHandler.bind(this))
        // Adds is-focused class so that if more than one Popover is displayed,
        // the Popover with focus will remain on top in the z-index order.
        .on('focusin.popover', this._focusInHandler.bind(this))
        .on('focusout.popover', this._focusOutHandler.bind(this));
    },

    /**
     * Swaps order of execution of popover event listeners. With more than
     * one popover open, we need to make sure that the last
     * popover closes before any preceding popovers.
     *
     * @param {HTMLElement} element   The element target to capture the event.
     * @param {String} eventName   The event name.
     * @ignore
     */
    _moveLastEventToFrontOfQueue: function(element, eventName) {
      var eventList = $._data($(element)[0], 'events'),
          keydownEvents = eventList[eventName],
          popoverIndexes = [];
      keydownEvents.forEach(function(e, index) {
        if (e.namespace.indexOf('popover-') === 0) {
          popoverIndexes.push(index);
        }
      });
      if (popoverIndexes.length > 1) {
        keydownEvents.splice(popoverIndexes[0], 0, keydownEvents.pop());
      }
    },

    /** @ignore */
    _hide: function() {
      // remove escape handler
      $(document).off('keydown.popover-' + this.uuid);
      clearTimeout(this.autoHideInitTimeout);
      this._unforceBlur();
      this.$element.hide().attr('aria-hidden', true);
      $(document).off('.popover-hide-' + this.uuid);

      // we remove the .is-selected class, just like in the show() method
      if (this._previousFocus.length !== 0) {
        // if the class was already there before the popover added it, then we leave it
        this._previousFocus.toggleClass('is-selected', this._restoreClass);
      }

      this._lastFocused = null;

      // keyboard handling
      this.$element
        .off('keydown.popover-focusLoop, focusin.popover, focusout.popover');
    },

    /** @ignore */
    _setContent: function() {
      if (typeof this.options.content !== 'string') return;

      // adds the content
      this._$content.html(this.options.content);

      this._position();
    },

    /**
     * Deprecated.
     * @param position
     * @deprecated Please use set('pointAt', [x, y]) instead.
     */
    setPosition: function(position) {
      this.set('pointAt', position);
    },

    /**
     keydown event handler
     @private
     */
    _keyDown: function(event) {
      switch(event.which) {
        case 27: // Esc
          this._escapeKeyHandler(event);
          break;
        case 117: // F6
          this._gotoTriggerHandler(event);
          break;
      }
    },

    /**
     handler to close the dialog on escape key
     @private
     */
    _escapeKeyHandler: function(event) {
      if ($(document.activeElement).is(this.$element) || $(document.activeElement).closest(this.$element).length) {
        this._previousFocus.focus();
      }
      this.hide();
      event.preventDefault();
      event.stopImmediatePropagation();
    },

    /**
     handler to close the popover on click outside
     @private
     */
    _clickOutsideHandler: function(event) {
      var $target = $(event.target);
      if ($target.closest('.coral-Popover').length === 0 && $target.closest('body').length > 0) {
        if ($(document.activeElement).is(document.body)) {
          this._previousFocus.focus();
        }
        this.hide();
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    },

    /**
     handler to shift focus between the dialog and the main document
     @private
     */
    _gotoTriggerHandler: function(event) {
      if ($(document.activeElement).is(this.$element) || $(document.activeElement).closest(this.$element).length) {
        this._previousFocus.focus();
        this._forceBlur();
      } else {
        this._unforceBlur();
        if (!this._lastFocused) {
          this.$element.find(':focusable').addBack().first().focus();
        } else {
          this._lastFocused.focus();
        }
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    },

    /**
     Handle tab key to manage focus loop within the Popover.
     @private
     */
    _tabKeyHandler: function(event) {
      // enables keyboard support
      var elem = $(event.currentTarget),
        tabbables = this.$element.find(':tabbable'),
        focusElem;

      switch (event.which) {
        case 9: //tab
          if (event.shiftKey && event.currentTarget === tabbables[0]) {
            // in case it is the first one, we switch to the last one
            focusElem = tabbables.last();
          } else if (!event.shiftKey && event.currentTarget === tabbables[tabbables.length - 1]) {
            // in case it is the last one, we switch to the first one
            focusElem = tabbables.first();
          }
          break;
      }

      if (focusElem && focusElem.length) { // if a key matched then we set the currently focused element
        event.preventDefault();
        focusElem.focus();
      }
      this._lastFocused = document.activeElement;
    },

    /**
      Timeout id used to test the focus.

      @private
    */
    _focusTimeoutInt: -1,

    /**
      Adds is-focused class so that if more than one Popover is displayed,
      the Popover with focus will remain on top in the z-index order.
      @private
      */
    _focusInHandler: function(event) {
      clearTimeout(this._focusTimeoutInt);
      $(event.currentTarget).addClass('is-focused');
    },

    /**
      Removes is-focused class so that if more than one Popover is displayed,
      the Popover without focus will go back to its original position in the z-order.
      @private
      */
    _focusOutHandler: function (event) {
      var $currentTarget = $(event.currentTarget),
          self = this;
      clearTimeout(this._focusTimeoutInt);
      this._focusTimeoutInt =  setTimeout(function() {
        $currentTarget.removeClass('is-focused');
        if (!self.options.preventAutoHide &&
          self.$element.get(0).contains(event.target) &&
          $(document.activeElement).closest(self.$element).length === 0 &&
          self.$element.closest('.coral-Popover').length > 1) {
          self.hide();
        }
      }, 50);
    },

    /** @private */
    _forcedBlur: false,

    /**
      Removes Popover from document focus loop and hides it from screen readers.
      @private
      */
    _forceBlur: function() {
      if (this._forcedBlur) {
        return;
      }
      this._forcedBlur = true;

      var $focusables = this.$element.find(':focusable').addBack();
      // for each focusable element including the $element,
      $focusables.each(function(i, focusable) {
        var $focusable = $(focusable);
        // cache any existing tabindex value.
        if ($focusable.data('cached-tabindex') === undefined) {
          $focusable.data('cached-tabindex', $focusable.attr('tabindex'));
        }
        // set the tabindex to -1, so that the focusable is not included in the document tab order.
        $focusable.attr('tabindex', -1);
      });
      // hide the Popover from assistive technology and add a focusin handler.
      this.$element.attr('aria-hidden', true).on('focusin.popover-' + this.uuid, this._unforceBlur.bind(this));
    },

    /**
      Restore focus from the document to the Popover focus loop.
      @private
      */
    _unforceBlur:  function() {
      if (!this._forcedBlur) {
        return;
      }
      this._forcedBlur = false;

      var $focusables = this.$element.find(':focusable').addBack();
      // for each focusable element including the $element,
      $focusables.each(function(i, focusable) {
        var $focusable = $(focusable);
        // restore the tabindex from the cached data value.
        if ($focusable.data('cached-tabindex') === undefined) {
          $focusable.removeAttr('tabindex');
        } else {
          $focusable.attr('tabindex', $focusable.data('cached-tabindex')).removeData('cached-tabindex');
        }
      });
      // reveal the Popover to assistive technology and remove the focusin handler.
      this.$element.attr('aria-hidden', false).off('focusin.popover-' + this.uuid);
    },

    _makeAccessible: function() {
      var $contentElements = this._getContentElement(this.$element);

      // the element has the role dialog
      this.$element.attr({
        'role': 'dialog',
        'tabindex': '-1'
      });

      $contentElements
        .attr('role', $contentElements.length > 1 ? 'group' : null)
        .not('[id]').each(function(i, contentElement) {
          contentElement.setAttribute('id', CUI.util.getNextId());
        });
    }
  });

  CUI.Widget.registry.register("popover", CUI.Popover);

  $(function() {
    // Must watch touchstart because click events don't bubble as expected on iOS Safari.
    $(document).on('touchstart.popover.data-api click.popover.data-api', '[data-toggle="popover"]',function(event) {
      var $trigger = $(this),
        $target = CUI.util.getDataTarget($trigger);

      // if data target is not defined try to find the popover as a sibling
      $target = $target && $target.length > 0 ? $target : $trigger.next('.coral-Popover');

      var popover = $target.popover($.extend({pointAt: $trigger}, $target.data(), $trigger.data())).data('popover');
      popover.toggleVisibility();
      event.preventDefault();
    });
  });
}(window.jQuery));

(function ($, window, undefined) {
  CUI.SelectList = new Class(/** @lends CUI.SelectList# */{
    toString: 'SelectList',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc A select list for drop down widgets. This widget is intended to be used by other widgets.
     *
     * @description Creates a new select list
     * @constructs
     *
     * @param  {Object} options Component options
     * @param  {Mixed} options.element jQuery selector or DOM element to use for panel
     * @param  {String} [options.type=static] static or dynamic list
     * @param  {Boolean} [options.multiple=false] multiple selection or not
     * @param  {Object} options.relatedElement DOM element to position at
     * @param  {Boolean} [options.autofocus=true] automatically sets the
     * caret to the first item in the list
     * @param  {Boolean} [options.autohide=true] automatically closes the
     * list when clicking the toggle button or clicking outside of the list
     * @param  {String} [options.dataurl] URL to receive values dynamically
     * @param  {String} [options.dataurlformat=html] format of the dynamic data load
     * @param  {Object} [options.dataadditional] additonal data to be sent with a remote loading request
     * @param  {Function} [options.loadData] function to be called if more data is needed. The function should return a $.Promise, which will be done, when all requested items where added to the list. This must not be used with a set dataurl.
     * @param {String} [options.collisionAdjustment] the collision option to be passed to jquery.ui.position. Use "none" to omit flipping.
     *
     *
     */
    construct: function (options) {
      this.applyOptions();

      this.$element
        .on('change:type', this._setType.bind(this))
        .on('click', this._SELECTABLE_SELECTOR, this._triggerSelected.bind(this))
        .on('mouseenter', this._SELECTABLE_SELECTOR, this._handleMouseEnter.bind(this));

      // accessibility
      this._makeAccessible();
    },

    defaults: {
      type: 'static', // static or dynamic
      multiple: false,
      relatedElement: null,
      autofocus: true, // autofocus on show
      autohide: true,
      dataurl: null,
      dataurlformat: 'html',
      datapaging: true,
      datapagesize: 10,
      dataadditional: null,
      loadData: $.noop, // function to receive more data
      position: 'center bottom-1',  // -1 to override the border,
      collisionAdjustment: ''
    },

    /**
     * Retrieve list of first level list items (groups or options). NB: The list
     * represents a snapshot of the current state. If items are added or
     * removed, the list will become invalid.
     *
     * @return {Array} List of CUI.SelectList.Option and CUI.SelectList.Group
     *                 instances
     */
    getItems: function () {
      return this.$element.children(".coral-SelectList-item").toArray().map(function (element) {
        var $element = $(element);
        if ($element.is(".coral-SelectList-item--option")) {
          return new CUI.SelectList.Option({element : $element});
        }
        else if ($element.is(".coral-SelectList-item--optgroup")) {
          return new CUI.SelectList.Group({element : $element});
        }
      });
    },

    /**
     * Get CUI.SelectList.Option representing the option at the given position.
     *
     * @returns option
     * @throws {TypeError} if position is not numeric or if position points to
     *         group element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getOption : function (position) {
      if (!$.isNumeric(position)) {
        throw new TypeError("Position should be numeric");
      }

      var items = this.$element.children(".coral-SelectList-item"),
          element = items.eq(position);

      if (position < 0 || element.length === 0) {
        throw new RangeError("Position >" + position + "< is not within expected range [0," + (items.length - 1) + "]");
      }

      if (!element.is(".coral-SelectList-item--option")) {
        throw new TypeError("Position does not point to option element");
      }

      return new CUI.SelectList.Option({element: element});
    },

    /**
     * Get CUI.SelectList.Group representing the group at the given position.
     *
     * @returns group
     * @throws {TypeError} if position is not numeric or if position points to
     *         option element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getGroup : function (position) {
      if (!$.isNumeric(position)) {
        throw new TypeError("Position should be numeric");
      }

      var items = this.$element.children(".coral-SelectList-item"),
          element = items.eq(position);

      if (position < 0 || element.length === 0) {
        throw new RangeError("Position >" + position + "< is not within expected range [0," + (items.length - 1) + "]");
      }

      if (!element.is(".coral-SelectList-item--optgroup")) {
        throw new TypeError("Position does not point to group element");
      }

      return new CUI.SelectList.Group({element: element});
    },

    /**
     * Adds option at the given position. If position is undefined, the option
     * is added at the end of the list.
     *
     * @param {Object|CUI.SelectList.Option|Element|jQuery|Array} option that
     *        should be added. If type is Object, the keys `value` and `display`
     *        are used to create the option. If type is CUI.SelectList.Option,
     *        the underlying element is added to the list. If type is Element,
     *        the node is added to the list. If type is jQuery <b>all</b>
     *        elements within the collection are added to the list. If type is
     *        Array, then the array is expected to contain one of the other
     *        types.
     * @param {Number} Position at which the element should be inserted. If
     *        undefined, the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addOption : function (optionDescription, position) {
      var item, element, i;

      if ($.isArray(optionDescription) || (optionDescription && optionDescription.jquery)) {
        for (i = 0; i < optionDescription.length; i++) {
          this.addOption(optionDescription[i], position !== undefined ? position + i : undefined);
        }
        return;
      }
      else if (optionDescription && optionDescription.$element) {
        this.addOption(optionDescription.$element);
        return;
      }
      else if ($.isPlainObject(optionDescription)) {
        item = optionDescription;
      }
      else if (optionDescription instanceof Element) {
        element = $(optionDescription);
        item = {
          value: element.data("value"),
          display: element.text()
        };
      }
      else {
        throw new TypeError("Only Object, Element, CUI.SelectList.Option, jQuery and Array type arguments allowed.");
      }

      if (!element) {
        element = $("<li>", {
          "class": "coral-SelectList-item coral-SelectList-item--option",
          "data-value": item.value
        }).text(item.display);
      }

      this._addItem(element, position);
      this.$element.trigger($.Event("itemadded", {item: new CUI.SelectList.Option({element: element})}));
    },

    /**
     * Adds option group at the given position. If position is undefined, the group
     * is added to the end of the list.
     *
     * @param {String|CUI.SelectList.Group|Element|jQuery|Array} group that
     *        should be added. If type is String, it is used as display value.
     *        If type is CUI.SelectList.Group, the underlying element is added
     *        to the list. If type is Element, the node is added to the list.
     *        If type is jQuery <b>all</b> element within the collection are
     *        added to the list. If type is Array, then the array is expected to
     *        contain one of the other types.
     * @param {Number} Position at which the element should be inserted. If
     *        undefined, the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addGroup : function (groupDescription, position) {
      var item, element, i;

      if ($.isArray(groupDescription) || (groupDescription && groupDescription.jquery)) {
        for (i = 0; i < groupDescription.length; i++) {
          this.addGroup(groupDescription[i], position !== undefined ? position + i : undefined);
        }
        return;
      }
      else if (groupDescription && groupDescription.$element) {
        this.addGroup(groupDescription.$element);
        return;
      }
      else if ($.type(groupDescription) === "string") {
        item = {
          display: groupDescription
        };
      }
      else if (groupDescription instanceof Element) {
        element = $(groupDescription);
        item = {
          display: element.children(".coral-SelectList-groupHeader").text()
        };
      }
      else {
        throw new TypeError("Only String, Element, CUI.SelectList.Group, jQuery and Array type arguments allowed.");
      }

      if (!element) {
        element = $("<li>", {"class": "coral-SelectList-item coral-SelectList-item--optgroup"});
      }
      if (element.find(".coral-SelectList-groupHeader").length === 0) {
        element.prepend($("<span>", {"class": "coral-SelectList-groupHeader"}).text(item.display));
      }
      if (element.find(".coral-SelectList-sublist").length === 0) {
        element.append($("<ul>", {"class": "coral-SelectList-sublist"}));
      }

      this._addItem(element, position);
      this.$element.trigger($.Event("itemadded", {item: new CUI.SelectList.Group({element: element})}));
    },

    /**
     * @private
     */
    _addItem : function (element, position) {
      this._makeAccessibleListOption(element);

      var list = this._getList(),
          items = this._getItems();


      if (position === undefined || position === items.length) {
        list.append(element);
        return items.length;
      }

      if (position === 0) {
        list.prepend(element);
        return 0;
      }

      var ref = items.eq(position);

      if (position > 0 && ref.length) {
        ref.before(element);
        return position;
      }

      throw new RangeError("Position " + position + " is not within " +
                           "accepted range [0..." + items.length + "].");
    },

    /**
     * @private
     */
    _getList : function () {
      return this.$element;
    },

    /**
     * @private
     */
    _getItems : function () {
      return this._getList().children(".coral-SelectList-item");
    },

    /**
     * Selector used to find selectable items.
     * @private
     */
    _SELECTABLE_SELECTOR: '.coral-SelectList-item--option:not(.is-disabled):not(.is-hidden)',

    applyOptions: function () {
      this._setType();
    },

    /**
     * @private
     */
    _setType: function () {
      var self = this,
        timeout;

      function timeoutLoadFunc() {
        var elem = self.$element.get(0),
          scrollHeight = elem.scrollHeight,
          scrollTop = elem.scrollTop;

        if ((scrollHeight - self.$element.height()) <= (scrollTop + 30)) {
          self._handleLoadData();
        }
      }

      // we have a dynamic list of values
      if (this.options.type === 'dynamic') {

        this.$element.on('scroll.cui-selectlist-dynamic-load', function (event) {
          // debounce
          if (timeout) {
            clearTimeout(timeout);
          }

          if (self._loadingComplete || this._loadingIsActive) {
            return;
          }

          timeout = setTimeout(timeoutLoadFunc, 500);
        });
      } else { // static
        this.$element.off('scroll.cui-selectlist-dynamic-load');
      }
    },

    /**
     * The element that "owns" this SelectList element for accessibility purposes.
     * It should be an element that has an aria-owns attribute containing the id of this.$element,
     * if such an element doesn't exist, the _ownerElement will be the same as the _relatedElement.
     * @private
     */
    _ownerElement: null,

    /**
     * adds some accessibility attributes and features
     * http://www.w3.org/WAI/PF/aria/roles#listbox
     * @private
     */
    _makeAccessible: function () {
      var self = this,
          $relatedElement = $(this.options.relatedElement),
          isVisible = this.$element.hasClass('is-visible');

      this._ownerElement = $('[aria-owns*="' + this.$element.attr('id') + '"]');

      if ($relatedElement.length) {
        if (!this._ownerElement.length) {
          this._ownerElement = $relatedElement;
        }
      }

      this._ownerElement.attr({
        'id': this._ownerElement.attr('id') || CUI.util.getNextId(),
        'aria-haspopup': true,
        'aria-expanded': isVisible
      });

      $relatedElement.not(this._ownerElement).removeAttr('aria-haspopup').removeAttr('aria-expanded');

      this.$element.attr({
        'role': 'listbox',
        'aria-hidden': !isVisible,
        'aria-multiselectable': this.options.multiple || null,
        'tabindex': -1
      });

      if (isVisible) {
          this.$element.attr('tabindex', 0);
          this.$element.not('.is-inline').addClass('is-inline');
      }

      this.$element
          .off('focusin.cui-selectlist focusout.cui-selectlist')
          .on('focusin.cui-selectlist', this._handleFocusIn.bind(this))
          .on('focusout.cui-selectlist', this._handleFocusOut.bind(this));

      this._makeAccessibleListOption(this.$element.children());
    },

    /**
     * Determine if the SelectList has focus.
     * @private
     */
    _hasFocus: function () {
      return this._ownerElement.is(document.activeElement) || $(document.activeElement).closest(this.$element).length === 1;
    },

    /**
     * Handles focusin events for accessibility purposes.
     * @param event The focusin event.
     * @private
     */
    _handleFocusIn: function (event) {
      var currentFocusEntry = this.$element.find(this._SELECTABLE_SELECTOR+'[aria-selected="true"], ' + this._SELECTABLE_SELECTOR+'[tabindex="0"], '+ this._SELECTABLE_SELECTOR+'.is-highlighted').first();
      if (currentFocusEntry.length === 0) {
        this.setCaretToItem(
          this.$element.find(this._SELECTABLE_SELECTOR).first(),
          true);
        this.$element.attr('tabindex', -1);
      }

      if (this.$element.is('.is-inline')) {
        this.$element.addClass('is-focused');
        this.$element.off('keydown.cui-selectlist keypress.cui-selectlist')
          .on('keydown.cui-selectlist', this._handleKeyDown.bind(this))
          .on('keypress.cui-selectlist', this._handleKeyPress.bind(this));
      }
    },

    /**
     * Handles focusout events for accessibility purposes.
     * @param event The focusout event.
     * @private
     */
    _handleFocusOut: function (event) {
      if (this.$element.is('.is-inline')) {
        this.$element.removeClass('is-focused');
        this.$element.off('keydown.cui-selectlist keypress.cui-selectlist');
      }
    },

    _restoreFocusToOwnerElement: function() {
      var self = this,
          $ownerElement = this._ownerElement;

      if (!$ownerElement.is(':tabbable')) {
        $ownerElement = $ownerElement.find('input[type="text"], input[type="search"], button, input[type="button"]').filter(':tabbable').first();
      }
      $ownerElement.trigger('focus');
    },

    /**
     * Handles key down events for accessibility purposes.
     * @param event The keydown event.
     * @private
     */
    _handleKeyDown: function(event) {
      // enables keyboard support
      var entries = this.$element.find(this._SELECTABLE_SELECTOR),
        currentFocusEntry = entries.filter('.is-highlighted'),
        currentFocusIndex = entries.index(currentFocusEntry),
        newFocusEntry;

      if (!entries.length) {
        return;
      }

      switch (event.which) {
        case 13: // enter
        case 32: // space
          // If the toggle button for the select list has focus and
          // the user hits enter or space when a list item is
          // highlighted, they would expect the item
          // to be selected. If no item is highlighted, they
          // would expect the toggle to hide the list.
          // This is why we only preventDefault() when an entry
          // is highlighted.
          if (currentFocusEntry.length && $(document.activeElement).closest(this.$element).length === 1) {
            currentFocusEntry.trigger('click');
            event.preventDefault();
          }
          break;
        case 27: //esc
          this.hide();
          event.preventDefault();
          break;
        case 33: //page up
        case 38: //up arrow
          // According to spec, don't loop to the bottom of the list.
          if (currentFocusIndex > 0) {
            newFocusEntry = entries[currentFocusIndex-1];
          } else if (currentFocusIndex == -1) {
            newFocusEntry = entries[entries.length-1];
          }
          event.preventDefault();
          break;
        case 34: //page down
        case 40: //down arrow
          // According to spec, don't loop to the top of the list.
          if (currentFocusIndex + 1 < entries.length) {
            newFocusEntry = entries[currentFocusIndex+1];
          }
          event.preventDefault();
          break;
        case 36: //home
          newFocusEntry = entries[0];
          event.preventDefault();
          break;
        case 35: //end
          newFocusEntry = entries[entries.length-1];
          event.preventDefault();
          break;
        case 9:  //tab
          if (this.options.visible && this.options.autohide) {
            event.preventDefault();
          }
          break;
      }

      if (newFocusEntry !== undefined && this._hasFocus()) {
        this.setCaretToItem($(newFocusEntry), true);
      }
    },

    _keypressTimeoutID: null,
    _keypressTimeoutDuration: 1000,
    _keypressSearchString: "",
    _unicodeRangesRegExp: /[\u0000-\u007F|\u0080-\u00FF|\u0100-\u017F|\u0180-\u024F|\u0250-\u02AF|\u02B0-\u02FF|\u0300-\u036F|\u0370-\u03FF|\u0400-\u04FF|\u0500-\u052F|\u0530-\u058F|\u0590-\u05FF|\u0600-\u06FF|\u0700-\u074F|\u0780-\u07BF|\u0900-\u097F|\u0980-\u09FF|\u0A00-\u0A7F|\u0A80-\u0AFF|\u0B00-\u0B7F|\u0B80-\u0BFF|\u0C00-\u0C7F|\u0C80-\u0CFF|\u0D00-\u0D7F|\u0D80-\u0DFF|\u0E00-\u0E7F|\u0E80-\u0EFF|\u0F00-\u0FFF|\u1000-\u109F|\u10A0-\u10FF|\u1100-\u11FF|\u1200-\u137F|\u13A0-\u13FF|\u1400-\u167F|\u1680-\u169F|\u16A0-\u16FF|\u1700-\u171F|\u1720-\u173F|\u1740-\u175F|\u1760-\u177F|\u1780-\u17FF|\u1800-\u18AF|\u1900-\u194F|\u1950-\u197F|\u19E0-\u19FF|\u1D00-\u1D7F|\u1E00-\u1EFF|\u1F00-\u1FFF|\u2000-\u206F|\u2070-\u209F|\u20A0-\u20CF|\u20D0-\u20FF|\u2100-\u214F|\u2150-\u218F|\u2190-\u21FF|\u2200-\u22FF|\u2300-\u23FF|\u2400-\u243F|\u2440-\u245F|\u2460-\u24FF|\u2500-\u257F|\u2580-\u259F|\u25A0-\u25FF|\u2600-\u26FF|\u2700-\u27BF|\u27C0-\u27EF|\u27F0-\u27FF|\u2800-\u28FF|\u2900-\u297F|\u2980-\u29FF|\u2A00-\u2AFF|\u2B00-\u2BFF|\u2E80-\u2EFF|\u2F00-\u2FDF|\u2FF0-\u2FFF|\u3000-\u303F|\u3040-\u309F|\u30A0-\u30FF|\u3100-\u312F|\u3130-\u318F|\u3190-\u319F|\u31A0-\u31BF|\u31F0-\u31FF|\u3200-\u32FF|\u3300-\u33FF|\u3400-\u4DBF|\u4DC0-\u4DFF|\u4E00-\u9FFF|\uA000-\uA48F|\uA490-\uA4CF|\uAC00-\uD7AF|\uD800-\uDB7F|\uDB80-\uDBFF|\uDC00-\uDFFF|\uE000-\uF8FF|\uF900-\uFAFF|\uFB00-\uFB4F|\uFB50-\uFDFF|\uFE00-\uFE0F|\uFE20-\uFE2F|\uFE30-\uFE4F|\uFE50-\uFE6F|\uFE70-\uFEFF|\uFF00-\uFFEF|\uFFF0-\uFFFF]/,

    /**
     * Handles key press events for accessibility purposes. Provides alphanumeric search.
     * @param event The keypress event.
     * @private
     */
    _handleKeyPress: function(event) {
      // enables keyboard support
      var entries = this.$element.find(this._SELECTABLE_SELECTOR),
        currentFocusEntry = entries.filter('.is-highlighted'),
        currentFocusIndex = entries.index(currentFocusEntry),
        $newFocusEntry,
        newString = '',
        start, i, entry, regex, comparison;

      if (!entries.length) {
        return;
      }
      switch (event.which) {
        case 13: // enter
        case 32: // space
        case 27: // esc
        case 33: // page up
        case 37: // left arrow
        case 38: // up arrow
        case 34: // page down
        case 39: // right arrow
        case 40: // down arrow
        case 36: // home
        case 35: // end
        case 9: // tab
          break;
        default:  // alphanumeric
          clearTimeout(this._keypressTimeoutID);

          newString = String.fromCharCode(event.which);


          if (!this._unicodeRangesRegExp.test(newString)) {
              newString = '';
          }

          if (newString === '') {
            return;
          }

          this._keypressSearchString += newString !== this._keypressSearchString ? newString : '';

          this._keypressTimeoutID = setTimeout(function () {
            this._keypressSearchString = '';
          }.bind(this), this._keypressTimeoutDuration);

          if (currentFocusIndex === -1) {
            start = 0;
          }
          else if (this._keypressSearchString.length === 1) {
            start = currentFocusIndex + 1;
          }
          else {
            start = currentFocusIndex;
          }

          regex = new RegExp('^' + this._keypressSearchString.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&'), 'i');

          for (i = start; i < entries.length; i++) {
            entry = entries.eq(i);
            comparison = $.trim((entry.data('display') || entry.text()));
            if (regex.test(comparison)) {
              $newFocusEntry = entry;
              break;
            }
          }

          if ($newFocusEntry === undefined) {
            for (i = 0; i < start; i++) {
              entry = entries.eq(i);
              comparison = $.trim((entry.data('display') || entry.text()));
              if (regex.test(comparison)) {
                $newFocusEntry = entry;
                break;
              }
            }
          }

          if ($newFocusEntry !== undefined) {
            this.setCaretToItem($newFocusEntry, true);
          }
      }
    },

    /**
     * makes the list options accessible
     * @private
     * @param  {jQuery} elem
     */
    _makeAccessibleListOption: function (elem) {
      elem.each(function (i, e) {
        var entry = $(e), $optGroupTitle;

        // group header
        if (entry.hasClass('coral-SelectList-item--optgroup')) {
          $optGroupTitle = entry.children('.coral-SelectList-groupHeader');
          $optGroupTitle.attr({
            'id': $optGroupTitle.attr('id') || CUI.util.getNextId(),
            'role': 'heading'
          });
          entry.attr({
            'role': 'presentation'
          }).children('ul').each(function(i, ul){
            var $ul = $(ul);
            $ul.attr({
              'role': 'group',
              'aria-labelledby': $optGroupTitle.attr('id')
            });
          }).children('li').each(function(i, li){
            var $li = $(li);
            $li.attr({
              'role': 'option',
              'id': $li.attr('id') || CUI.util.getNextId()
            });
          });
        } else {
          entry.attr({
            'role': 'option',
            'id': entry.attr('id') || CUI.util.getNextId()
          });
        }
      });
    },

    /**
     * Visually focuses the provided list item and ensures it is within
     * view.
     * @param {jQuery} $item The list item to focus.
     * @param {boolean} scrollToItem Whether to scroll to ensure the item
     * is fully within view.
     */
    setCaretToItem: function($item, scrollToItem) {
      this.$element.find('.coral-SelectList-item--option')
        .removeClass('is-highlighted')
        .removeAttr('tabindex');

      $item.addClass('is-highlighted').attr('tabindex', 0);
      this._ownerElement.attr('aria-activedescendant', $item.attr('id'));
      this.$element.attr('aria-activedescendant', $item.attr('id'));

      if (this._hasFocus()) {
        $item.trigger('focus');
      } else if (scrollToItem) {
        this.scrollToItem($item);
      }
    },

    /**
     * Removes visual focus from list items and scrolls to the top.
     */
    resetCaret: function() {
      this.$element.find('[role="option"]')
        .removeClass('is-highlighted')
        .removeAttr('tabindex');
      this.$element.scrollTop(0);
      this._ownerElement.removeAttr('aria-activedescendant');
      this.$element.removeAttr('aria-activedescendant');
    },

    /**
     * Scrolls as necessary to ensure the list item is within view.
     * @param {jQuery} $item The list item
     */
    scrollToItem: function($item) {
      if (!$item.length) {
        return;
      }

      var itemTop = $item.position().top,
        itemHeight = $item.outerHeight(false),
        scrollNode = this.$element[0];

      var bottomOverflow = itemTop + itemHeight - scrollNode.clientHeight;

      if (bottomOverflow > 0) {
        scrollNode.scrollTop += bottomOverflow;
      } else if (itemTop < 0) {
        scrollNode.scrollTop += itemTop;
      }
    },

    show: function () {
      if (this.options.visible) {
        return this;
      } else {
        hideLists(); // Must come before the parent show method.
        return this.inherited(arguments);
      }
    },

    /**
     * @private
     */
    _show: function () {
      var self = this,
          currentFocusEntry = this.$element.find(this._SELECTABLE_SELECTOR+'[aria-selected="true"], ' + this._SELECTABLE_SELECTOR+'[tabindex="0"], '+ this._SELECTABLE_SELECTOR+'.is-highlighted').first();

      this.$element
        .addClass('is-visible')
        .attr('aria-hidden', false);

      this._ownerElement.attr('aria-expanded', true);

      this._position();

      if (this.options.autofocus) {
        if (currentFocusEntry.length === 0) {
            currentFocusEntry = this.$element.find(this._SELECTABLE_SELECTOR).first();
        }
        this.setCaretToItem(
          currentFocusEntry,
          true);
      }

      // if dynamic start loading
      if (this.options.type === 'dynamic') {
        var dataRequest = this._outstandingRequest || this._handleLoadData();
        dataRequest.done(function () {
          if (self.options.autofocus) {
            self.setCaretToItem(
              self.$element.find(self._SELECTABLE_SELECTOR).first(),
              true);
          }
        });
      }

      $(document).on('keydown.cui-selectlist', this._handleKeyDown.bind(this))
        .on('keypress.cui-selectlist', this._handleKeyPress.bind(this));
    },

    /**
     * Positions the list below a related component (or above when it does not fit below).
     * @private
     */
    _position: function () {
      if (this.options.visible) {
        this.$element.position({
          my: 'top',
          at: this.options.position,
          of: this.options.relatedElement,
          collision: this.options.collisionAdjustment
        });

        var $relatedElement = $(this.options.relatedElement);
        // Verify if select list is positioned above or below the related element
        if(this.$element.offset().top < $relatedElement.offset().top) {
          this.$element
            .removeClass('is-below')
            .addClass('is-above');
          $relatedElement
            .removeClass('is-above')
            .addClass('is-below');
        }
        else {
          this.$element
            .removeClass('is-above')
            .addClass('is-below');
          $relatedElement
            .removeClass('is-below')
            .addClass('is-above');
        }
      }
    },

    /**
     * @private
     */
    _hide: function () {
      var $relatedElement = $(this.options.relatedElement),
          $ownerElement = this._ownerElement,
          removeKeyboardEventHandlers = true,
          hasFocus = this._hasFocus();

      this.$element
        .removeClass('is-visible')
        .attr('aria-hidden', true);

      this._ownerElement.attr('aria-expanded', false);

      this.reset();

      // Determine if there is a visible selectList with autohide=false
      $(selectListSelector).each(function () {
        var selectList = $(this).data('selectList');
        if (selectList && !selectList.get('autohide') && selectList.get('visible')) {
          // If the selectList with autohide=false is visible,
          // we don't want to remove the keyboard event listeners.
          removeKeyboardEventHandlers = false;
        }
      });

      // Only remove keyboard event listeners when no selectList with autohide=false is visible.
      if (removeKeyboardEventHandlers) {
        $(document).off('keydown.cui-selectlist keypress.cui-selectlist');
      }

      $ownerElement.removeAttr('aria-activedescendant');
      if ($ownerElement.length && hasFocus) {
          setTimeout(this._restoreFocusToOwnerElement.bind(this), 50);
      }
    },

    /**
     * triggers an event for the currently selected element
     * @fires SelectList#selected
     * @private
     */
    _triggerSelected: function (event) {
      var cur = $(event.currentTarget),
        val = cur.data('value'),
        display = cur.data('display') || cur.text();

      cur.trigger($.Event('selected', {
        selectedValue: val,
        displayedValue: display
      }));
    },

    /**
     * handles the mousenter event on an option
     * this events sets the the focus to the current event
     * @param  {jQuery.Event} event
     *
     * @private
     */
    _handleMouseEnter: function (event) {
      this.setCaretToItem($(event.currentTarget), false);
    },

    /**
     * deletes the item from the dom
     */
    clearItems: function () {
      this.$element.empty();
    },

    /**
     * current position for the pagination
     * @private
     * @type {Number}
     */
    _pagestart: 0,

    /**
     * indicates if all data was fetched
     * @private
     * @type {Boolean}
     */
    _loadingComplete: false,

    /**
     * indicates if currently data is fetched
     * @private
     * @type {Boolean}
     */
    _loadingIsActive: false,

    /**
     * The outstanding request. When data is actively being loaded this will be an implementation of the jQuery
     * Promise interface, typically a jqXHR object.
     * @type {Object}
     */
    _outstandingRequest: null,

    /**
     * handle asynchronous loading of data (type == dynamic)
     * @private
     */
    _handleLoadData: function () {
      var promise,
        self = this,
        end = this._pagestart + this.options.datapagesize;

      if (this._outstandingRequest && typeof this._outstandingRequest.abort === 'function') {
        this._outstandingRequest.abort();
      } else {
        // add wait
        $('<div/>', {
          'class': 'coral-SelectList-item--wait',
          'role': 'presentation'
        }).append($('<span/>', {
          'class': 'coral-Wait',
          'role': 'progressbar'
        })).appendTo(self.$element);

        this._position();

        // activate fetching
        this._loadingIsActive = true;
      }

      // load from given URL
      if (this.options.dataurl) {
        promise = $.ajax({
          url: this.options.dataurl,
          context: this,
          dataType: this.options.dataurlformat,
          data: $.extend({
            start: this._pagestart,
            end: end
          }, this.options.dataadditional || {})
        }).done(function (data) {
            var cnt = 0;

            if (self.options.dataurlformat === 'html') {
              var elem = $(data);

              cnt = elem.filter('li').length;

              self._makeAccessibleListOption(elem);
              self.$element.append(elem);
            }

            // if not enough elements came back then the loading is complete
            if (cnt < self.options.datapagesize) {
              this._loadingComplete = true;
            }

          });

      } else { // expect custom function to handle
        promise = this.options.loadData.call(this, this._pagestart, end);
        promise.done(function (loadingComplete) {
          if (loadingComplete !== undefined) {
            self._loadingComplete = loadingComplete;
          }
        });
      }

      promise.done(function() {
         // increase to next page
         self._pagestart = end;
      });

      promise.always(function () {
        self.$element.find('.coral-SelectList-item--wait').remove();
        self._position();
        self._loadingIsActive = false;
        self._outstandingRequest = null;
      });

      this._outstandingRequest = promise;

      return promise;
    },

    /**
     * resets the dynamic loaded data
     */
    reset: function () {
      if (this.options.type === 'dynamic') {
        this.clearItems();
        this._pagestart = 0;
        this._loadingComplete = false;
      }
    },

    /**
     * triggers a loading operation
     * this requires to have the selectlist in a dynamic configuration
     * @param  {Boolean} reset resets pagination
     */
    triggerLoadData: function (reset) {
      if (reset) {
        this.reset();
      }

      this._handleLoadData();
    },

    /**
     * Filters the list of items based on a provided filtering function. This
     * filtering only occurs on the client and therefore is primarily intended
     * to be used with a static list (type=static).
     * @param {CUI.SelectList~filterCallback} [callback] Callback used to test
     * list options. If no function is passed, all items will be shown.
     */
    filter: function(callback) {
      var $items = this.$element.find('.coral-SelectList-item--option'),
          $groups = this.$element.find('.coral-SelectList-item--optgroup');

      if (callback) {
        $items.each(function() {
          var $item = $(this);

          var hideItem =
              !callback.call(this, $item.data('value'), $item.data('display') || $item.text());

          $item.toggleClass('is-hidden', hideItem);

          if (hideItem) {
            $item.removeClass('is-highlighted');
          }
        });

        $groups.each(function() {
          var $group = $(this);

          var hasVisibleItems =
              $group.find('[role="option"]:not(.is-hidden)').length > 0;

          $group.toggleClass('is-hidden', !hasVisibleItems);
        });
      } else {
        // Shortcut for performance. Assumes that all groups have items
        // and therefore should be shown.
        $items.removeClass('is-hidden');
        $groups.removeClass('is-hidden');
      }

      // Important when the bottom of the list needs to stay pegged to the top of an input, for example.
      this._position();
    }
  });

  CUI.Widget.registry.register("selectlist", CUI.SelectList);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.SelectList.init($('[data-init~=selectlist]', event.target));
    });
  }

  var selectListSelector = '.coral-SelectList',
    toggleSelector = '[data-toggle~=selectlist]';

  /**
   * Hides all select lists that have autohide enabled.
   * @ignore
   */
  var hideLists = function () {
    $(selectListSelector).each(function () {
      var selectList = $(this).data('selectList');
      if (selectList && selectList.get('autohide')) {
        selectList.hide();
      }
    });
  };

  /**
   * From a toggle element, toggles the visibility of its target select list.
   * @ignore
   */
  var toggleList = function () {
    var $selectList = CUI.util.getDataTarget($(this)),
        selectListWidget;
    if ($selectList.length) {
      selectListWidget = $selectList.data('selectList');
      if (!selectListWidget.get('relatedElement')) {
        selectListWidget.set('relatedElement', this);
        selectListWidget._makeAccessible();
      }
      selectListWidget.resetCaret();
      selectListWidget.toggleVisibility();
    }
    return false;
  };

  var handleToggleSelectorKeydown = function(event) {
    var $selectList = CUI.util.getDataTarget($(this)),
        selectList = $selectList.data('selectList'),
        isVisible = $selectList.length && $selectList.hasClass('is-visible');
    switch(event.which) {
      case 40:
        if ($selectList.length && !isVisible) {
          toggleList.call(this);
        }
        event.preventDefault();
        break;
      case 9:
        if (isVisible && selectList.get('autohide')) {
          event.preventDefault();
        }
        break;
    }
  };

  $(document)
    // If a click reaches the document, hide all open lists.
    .on('click.cui-selectlist', hideLists)

    // If the click is from a select list, don't let it reach the document
    // to keep the listener above from hiding the list.
    .on('click.cui-selectlist', selectListSelector, function (event) {
      event.stopPropagation();
    })

    // If a click is from a trigger button, toggle its menu.
    .on('click.cui-selectlist', toggleSelector, toggleList)

    .on('keydown.cui-selectlist-toggleSelector', toggleSelector, handleToggleSelectorKeydown);


  /**
   * Triggered when option was selected
   *
   * @name CUI.SelectList#selected
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.selectedValue value which was selected
   * @param {String} event.displayedValue displayed text of the selected element
   */

  /**
   * Triggered after option or group was added
   *
   * @name CUI.SelectList#itemadded
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.kind either "option" or "group"
   * @param {String} event.position index of element within parents child list
   * @param {String} event.display displayed text of added element
   * @param {String} event.value value of added element (not present for groups)
   * @param {String} event.target either .coral-SelectList or .coral-SelectList-item--optgroup
   *                              node to which the element was added. Use this
   *                              to detect hierarchies
   */

  /**
   * Triggered after option or group was removed
   *
   * @name CUI.SelectList#itemremoved
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.kind either "option" or "group"
   * @param {String} event.position index of element within parents child list
   *                                before it was removed
   * @param {String} event.display displayed text of removed element
   * @param {String} event.value value of removed element (not present for groups)
   * @param {String} event.target either .coral-SelectList or .coral-SelectList-item--optgroup
   *                              node from which the element was removed. Use
   *                              this to detect hierarchies
   */

  /**
   * Triggered when option was unselected (not implemented)
   *
   * @name CUI.SelectList#unselected
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.selectedValue value which was unselected
   * @param {String} event.displayedValue displayed text of the unselected element
   */

  /**
   * Callback used to test list options for filtering purposes. Expects a
   * return value of true if the list item should be visible or false if it
   * should be hidden.
   *
   * @callback CUI.SelectList~filterCallback
   * @param {Object} value The value of the list item.
   * @param {String} display The text representation of the list item.
   */

}(jQuery, this));

(function ($, window, undefined) {
  CUI.SelectList.Item = new Class(/** @lends CUI.SelectList.Item# */{
    toString : 'SelectList.Item',
    $element : undefined,

    /**
     * @private
     * The last known position before the element was removed.
     */
    _cachedPosition: null,

    construct : function (args) {
      this.$element = $(args.element);
    },

    /**
     * Get position within the set of sibling items. The return value may be
     * used as index with {get,add}Group() and {get,add}Option().
     */
    getPosition : function () {
      var position = this.$element.index();
      return position > -1 ? position : this._cachedPosition;
    },

    /**
     * @abstract
     */
    getDisplay : function () {
      throw new Error("Subclass responsibility");
    },

    /**
     * Remove item from list.
     */
    remove : function () {
      var parent = this._getParent();

      this._cachedPosition = this.getPosition();
      this.$element.remove();
      parent.trigger($.Event("itemremoved", {item: this}));
    },

    /**
     * @abstract
     * @private
     */
    _getParent : function () {
      throw new Error("Subclass responsibility");
    }
  });
}(jQuery, this));

(function ($, window, undefined) {
  CUI.SelectList.Option = new Class(/** @lends CUI.SelectList.Option# */{
    toString : 'SelectList.Option',

    extend: CUI.SelectList.Item,

    /**
     * Get displayed text, which represents the Option.
     */
    getDisplay : function () {
      return this.$element.text();
    },

    /**
     * Get value, which represents the Option.
     */
    getValue : function () {
      return this.$element.attr("data-value");
    },

    /**
     * @override
     * @private
     */
    _getParent : function () {
      return this.$element.closest(".coral-SelectList, .coral-SelectList-item--optgroup");
    }
  });
}(jQuery, this));

(function ($, window, undefined) {
  CUI.SelectList.Group = new Class(/** @lends CUI.SelectList.Group# */{
    toString : 'SelectList.Group',
    extend: CUI.SelectList.Item,

    /**
     * Get displayed text, which represents the Group.
     */
    getDisplay : function () {
      return this.$element.children("span").text();
    },

    /**
     * Get list of Options, that are part of this Group. Similar to
     * {@linkcode CUI.SelectList.getItems()}, only that this may only return
     * Option instances.
     *
     * @return {Array} List of CUI.SelectList.Option instances.
     */
    getItems : function () {
      return this._getItems().toArray().map(function (element) {
        return new CUI.SelectList.Option({element : element});
      });
    },

    /**
     * Get CUI.SelectList.Option representing the option at the given position.
     *
     * @returns option
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getOption : function (position) {
      if (!$.isNumeric(position)) {
        throw new TypeError("Position should be numeric");
      }

      var items = this._getItems(),
          element = items.eq(position);

      if (position < 0 || element.length === 0) {
        throw new RangeError("Position >" + position + "< is not within expected range [0," + (items.length - 1) + "]");
      }

      return new CUI.SelectList.Option({element: element});
    },

    /**
     * Add Option to Group. If specified, the option will be inserted at
     * `position`, otherwise at the end.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     */
    addOption : CUI.SelectList.prototype.addOption,

    /**
     * @private
     */
    _addItem : CUI.SelectList.prototype._addItem,
    /**
     * @private
     */
    _getList : function () {
      return this.$element.children(".coral-SelectList-sublist").first();
    },
    /**
     * @private
     */
    _getItems : CUI.SelectList.prototype._getItems,
    /**
     * @private
     */
    _makeAccessibleListOption : CUI.SelectList.prototype._makeAccessibleListOption,

    /**
     * @override
     * @private
     */
    _getParent : function () {
      return this.$element.parent();
    }
  });
}(jQuery, this));

(function ($, window, undefined) {
  CUI.TagList = new Class(/** @lends CUI.TagList# */{
    toString: 'TagList',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc A tag list for input widgets. This widget is intended to be used by other widgets.
     * @description Creates a new tag list
     * @constructs
     *
     * @param  {Object} options Component options
     * @param  {Mixed} options.element jQuery selector or DOM element to use for taglist container
     * @param  {String} options.fieldname fieldname for the input fields
     * @param  {Array} options.values to set the taglist
     * @param  {Boolean} [options.disabled=false] 'true' to disable the taglist
     * @param  {Boolean} [options.multiline=false] defines if newly created tags are multiline elements
     * @param  {CUI.TagList~rendererCallback} [options.renderer] a custom
     + renderer to use for rendering tags.
     *
     * @fires TagList#itemadded
     * @fires TagList#itemremoved
     *
     */
    construct: function (options) {
      var self = this;

      this.applyOptions();

      // Set up listeners for option change events
      this.$element
        .on('change:values', this._setValues.bind(this))
        .on('change:disabled', this._toggleDisabled.bind(this));

      // Convert to using js-* class when we can break backward-compatibility
      this.$element.on('click', 'button', function (event) {
        var elem = self.$element
            .children()
            .has(event.currentTarget)
            .find('input');

        self.removeItem(elem.val());
      });

      // accessibility
      this._makeAccessible();
    },

    defaults: {
      fieldname: "",
      values: null,
      disabled: false,
      tag: 'li',
      renderer: null
    },

    /**
     * existing values in the tag list
     * @private
     * @type {Array}
     */
    _existingValues: null,

    applyOptions: function () {
      var self = this;

      this._existingValues = [];

      this.options.values = this.options.values || [];

      // set values if given
      if (this.options.values.length > 0) {
        this._setValues();
      } else { // read from markup
        this.$element.find('input').each(function (i, e) {
          var elem = $(e);

          // add to options.values
          self._existingValues.push(elem.attr('value'));
        });
      }

      this._toggleDisabled(this.options.disabled);
    },

    /**
     * @private
     */
    _setValues: function () {
      var items = this.options.values;

      // remove list elements
      this.$element.empty();

      // clear options to readd
      this.options.values = [];
      // add elements again
      this.addItem(items);
    },

    /**
     * adds some accessibility attributes and features
     * http://www.w3.org/WAI/PF/aria/roles#list
     * @private
     */
    _makeAccessible: function () {
      var self = this;
      this.$element.attr({
        'role': 'listbox'
      });

      this.$element.children(this.options.tag)
        .attr({
          'role': 'option',
          'tabindex': 0
        })
        .on('keydown', this._onKeyDown.bind(this))
        .children('.coral-TagList-tag-removeButton')
          .attr({
            'tabindex': -1
          });
    },

    /** @private */
    _onKeyDown: function(event) {
      // backspace key
      if(event.which === 8) {
        event.preventDefault();
        event.stopPropagation();

        // gets the next item before it gets removed
        var itemToFocus = $(event.currentTarget).next();

        if (itemToFocus.length === 0) {
          itemToFocus = $(event.currentTarget).prev();
        }

        this.removeItem($(event.currentTarget).children('input').val());

        itemToFocus.focus();
      }
    },

    /**
     * @private
     */
    _show: function () {
      this.$element
        .show()
        .attr('aria-hidden', false);
    },

    /**
     * @private
     */
    _hide: function () {
      this.$element
        .hide()
        .attr('aria-hidden', true);
    },

    /**
     * remove an item from the DOM
     * @private
     * @param  {String} item
     */
    _removeItem: function (item) {
      var elem = this.$element.children(':has(input[value="' + item + '"])');

      if (elem.length > 0) {
        elem.remove();

        this.$element.trigger($.Event('itemremoved'), {
          value: item
        });
      }
    },

    /**
     * adds a new item to the DOM
     * @private
     * @param  {String|Object} item entry to be displayed
     */
    _appendItem: function (item) {
      var display, val;

      // see if string or object
      if ($.type(item) === "string") {
        display = val = item;
      } else {
        display = item.display;
        val = item.value;
      }

      // always be a string
      val += "";

      if (($.inArray(val, this._existingValues) > -1) || val.length === 0) {
        return;
      }

      // add to internal storage
      this._existingValues.push(val); // store as string

      var renderer = this.options.renderer || this._renderTag;
      var $itemElement = $(renderer.call(this, val, display));
      $itemElement.on('keydown', this._onKeyDown.bind(this));

      // Disable interaction with tag element, if necessary
      this._toggleItemDisabled($itemElement[0], this.options.disabled);

      this.$element.append($itemElement);

      this.$element.trigger($.Event('itemadded'), {
        value: val,
        display: display
      });
    },

    /**
     * Renders a tag for a given item.
     * @see CUI.TagList~rendererCallback
     * @private
     */
    _renderTag: function(value, display) {
      var elem, btn;

      // add DOM element
      elem = $('<' + this.options.tag + '/>', {
        'role': 'option',
        'tabindex': '0',
        'class': 'coral-TagList-tag' + (this.options.multiline ? ' coral-TagList-tag--multiline' : ''),
        'title': display
      });

      btn = $('<button/>', {
        'class': 'coral-MinimalButton coral-TagList-tag-removeButton',
        'type': 'button',
        'tabindex': '-1',
        'title': 'Remove'
      }).appendTo(elem);

      $('<i/>', {
        'class': 'coral-Icon coral-Icon--sizeXS coral-Icon--close'
      }).appendTo(btn);

      $('<span/>', {
        'class': 'coral-TagList-tag-label',
        'text': display
      }).appendTo(elem);

      $('<input/>', {
        'type': 'hidden',
        'value': value,
        'name': this.options.fieldname
      }).appendTo(elem);

      return elem;
    },

    /**
     * Toggles disabled state.
     * @param {Boolean} disabled 'true' to disable the taglist
     * @private
     */
    _toggleDisabled: function (disabled) {
      var disable = (typeof disabled === 'boolean') ? disabled : this.options.disabled;
      var items = this._getItems();

      this.$element.toggleClass('is-disabled', disable);
      this.$element.attr('aria-disabled', disable);

      items.map(function (item) {
        this._toggleItemDisabled(item, disable);
      }.bind(this));
    },

    /**
     * Toggles item disabled state.
     * @param {HTMLElement} item The item to toggle disabled state for
     * @param {Boolean} disabled 'true' to disable the item
     * @returns {HTMLElement} The item for which disabled state was toggled
     * @private
     */
    _toggleItemDisabled: function (item, disabled) {
      var disable = (typeof disabled === 'boolean') ? disabled : this.options.disabled;
      var $toDisable = $(item).find('input, button');

      // Disable the <input> and <button> elements associated with each tag.
      $toDisable.each(function (index, element) {
        $(element).prop('disabled', disable);
      });

      $(item).attr('tabindex', (disable) ? -1 : 0);
    },

    /**
     * Gets all tag items
     * @returns {Array.<HTMLElement>} The items
     */
    _getItems: function () {
      var self = this;
      var $children = self.$element.children();

      return this._existingValues.map(function(value) {
        var $match = $children.has('input[value="' + value + '"]');

        if ($match.length > 1) {
          $match = $match.first();
        }

        return ($match.length) ? $match[0] : false;
      }).filter(function(item) {
        return item;
      });
    },

    /**
     * @param {String} item value to be deleted
     */
    removeItem: function (item) {
      var idx = this._existingValues.indexOf("" + item);

      if (idx > -1) {
        this._existingValues.splice(idx, 1);
        this._removeItem(item);
      }
    },

    /**
     * @param  {String|Object|Array} item
     * @param  {String} item.display
     * @param  {String} item.value
     */
    addItem: function (item) {
      var self = this,
        items = $.isArray(item) ? item : [item];

      $.each(items, function (i, item) {
        self._appendItem(item);
      });
    },

    getValues: function () {
      return this._existingValues.slice(0);
    }
  });

  CUI.Widget.registry.register("taglist", CUI.TagList);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.TagList.init($('[data-init~=taglist]', event.target));
    });
  }

  /**
   * Triggered when an item was added
   *
   * @name CUI.TagList#itemadded
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.value value which was added
   * @param {String} event.display displayed text of the element
   */

  /**
   * Triggered when an item was removed
   *
   * @name CUI.TagList#itemremoved
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.value value which was removed
   */

  /**
   * Callback used to render a tag. If a child of the returned tag is a button,
   * it will be used to remove the tag. The returned tag element should also
   * contain a hidden input with a value that matches the <code>value</code>
   * argument.
   *
   * @callback CUI.TagList~rendererCallback
   * @param {String} value The underlying value for the item.
   * @param {*} display Represents what should be displayed for the item.
   * @return {String|HTMLElement|jQuery} The constructed element to use
   * as a tag.
   */

}(jQuery, this));

(function ($, window, undefined) {
  CUI.Select = new Class(/** @lends CUI.Select# */{
    toString: 'Select',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc a widget which is similar to the native &lt;select&gt;
     *
     * @description Creates a new select
     * @constructs
     *
     * @param {Object} [options=null] Component options
     * @param {Mixed} [options.element=null] jQuery selector or DOM element to use for panel
     * @param {String} [options.type=static] static or dynamic list
     * @param {Boolean} [options.disabled=false] 'true' to disable the select
     * @param {Boolean} [options.nativewidget=false] shows a native select; instead of a SelectList widget
     * @param {Boolean} [options.nativewidgetonmobile=true] forces a native select on a mobile device if possible
     * @param {Boolean} [options.multiple=false] multiple selection, will automatically be detected form a given &lt;select&gt; source
     */
    construct: function () {
      var self = this;

      // find elements
      this._button = this.$element.children('.coral-Select-button');
      this._buttonText = this._button.children('.coral-Select-button-text');
      this._nativeSelect = this.$element.children('.coral-Select-select');
      this._selectList = this.$element.children('.coral-SelectList');
      this._tagList = this.$element.children('.coral-TagList');
      this._valueInput = this.$element.children('input[type=hidden]');

      // set up listeners for option change events
      this.$element.on('change:disabled', function(event) {
        // Change event bubbles from CUI.TagList, we add this handling to prevent infinite loop.
        if (event.target === this.$element[0]) {
          this._toggleDisabled();
        }
      }.bind(this));

      // apply
      this.applyOptions();
    },

    defaults: {
      type: 'static',
      disabled: false,
      nativewidget: false,
      nativewidgetonmobile: true,
      multiple: false,
      tagConfig: null,
      selectlistConfig: null
    },

    applyOptions: function () {
      // there is a select given so read the "native" config options
      if (this._nativeSelect.length > 0) {
        // if multiple set multiple
        if (this._nativeSelect.prop('multiple')) {
          this.options.multiple = true;
        }
      }

      // Create SelectList in any case, since it is used to implement
      // add{Option,Group} and getItems APIs.
      this._createSelectList();

      // Backwards compatibility; is-disabled class on the button implies disabled.
      if (this.options.disabled || this._button.hasClass('is-disabled') || this.$element.data('disabled')) {
        this.set('disabled', true);
      }

      this._nativeSelect.removeClass("coral-Select-select--native");
      this._nativeSelect.off(".selectlist");
      this._button.off(".selectlist");

      switch (this._getModeOfOperation()) {
        case "nativeselect":
          this._prepareSelectForInteraction();
          this._disableKeyboardInteractionWithSelectList();
          break;

        case "selectlist":
          this._prepareSelectListForInteraction();
          this._disableKeyboardInteractionWithNativeSelect();
          break;

        case "hybrid":
          this._prepareSelectForInteraction();
          this._prepareSelectListForInteraction();

          this._hybridEventHandling();
          this._disableKeyboardInteractionWithNativeSelect();
          break;
      }

      if (this.options.multiple) {
        this._setTagList();
      } else if (this.options.type === 'static') {
        this._handleNativeSelect();
      }

      this._makeAccessible();
    },

    _makeAccessible: function() {
      var labelElementSelector, $labelElement, labelElementId,
          isMacLike = window.navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i) ? true : false;

      this._button.attr({
        'id': this._button.attr('id') || CUI.util.getNextId()
      });

      if (this._button.hasClass('is-invalid')) {
        this._button.attr({
          'aria-invalid': true
        });
        this._nativeSelect.attr({
          'aria-invalid': true
        });
        this._selectList.attr({
          'aria-invalid': true
        });
      }

      labelElementSelector = (this._nativeSelect.length && this._nativeSelect.attr('id')) ? 'label[for="'+ this._nativeSelect.attr('id') +'"]' : 'label[for="'+ this._button.attr('id') +'"]';

      $labelElement = $(labelElementSelector);

      $labelElement.attr({
        'id':  $labelElement.attr('id') || CUI.util.getNextId()
      });

      labelElementId = $labelElement.attr('id');

      this._buttonText.attr({
        'id': this._buttonText.attr('id') || CUI.util.getNextId()
      });

      this._button.attr({
        'role': isMacLike ? 'button' : 'combobox',
        'aria-expanded': false,
        'aria-haspopup': true,
        'aria-labelledby': labelElementId ?  this._buttonText.attr('id') + ' ' + labelElementId : null,
        'aria-owns': this._selectList.attr('id'),
        'aria-multiselectable': this.options.multiple || null
      });

      if (this._selectListWidget) {
        this._selectListWidget._makeAccessible();
      }

      this._selectList.attr({
        'aria-controls': this._button.attr('id'),
        'aria-multiselectable': this.options.multiple || null
      });

      if ($labelElement.length && !this._button.is('[aria-hidden=true]')) {
        $labelElement.on('click.selectLabel', function (event) {
          this._button.focus();
          event.preventDefault();
        }.bind(this));
      }
    },

    /**
     * @return {Array|String} current value
     */
    getValue: function () {
      if (this.options.multiple) { // multiple returns array
        return this._tagListWidget.getValues();
      } else if (this.options.type === 'static') { // static
        return this._nativeSelect[0][this._nativeSelect[0].selectedIndex].value;
      } else if (this.options.type === 'dynamic') {
        return this._valueInput.val();
      }

      return null;
    },

    /**
     * Mark the options that match the specified value(s) as selected. Any options
     * not matching one of the specified values will get deselected. Values must
     * be strings for option values can only be strings (because they are
     * stored as DOM attributes).
     *
     * @param {string|Array.<string>} value The string value(s) matching the values
     * of the options that should be marked as selected.
     */
    setValue : function (values) {
      var self = this;

      // Make sure we don't break when `values` is undefined:
      if (values === undefined) {
        values = [];
      }
      // Make sure we convert `values` into a proper array:
      else if (!$.isArray(values)) {
        values = [values];
      }

      var deselectedValues = [];

      var handleOption = function(option) {
        var value = option.getValue(),
          index = values.indexOf(value);

        if (index === -1) {
          deselectedValues.push(value);
        } else {
          self._select(value, option.getDisplay());
        }
      };

      this.getItems().forEach(function(item){
        if (item instanceof CUI.SelectList.Option) {
          handleOption(item);
        } else if (item instanceof CUI.SelectList.Group) {
          item.getItems().forEach(handleOption);
        }
      });

      // Make sure that no previously selected options linger:
      this._deselect(deselectedValues);
    },

    /**
     * Retrieve list of first level list items (groups or options). NB: The list
     * represents a snapshot of the current state. If items are added or
     * removed, the list will become invalid.
     *
     * @return {Array} List of CUI.SelectList.Option and CUI.SelectList.Group
     *                 instances
     */
    getItems : function () {
      return this._selectListWidget.getItems();
    },

    /**
     * Get CUI.SelectList.Option representing the option at the given position.
     *
     * @param {Number} position
     *
     * @returns option
     * @throws {TypeError} if position is not numeric or if position points to
     *         group element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getOption: function (position) {
      return this._selectListWidget.getOption(position);
    },

    /**
     * Get CUI.SelectList.Group representing the group at the given position.
     *
     * @param {Number} position
     *
     * @returns group
     *
     * @throws {TypeError} if position is not numeric or if position points to
     *         option element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getGroup: function (position) {
      return this._selectListWidget.getGroup(position);
    },

    /**
     * Adds option at the given position. If position is undefined, the option
     * is added at the end of the list.
     *
     * <b>Please note</b>: Using this API in combination with type="dynamic" is
     * discouraged. Since closing/opening the select will reload the list
     * content, the elements that were added via this method call will be lost.
     *
     * @param {Object|CUI.SelectList.Option|Element|jQuery|Array} option
     *        Option that should be added. If type is Object, the keys `value`
     *        and `display` are used to create the option. If type is
     *        CUI.SelectList.Option, the underlying element is added to the
     *        list. If type is Element, the node is added to the list. If type
     *        is jQuery <b>all</b> elements within the collection are added to
     *        the list. If type is Array, then the array is expected to contain
     *        one of the other types.
     * @param {Number} position
     *        Position at which the element should be inserted. If undefined,
     *        the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addOption : function (option, position) {
      this._selectListWidget.addOption(option, position);
    },

    /**
     * Adds option group at the given position. If position is undefined, the
     * group is added to the end of the list.
     *
     * <b>Please note</b>: Using this API in combination with type="dynamic" is
     * discouraged. Since closing/opening the select will reload the list
     * content, the elements that were added via this method call will be lost.
     *
     * @param {String|CUI.SelectList.Group|Element|jQuery|Array} group
     *        Group that should be added. If type is String, it is used as
     *        display value.  If type is CUI.SelectList.Group, the underlying
     *        element is added to the list. If type is Element, the node is
     *        added to the list.  If type is jQuery <b>all</b> element within
     *        the collection are added to the list. If type is Array, then the
     *        array is expected to contain one of the other types.
     * @param {Number} position
     *        Position at which the element should be inserted. If undefined,
     *        the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addGroup : function (group, position) {
      this._selectListWidget.addGroup(group, position);
    },

    /**
     * @private
     */
    _getModeOfOperation : function () {
      if (this.options.type === 'dynamic') {
        // Functionality only supported in combination with SelectList component
        return "selectlist";
      }
      if (this.options.nativewidget) {
        // If native widget is set explicitly, we should follow the wish
        return "nativeselect";
      }
      if (this.options.nativewidgetonmobile) {
        // Unless specified otherwise, we want to have native controls on touch
        return "hybrid";
      }

      return "selectlist";
    },

    /**
     * Sets up event handling for hybrid mode. When a user clicks on the select,
     * which is positioned right above the button, then the opening of the
     * native options list should be aborted. Instead a button click should be
     * emulated. If the user taps on the select, no special handling should take
     * place. Instead the native default behaviour should cause the select to be
     * opened.
     *
     * @private
     */
    _hybridEventHandling : function () {
      var isTouch = false,
          stopClick = false,
          self = this;

      this._nativeSelect
        .on("touchstart.selectlist", function () {
          isTouch = true;
        })
        .on("pointerdown.selectlist", function (e) { // IE 11+
          if (e.originalEvent && e.originalEvent.pointerType === "touch") {
            isTouch = true;
          }
        })
        .on("MSPointerDown.selectlist", function (e) { // IE 10
          if (e.originalEvent && e.originalEvent.pointerType === 2) {
            isTouch = true;
          }
        })
        .on("mousedown.selectlist", function (e) {
          // Ignore touch interaction. We're prefering the defaults in this case
          if (isTouch) {
            isTouch = false;
            return;
          }

          // Ignore everything but left clicks
          if (e.which !== 1) {
            return;
          }

          /**
           * Trying to trick the browser into using the custom SelectList
           * instead of the native select.
           */

          // Avoid display of native options list
          self._nativeSelect.attr("disabled", "disabled");
          setTimeout(function () {
            self._nativeSelect.removeAttr("disabled");
            self._button.focus();
          }, 0);

          stopClick = true;
          self._button.click();
        })
        .on("click.selectlist", function (e) {
          if (stopClick) {
            e.stopPropagation();
            stopClick = false;
          }
        })
        .on("mouseenter.selectlist mouseleave.selectlist", function (e) {
          self._button.toggleClass("is-hovered", e.type === "mouseenter");
        })
        .on("focus.selectlist", function (e) {
          self._button.toggleClass("is-focused", e.type === "focus");
        })
        .on("blur.selectlist", function (e) {
          self._button.removeClass("is-focused");
        });
    },

    /**
     * @private
     */
    _disableKeyboardInteractionWithNativeSelect :  function () {
      // Keyboard focus should not jump to native select
      this._nativeSelect.attr({
        "tabindex": "-1",
        "aria-hidden": true
      });

      this._nativeSelect.off('focusin.nativeselect focusout.nativeselect keydown.nativeselect pointerdown.nativeselect MSPointerDown.nativeselect mousedown.nativeselect');
    },

    /**
     * @private
     */
    _disableKeyboardInteractionWithSelectList : function () {
      // Keyboard focus should not jump to button
      this._button.attr({
        "tabindex": "-1",
        "aria-hidden": true
      });
    },

    /**
     * Applies necessary changes to native select element, so that a user might
     * interact with it.
     *
     * @private
     */
    _prepareSelectForInteraction : function () {
      var self = this;

      self._nativeSelect.addClass("coral-Select-select--native");

      self._nativeSelect.css({
        height: self._button.outerHeight()
      });

      self._nativeSelect.on('change.select', self._handleNativeSelect.bind(self));

      self._nativeSelect.on('focusin.nativeselect', function () {
        self._button.addClass('is-focused');
      });

      self._nativeSelect.on('focusout.nativeselect', function (e) {
        self._button.removeClass('is-focused');
      });
    },

    /**
     * Creates SelectList and initially syncs with native &lt;select&gt;
     *
     * @private
     */
    _createSelectList : function () {
      var self = this,
          type = 'static';

      // if the element is not there, create it
      if (this._selectList.length === 0) {
        this._selectList = $('<ul/>', {
          'id': CUI.util.getNextId(),
          'class': 'coral-SelectList'
        }).appendTo(this.$element);
      } else if (!this._selectList.attr('id')) {
        this._selectList.attr('id', CUI.util.getNextId());
      }

      // read values from markup
      if (this._nativeSelect.length > 0) {
        this._parseMarkup();
      } else { // if no <select> is found then a dynamic list is expected
        type = 'dynamic';
      }

      this._selectList.selectList($.extend({
        relatedElement: this._button,
        type: type
      }, this.options.selectlistConfig || {}));

      this._selectListWidget = this._selectList.data('selectList');

      this._selectList
        .on("itemadded", this._addItemToSelect.bind(this))
        .on("itemremoved", function (e) {
          var values;

          if (e.item instanceof CUI.SelectList.Group) {
            values = e.item.getItems().map(function(option) { return option.getValue(); });
          } else {
            values = [e.item.getValue()];
          }

          self._deselect(values);
          self._removeItemFromSelect(e);
        });
    },

    /**
     * Event handler, which acts on element insertions to SelectList and updates
     * &lt;select&gt; accordingly.
     *
     * @private
     */
    _addItemToSelect : function (e) {
      var node;
      if (e.item instanceof CUI.SelectList.Option) {
        node = $("<option>");
        node.attr("value", e.item.getValue());
      }
      else if (e.item instanceof CUI.SelectList.Group) {
        node = $("<optgroup>");
      }
      else {
        // something went wrong.
        return;
      }

      node.text(e.item.getDisplay());


      var parentNode = this._nativeSelect;

      if (e.target != this._selectList.get(0)) {
        // Event occured on nested option, find matching optgroup!
        parentNode = parentNode.children().eq($(e.target).closest(".coral-SelectList-item--optgroup").index());
      }

      var position = e.item.getPosition();

      if (position >= parentNode.children().length) {
        parentNode.append(node);
      }
      else if (position === 0) {
        parentNode.prepend(node);
      }
      else {
        parentNode.children().eq(position).before(node);
      }
    },

    /**
     * Event handler, which acts on element removal from SelectList and updates
     * &lt;select&gt; accordingly.
     *
     * @private
     */
    _removeItemFromSelect : function (e) {
      var parentNode = this._nativeSelect;

      if (e.target != this._selectList.get(0)) {
        // Event occured on nested option, find matching optgroup!
        parentNode = parentNode.children().eq($(e.target).closest(".coral-SelectList-item--optgroup").index());
      }

      parentNode.children().eq(e.item.getPosition()).remove();
    },

    /**
     * Creates SelectList if necessary and populates it with the given data. It
     * also binds the button to the SelectList, such that a click on the button
     * toggles the SelectList visibility.
     *
     * @private
     */
    _prepareSelectListForInteraction : function () {
      var self = this;

      this._button.attr({
        'data-toggle': 'selectlist',
        'data-target': '#' + this._selectList.attr('id')
      });

      this._selectList
        // receive the value from the list
        .on('selected.select', this._handleSelectedFromSelectList.bind(this))
        // handle open/hide for the button
        .on('show.select hide.select', function (event) {
          if(event.type !== 'show') {
            self._button.removeClass('is-above is-below');
          }
          self._button.toggleClass('is-active', event.type === 'show');
        });
    },

    /**
     * Handles a native change event on the select
     * @fires Select#selected
     * @private
     */
    _handleNativeSelect: function (event) {
      var self = this,
        selected, selectedElem;

      if (self.options.multiple) {
        // loop over all options
        $.each(self._nativeSelect[0].options, function (i, opt) {
          if (opt.selected) {
            self._tagListWidget.addItem({
              value: opt.value,
              display: opt.text
            });
          } else {
            self._tagListWidget.removeItem(opt.value);
          }
        });

        selected = self._tagListWidget.getValues();
      } else if (self._nativeSelect[0]) {

        selectedElem = self._nativeSelect[0][self._nativeSelect[0].selectedIndex];

        self._buttonText.text(selectedElem ? selectedElem.text : '');

        selected = selectedElem ? selectedElem.value : null;
      }

      if (event) {
        this.$element.trigger($.Event('selected', {
          selected: selected
        }));
      }
    },

    /**
     * Selects options within the native select element using the provided values and deselects any options
     * not matching the provided values.
     * @param selectedValues The values for which options should be selected.
     * @private
     */
    _syncSelectionToNativeSelect: function (selectedValues) {
      if (this._nativeSelect.length) {
        $.each(this._nativeSelect[0].options, function (i, option) {
          option.selected = selectedValues.indexOf(option.value) > -1;
        });
      }
    },

    /**
     * Selects options within the SelectList using the provided values and deselects any options
     * not matching the provided values.
     * @param selectedValues The values for which options should be selected.
     * @private
     */
    _syncSelectionToSelectList: function (selectedValues) {
      if (this._selectList.length) {
        $.each(this._selectList.find(this._selectListWidget._SELECTABLE_SELECTOR), function (i, option) {
          var $option = $(option);
          $option.attr('aria-selected', selectedValues.indexOf($option.attr('data-value')) > -1);
        });
      }
    },

    /**
     * this function parses the values from the native select
     * and prints the right markup for the SelectList widget
     * This function may only be called in SelectList widget mode.
     * @private
     */
    _parseMarkup: function () {
      var self = this,
        optgroup = this._nativeSelect.children('optgroup');

      function parseGroup(parent, dest) {
        parent.children('option').each(function (i, e) {
          var opt = $(e);

          $('<li/>', {
            'class': 'coral-SelectList-item coral-SelectList-item--option',
            'data-value': opt.val(),
            'text': opt.text()
          }).appendTo(dest)
            .toggleClass('is-disabled', e.hasAttribute('disabled'))
            .attr('aria-selected', (e.hasAttribute('selected') && !self.options.multiple));
        });
      }

      // optgroups are part of the select -> different markup
      if (optgroup.length > 0) {
        optgroup.each(function (i, e) {
          var group = $(e),
            entry = $('<li/>', {
              'class': 'coral-SelectList-item coral-SelectList-item--optgroup'
            }).append($('<span/>', {
              'class': 'coral-SelectList-groupHeader',
              'text': group.attr('label')
            }));

          parseGroup(group, $('<ul/>', {
            'class': 'coral-SelectList-sublist'
          }).appendTo(entry));

          self._selectList.append(entry);
        });
      } else { // flat select list
        parseGroup(this._nativeSelect, this._selectList);
      }
    },

    /**
     * sets a tag list for the multiple selection
     * @private
     */
    _setTagList: function () {
      var self = this;

      // if the element is not there, create it
      if (this._tagList.length === 0) {
        this._tagList = $('<ol/>', {
          'class': 'coral-TagList'
        }).appendTo(this.$element);
      }

      this._tagList.tagList(this.options.tagConfig || {});

      this._tagListWidget = this._tagList.data('tagList');

      this._tagList.on('itemremoved', function (ev, data) {
        var selectedValues = self._tagListWidget.getValues();
        self._syncSelectionToNativeSelect(selectedValues);
        self._syncSelectionToSelectList(selectedValues);
      });

      // Load selected values from markup
      this._handleNativeSelect();
    },

    _handleSelectedFromSelectList: function(e) {
      // we stop the propagation because the component itself provides a selected event too
      if (e) {
        e.stopPropagation();
      }

      this._selectListWidget.hide();

      this._select(e.selectedValue, e.displayedValue);

      this._button.trigger('focus');

      this.$element.trigger($.Event('selected', {
        selected: this.getValue()
      }));
    },

    /**
     * Select an item.
     * @param value The value of the item to be selected.
     * @param display The display text for the item to be selected.
     * @private
     */
    _select: function (value, display) {
      var newSelectedValues;

      if (this.options.multiple) {
        this._tagListWidget.addItem({
          value: value,
          display: display
        });
        newSelectedValues = this._tagListWidget.getValues();
      } else {
        // set the button label
        this._buttonText.text(display);
        // in case it is dynamic a value input should be existing
        this._valueInput.val(value);
        newSelectedValues = ['' + value];
      }

      this._syncSelectionToNativeSelect(newSelectedValues);
      this._syncSelectionToSelectList(newSelectedValues);
    },

    /**
     * Deselects an item.
     * @param value The value of the item to be deselected.
     * @private
     */
    _deselect: function (values) {
      var self = this,
        newSelectedValues;

      if (this.options.multiple) {
        values.forEach(function(value) {
            self._tagListWidget.removeItem(value);
        });
        newSelectedValues = this._tagListWidget.getValues();
      } else {
        // If the selected value is being deselected, select the first option that's not being deselected if one exists.
        if (values.indexOf(this.getValue()) > -1) {
          var newSelectedOption = this._getFirstOptionWithoutValues(this._getAllOptions(), values),
            newValue,
            newDisplay;

          if (newSelectedOption) {
            newValue = newSelectedOption.getValue();
            newDisplay = newSelectedOption.getDisplay();
            newSelectedValues = [newValue];
          } else {
            newValue = '';
            newDisplay = '';
            newSelectedValues = [];
          }

          this._buttonText.text(newDisplay);
          this._valueInput.val(newValue);
        }
      }

      if (newSelectedValues) {
        this._syncSelectionToNativeSelect(newSelectedValues);
        this._syncSelectionToSelectList(newSelectedValues);
      }
    },

    /**
     * Toggles disabled state.
     * @param {Boolean} [disabled] 'true' to disable the select
     * @private
     */
    _toggleDisabled: function (disabled) {
      var disable = (typeof disabled === 'boolean') ? disabled : this.options.disabled;

      this._button.toggleClass('is-disabled', disable);
      this._button.attr('aria-disabled', disable);
      this._button.prop('disabled', disable);
      this._nativeSelect.prop('disabled', disable);
      this._selectList.attr('aria-disabled', disable);

      if (this._tagListWidget) {
        this._tagListWidget.set('disabled', disable);
      }

      if (disabled && this._selectListWidget) {
        this._selectListWidget.hide();
      }
    },

    /**
     * Gets the first option that does not have a value equal to those within an array of provided values.
     * @param {Array} options The options to search through.
     * @param {Array} values A blacklist of values.
     * @returns {CUI.SelectList.Option}
     * @private
     */
    _getFirstOptionWithoutValues: function (options, values) {
      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        if (values.indexOf(option.getValue()) === -1) {
          return option;
        }
      }
    },

    /**
     * Retrieves all options as an array of CUI.SelectList.Option objects.
     * Possibly move this up to CUI.SelectList when/if others need it?
     * @returns {Array}
     * @private
     */
    _getAllOptions: function () {
      var items = this.getItems();
      var options = [];

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (item instanceof CUI.SelectList.Group) {
          options = options.concat(item.getItems());
        } else {
          options.push(item);
        }
      }

      return options;
    }
  });

  CUI.Widget.registry.register("select", CUI.Select);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (e) {
      CUI.Select.init($('[data-init~=select]', e.target));
    });
  }

  /**
   * Triggered when option was selected
   *
   * @name CUI.Select#selected
   * @event
   *
   * @param {Object} event Event object
   * @param {String|Array} event.selected value which was selected
   *
   */

}(jQuery, this));

(function ($) {
  CUI.Tooltip = new Class(/** @lends CUI.Tooltip# */{
    toString: 'Tooltip',

    extend: CUI.Widget,
    /**
     @extends CUI.Widget
     @classdesc A tooltip that can be attached to any other element and may be displayed immediately, on mouse over or only on API call.

     @desc Creates a new tooltip.
     @constructs

     @param {Object} options                       Component options
     @param {Mixed} [options.element]              jQuery selector or DOM element to use for tooltip.
     @param {Mixed} options.target                 jQuery selector or DOM element the tooltip is attached to
     @param {String} [options.content]             Content of the tooltip (HTML)
     @param {String} [options.type=info]           Type of dialog to display. One of info, error, notice, success, or inspect
     @param {String} [options.arrow=left]          Where to place the arrow? One of left, right, top or bottom.
     @param {Integer} [options.delay=500]          Delay before an interactive tooltip is shown.
     @param {Integer} [options.distance=5]         Additional distance of tooltip from element.
     @param {Boolean} [options.visible=true]       True to display immediately, False to defer display until show() called
     @param {Boolean} [options.interactive=false]  True to display tooltip on mouse over, False to only show/hide it when show()/hide() is called manually
     @param {Boolean} [options.autoDestroy=false]  Automatically destroy tooltip on hide?
     */
    construct: function (options) {
      // Ensure we have an object, not only a selector
      if (this.options.target) this.options.target = $(this.options.target);

      if (this.$element.length === 0 && this.options.target) {
        // Special case: We do not have a element yet, but a target
        // -> let us create our own element
        this.$element = $("<div>");
        this.$element.insertAfter(this.options.target);
      }

      // Add coral-Tooltip class to give styling
      this.$element.addClass('coral-Tooltip');

      if (this.$element.data("interactive")) {
        this.options.interactive = true;
        if (!this.options.target) this.options.target = this.$element.parent();
      }

      if (this.$element.data("target")) {
        this.options.target = $(this.$element.data("target"));
      }

      if (!this.options.arrow) {
        this.options.arrow = "left"; // set some default
        if (this.$element.hasClass("coral-Tooltip--positionRight")) this.options.arrow = "left";
        if (this.$element.hasClass("coral-Tooltip--positionLeft")) this.options.arrow = "right";
        if (this.$element.hasClass("coral-Tooltip--positionBelow")) this.options.arrow = "top";
        if (this.$element.hasClass("coral-Tooltip--positionAbove")) this.options.arrow = "bottom";
      }

      if (!this.options.type) {
        this.options.type = "info"; // set some default
        if (this.$element.hasClass("coral-Tooltip--info")) this.options.type = "info";
        if (this.$element.hasClass("coral-Tooltip--error")) this.options.type = "error";
        if (this.$element.hasClass("coral-Tooltip--success")) this.options.type = "success";
        if (this.$element.hasClass("coral-Tooltip--notice")) this.options.type = "notice";
        if (this.$element.hasClass("coral-Tooltip--inspect")) this.options.type = "inspect";
      }

      // Interactive Tooltips are never visible by default!
      if (this.options.interactive) {
        this.options.visible = false;
      }

      this.$element.toggleClass("is-hidden", !this.options.visible);


      // Listen to changes to configuration
      this.$element.on('change:content', this._setContent.bind(this));
      this.$element.on('change:type', this._setType.bind(this));
      this.$element.on('change:arrow', this._setArrow.bind(this));

      this.applyOptions();
      this.reposition();
      this._makeAccessible();

      if (this.options.target) {
          this.options.target.data("tooltip", this);
      }

      if (this.options.interactive && this.options.target) {
        var hto = null;
        // Special behaviour on mobile: show tooltip on every touchstart
        $(this.options.target).on("touchstart.cui-tooltip", function (event) {
          if (hto) clearTimeout(hto);
          this.show();
          hto = setTimeout(function () {
            this.hide();
          }.bind(this), 3000); // Hide after 3 seconds
        }.bind(this));

        var showTimeout = false;

//a11y--> focusin and focusout events added for accessibility support
//a11y--> Added aria-hidden =true/false based on the tooltip visibility

        $(this.options.target).on("mouseover.cui-tooltip focusin.cui-tooltip", function (event) {
          if (showTimeout) clearTimeout(showTimeout);
          showTimeout = setTimeout(function () {
            this.show();
            this.$element.attr("aria-hidden","false");
          }.bind(this), this.options.delay);
        }.bind(this));

        $(this.options.target).on("focusout.cui-tooltip", function (event) {
          if (showTimeout) clearTimeout(showTimeout);
          this.hide();
          this.$element.attr("aria-hidden","true");
        }.bind(this));

        $(this.options.target).on("mouseout.cui-tooltip", function (event) {
         if (!$(document.activeElement).is(this.options.target)){
          if (showTimeout) clearTimeout(showTimeout);
          this.hide();
          this.$element.attr("aria-hidden","true");
         }
        }.bind(this));
      }
    },

    _makeAccessible: function () {
      //a11y--Adding aria role=tooltip and id for all tooltips
      this.$element.attr({
        'role': "tooltip",
        'id': this.$element.attr('id') || CUI.util.getNextId()
        });
      //a11y--Adding aria-describedby
      if (this.options.target) {
        this.options.target.attr("aria-describedby", this.$element.attr("id"));
      }
      //a11y--Adding aria-label if target html is empty
      if ($(this.options.target).is(':empty')){
        $(this.options.target).attr("aria-label",this.options.content);
      }
    },

    defaults: {
      target: null,
      visible: true,
      type: null,
      interactive: false,
      arrow: null,
      delay: 500,
      distance: 5
    },

    _stylesTypes: {
      'info': 'coral-Tooltip--info',
      'error': 'coral-Tooltip--error',
      'notice': 'coral-Tooltip--notice',
      'success': 'coral-Tooltip--success',
      'inspect': 'coral-Tooltip--inspect'
    },

    _arrows: {
      'left': 'coral-Tooltip--positionRight',
      'right': 'coral-Tooltip--positionLeft',
      'top': 'coral-Tooltip--positionBelow',
      'bottom': 'coral-Tooltip--positionAbove'
    },

    applyOptions: function () {
      this._setContent();
      this._setType();
      this._setArrow();
    },

    /** @ignore */
    _setType: function () {
      if (typeof this.options.type !== 'string' || !this._stylesTypes.hasOwnProperty(this.options.type)) return;

      // Remove old type
      var classesNames = this._stylesTypes['info'] + ' ' +
                        this._stylesTypes['error'] + ' ' +
                        this._stylesTypes['notice'] + ' ' +
                        this._stylesTypes['success'] + ' ' +
                        this._stylesTypes['inspect'];

      this.$element.removeClass(classesNames);

      // Add new type
      this.$element.addClass(this._stylesTypes[this.options.type]);

      // Re-positioning
      this.reposition();
    },

    /** @ignore */
    _setArrow: function () {

      if (typeof this.options.arrow !== 'string' || !this._arrows.hasOwnProperty(this.options.arrow)) return;

      // Remove old type
      var classesNames = this._arrows['left'] + ' ' +
                        this._arrows['right'] + ' ' +
                        this._arrows['top'] + ' ' +
                        this._arrows['bottom'];

      this.$element.removeClass(classesNames);

      // Add new type
      this.$element.addClass(this._arrows[this.options.arrow]);

      // Re-positioning
      this.reposition();
    },

    /** @ignore */
    _setContent: function () {
      if (typeof this.options.content !== 'string') return;

      this.$element.html(this.options.content);

      // Re-positioning
      this.reposition();
    },

    /** @ignore */
    _show: function () {
      if (this.$element.hasClass("is-hidden")) {
        this.$element.removeClass('is-hidden');
        this.$element.css("display", "none");
      }
      this.$element.fadeIn();
      //this.reposition();
      $(document).on('keydown.cui-tooltip', function(event) {
          if (event.which === 27) {
              this._hide();
              event.preventDefault();
              event.stopPropagation();
          }
      }.bind(this));
    },

    /** @ignore */
    _hide: function () {
      this.$element.fadeOut(400, function () {
        if (this.options.autoDestroy) {
          this.$element.remove();
          $(this.options.target).off(".cui-tooltip");
          $(this.options.target).data("tooltip", null);
        }
        $(document).off('keydown.cui-tooltip');
      }.bind(this));
      return this;
    },

    /**
     Place tooltip on page

     @returns {CUI.Tooltip} this, chainable
     */
    reposition: function () {
      if (!this.options.target) return;

      this.$element.detach().insertAfter(this.options.target);

      this.$element.css("position", "absolute");

      var el = $(this.options.target);
      var eWidth = el.outerWidth(true);
      var eHeight = el.outerHeight(true);

      var eLeft = el.position().left;
      var eTop = el.position().top;

      var offsetParent = el.offsetParent();
      if (!offsetParent.is("html")) {
        eTop  += offsetParent.scrollTop();
        eLeft += offsetParent.scrollLeft();
      }

      var width = this.$element.outerWidth(true);
      var height = this.$element.outerHeight(true);

      var left = 0;
      var top = 0;

      if (this.options.arrow === "left") {
        left = eLeft + eWidth + this.options.distance;
        top = eTop + (eHeight - height) / 2;
      }
      if (this.options.arrow === "right") {
        left = eLeft - width - this.options.distance;
        top = eTop + (eHeight - height) / 2;
      }
      if (this.options.arrow === "bottom") {
        left = eLeft + (eWidth - width) / 2;
        top = eTop - height - this.options.distance;
      }
      if (this.options.arrow === "top") {
        left = eLeft + (eWidth - width) / 2;
        top = eTop + eHeight + this.options.distance;
      }

      this.$element.css('left', left);
      this.$element.css('top', top);

      return this;
    }
  });

  CUI.Widget.registry.register("tooltip", CUI.Tooltip);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      // Only initialize non-interactive tooltips this way!
      CUI.Tooltip.init($("[data-init~=tooltip]", e.target));
      //ally---Only those empty quicktips without any label or alternate text associations are assigned aria-label
      $('[data-init~=quicktip][data-quicktip-content]:empty')
        .not('[aria-label], [aria-labelledby], img[alt], input, select, textarea, button').each(function(i, elem) {
        var $e = $(elem);
        if ($e.closest('label').length === 1 || ($e.attr('id') && $('label[for="'+ $e.attr('id') +'"]').length > 0)) return;
        $e.attr('aria-label', $e.attr('data-quicktip-content'));
      });
      $('[data-init~=quicktip]').not('input, select, textarea, button').not(':tabbable').attr('tabindex', 0);
    });

    $(document).on("touchstart mouseover focusin", "[data-init~=quicktip]", function (e) {
      var el = $(this),
          tooltip = el.data("tooltip"),
          quicktip,
          hideQuicktip = function(qt) {
            qt.hide();
            //ally--Removing aria-describedby after tooltip is removed
            el.removeAttr("aria-describedby");
            el.off("mouseout.cui-quicktip focusout.cui-quicktip");
            $(window).off("keydown.cui-tooltip mousedown.cui-tooltip");
          };

      if (!tooltip) {
        quicktip = new CUI.Tooltip({
          target: el,
          content: el.data("quicktip-content") || el.html(),
          type: el.data("quicktip-type"),
          arrow: el.data("quicktip-arrow"),
          interactive: false,
          autoDestroy: true,
          visible: false
        }).show();
        
        // Store a reference to the instance on the trigger element
        // This is required for testing so we can call methods
        el.data('quicktip', quicktip);

        switch(e.type) {
          case 'mouseover':
          case 'focusin':
            if (e.type === 'mouseover') {
              el.on("mouseout.cui-quicktip", function () {
                if (!$(document.activeElement).is(el)) {
                  hideQuicktip(quicktip);
                }
              });
            } else {
              el.on("focusout.cui-quicktip", function () {
                hideQuicktip(quicktip);
              });
            }
            $(window).on("keydown.cui-tooltip", function(event) {
              if (event.which === 27) {
                  hideQuicktip(quicktip);
                  event.preventDefault();
              }
            }).on("mousedown.cui-tooltip", function(event) {
              if (!el.is(event.target) && !quicktip.$element.is(event.target)) {
                  hideQuicktip(quicktip);
              }    
            });
            break;
          default:
            setTimeout(function() {
              hideQuicktip(quicktip);
            }, 3000);
        }
      }
    });
  }
}(window.jQuery));

(function ($, window, undefined) {
  CUI.Slider = new Class(/** @lends CUI.Slider# */{
    toString: 'Slider',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @desc Creates a slider.
     * @constructs
     *
     * @param {Object} options Component options
     * @param {number} [options.step=1]  The steps to snap in
     * @param {number} [options.min=1]   Minimum value
     * @param {number} [options.max=100] Maximum value
     * @param {number} [options.value=1] Starting value
     * @param {number} [options.tooltips=false] Show tooltips?
     * @param {String} [options.orientation=horizontal]  Either 'horizontal' or 'vertical'
     * @param {boolean} [options.slide=false]    True for smooth sliding animations. Can make the slider unresponsive on some systems.
     * @param {boolean} [options.disabled=false] True for a disabled element
     * @param {boolean} [options.bound=false] For multi-input sliders, indicates that the min value is bounded by the max value and the max value is bounded by the min
     *
     */
    construct: function () {
      var self = this,
        elementId = this.$element.attr('id'),

        values = [];

      // reads the options from markup
      this._readOptions();

      // if the element doesn't have an id, build a unique id using CUI.util.getNextId()
      if (!elementId) {
        elementId = CUI.util.getNextId();
        this.$element.attr('id', elementId);
      }

      this._renderMissingElements();

      // get all input value fields
      this.$inputs = this.$element.find('input');

      this.$inputs.each(function (index, input) {
        var $input = $(input);

        // setting default step
        if (!$input.is('[step]')) $input.attr('step', self.options.step);

        // setting default min
        if (!$input.is('[min]')) $input.attr('min', self.options.min);

        // setting default max
        if (!$input.is('[max]')) $input.attr('max', self.options.max);

        // setting default value
        if (!$input.is('[value]')) {
          $input.attr({'value': self.options.value});
          values.push(self.options.value);
        } else {
          values.push($input.attr('value'));
        }

        if (index === 0) {
          if ($input.is(':disabled')) {
            self.options.disabled = true;
            self.$element.addClass('is-disabled');
          } else if (self.options.disabled) {
            $input.attr('disabled', 'disabled');
            self.$element.addClass('is-disabled');
          }
        }
      });

      self.values = values;
      if (this.options.orientation === 'vertical') this.isVertical = true;

      // Set up event handling
      this.$element
        .on('touchstart.slider pointerdown.slider mspointerdown.slider mousedown.slider', this._mouseDown.bind(this))
        .on('focusin.slider', 'input[type=range], [role=slider].coral-Slider-handle', this._focus.bind(this))
        .on('focusout.slider', 'input[type=range], [role=slider].coral-Slider-handle', this._blur.bind(this))
        .on('input.slider change.slider', 'input', this._handleInputChange.bind(this));

      // Listen to changes to configuration
      this.$element
        .on('change:value', this._processValueChanged.bind(this))
        .on('change:disabled', this._processDisabledChanged.bind(this))
        .on('change:min', this._processMinMaxStepChanged.bind(this))
        .on('change:max', this._processMinMaxStepChanged.bind(this))
        .on('change:step', this._processMinMaxStepChanged.bind(this));

      // Adjust dom to our needs
      this._render();

      // Initialize accessibility
      this._makeAccessible();
    }, // construct

    defaults: {
      step: '1',
      min: '1',
      max: '100',
      value: '1',
      orientation: 'horizontal',
      slide: false,
      disabled: false,
      tooltips: false,
      tooltipFormatter: function (value) {
        return value.toString();
      },
      valuetextFormatter: function (value) {
        return value.toString();
      },
      ticks: false,
      filled: false,
      bound: false
      // @todo [~mijordan] provide a mechanism for adding a legend and labels with JS Class Initialization
    },

    values: [],
    $inputs: null,
    $ticks: null,
    $fill: null,
    $handles: null,
    $tooltips: null,
    isVertical: false,
    draggingPosition: -1,
    _inputsOrHandles: null,

    /**
     * reads the options from the markup (classes)
     * TODO optimize
     * @private
     */
    _readOptions: function () {
      // setting default dom attributes if needed
      if (this.$element.hasClass('coral-Slider--vertical')) {
        this.options.orientation = 'vertical';
        this.isVertical = true;
      }

      if (this.$element.hasClass('coral-Slider--tooltips')) {
        this.options.tooltips = true;
      }

      if (this.$element.hasClass('coral-Slider--ticked')) {
        this.options.ticks = true;
      }

      if (this.$element.hasClass('coral-Slider--filled')) {
        this.options.filled = true;
      }

      if (this.$element.hasClass('coral-Slider--bound')) {
        this.options.bound = true;
      }

      if (this.$element.data('slide') || this.$element.hasClass('coral-Slider--slide')) {
        this.options.slide = true;
      }
    },

    /**
     * Set the current value of the slider
     * @param {int}   value   The new value for the slider
     * @param {int}   handleNumber   If the slider has 2 handles, you can specify which one to change, either 0 or 1
     */
    setValue: function (value, handleNumber) {
      handleNumber = handleNumber || 0;

      this._updateValue(handleNumber, value, true); // Do not trigger change event on programmatic value update!
      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
    },

    _renderMissingElements: function () {
      if (!this.$element.find('input').length) {
        var self = this,
          el,
          values = ($.isArray(this.options.value)) ? this.options.value : [this.options.value];
        $.each(values, function (index, value) {
          el = $('<input>');
          el.attr({
            'type': 'range',
            'min': self.options.min,
            'max': self.options.max,
            'step': self.options.step,
            'value': value
          });
          self.$element.append(el);
        });
      }

      if (!this.$element.find('div.coral-Slider-clickarea').length) {
        var el2 = $('<div class="coral-Slider-clickarea">');
        this.$element.prepend(el2); // Prepend: Must be first element to not hide handles!
      }

      // @todo This is not a missing element, so it's odd to have this method called as such
      this.$element.toggleClass('coral-Slider', true);
      this.$element.toggleClass('coral-Slider--vertical', this.options.orientation === 'vertical');
      this.$element.toggleClass('coral-Slider--tooltips', this.options.tooltips); // Not used in CSS
      this.$element.toggleClass('coral-Slider--ticked', this.options.ticks); // Not used in CSS
      this.$element.toggleClass('coral-Slider--filled', this.options.filled); // Not used in CSS
    },

    _processValueChanged: function () {
      var self = this,
        values = ($.isArray(this.options.value)) ? this.options.value : [this.options.value];
      $.each(values, function (index, value) {
        self._updateValue(index, value, true); // Do not trigger change event on programmatic value update!
      });
      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
    },

    _processMinMaxStepChanged: function () {
      var self = this,
          $inputs = this.$inputs;
      $inputs.attr({
        'min': this.options.min,
        'max': this.options.max,
        'step': this.options.step,
        'value': '' // removing the value attribute ensures that _updateValue call that follows actually does something
      });
      if (!this._supportsRangeInput) {
        this.$handles.attr({
          'aria-valuemin': this.options.min,
          'aria-valuemax': this.options.max,
          'aria-valuestep': this.options.step
        });
      }
      $.each(this.values, function (index, value) {
        self._updateValue(index, value, true); // Ensure current values are between min and max
      });

      if (this.options.ticks) {
        this.$element.find('.coral-Slider-ticks').remove();
        this._buildTicks();
      }

      if (this.options.filled) {
        this.$element.find('.coral-Slider-fill').remove();
        this._buildFill();
      }

      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
    },

    _processDisabledChanged: function () {
      if (this.options.disabled) {
        this.$inputs.attr('disabled', 'disabled');
        this.$handles.each(function () {
          // @todo always chain class or cache selectors
          $(this).removeClass('is-focused');
          $(this).parent().removeClass('is-focused');

          if (!this._supportsRangeInput) {
            $(this).attr('aria-disabled', true);
          }
        });
      } else {
        this.$inputs.removeAttr('disabled');
        if (!this._supportsRangeInput) {
          this.$handles.removeAttr('aria-disabled');
        }
      }
      this.$element.toggleClass('is-disabled', this.options.disabled);
    },

    _render: function () {
      var self = this,
          // get maximum max value
          maximums = self.$inputs.map(function () {
            return $(this).attr('max');
          }),
          // get minimum min value
          minimums = self.$inputs.map(function () {
            return $(this).attr('min');
          }),
          // get step step value
          steps = self.$inputs.map(function () {
            return $(this).attr('step');
          });

      self.options.max = Math.max.apply(null, maximums.toArray());
      self.options.min = Math.min.apply(null, minimums.toArray());
      self.options.step = Math.min.apply(null, steps.toArray());

      // Correct the labelling of inputs for accessibility
      this._adjustLabelling();

      // Todo: do not add already existing elements or remove them before adding new elements
      // build ticks if needed
      if (self.options.ticks) {
        self._buildTicks();
      }

      // build fill if needed
      if (self.options.filled) {
        self._buildFill();
      }

      // add css class so that slide animation is done through css transition rather than jQuery.animate
      self.$element.toggleClass('coral-Slider--slide', self.options.slide);

      self._buildHandles();
    },

    _buildTicks: function () {
      // The ticks holder
      var $ticks = $('<div/>').addClass('coral-Slider-ticks'),
          numberOfTicks = Math.round((this.options.max - this.options.min) / this.options.step) - 1,
          trackDimensions = this.isVertical ? this.$element.height() : this.$element.width();

      this.$element.prepend($ticks);
      for (var i = 0; i < numberOfTicks; i++) {
        var position = trackDimensions * (i + 1) / (numberOfTicks + 1),
            percent = (position / trackDimensions) * 100,
            tick = $('<div/>').addClass('coral-Slider-tick').css((this.isVertical ? 'bottom' : 'left'), percent + '%');
        $ticks.append(tick);
      }
      this.$ticks = $ticks.find('.coral-Slider-tick');
      if (this.options.filled) {
        // this._coverTicks();
      }
    },

    _buildFill: function () {
      var self = this;

      this.$fill = $('<div/>').addClass('coral-Slider-fill');

      if (self.values.length !== 0) {
        var percent, fillPercent,
          heightOrWidth = self.isVertical ? 'height' : 'width',
          bottomOrLeft = self.isVertical ? 'bottom' : 'left';
        if (self.values.length < 2) {
          percent = (self.values[0] - self.options.min) / (self.options.max - self.options.min) * 100;
          this.$fill.css(heightOrWidth, percent + '%');
        } else {
          percent = (this._getLowestValue() - self.options.min) / (self.options.max - self.options.min) * 100;
          fillPercent = (this._getHighestValue() - this._getLowestValue()) / (self.options.max - self.options.min) * 100;
          this.$fill.css(heightOrWidth, fillPercent + '%')
            .css(bottomOrLeft, percent + '%');
        }
      }
      this.$element.prepend(this.$fill);
      self.options.filled = true;
    },

    _buildHandles: function () {
      var self = this,
          elementId = self.$element.attr('id');

      // Wrap each input field and add handles and tooltips (if required)
      self.$inputs.each(function (index) {

        var $input = $(this),
            $wrap = $input.wrap('<div/>').parent().addClass('coral-Slider-value'),

            // Add handle for input field
            percent = (self.values[index] - self.options.min) / (self.options.max - self.options.min) * 100,
            percentString =  percent + '%',
            bottomOrLeft = self.isVertical ? 'bottom' : 'left',
            $handle = $('<div/>')
              .addClass('coral-Slider-handle u-coral-openHand')
              .css(bottomOrLeft, percentString)
              .attr({
                'id': elementId + '-handle' + index
              }),
            $tooltip;

        // position the input relative to the slider container element
        $input.css(bottomOrLeft, percentString);
        $wrap.append($handle);

        // Add tooltip to handle if required
        if (self.options.tooltips) {
          // @todo replace with correct classnames for coral-Tooltip-arrow**
          $tooltip = $('<output>' + $input.attr('value') + '</output>')
            .addClass('coral-Tooltip coral-Tooltip--inspect ' + (self.isVertical ? 'coral-Tooltip--positionRight' : 'coral-Tooltip--positionAbove'))
            .attr({
              'role': 'tooltip',
              'aria-hidden': true,
              'id': $input.attr('id') + '-tooltip',
              'for': $input.attr('id')
              });
          $handle.append($tooltip);
        }

        if (self.$inputs.length > 1 && $input.attr('aria-labelledby')) {
          var inputlabelids = $input.attr('aria-labelledby').split(' '), $label;
          for (var i = 0; i < inputlabelids.length; i++) {
            if (i > 0) {
              $label = $('#' + inputlabelids[i]);
              $handle.prepend($label);
            }
          }
        }
      });

      self.$handles = self.$element.find('.coral-Slider-handle');
      self.$tooltips = self.$element.find('.coral-Tooltip');

      self._moveHandles();
    },

    _handleClick: function (event) {
      if (this.options.disabled) return false;
      var self = this,

          // Mouse page position
          mouseX = event.pageX,
          mouseY = event.pageY,

          pointerdown = /^(ms)?pointerdown$/i.test(event.type);

      if (event.type === 'touchstart') {
        var touches = (event.originalEvent.touches.length > 0) ? event.originalEvent.touches : event.originalEvent.changedTouches;
        mouseX = touches[0].pageX;
        mouseY = touches[0].pageY;
      } else if (pointerdown) {
        mouseX = event.originalEvent.clientX + window.pageXOffset;
        mouseY = event.originalEvent.clientY + window.pageYOffset;
      }

      if (mouseX === undefined || mouseY === undefined) return; // Do not use undefined values!

      // Find the nearest handle
      var pos = self._findNearestHandle(mouseX, mouseY);

      var val = self._getValueFromCoord(mouseX, mouseY, true);

      if (!isNaN(val)) {
        self._updateValue(pos, val);
        self._moveHandles();
        if (self.options.filled) {
          self._updateFill();
        }
      }

      if (event.type === 'mousedown' || pointerdown) {
        self.$handles.eq(pos).data('mousedown', true);
      }
      self._inputsOrHandles.eq(pos).focus();
    },

    /**
     * Locates the nearest handle to given mouse coordinates.
     * @return The index position of the handle within the this.$handles collection.
     * @private
     */
    _findNearestHandle: function (mouseX, mouseY) {
      var self = this;

      var closestDistance = Infinity; // Incredible large start value

      // Find the nearest handle
      var pos = 0;
      self.$handles.each(function (index) {

        // Handle position
        var handleX = $(this).offset().left;
        var handleY = $(this).offset().top;

        // Handle Dimensions
        var handleWidth = $(this).width();
        var handleHeight = $(this).height();

        // Distance to handle
        var distance = Math.abs(mouseX - (handleX + (handleWidth / 2)));
        if (self.options.orientation === 'vertical') {
          distance = Math.abs(mouseY - (handleY + (handleHeight / 2)));
        }

        if (distance < closestDistance) {
          closestDistance = distance;
          pos = index;
        }
      });

      return pos;
    },

    /**
     * Handles "oninput" and "onchange" events from the input.
     * @private
     */
    _handleInputChange: function (event) {
      if (this.options.disabled) return false;

      var $input = $(event.target),
          index = this.$inputs.index($input);

      if ($input.val() === this.values[index]) return;

      this.setValue($input.val(), index);

      if ($input.is(document.activeElement)) {
        this.$handles.eq(index).removeData('mousedown');
        this._focus(event);
      }
    },

    /**
     * Handles "focusin" event from  either an input or its handle.
     * @private
     */
    _focus: function (event) {
      if (this.options.disabled) return false;
      var self = this,
        $this = $(event.target),
        $value = $this.closest('.coral-Slider-value'),
        $handle = $value.find('.coral-Slider-handle');

      if (!$handle.data('mousedown')) {
        this.$element.addClass('is-focused');
        $value.addClass('is-focused');
        $handle.addClass('is-focused');
      }

      $(window).on('touchstart.slider pointerdown.slider mspointerdown.slider mousedown.slide', function(event) {
        if ($(event.target).closest(self.$element).length === 1) {
          return;
        }
        $this.trigger('focusout.slider');
      });

    },

    /**
     * Handles "focusout" event from  either an input or its handle.
     * @private
     */
    _blur: function (event) {
      if (this.options.disabled) return false;

      var $this = $(event.target),
        $value = $this.closest('.coral-Slider-value'),
        $handle = $value.find('.coral-Slider-handle');

      this.$element.removeClass('is-focused');
      $value.removeClass('is-focused');
      $handle.removeClass('is-focused').removeData('mousedown');

      $(window).off('touchstart.slider pointerdown.slider mspointerdown.slider mousedown.slider');
    },

    /**
     * Handles "keydown" event from a handle.
     * Should only be needed when this._supportsRangeInput === false, otherwise keyboard events will be handled by the native input[type=range] element.
     * @private
     */
    _keyDown: function (event) {
      if (this.options.disabled) return false;

      var self = this,
        $this = $(event.target),
        which = event.which || event.keyCode,
        $value = $this.closest('.coral-Slider-value'),
        $input = $value.find('input'),
        index = self.$inputs.index($input),
        $handle = self.$handles.eq(index),
        val = Number($input.val()),
        step = Number(self.options.step),
        minimum = Number(self.options.min),
        maximum = Number(self.options.max),
        page = Math.max(step, Math.round((maximum - minimum) / 10)),
        capture = false;

      $handle.removeData('mousedown');
      self._focus(event);

      switch (which) {
        case 40:
        case 37:
          // down/left
          val -= step;
          capture = true;
          break;
        case 38:
        case 39:
          // up/right
          val += step;
          capture = true;
          break;
        case 33:
          // page up
          val += (page - (val % page));
          capture = true;
          break;
        case 34:
          // page down
          val -= (page - (val % page === 0 ? 0 : page - val % page));
          capture = true;
          break;
        case 35:
          // end
          val = maximum;
          capture = true;
          break;
        case 36:
          // home
          val = minimum;
          capture = true;
          break;
      }

      if (capture) {
        event.preventDefault();
      }

      if (val !== Number($input.val())) {
        self.setValue(val, index);
        $input.trigger('change.slider'); // Keep input element value updated too and fire change event for any listeners
      }
    },

    _mouseDown: function (event) {
      if (this.options.disabled) return false;

      event.preventDefault();

      var self = this, $handle;

      this.draggingPosition = -1;
      this.$handles.each(function (index, handle) {
        if (handle === event.target) self.draggingPosition = index;
      });

      this.$tooltips.each(function (index, tooltip) {
        if (tooltip === event.target) self.draggingPosition = index;
      });

      // Did not touch any handle? Emulate click instead!
      if (this.draggingPosition < 0) {
        this._handleClick(event);
        return;
      }

      $handle = this.$handles.eq(this.draggingPosition);

      $handle.addClass('is-dragged');
      $('body').addClass('u-coral-closedHand');

      $(window).on('touchmove.slider pointermove.slider mspointermove.slider mousemove.slider', this._handleDragging.bind(this));
      $(window).on('touchend.slider pointerup.slider mspointerup.slider mouseup.slider', this._mouseUp.bind(this));

      if (event.type === 'mousedown' || /^(ms)?pointerdown$/i.test(event.type)) {
        $handle.data('mousedown', true);
      }

      this._inputsOrHandles.eq(this.draggingPosition).focus();
    },

    _handleDragging: function (event) {
      var mouseX = event.pageX,
          mouseY = event.pageY;

      // Handle touch events
      if (event.originalEvent.targetTouches) {
        var touch = event.originalEvent.targetTouches.item(0);
        mouseX = touch.pageX;
        mouseY = touch.pageY;
      } else if (/^(ms)?pointermove$/i.test(event.type)) {
        mouseX = event.originalEvent.clientX + window.pageXOffset;
        mouseY = event.originalEvent.clientY + window.pageYOffset;
      }

      this._updateValue(this.draggingPosition, this._getValueFromCoord(mouseX, mouseY));
      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
      event.preventDefault();
    },

    _mouseUp: function () {
      this.$handles.eq(this.draggingPosition).removeClass('is-dragged');
      $('body').removeClass('u-coral-closedHand');

      this.draggingPosition = -1;
      $(window).off('mousemove.slider mspointermove.slider pointermove.slider touchmove.slider');
      $(window).off('mouseup.slider mspointerup.slider pointerup.slider touchend.slider');
    },

    _clickLabel: function (event) {
      if (this.options.disabled) return;
      this._inputsOrHandles.eq(0).focus();
    },

    _updateValue: function (pos, value, doNotTriggerChange) {
      var self = this,
          $input = self.$inputs.eq(pos),
          valueString = value.toString(),
          $relatedInput,
          boundary,
          minmax = ['min','max'],
          updatedAttributes = {},
          ariaAttribute;

      if ($input.val() !== valueString ||
          $input.attr('value') !== valueString ||
          self.values[pos] !== valueString) {

        // snap the new value to the appropriate step
        value = this._snapValueToStep(value, this.options.min,  this.options.max, this.options.step);

        // if this is a bound slider we need to:
        // 1. make sure that the new value is bounded by the value of the related input.
        // 2. adjust the min or max value on the related input so that it is bounded by the new value
        // 3. update the appropriate attributes on the input and handle
        if (self.$inputs.length === 2 && this.options.bound) {
          // pos is 0 || 1, so the related input's index is !pos
          $relatedInput = self.$inputs.eq(!pos);

          // the boundary is the current value of the relatedInput
          boundary = Number($relatedInput.val());

          // depending on the index of the input, limit the value using either Math.min or Math.max
          // (for pos === 0, use Math.min, for pos === 1, use Math.max)
          value = Math[ minmax[pos] ](value, boundary);

          // depending on the index of the input, set the min/max attribute on the related input
          // (for pos === 0, use [min], for pos === 1, use [max])
          $relatedInput.attr(minmax[pos], value);

          // depending on the index of the input, set the min/max attribute on the input
          // (for pos === 0, use [max], for pos === 1, use [min])
          ariaAttribute = minmax[!pos];
          $.extend(updatedAttributes, {
            ariaAttribute: boundary
          });
        }

        self.values[pos] = value.toString();

        $.extend(updatedAttributes, {
          'value': value,
          'aria-valuetext': self._supportsRangeInput ? self.options.valuetextFormatter(value) : null
        });

        $input.val(value).attr(updatedAttributes);

        if (!this._supportsRangeInput) {
          // depending on the index of the input,
          // set the aria-valuemin/aria-valuemax, aria-valuenow and aria-valuetext for the handles
          self.$handles.each(function (i, handle) {
            var isPos = (i === pos),
                boundaryOrValue = isPos ? boundary : value;
            ariaAttribute = 'aria-value' + minmax[!isPos];
            updatedAttributes = {
              ariaAttr: boundaryOrValue
            };
            if (isPos) {
              $.extend(updatedAttributes, {
                'aria-valuenow': value,
                'aria-valuetext': self.options.valuetextFormatter(value)
              });
            }
            $(handle).attr(updatedAttributes);
          });
        }

        if (!doNotTriggerChange) {
          setTimeout(function () {
            $input.change(); // Keep input element value updated too and fire change event for any listeners
          }, 1); // Not immediatly, but after our own work here
        }
      }
    },

    _moveHandles: function () {
      var self = this;

      // Set the handle position as a percentage based on the stored values
      this.$handles.each(function (index,  handle) {
        var $handle = $(handle),
            percent = (self.values[index] - self.options.min) / (self.options.max - self.options.min) * 100,
            $input = self.$inputs.eq(index),
            $tooltip;

        if (self.options.orientation === 'vertical') {
          $handle.css('bottom', percent + '%');
          $input.css('bottom', percent + '%');
        } else { // Horizontal
          $handle.css('left', percent + '%');
          $input.css('left', percent + '%');
        }

        // Update tooltip value (if required)
        if (self.options.tooltips) {
          $tooltip = self.$tooltips.eq(index);
          $tooltip.html(self.options.tooltipFormatter(self.values[index]));

          // adjust position of tooltip to accommodate the updated value.
          if (self.options.orientation === 'vertical') {
             $tooltip.css('top', -(($tooltip.outerHeight() + $handle.outerHeight() / 2) / 2) + 'px');
          } else {
            $tooltip.css('left', -(($tooltip.outerWidth() + $handle.outerWidth() / 2) / 2) + 'px');
          }
        }
      });
    },

    _updateFill: function () {
      var self = this;
      var percent;

      if (self.values.length !== 0) {
        if (self.values.length === 2) { // Double value/handle
          percent = ((self._getLowestValue() - self.options.min) / (self.options.max - self.options.min)) * 100;
          var secondPercent = ((self._getHighestValue() - self.options.min) / (self.options.max - self.options.min)) * 100;
          var percentDiff = secondPercent - percent;
          if (self.options.orientation === 'vertical') {
            self.$fill.css('bottom', percent + '%').css('height', percentDiff + '%');
          } else { // Horizontal
            self.$fill.css('left', percent + '%').css('width', percentDiff + '%');
          }
        } else { // Single value/handle
          percent = ((self.values[0] - self.options.min) / (self.options.max - self.options.min)) * 100;
          if (self.options.orientation === 'vertical') {
            self.$fill.css('height', percent + '%');
          } else {
            self.$fill.css('width', percent + '%');
          }
        }
      }
      if (self.options.ticks) {
        self._coverTicks();
      }
    },

    _coverTicks: function () {
      var self = this;

      // Ticks covered by the fill are given a different class
      self.$ticks.each(function (index) {
        var value = self._getValueFromCoord($(this).offset().left, $(this).offset().top);
        if (self.values.length === 2) { // @todo Figure out what previous comitter said when they wrote "add a parameter to indicate multi values/handles" here
          if ((value >= self._getLowestValue()) && (value <= self._getHighestValue())) {
            $(this).addClass('coral-Slider-tick--covered');
          }
          else {
            $(this).removeClass('coral-Slider-tick--covered');
          }
        }
        else {
          if (value <= self._getHighestValue()) {
            $(this).addClass('coral-Slider-tick--covered');
          }
          else {
            $(this).removeClass('coral-Slider-tick--covered');
          }
        }
      });
    },

    _getValueFromCoord: function (posX, posY, restrictBounds) {
      var self = this,
          percent,
          elementOffset = self.$element.offset();

      if (self.options.orientation === 'vertical') {
        var elementHeight = self.$element.height();
        percent = ((elementOffset.top + elementHeight) - posY) / elementHeight;
      } else {
        var elementWidth = self.$element.width();
        percent = ((posX - elementOffset.left) / elementWidth);
      }

      // if the bounds are retricted, as with _handleClick, we souldn't change the value.
      if (restrictBounds && (percent < 0 || percent > 1)) return NaN;

      var rawValue = self.options.min * 1 + ((self.options.max - self.options.min) * percent);

      // Snap value to nearest step
      return this._snapValueToStep(rawValue, self.options.min, self.options.max, self.options.step);
    },

    _getHighestValue: function () {
      return Math.max.apply(null, this.values);
    },

    _getLowestValue: function () {
      return Math.min.apply(null, this.values);
    },

    /**
     * Initializes inputs and handles for accessibility.
     * If the user agent supports input[type=range], the inputs should receive keyboard focus and keyboard events should be handled natively.
     * When the user agent does not support input[type=range], the handles should implement the WAI-ARIA Slider widget design pattern.
     * @private
     */
    _makeAccessible: function () {
      var self = this,
          $input, $handle;

      this.$inputs.each(function(i, inputElement) {
        $input = $(inputElement);
        $handle =  self.$handles.eq(i);

        if (self._supportsRangeInput) {
          $input.attr({
            'aria-valuetext': self.options.valuetextFormatter($input.attr('value')),
            'aria-hidden': null,
            'tabindex': null
          });
          $handle.attr({
            'role': null,
            'aria-valuemin': null,
            'aria-valuemax': null,
            'aria-valuestep': null,
            'aria-valuenow': null,
            'aria-valuetext': null,
            'tabindex': null,
            'aria-labelledby': null
          });
          $('label[for="#' + $handle.attr('id') + '"]').attr('for', $input.attr('id'));
        } else {
          $input.attr({
            'aria-valuetext': null,
            'aria-hidden': true,
            'tabindex': -1
          });
          $handle.attr({
            'role': 'slider',
            'aria-valuemin': $input.attr('min'),
            'aria-valuemax': $input.attr('max'),
            'aria-valuestep': $input.attr('step'),
            'aria-valuenow': $input.attr('value'),
            'aria-valuetext': self.options.valuetextFormatter($input.attr('value')),
            'tabindex': !$input.is(':disabled') ? 0 : null,
            'aria-labelledby': $input.attr('aria-labelledby') || null
          });
          $('label[for="' + $input.attr('id') + '"]').attr('for', $handle.attr('id'));
        }
      });

      if (!self._supportsRangeInput) {
        this._inputsOrHandles = this.$handles;
        this.$element.on('keydown.slider', '[role=slider].coral-Slider-handle' , this._keyDown.bind(this));
      } else {
        this._inputsOrHandles = this.$inputs;
        this.$element.off('keydown.slider');
      }

      // update values to make sure that all aria attributes and values are in sync
      $.each(this.values, function (i, value){
        self._updateValue(i, value, true);
      });
    },

    /**
     * Ensure that legend and label elements correctly label the inputs of the slider,
     * and adjusts the DOM so that labels don't break the layout of the CUI.Slider.
     * @private
     */
    _adjustLabelling: function () {
      var self = this,
        elementId = this.$element.attr('id'),
        $legend = this._adjustFieldsetAndLegend();

      this._adjustInputLabels($legend);
    },

    /**
     * Sliders with two inputs should be contained within a fieldset
     * with a legend element as its first child, which provides a label for the grouping.
     *
     * This method corrects the DOM of the fieldest and legend elements
     * so that they don't break the layout of the CUI.Slider.
     *
     * @return {jQuery} the new legend element
     * @private
     */
    _adjustFieldsetAndLegend: function () {
      var self = this,
        elementId = this.$element.attr('id'),
        // sliders with two inputs should be contained within a fieldset to provide a label for the grouping
        $fieldset = this.$element.children('fieldset'),
        $legend = $fieldset.children('legend'),
        $group, $grouplegend;

      // [~dantipa]
      // this block has to be optimized
      // taking the content of fieldset and appending it somewhere else causes flashing
      // future markup should be like the expected markup (breaking change)
      if ($fieldset.length) {
        // move all fieldset children other than the legend to be children of the element.
        this.$element.append($fieldset.contents(':not(legend)'));

        // create a new wrapper div with role="group" and class="coral-Slider-fieldset", which will behave as a fieldset but render as an inline block
        $group = $('<div/>', {
          'role': 'group',
          'class': 'coral-Slider-fieldset'
        }).insertBefore(this.$element);

        // wrap the element with the new "coral-Slider-fieldset " div.
        // [~mijordan] we wrap the div so that the label or legend for the slider
        // can be displayed without interfering with the generated markup elements for the slider
        // which are absolutely positioned relative to the coral-Slider element.
        $group.append(this.$element);

        if ($legend.length) {
          // create new label element and append the contents of the legend
          $grouplegend = $('<div/>');
          $grouplegend.append($legend.contents());

          // give the new label element all the same attributes as the legend
          $.each($legend.prop('attributes'), function () {
            $grouplegend.attr(this.name, this.value);
          });

          // if the new grouplegend has no id, which would have been inherited from the original legend, assign one.
          if (!$grouplegend.attr('id')) {
            $grouplegend.attr('id', elementId + '-legend');
          }

          // replace the original fieldset, which now only contains the original legend, with the new legend label element
          $fieldset.replaceWith($grouplegend);

          // insert the new grouplegend before the element
          $legend = $grouplegend.insertBefore(this.$element);

          // the group should be labelled by the legend
          $group.attr('aria-labelledby', $legend.attr('id'));
        }
      }

      return $legend;
    },

    /**
     * Explicitly associates the legend and labels to the inputs they label.
     * Adjusts the DOM so that the label doesn't break the layout of the CUI.Slider.
     * @private
     */
    _adjustInputLabels: function (legend) {
      var self = this,
          elementId = this.$element.attr('id'),
          $legend = $(legend);

      this.$inputs.each(function (index, input) {
        var $input = $(input),
            inputId = $input.attr('id'),
            $label,
            ariaLabelledby = $input.attr('aria-labelledby');

        // if the input doesn't have an id, make one
        if (!inputId) {
          $input.attr('id', elementId + '-input' + index);
          inputId = $input.attr('id');
        }

        if (!ariaLabelledby) {
          ariaLabelledby = '';
          $input.attr('aria-labelledby', ariaLabelledby);
        }

        // existing labels that use the "for" attribute to identify the input
        $label = self.$element.find('label[for="' + inputId + '"]');

        // If we have a legend, the input should first be labelled by the legend.
        // On Windows, screen readers do a good job of announcing the containing group when identifying the control,
        // so we exclude Windows to prevent double voicing of the legend.
        if ($legend.length && window.navigator.platform.indexOf('Win') === -1) {
          if (ariaLabelledby.indexOf($legend.attr('id')) === -1) {
            ariaLabelledby = $legend.attr('id') + (ariaLabelledby.length ? ' ' : '') + ariaLabelledby;
            $input.attr('aria-labelledby', ariaLabelledby);
          }
        }

        // for existing labels that use the "for" attribute to identify the input,
        if ($label.length) {
          // if the label is not the input's parent, move it before the slider element tag
          $label.not($input.parent()).insertBefore(self.$element);
          $label.each(function (index) {
            // if the label doesn't have an id, create one
            if (!$(this).attr('id')) {
              $(this).attr('id', inputId + '-label' + index);
            }

            // explicity identify the input's label
            if (ariaLabelledby.indexOf(inputId + '-label' + index) === -1) {
              ariaLabelledby = ariaLabelledby + (ariaLabelledby.length ? ' ' : '') + inputId + '-label' + index;
              $input.attr('aria-labelledby', ariaLabelledby);
            }

            $(this).on('mousedown.slider', function (event) {
              self._inputsOrHandles.eq(index).focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            });
          });
        }

        // if the input is contained by a label
        if ($input.parent().is('label')) {
          $label = $input.parent();

          // make sure it has an id
          if (!$label.attr('id')) {
            $label.attr('id', inputId + '-label');
          }

          // make sure it explicitly identifies the input it labels
          if (!$label.attr('for')) {
            $label.attr('for', inputId);
          }

          // move the input after the label
          $input.insertAfter($label);

          // if there is a legend, this is a two thumb slider; internal labels identify the minimum and maximum, and they should have the class="u-coral-screenReaderOnly"
          // aria-hidden=true hides the label from screen readers, but keeps it in the DOM as a label for the input;
          // the label should never be read independent of the input.
          if ($legend.length) {
            $label.addClass('u-coral-screenReaderOnly')
              .attr({
                'aria-hidden': true
              });
          }

          // move the label outside the slider element tag
          $label.insertBefore(self.$element);
        }

        // if the input has a label that is not included in the aria-labelledby attribute, add the label id to the "aria-labelledby" attribute
        if ($label.length && ariaLabelledby.indexOf($label.attr('id')) === -1) {
          ariaLabelledby = ariaLabelledby + (ariaLabelledby.length ? ' ' : '') + $label.attr('id');
          $input.attr('aria-labelledby', ariaLabelledby);
        }

        if ($label.length === 0 && ariaLabelledby.length > 0) {
          $label = $('#' + ariaLabelledby.split(' ')[0]);
        }

        if (ariaLabelledby.length === 0) {
          $input.removeAttr('aria-labelledby');
        }

        // clicking on a label or legend should focus the first input or handle in the group
        if (index === 0) {
          if ($label.length) {
            $label.on('click.slider', self._clickLabel.bind(self));
          }

          if ($legend.length) {
            $legend.on('click.slider', self._clickLabel.bind(self));
          }
        }
      });
    },

    /**
     * Boolean to flag support for HTML5 input[type=range]
     * @private
     */
    _supportsRangeInput: (function () {
      var i = document.createElement('input');
      i.setAttribute('type', 'range');
      return (i.type === 'range');
    })(),

    _snapValueToStep:function(rawValue, min, max, step) {
      step = parseFloat(step);
      var remainder = ((rawValue - min) % step), snappedValue,
          floatString = step.toString().replace(/^(?:\d+)(?:\.(\d+))?$/g, '$1'),
          precision = floatString.length;

      if (Math.abs(remainder) * 2 >= step) {
        snappedValue = (rawValue - Math.abs(remainder)) + step;
      } else {
        snappedValue = rawValue - remainder;
      }

      if (snappedValue < min) {
        snappedValue = min;
      } else if (snappedValue > max) {
        snappedValue = min + Math.floor((max - min) / step) * step;
      }

      // correct floating point behavior by rounding to step precision
      if (precision > 0) {
        snappedValue = parseFloat(snappedValue.toFixed(precision));
      }

      return snappedValue;
    }

    /*
    update: function() {
     // @todo Figure out what last committer meant when they wrote "Single update method" here
    }
    */
  });

  CUI.Widget.registry.register('slider', CUI.Slider);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (e) {
      CUI.Slider.init($('.coral-Slider[data-init~="slider"]', e.target));
    });
  }
}(jQuery, this));


(function ($) {
  CUI.LabeledSlider = new Class(/** @lends CUI.LabeledSlider# */{
    toString: 'LabeledSlider',
    extend: CUI.Slider,

    /**
     @extends CUI.Slider
     @classdesc <p><span id="slider-label">A slider widget with labeled ticks</span></p>


     <p>
     The labeled slider uses the same options/markup as the slider label, but with one addition: You can provide a list of labels for the
     slider's ticks. (And of course use data-init="labeled-slider"!)
     </p>
     <p><em>Please note</em> that you have to list the labels for the ticks exactly in the order and count that you configured
     your slider's ticks. If your slider has 5 ticks, provide 5 labels for it. The number of ticks depends on the step / min / max values and
     can be calculated by ceil((max - min) / step) - 1.</p>

     @desc Creates a labeled slider from a div
     @constructs

     @param {Object}   options                               Component options
     @param {number} [options.step=1]  The steps to snap in
     @param {number} [options.min=1]   Minimum value
     @param {number} [options.max=100] Maximum value
     @param {number} [options.value=1] Starting value
     @param {number} [options.tooltips=false] Show tooltips?
     @param {String} [options.orientation=horizontal]  Either 'horizontal' or 'vertical'
     @param {boolean} [options.slide=false]    True for smooth sliding animations. Can make the slider unresponsive on some systems.
     @param {boolean} [options.disabled=false] True for a disabled element
     @param {boolean} [options.bound=false] For multi-input sliders, indicates that the min value is bounded by the max value and the max value is bounded by the min
     @param {boolean} [options.alternating=false] Staggers the layout of tick labels.
     **/
    construct: function () {
      this.$element.addClass("coral-Slider--labeled");

      if (this.options.alternating) {
        this.$element.addClass("coral-Slider--alternatingLabels");
      }
    },

    defaults: $.extend(CUI.Slider.prototype.defaults, {
      'alternating': false
    }),

    /**
     * reads the options from the markup (classes)
     * @private
     */
    _readOptions: function () {
      this.inherited(arguments);

      if (this.$element.hasClass("coral-Slider--alternatingLabels")) {
        this.options.alternating = true;
      }
    },

    _getTickLabel: function (index) {
      var el = this.$element.find("ul.coral-Slider-tickLabels li").eq(index);
      return el.html();
    },

    _buildTicks: function () {
      var self = this,

          // The ticks holder
          $ticks = $("<div></div>").addClass('coral-Slider-ticks'),
          numberOfTicks = Math.ceil((self.options.max - self.options.min) / self.options.step) + 1,
          trackDimensions = self.isVertical ? self.$element.height() : self.$element.width(),
          maxSize = 100 * (trackDimensions / (numberOfTicks)) / trackDimensions;

      this.$element.append($ticks);

      if (this.options.alternating) {
        maxSize *= 2;
      }

      for (var i = 0; i < numberOfTicks; i++) {
        var position = trackDimensions * (i) / (numberOfTicks - 1),
            percent = (position / trackDimensions) * 100,
            tick = $('<div/>').addClass('coral-Slider-tick').css((self.isVertical ? 'bottom' : 'left'), percent + "%"),
            tickLabelId = 'coral-Slider-tickLabel-' + self.$element.attr('id') + '-'+ i,
            ticklabel = $('<div/>').addClass('coral-Slider-tickLabel').attr('id', tickLabelId);
        $ticks.append(tick);
        if (!self.isVertical) percent -= maxSize / 2;
        ticklabel.css((self.isVertical ? 'bottom' : 'left'), percent + "%");
        if (!self.isVertical) ticklabel.css('width', maxSize + "%");
        ticklabel.append(self._getTickLabel(i));
        $ticks.append(ticklabel);
      }
      self.$ticks = $ticks.find('.coral-Slider-tick');
      if (self.options.filled) {
        self._coverTicks();
      }
    },

    /**
     * Finds the nearest tick and assigns its corresponding label to the slider's aria-describedby property.
     * @private
     */
    _moveHandles: function () {
      var self = this;
      this.inherited(arguments);

      if (!this.$ticks || this.$ticks.length === 0) return;

      this.$inputs.each(function (index) {
        var $input = self.$inputs.eq(index),
          $handle = self.$handles.eq(index),
          inputOffset = $input.offset(),
          inputX = inputOffset.left + $input.width() / 2,
          inputY = inputOffset.top + $input.height() / 2,
          tickPos = self._findNearestTick(inputX, inputY),
          $tickLabel = self.$ticks.eq(tickPos).next('.coral-Slider-tickLabel');

        (self._supportsRangeInput ? $input : $handle).attr({
          'aria-describedby': $tickLabel.attr('id')
        });
      });
    },

    /**
     * Finds the nearest tick relative to a given offset coordinates.
     * @private
     */
    _findNearestTick: function (posX, posY) {
      if (!this.$ticks || this.$ticks.length === 0) return;
      var self = this,
          closestDistance = Infinity, // Incredible large start value
          // Find the nearest handle
          pos = 0;

      self.$ticks.each(function (index) {

        // Handle position
        var tickX = $(this).offset().left,
          tickY = $(this).offset().top,

        // Handle Dimensions
          tickWidth = $(this).width(),
          tickHeight = $(this).height(),

        // Distance to tick
          distance = Math.abs(posX - (tickX + (tickWidth / 2)));
        if (self.options.orientation === 'vertical') {
          distance = Math.abs(posY - (tickY + (tickHeight / 2)));
        }

        if (distance < closestDistance) {
          closestDistance = distance;
          pos = index;
        }
      });

      return pos;
    }
  });

  CUI.Widget.registry.register("labeled-slider", CUI.LabeledSlider);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      CUI.LabeledSlider.init($(".coral-Slider[data-init~='labeled-slider']", e.target));
    });
  }
}(window.jQuery));




(function ($, window, undefined) {
  CUI.ColumnView = new Class(/** @lends CUI.ColumnView */{
    toString: 'ColumnView',
    extend: CUI.Widget,

    defaults: {
      multiselect: false,
      single: false
    },

    /**
     * Creates a new ColumnView
     *
     * @extends CUI.Widget
     * @classdesc A widget for column-based (miller or single) navigation
     * @constructs
     * @param {Object} options Component options
     * @param {Boolean} [options.multiselect=false] whether multiple items should be selectable
     * @param {Boolean} [options.single=false] whether the widget should be single column mode, which means that a single column is
     *        displayed at one time; good for low-horizontal space situations
     */
    construct: function() {
      // bind/overwrite this functions so we can remove listeners specific to this instance later
      this._handleDocumentKeyUp = this._handleDocumentKeyUp.bind(this);
      this._handleDocumentKeyDown = this._handleDocumentKeyDown.bind(this);

      this._activeColumnRequest = 0;

      this.$element.addClass('coral-ColumnView');

      if (this.get('single') || this.$element.hasClass('coral-ColumnView--single')) {
        this.set('single', true);
        this.$element.addClass('coral-ColumnView--single');
      }

      if (this.get('multiselect') || this.$element.hasClass('coral-ColumnView--multiselect')) {
        this.set('multiselect', true);
        this.$element.addClass('coral-ColumnView--multiselect');
      }

      // select: tap the text: single selection
      this.$element.on('click', '.coral-ColumnView-item', this._itemActivateHandler.bind(this));

      // check: tap the icon: multiple selection
      this.$element.on('click', '.coral-ColumnView-icon', this._itemSelectHandler.bind(this));

      // handles clicking the body of the column content
      this.$element.on('click', '.coral-ColumnView-column-content', this._columnContentHandler.bind(this));

      // if there is a data-src then we load the data
      if (this.get('src')) {
        this.setSource(this.get('src'));
      } else {
        // otherwise we just initialize the current column
        this._loadInnerMarkup();
      }

      this._makeAccessible();
    },

    /**
     * Cleans up the component by removing any internal data and listeners. The component should be
     * used anymore after calling this method.
     *
     * @instance
     */
    destroy: function() {
      // removes the reference to the coral component
      this.$element.removeData('columnView');

      // removes the item elements
      this.$element.off('click', '.coral-ColumnView-item');
      this.$element.off('click', '.coral-ColumnView-icon');
      this.$element.off('click', '.coral-ColumnView-column-content');

      // removes the listener for keyboard navigation
      this.$element.off('keydown');

      // removes the scroll event
      this.$element.find('.coral-ColumnView-column-content').off('scroll');

      // remove document-level listeners
      // this will remove listeners only for this instance
      // as the methods are overwritten with bound versions in construct
      $(document).off('keyup', this._handleDocumentKeyUp);
      $(document).off('keydown', this._handleDocumentKeyDown);

      // deletes the internal variables
      delete this._data;
      delete this.$element;
    },

    /** @private */
    _handleDocumentKeyUp: function(event) {
      if (event.which === 16) {
        this.$element.removeClass('is-unselectable');
      }
    },

    /** @private */
    _handleDocumentKeyDown: function(event) {
      if (event.which === 16) {
        this.$element.addClass('is-unselectable');
      }
    },

    /** @private */
    _makeAccessible: function() {
      this.$element.attr('tabindex', '0');

      // removes the user-select when shift is up
      $(document).on('keyup', this._handleDocumentKeyUp);

      // removes the user-select when shift is up
      $(document).on('keydown', this._handleDocumentKeyDown);

      this.$element.on('keydown', function(event) {

        var captureEvent = false;

        var $selectedItems = this.getSelectedItems();
        var $activeColumn;
        var lastSelected = this.$element.data('lastSelected');

        if ($selectedItems.length > 0) {
            switch(event.which) {
            case 38: // up
              captureEvent = true;
              if (event.shiftKey) {
                if(lastSelected.item.is(':not(:first-child)')) {
                  if(!lastSelected.direction || lastSelected.direction === 'up') {
                    lastSelected.item = lastSelected.item.prev();

                    if(lastSelected.item.hasClass('is-selected') && !lastSelected.item.prev().hasClass('is-selected')) {
                      lastSelected.item = lastSelected.item.prev();
                    }
                  }

                  lastSelected.item.find('.coral-ColumnView-icon').trigger('click');

                  if(lastSelected.item.hasClass('is-selected') && lastSelected.item.prev().hasClass('is-selected')) {
                    lastSelected.item = lastSelected.item.prevUntil(':not(.is-selected)').last();
                  }

                  $selectedItems = this.getSelectedItems();
                  if($selectedItems.length === 1 && $selectedItems[0].item.is(':first-child')) {
                    lastSelected.item = $selectedItems[0].item.next();
                  }

                  this.$element.data('lastSelected', {
                    item: lastSelected.item,
                    direction: 'up'
                  });
                }
              } else {
                if ($selectedItems[0].item.prev().length !== 0) {
                  $selectedItems[0].item.prev().trigger('click');
                } else if ($selectedItems.length > 1) {
                  $selectedItems[0].item.trigger('click');
                }
              }
              break;
            case 40: // down
              captureEvent = true;
              if (event.shiftKey) {
                if(lastSelected.item.is(':not(:last-child)')) {
                  if(!lastSelected.direction || lastSelected.direction === 'down') {
                    lastSelected.item = lastSelected.item.next();

                    if(lastSelected.item.hasClass('is-selected') && !lastSelected.item.next().hasClass('is-selected')) {
                      lastSelected.item = lastSelected.item.next();
                    }
                  }

                  lastSelected.item.find('.coral-ColumnView-icon').trigger('click');

                  if(lastSelected.item.hasClass('is-selected') && lastSelected.item.next().hasClass('is-selected')) {
                    lastSelected.item = lastSelected.item.nextUntil(':not(.is-selected)').last();
                  }

                  if($selectedItems.length === 1 && $selectedItems[0].item.is(':last-child')) {
                    lastSelected.item = $selectedItems[0].item;
                  }

                  $selectedItems = this.getSelectedItems();
                  if($selectedItems.length === 1 && $selectedItems[0].item.is(':last-child')) {
                    lastSelected.item = $selectedItems[0].item.prev();
                  }

                  this.$element.data('lastSelected', {
                    item: lastSelected.item,
                    direction: 'down'
                  });
                }
              } else {
                if ($selectedItems[$selectedItems.length - 1].item.next().length !== 0) {
                  $selectedItems[$selectedItems.length - 1].item.next().trigger('click', {metaKey: true});
                } else if ($selectedItems.length > 1) {
                  $selectedItems[$selectedItems.length - 1].item.trigger('click');
                }
              }
              break;
            case 39: // right
              captureEvent = true;

              if ($selectedItems[0].item.hasClass('coral-ColumnView-item--hasChildren')) {
                $activeColumn = this._getActiveColumn();
                $activeColumn.next().find('.coral-ColumnView-item').first().trigger('click');
              }
              break;
            case 37: // left
              captureEvent = true;

              $activeColumn = this._getActiveColumn();
              $activeColumn.prev().find('.coral-ColumnView-item.is-active').trigger('click');
              break;
          }

        } else {

          var $column = this.$element.children('.coral-ColumnView-column').first();
          var $item = $column.find('.coral-ColumnView-item');
          switch(event.which) {
            case 38: // up
              $item = $item.last();
              $item.trigger('click');
              this.$element.data('lastSelected', {
                item: $item,
                direction: 'up'
              });

              captureEvent = true;
              break;
            case 40: // down
            case 39: // right
              $item = $item.first();
              $item.trigger('click');
              this.$element.data('lastSelected', {
                item: $item,
                direction: 'down'
              });

              captureEvent = true;
              break;
          }
        }

        if (captureEvent) {
          event.stopImmediatePropagation();
          event.preventDefault();
        }

      }.bind(this));
    },

    /**
     * Initializes the component without a source.
     * @private
     */
    _loadInnerMarkup: function() {

      if(this.$element.children().length > 0) {
        // current markup inside the component
        var loadedColumn = this.$element.html();

        // stores the inner html as a the main content
        this._data = {};
        // stores the initial markup as the root
        this._data['/'] = loadedColumn;

        // clears the inner contents to properly initialize the column
        this.$element.empty();

        var activeColumnRequest = ++this._activeColumnRequest;
        this.setNextColumn('/').done(function(data, $column) {
          this._setActiveColumn($column, false, activeColumnRequest);
        }.bind(this));
      }
    },

    /**
     * Set the source for this ColumnView. This wipes any pre-existing data in this widget.
     *
     * @instance
     * @param {String} sourceHref the URL to load; this will be used for the first column in the widget
     * @returns {jQuery.Deferred} a promise that will be accepted when the data has been loaded and the first column rendered, or rejected
     *          if the data fails to load
     */
    setSource: function(sourceHref) {
      this.cancelNavigation();

      var deferred = $.Deferred();
      this._data = {};
      this.$element.empty();

      var activeColumnRequest = ++this._activeColumnRequest;
      this.setNextColumn(sourceHref).done(function(data, $column) {
        this._setActiveColumn($column, false, activeColumnRequest);
        deferred.resolve();
      }.bind(this)).fail(function() {
        deferred.reject();
      });

      return deferred.promise();
    },

    /**
     * Set raw data for this ColumnView
     *
     * @instance
     * @param {Object} data the data to set; needs to contain at least a self link
     * @param {Boolean} [clear=false] whether to wipe pre-existing data from the widget and set <code>data</code> as the first (and only) column
     */
    setData: function(data, clear) {
      if (!data._links || !data._links.self ||!data._links.self.href) {
        throw 'Invalid data: needs to contain self link (_links.self.href)';
      }
      var href = data._links.self.href;

      this._data = clear || !this._data ? {} : this._data;

      this._storeData(data);

      if (clear) {
        this.cancelNavigation();

        this.$element.empty();
        var activeColumnRequest = ++this._activeColumnRequest;
        this.setNextColumn(href).done(function(data, $column) {
          this._setActiveColumn($column, false, activeColumnRequest);
        }.bind(this));
      }
    },

    /**
     * Get the selected items. This does not include the breadcrumb items of other columns.
     *
     * @instance
     * @returns {Array}
     */
    getSelectedItems: function() {
      var items = [];
      this._getColumnContent(this._getActiveColumn()).children('.is-active').each(function(i, item) {
        var $item = $(item);
        items.push({
          'checked': $item.hasClass('is-selected'),
          'data': $item.data('data'),
          'item': $item
        });
      });
      return items;
    },

    /**
     * Get the items of the breadcrumb i.e. selected items not located in the active column.
     *
     * @instance
     * @returns {Array}
     */
    getBreadcrumbItems: function() {
      var breadcrumbs = [];
      this._getActiveColumn().prevAll().find('.is-active').each(function(i, item) {
        var $item = $(item);
        breadcrumbs.push({
          'checked': $item.hasClass('is-selected'),
          'data': $item.data('data'),
          'item': $item
        });
      });
      return breadcrumbs;
    },

    /**
     * Get the column where actions like adding or pasting items will be applied to. If a single folder is selected
     * this would be the sub column and otherwise the active column.
     *
     * @instance
     * @returns {Object} the data associated with the target column.
     */
    getTargetColumn: function() {
      var activeColumn = this._getActiveColumn();
      var items = this.getSelectedItems().filter(function(item) { return !item.checked; });
      if (items.length === 1 && items[0].data && items[0].data.hasChildren) {
        return activeColumn.next().data('data');
      } else {
        return activeColumn.data('data');
      }
    },

    /**
     * Navigate multiple levels at once.
     *
     * @instance
     * @param  {function} itemFinder a function that finds the item to select in a column; arguments: columnData, $column; the return value
     *                               of this function can be: an item (jQuery object, data object or href) that is to be selected,
     *                               <code>false</code> if the navigation is finished or <code>undefined</code> if the item was not found;
     *                               note that this method can be called multiple times for the same column if more data is available for it
     * @param  {jQuery} [column] the column where to start the navigation ("active", href or jQuery object); if omitted, the first column
     *                           is used
     * @return {jQuery.Deferred} a promise that will be resolved when the navigation is finished or rejected if some error occurs (e.g. an
     *                           item is not found); aditionally, the deferred object will have a <code>navigationId</code> property which
     *                           can be used in conjunction with {@link #cancelNavigation}.
     */
    navigate: function(itemFinder, column) {
      var self = this;
      var deferred = $.Deferred();
      var $column;
      if (!column) {
         $column = self.$element.find(".coral-ColumnView-column:eq(0)");
      } else if (column === 'active') {
        $column = self._getActiveColumn();
      } else if (typeof column === 'string') {
        $column = self.$element.children().filter(function() {
          return $(this).data('href') === column;
        });
      } else if (column instanceof $) {
        $column = column;
      }
      $column.nextAll().remove();

      self.cancelNavigation();
      self._navigation = self._navigation || {};
      var navigationId = (self._lastNavigationId || 0) + 1;
      self._lastNavigationId = navigationId;
      self._navigation[navigationId] = "pending";

      if ($column.length > 0) {
        var selectInColumn = function($column, activeColumnRequest) {
          if (self._navigation[navigationId] === "cancel") {
            self._navigation[navigationId] = "cancelled";
            deferred.reject();
            return;
          }
          var item = itemFinder(self._data[$column.data('href')], $column);
          if (item) {
            var $item = item instanceof $ ? item : $column.find(".coral-ColumnView-item").filter(function() {
              return $(this).data('href') === (item._links && item._links.self ? item._links.self.href : item);
            }).eq(0);
            var href = $item.data('href');

            if ($item && $item.length > 0) {
              self._setActiveColumn($item, false, activeColumnRequest);
              $item.addClass("is-active");
            }

            if ($item || href) {
              self.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
            }

            var newActiveColumnRequest = ++self._activeColumnRequest;

            if (href) {
              self.setNextColumn(href, function() {
                return self._navigation[navigationId] === "pending";
              }).done(function(data, $column) {
                selectInColumn($column, newActiveColumnRequest);
              }).fail(function() {
                self._navigation[navigationId] = "failed";
                deferred.reject();
              });
            } else {
              // scrolls to the active column
              self._scrollToColumn();
              self._navigation[navigationId] = "finished";
              deferred.resolve();
            }
          } else if (item === false) {
            // scrolls to the active column
            self._scrollToColumn();
            self._navigation[navigationId] = "finished";
            deferred.resolve();
          } else {
            self._loadNext($column).done(function() {
              selectInColumn($column, newActiveColumnRequest);
            }).fail(function() {
              self._navigation[navigationId] = "failed";
              deferred.reject();
            });
          }
        };
        selectInColumn($column, ++self._activeColumnRequest);
      } else {
        self._navigation[navigationId] = "failed";
        deferred.reject();
      }

      var promise = deferred.promise();
      promise.navigationId = navigationId;
      return promise;
    },

    /**
     * Cancel in-progress navigation requested with {@link #navigate}.
     *
     * @instance
     * @param {number} [navigationId] the navigationId returned by {@link #navigate}; leave unspecified to cancel all
     *                                navigation requests
     * @return {boolean} <code>true</code> if the navigation will be cancelled, <code>false</code> if <code>navigationId</code>
     *                                     was specified but invalid or already completed.
     */
    cancelNavigation: function(navigationId) {
      this._navigation = this._navigation || {};
      if (navigationId) {
        if (this._navigation.hasOwnProperty(navigationId) && this._navigation[navigationId] === 'pending') {
          this._navigation[navigationId] = "cancel";
          return true;
        }
        return false;
      } else {
        $.each(this._navigation, function(i, item) {
          if (this._navigation[i] === "pending") {
            this._navigation[i] = "cancel";
          }
        }.bind(this));
        return true;
      }
    },

    /**
     * Render a column. This method is not indended to be called directly, instead it is intended to be overridden by subclasses to
     * customize / alter column rendering.
     *
     * @instance
     * @param  {String} href the location that is being rendered in this column; the data for this location must be already loaded and
     *         present in the <code>_data</code> field
     * @returns {jQuery} a new jQuery object that will be added to the ColumnView widget
     * @see {@link CUI.ColumnView#setSource}
     * @see {@link CUI.ColumnView#setData}
     */
    renderColumn: function(href) {
      var data = this._data[href];

      if($.type(data) === 'object') {
        // create the column
        var $column = $('<div class="coral-ColumnView-column"></div>');

        // column content
        var $content = $('<div class="coral-ColumnView-column-content"></div>').appendTo($column);

        // back button (if needed)
        if (this.get('single') && data._links && data._links.up) {
          var backTitle = data._links.self ? data._links.self.title : '';
          var $back = $('<a class="coral-ColumnView-item coral-ColumnView-item--back"></a>')
              .append($('<div class="coral-ColumnView-label"></div>').text(backTitle));
          $column.prepend($back);
        }

        if (data._embedded && data._embedded.items) {
          // render items
          while (data) {
            if (data._embedded && data._embedded.items) {
              var items = data._embedded.items;
              for (var i=0; i < items.length; i++) {
                var item = items[i];
                this.renderItem(item).appendTo($content);
              }
            }
            data = this._data[data._links.next];
          }
        } else if (data.properties || data.preview) {
          $content.append(this.renderPreview(data));
        }

        return $column;
      }

      return $(data);
    },

    /**
     * Render an item. This method is not indended to be called directly, instead it is intended to be overridden by subclasses to
     * customize / alter item rendering.
     *
     * @instance
     * @param  {Object} item the data associated with the item being rendered
     * @returns {jQuery} a new jQuery object that will be added to a column
     */
    renderItem: function(item) {
      var $item = $('<div class="coral-ColumnView-item"></div>');
      if (item.hasChildren) {
        $item.addClass('coral-ColumnView-item--hasChildren');
      }
      if (item.icon || item.image) {
        var $icon = $('<div class="coral-ColumnView-icon"></div>').appendTo($item);
        if (item.image) {
          $('<img/>').addClass('coral-ColumnView-thumbnail').attr('src', item.image).appendTo($icon);
        } else {
          $('<i/>').addClass('coral-Icon coral-Icon--' + item.icon + ' coral-Icon--sizeS').appendTo($icon);
        }
      }
      $('<div class="coral-ColumnView-label"></div>').text(item._links.self.title).appendTo($item);
      return $item;
    },

    /**
     * Render the preview for an item. This method is not indended to be called directly, instead it is intended to be overridden by subclasses to
     * customize / alter preview rendering.
     *
     * @instance
     * @param  {Object} item the data associated with the item being rendered; this will have a <code>preview</code> and/or
     *         <code>properties</code> key
     * @returns {jQuery} a new jQuery object that will be added to a preview column
     */
    renderPreview: function(data) {
      var $content = $('<div class="coral-ColumnView-preview"></div>');
      // preview icon / image / thumbnail
      if (data.preview) {
        if (data.preview.image) {
          var imageContainer = $('<div class="coral-ColumnView-preview-icon"></div>');
          $('<img class="coral-ColumnView-preview-thumbnail">').attr('src', data.preview.image).appendTo(imageContainer);
          imageContainer.appendTo($content);
        } else if (data.preview.icon) {
          var iconContainer = $('<div class="coral-ColumnView-preview-icon"></div>');
          $('<i></i>').addClass('coral-Icon coral-Icon--' + data.preview.icon + ' coral-Icon--sizeL').appendTo(iconContainer);
          iconContainer.appendTo($content);
        }
      }
      // properties
      if (data.properties) {
        for (var j=0; j < data.properties.length; j++) {
          var property = data.properties[j];
          var label = $('<div class="coral-ColumnView-preview-label"></div>').text(property.label).appendTo($content);
          var value = $('<div class="coral-ColumnView-preview-value"></div>').text(property.value).appendTo($content);
          if (property.icon) {
            $('<i></i>').addClass('coral-Icon coral-Icon--' + property.icon + ' coral-Icon--sizeXS').prependTo(value);
            label.before('<div class="coral-ColumnView-preview-spacer"></div>');
          }
        }
      }

      return $content;
    },

    /**
     * Set the column to the right of the current active column to display the data at <code>href</code>; if there are any other columns to
     * the right of the active column, they are removed
     *
     * @instance
     * @param {String} href the location to display in the new column; the contents fetched from this location are cached, any subsequent
     *        calls with the same <code>href</code> do not issue a new request
     * @param {function} [validate] a callback that needs to return <code>true</code> if the next column should still be set when the data
     *                              becomes available or <code>false</code> if the request is no longer valid
     * @returns {jQuery.Deferred} a promise that will be resolved with the new column (as a jQuery object) or rejected if the data can not be
     *         loaded
     */
    setNextColumn: function(href, validate) {
      var deferred = $.Deferred();

      var handleData = function() {
        if ($.type(validate) === "function" && !validate()) {
          deferred.reject();
        } else {
          var $column = this.renderColumn(href);
          this._prepareColumn($column, href);

          var $activeColumn = this._getActiveColumn();
          if (this.get('single') && $activeColumn.length > 0) {
            $column.addClass('is-right');
          }
          $activeColumn.nextAll().empty().removeClass('is-active');
          if ($activeColumn.length > 0 && $activeColumn.next().length > 0) {
            $activeColumn.next().replaceWith($column);
          } else {
            this.$element.append($column);
          }
          this._loadMoreIfNeeded($column).always(function() {
            deferred.resolve(this._data[href], $column);
          }.bind(this));
        }
      }.bind(this);

      if (this._data[href]) {
        handleData(href);
      } else {
        this._loadData(href).done(handleData).fail(function() {
          deferred.reject();
        });
      }

      return deferred.promise();
    },

    /**
     * Set the column to the left of the current active column to display the data at <code>href</code>; any other columns to the left of
     * the active column, they are removed.
     *
     * @instance
     * @param {String} href the location to display in the new column; the contents fetched from this location are cached, any subsequent
     *        calls with the same <code>href</code> do not issue a new request
     * @param {function} [validate] a callback that needs to return <code>true</code> if the next column should still be set when the data
     *                              becomes available or <code>false</code> if the request is no longer valid
     * @returns {jQuery.Deferred} a promise that will be resolved with the new column (as a jQuery object) or rejected if the data can not be
     *         loaded
     */
    setPreviousColumn: function(href, validate) {
      var deferred = $.Deferred();

      var handleData = function() {
        if ($.type(validate) === "function" && !validate()) {
          deferred.reject();
        } else {
          var $column = this.renderColumn(href);
          this._prepareColumn($column, href);
          if (this.get('single')) {
            $column.addClass('is-left');
          }

          var $activeColumn = this._getActiveColumn();
          if ($activeColumn.length > 0) {
            $activeColumn.prevAll().remove();
          }
          this.$element.prepend($column);
          this._loadMoreIfNeeded($column).always(function() {
            deferred.resolve(this._data[href], $column);
          }.bind(this));
        }
      }.bind(this);

      if (this._data[href]) {
        handleData(href);
      } else {
        this._loadData(href).done(handleData).fail(function() {
          deferred.reject();
        });
      }

      return deferred.promise();
    },

    /**
     * Add an item to a column.
     *
     * @instance
     * @param {string|jQuery} itemOrData the item to add, specified by either item data (json+hal format) or jQuery object
     * @param {string|jQuery} [columnOrHref] the column in which to add the item, specified by either <code>href</code> or jQuery object;
     *                                       leave <code>undefined</code> to use the active column
     * @param {number} [index] the index where to add the item: 0 for first (top), unspecified for last (bottom)
     *
     * @return {jQuery} the item that was added
     */
    addItem: function(itemOrData, columnOrHref, index) {
      var $column;
      if (!columnOrHref) {
        $column = this._getActiveColumn();
      } else if ($.type(columnOrHref) === "string") {
        if (columnOrHref === "active") {
          $column = this._getActiveColumn();
        } else {
          $column = this.$element.children().filter(function() {
            return $(this).data("href") === columnOrHref;
          });
        }
      } else {
        $column = $(columnOrHref);
      }

      var $item;
      if (itemOrData instanceof $) {
        $item = itemOrData;
      } else {
        $item = this._prepareItem(this.renderItem(itemOrData), itemOrData);
      }

      var $content = this._getColumnContent($column);
      var $items = $content.children();

      if (index === 0) {
        $content.prepend($item);
      } else if (index > 0 && index < $items.length) {
        $items.eq(index - 1).after($item);
      } else {
        $content.append($item);
      }

      return $item;
    },

    /**
     * Get the active column.
     *
     * @instance
     * @private
     * @returns {jQuery}
     */
    _getActiveColumn: function() {
      return this.$element.children('.is-active');
    },

    /**
     * Get the content (.coral-ColumnView-column-content) for this column, or create it if it doesn't exist. Attach
     * appropriate listeners if needed.
     *
     * @instance
     * @private
     * @returns {jQuery}
     */
    _getColumnContent: function($column) {
      var $content = $column.children('.coral-ColumnView-column-content');
      if ($content.length === 0) {
        // TODO: check if this could add a double scroll event
        $content = $('<div class="coral-ColumnView-column-content"></div>').appendTo($column);
        $content.on('scroll', this._columnScrollHandler.bind(this));
      }
      return $content;
    },

    /**
     * Set data attributes, attach listeners etc. to a new column
     *
     * @instance
     * @private
     * @param  {jQuery} $column the new column
     * @param  {String} href the location of the new column
     * @returns {jQuery} $column, for chaining
     */
    _prepareColumn: function($column, href) {
      var data = this._data[href];
      var $content = this._getColumnContent($column);

      $column.data('href', href);

      // set data attributes
      if($.type(data) === 'object') {
        $column.data('data', data);

        if (data._links && data._links.next) {
          $column.data('next', data._links.next.href);
        }
        if (data._links && data._links.up) {
          $column.data('back', data._links.up.href);
        }

        // prepare items
        if (data._embedded && data._embedded.items) {
          var items = data._embedded.items;
          $content.find('.coral-ColumnView-item').each(function(i, item) {
            this._prepareItem($(item), items[i]);
          }.bind(this));
        }
      }

      // attach listeners
      $content.on('scroll', this._columnScrollHandler.bind(this));

      return $column; // for chaining
    },

    /**
     * Set data attributes, attach listeners etc. to a new item
     *
     * @instance
     * @private
     * @param  {jQuery} $item the new column
     * @param  {Object} data the data for the new item
     * @returns {jQuery} $item, for chaining
     */
    _prepareItem: function($item, data) {
      $item.data('data', data);
      if (data._links && data._links.self) {
        $item.data('href', data._links.self.href);
      }
      return $item; // for chaining;
    },

    /**
     * Puts data into the <code>_data</code> field. If the passed data contains deep hierarchies they are flattened so that paths can easily
     * be accessed via <code>_data[path]</code>.
     *
     * @instance
     * @private
     * @param  {Object} data the data to store
     */
    _storeData: function(data) {
      var href = data._links.self.href;

      this._data[href] = data;
      if (data._embedded && data._embedded.items) {
        var items = data._embedded.items;
        $.each(items, function(i, item) {
          if (item.properties || item.preview || (item._embedded && item._embedded.items)) {
            this._storeData(item);
          }
        }.bind(this));
      }
    },

    /**
     * Loads data from a href and stores it in <code>this._data</code>. If there's already a request in progress for
     * this href, its promise is returned.
     *
     * @instance
     * @private
     * @param  {String} href the URL to load data from
     * @param {jQuery} [$column] the column for which data is being loaded
     * @returns {jQuery.Deferred}
     */
    _loadData: function(href, $column) {
      if (this._data && this._data[href]) {
        return $.Deferred().resolve(this._data[href]);
      }
      this._pendingRequests = this._pendingRequests || {};
      if (!this._pendingRequests[href]) {
        // cache: false stops IE from caching the requests
        this._pendingRequests[href] = $.ajax({url: href, cache: false}).done(function(data) {
          this._data = this._data || {};
          this._data[href] = data;

          // stores the json data
          if ($.type(data) === 'object') {
            this._storeData(data);
          }

          this.$element.trigger('coral-columnview-load', [href, data]);
          delete this._pendingRequests[href];
        }.bind(this));
      }
      return this._pendingRequests[href];
    },

    /**
     * If the current contents of the column to not exceed its height, this method loads more items (if possible).
     *
     * @instance
     * @private
     * @param  {jQuery} $column the column in which to load items
     * @returns {jQuery.Deferred} a promise that will be rejected if no items are to be loaded and resolved
     */
    _loadMoreIfNeeded: function($column) {
      var deferred = $.Deferred();
      var $content = this._getColumnContent($column);
      var items = $content.children('.coral-ColumnView-item');
      var itemsHeight = 0;
      items.each(function(i, item) {
        itemsHeight += $(item).height();
      });
      if (itemsHeight < $content.height() && $column.data('next')) {
        this._loadNext($column).done(function() {
          this._loadMoreIfNeeded($column).done(function() {
            deferred.resolve();
          }).fail(function() {
            deferred.reject();
          });
        }.bind(this)).fail(function() {
          deferred.reject();
        });
      } else {
        deferred.resolve();
      }
      return deferred.promise();
    },

    /**
     * Handles the column click. When the column body is clicked, we need to
     * deselect everything up to that column. This behavior is not available
     * in single mode.
     *
     * @instance
     * @private
     * @param {jQuery.Event} event
     */
    _columnContentHandler: function(event) {
      // this behavior is not supported in single mode
      if (this.get('single')) { return; }

      // we only deselect all the items when the user clicked on the content
      // and not an item
      var $target = $(event.target);
      if (!$target.hasClass('coral-ColumnView-column-content')) { return; }

      this.cancelNavigation();
      event.preventDefault();

      var $column = $target.closest('.coral-ColumnView-column');

      // we remove every column to the right of the select one
      $column.nextAll().empty().removeClass('is-active');

      // we deselect every item in the clicked column
      $column.find('.coral-ColumnView-item').removeClass('is-active');

      // if our parent exists, we mark it as active and scroll to it
      var $parentColumn = $column.prev();
      if ($parentColumn.length !== 0) {
        $parentColumn.addClass('is-active');
      }

      $column.removeClass('is-active');

      this._scrollToColumn();

      // announces the new selection
      var $item = $parentColumn.find('.coral-ColumnView-item.is-active');
      this.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
    },

    /**
     * Handles the item selection, this causes the current item to get active and sets the next column to the
     * item's href.
     *
     * @instance
     * @private
     * @param {jQuery.Event} event
     */
    _itemActivateHandler: function(event) {
      // clicking on a single item, activates the item and deactivates
      // items in the former active column
      this.cancelNavigation();
      event.preventDefault();

      var $item = $(event.target).closest('.coral-ColumnView-item');

      // @polyfill ie
      // ie does not respect user-none
      if(event.shiftKey) {

        // @polyfill ie9
        if (document.selection) {
          document.selection.empty();
        }
        else if (window.getSelection) {
          // @polyfill ie11
          if (window.getSelection().removeAllRanges) {
            window.getSelection().removeAllRanges();
          }
        }
      }

      // handles it as a select in case command or ctrl or shift where pressed
      if (event.metaKey || event.ctrlKey || event.shiftKey) {
        return this._itemSelectHandler(event);
      }

      var href = $item.data('href');
      var $column = $item.closest('.coral-ColumnView-column');

      this.$element.data('lastSelected', {
        item: $item
      });

      var activeColumnRequest = ++this._activeColumnRequest;
      if (href) {
        if (this.get('single')) {
          this.setNextColumn(href).done(function(data, $column) {
            setTimeout(function() {
              // without the timeout the CSS animations don't kick in
              this._setActiveColumn($column, false, activeColumnRequest);
            }.bind(this), 30);
          }.bind(this));
        } else {
          if ($item.hasClass('is-active') && !$item.hasClass('is-selected') && $column[0] === this._getActiveColumn()[0]) {
            $item.removeClass('is-active');

            //always close all next columns
            $column.nextAll().empty().removeClass('is-active');

            var $parentColumn = $column.prev();
            if ($parentColumn.length !== 0) {
              $parentColumn.addClass('is-active');
            }

            $column.removeClass('is-active');
            this._scrollToColumn();
          } else {
            this._setActiveColumn($item, false);
            $item.addClass('is-active');
            $item.focus();
            this.setNextColumn(href).done(function(data, $column) {
              this._scrollToColumn();
            }.bind(this));
          }
        }
      } else if ($item.hasClass('coral-ColumnView-item--back')) {
        if ($column.data('back')) {
          this.setPreviousColumn($column.data('back')).done(function(data, $column) {
            setTimeout(function() {
              // without the timeout the CSS animations don't kick in
              this._setActiveColumn($column, false, activeColumnRequest);
            }.bind(this), 30);
          }.bind(this));
        }
      }

      // the current active item is also regarded as selected
      this.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
    },

    /**
     * Handles selecting multiple items in the same column. Selection could result in none, a single or multiple
     * selected items.
     *
     * @instance
     * @private
     * @param {jQuery.Event} event
     */
    _itemSelectHandler: function(event) {
      if (!this.get('multiselect')) {
        return;
      }

      // selecting multiple items
      event.stopPropagation();
      event.preventDefault();

      var $item = $(event.target).closest('.coral-ColumnView-item');
      this._setActiveColumn($item, true);

      var href = $item.data('href');
      var direction;

      $item.toggleClass('is-active is-selected');

      if (this.getSelectedItems().length === 0) {
        // unchecked last item of a column: parent column (if available) is new active column
        var $column = this._getActiveColumn();
        var $parentColumn = $column.prev();
        if ($parentColumn.length !== 0) {
          $parentColumn.addClass('is-active');
        }

        $column.removeClass('is-active');
      }

      if(event.shiftKey) {
        if(this.getSelectedItems().length === 1) {
          if($item.is(':not(:first-child)')) {
            var $firstItem = $item.siblings().first();
            $firstItem
              .addClass('is-active is-selected')
              .nextUntil($item).addClass('is-active is-selected');
          }

          direction = 'down';
        }
        else {
          if(this.$element.data('lastSelected').item.index() < $item.index()) {
            this.$element.data('lastSelected').item.nextUntil($item).addClass('is-active is-selected');
            direction = 'down';
          }
          else {
            this.$element.data('lastSelected').item.prevUntil($item).addClass('is-active is-selected');
            direction = 'up';
          }
        }
      }

      this.$element.data('lastSelected', {
        item: $item.hasClass('is-selected') ? $item : $item.siblings('.is-selected').first(),
        direction: direction
      });

      this._scrollToColumn();

      this.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
    },

    /**
     * This method is called by the scroll event on a column's content. If the scroll has reached the bottom, more items are potentially
     * loaded.
     *
     * @instance
     * @private
     * @param  {jQuery.Event} event
     */
    _columnScrollHandler: function(event) {
      var $content = $(event.target);
      var $column = $content.closest('.coral-ColumnView-column');
      var tolerance = 10;
      if ($content[0].scrollTop + $content.height() + tolerance >= $content[0].scrollHeight) {
        this._loadNext($column);
      }
    },

    /**
     * Loads more items in a column, if available. I.e. if the column has a <code>next</code> data attribute.
     *
     * @instance
     * @private
     * @param  {jQuery} $column the column that needs more items
     * @returns {jQuery.Deferred} a promise that is resolved if more items are loaded successfully and rejected otherwise
     */
    _loadNext: function($column) {
      var deferred = $.Deferred();
      var next = $column.data('next');

      if (next) {
        // make sure multiple requests for the same 'next' don't go through
        $column.removeAttr('data-next');
        $column.removeData('next');

        var $content = this._getColumnContent($column);
        var handleData = function() {

          // data has to be loaded from the cache
          var data = this._data[next];

          var clearNext = false;

          if($.type(data) === 'object') {
            if (data._embedded && data._embedded.items) {
              var items = data._embedded.items;
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                this._prepareItem(this.renderItem(item), item).appendTo($content);
              }
              this._data[$column.data('href')]._embedded.items =
                  this._data[$column.data('href')]._embedded.items.concat(data._embedded.items);
            }
            if (data._links && data._links.next) {
              $column.data('next', data._links.next.href);
            } else {
               clearNext = true;
            }
          } else {
            var $loadedColumn = $(data);

            // adds the next link to the column in case there is more data to load.
            if($loadedColumn.data('next')) {
              $column.data('next', $loadedColumn.data('next'));
            } else {
               clearNext = true;
            }

            // appends every new item to the end of the current column
            $loadedColumn.find('.coral-ColumnView-item').appendTo($content);
          }

          if(clearNext) {
            // removes both the attribute and the data value
            $column.removeAttr('data-next');
            $column.removeData('next');
          }

          deferred.resolve();
        }.bind(this);
        if (this._data[next]) {
          handleData(this._data[next]);
        } else {
          this._loadData(next, $column).done(handleData).fail(function() {
            deferred.reject();
          });
        }
      } else {
        deferred.reject();
      }

      return deferred.promise();
    },

    /**
     * Sets the current active column. Selected items are deselected and unchecked. If the former active column is the same as the new one
     * the items will be unchecked solely if <code>forceUncheck</code> is true.
     *
     * @instance
     * @private
     * @param {jQuery} $item the item whose column to set as active, or the column itself
     * @param {Boolean} checking <code>true</code> when the 'checkbox' (icon) was tapped
     */
    _setActiveColumn: function($item, checking, request) {
      if (request !== undefined && request < this._activeColumnRequest) {
        return;
      }
      var $formerActiveColumn = this._getActiveColumn();
      var $activeColumn = $item.closest('.coral-ColumnView-column');
      var $activeContent = this._getColumnContent($activeColumn);


      var isColumnViewItem = false;

      if ($item.is(".coral-ColumnView-item")) {
        isColumnViewItem =  true;

        if (checking === true) {
          // tapping 'checkbox': convert selected item of active column into checked
          $activeContent.children('.is-active:not(.is-selected)').addClass('is-selected');
        } else {
          // tapping label: deselect all items (note: does not include checked items, see below)
          $activeContent.children('.is-active:not(.is-selected)').removeClass('is-active');
        }

        if (checking === false || $activeColumn.hasClass('is-active') === false) {
          // tapping label or a 'checkbox' in a different column: uncheck all items
          $activeContent.children('.is-selected').removeClass('is-active is-selected');
        }
      }

      // the parent of the item is the new active column
      $formerActiveColumn.removeClass('is-active');

      // the column is added as active if: it is not the initial column or if
      // something was clicked by the user. This causes the initial state of the
      // columnview not to have an "active" column.
      if ($formerActiveColumn.length !== 0 || isColumnViewItem) {
        $activeColumn.addClass('is-active');
      }

      if (!this.get('single')) {
        // clear the columns after the new active column
        $activeColumn.nextAll().empty().removeData().removeClass('is-active');
      } else {
        if ($formerActiveColumn.index() < $activeColumn.index()) {
          $formerActiveColumn.addClass('is-left');
          $activeColumn.removeClass('is-right');
        } else if ($formerActiveColumn.index() > $activeColumn.index()) {
          $formerActiveColumn.addClass('is-right');
          $activeColumn.removeClass('is-left');
        }
      }
    },

    /**
     * Scroll to the relevant column. If the target column is right of the visible area it will be scrolled into
     * view. Otherwise if the active column is left of the visible area this one will be scrolled into view.
     *
     * @instance
     * @private
     */
    _scrollToColumn: function() {
      var left, duration;
      var $activeColumn = this._getActiveColumn();

      // if no columns are active, we need to scroll back to the root
      if ($activeColumn.length === 0) {
        left = 0;
        duration = this.$element.scrollLeft() * 1.5; // constant speed

        this.$element.animate({
          scrollLeft: left
        }, duration);

        return;
      }

      // most right column: target column, preview column or active column
      var $rightColumn;
      var items = this.getSelectedItems().filter(function(item) { return !item.checked; });
      if (items.length === 1) {
        $rightColumn = $activeColumn.next();
      } else {
        $rightColumn = $activeColumn;
      }

      if ($rightColumn.position() && $rightColumn.position().left + $rightColumn.outerWidth() >= this.$element.width()) {
        // most right column is (partially) right of visible area: scroll right column into view

        // remove empty columns right of most right column
        $rightColumn.nextAll().remove();

        left = this.$element[0].scrollWidth - this.$element.outerWidth();
        duration = (left - this.$element.scrollLeft()) * 1.5; // constant speed

        this.$element.animate({
          scrollLeft: left
        }, duration);

      } else if ($activeColumn.position() && $activeColumn.position().left < 0) {
        // active column is (partially) left of visible area: scroll active column into view

        left = 0;
        $activeColumn.prevAll().each(function() {
          left += $(this).outerWidth();
        });
        duration = (this.$element.scrollLeft() - left) * 1.5; // constant speed

        this.$element.animate({
          scrollLeft: left
        }, duration);
      }
    }

    /**
     * Triggered when an item is selected. Use getSelectedItems() to get
     * an array with all the selected items.
     *
     * @name CUI.ColumnView#coral-columnview-item-select
     * @event
     *
     * @param {jQuery.Event} evt              The event object
     * @param {String} href                   The selected item's href
     * @param {Object} item                   The selected item
     */

    /**
     * Triggered when some data is loaded.
     *
     * @name CUI.ColumnView#coral-columnview-load
     * @event
     *
     * @param {jQuery.Event} evt              The event object.
     * @param {String} href                   The loaded URL.
     * @param {Object} data                   The loaded data.
     */
  });

  CUI.Widget.registry.register('columnview', CUI.ColumnView);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function(event) {
      CUI.ColumnView.init($('[data-init~=columnview]', event.target));
    });
  }

}(jQuery, this));

(function ($, window, undefined) {

  CUI.Modal = new Class(/** @lends CUI.Modal# */{
    toString: 'Modal',

    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc A dialog that prevents interaction with page elements while displayed.

     @desc Creates a new modal dialog.
     @constructs
     @param {Object} options Component options
     @param {Mixed} options.element jQuery selector or DOM element to use for dialog
     @param {String} options.header Title of the modal dialog (HTML)
     @param {String} options.content Title of the modal dialog (HTML)
     @param {String} [options.type=default] Type of dialog to display. One of default, error, notice, success, help, or info
     @param {Array} [options.buttons] Array of button descriptors
     @param {String} [options.buttons.label] Button label (HTML)
     @param {String} [options.buttons.className] CSS class name to apply to the button
     @param {Mixed} [options.buttons.click] Click handler function or string 'hide' to hide the dialog
     @param {String} [options.remote] URL to asynchronously load content from the first time the modal is shown
     @param {Mixed} [options.backdrop=static] False to not display transparent underlay, True to display and close when clicked, 'static' to display and not close when clicked
     @param {Mixed} [options.visible=true] True to display immediately, False to defer display until show() called

     */
    construct: function (options) {

      // modal parts
      this.header = this.$element.find('.coral-Modal-header');
      this.body = this.$element.find('.coral-Modal-body');
      this.footer = this.$element.find('.coral-Modal-footer');

      // previous focus element
      this._previousFocus = $();

      // creates a backdrop object
      // but it does not attach it to the document
      this.backdrop = $('<div/>', {
        'class': 'coral-Modal-backdrop',
        'style': 'display: none;'
      }).on('click', function (event) {
          if (this.options.backdrop !== 'static') {
            this.hide();
          }
        }.bind(this));

      // Fetch content asynchronously, if remote is defined
      this.body.loadWithSpinner(this.options.remote);

      this.applyOptions();

      this.$element.on('change:heading', this._setHeading.bind(this)) // @deprecated
        .on('change:header', this._setHeader.bind(this))
        .on('change:content', this._setContent.bind(this))
        .on('change:buttons', this._setFooter.bind(this))
        .on('change:type', this._setType.bind(this))
        .on('change:fullscreen', this._setFullscreen.bind(this))

        // close when a click was fired on a close trigger (e.g. button)
        .on('click', '[data-dismiss="modal"]', this.hide.bind(this));

      this._makeAccessible();
    },

    defaults: {
      backdrop: 'static',
      visible: true,
      type: 'default',
      fullscreen: false,
      attachToBody: true
    },

    _types: {
      "default": { "class": '', "iconClass": ""},
      "error": { "class": 'coral-Modal--error', "iconClass": "coral-Icon--alert"},
      "notice": { "class": 'coral-Modal--notice', "iconClass": "coral-Icon--alert"},
      "success": { "class": 'coral-Modal--success', "iconClass": "coral-Icon--checkCircle"},
      "help": { "class": 'coral-Modal--help', "iconClass": "coral-Icon--helpCircle"},
      "info": { "class": 'coral-Modal--info', "iconClass": "coral-Icon--infoCircle"}
    },

    applyOptions: function () {
      this._setHeader();
      this._setHeading();  // @deprecated
      this._setContent();
      this._setFooter();
      this._setType();
      this._setFullscreen();

      if (this.options.visible) {
        // Show immediately
        this.options.visible = false;
        this.show();
      }
    },

    /**
     adds some accessibility attributes and features
     http://www.w3.org/WAI/PF/aria-practices/#dialog_modal
     @private
     */
    _makeAccessible: function () {
      var self = this,
        idPrefix = 'modal-header' + new Date().getTime() + '-';

      // the element has the role dialog
      this.$element.attr({
        'role': 'dialog',
        'aria-hidden': !this.options.visible,
        'aria-labelledby': idPrefix + 'label',
        'aria-describedby': idPrefix + 'message',
        'tabindex': -1
      });

      this.header.find('h2').attr({
        'id': idPrefix + 'label',
        'tabindex': 0
      });

      // Message areas have role document and tabindex="0"
      this.body.attr({
        'id': idPrefix + 'message',
        'role': 'document',
        'tabindex': 0
      });

      // keyboard handling
      this.$element.on('keydown', ':focusable', function (event) {
        // enables keyboard support

        var elem = $(event.currentTarget),
          tabbables = self.$element.find(':tabbable'),
          focusElem;

        switch (event.which) {
          case 9: //tab
            if (event.shiftKey && event.currentTarget === tabbables[0]) {
              // in case it is the first one, we switch to the last one
              focusElem = tabbables.last();
            } else if (!event.shiftKey && event.currentTarget === tabbables[tabbables.length - 1]) {
              // in case it is the last one, we switch to the first one
              focusElem = tabbables.first();
            }
            break;
        }

        if (focusElem) { // if a key matched then we set the currently focused element
          event.preventDefault();
          focusElem.trigger('focus');
        }
      });
    },

    /**
     sets the type of the modal
     @private
     */
    _setType: function () {
      if (this.options.type) {

        var icon = this.$element.find('.coral-Modal-header > .coral-Icon');
        // Remove old type
        for (var typeKey in this._types) {
          this.$element.removeClass(this._types[typeKey]["class"]);
          icon.removeClass(this._types[typeKey]["iconClass"]);
        }
        // Add new type
        if (this.options.type !== 'default') {
          this.$element.addClass(this._types[this.options.type]["class"]);
          icon.addClass(this._types[this.options.type]["iconClass"]);
        }
      }
    },

    /**
     sets the header of the modal
     @private
     */
    _setHeader: function () {
      if (!this.options.header) {
        return;
      }

      this.header.find('h2').html(this.options.header);
    },

    /**
     @deprecated rather use #_setHeader
     @private
     */
    _setHeading: function () {
      if (!this.options.heading) {
        return;
      }

      this.options.header = this.options.heading;
      this._setHeader.apply(this, arguments);
    },

    /**
     sets the content of the modal body
     @private
     */
    _setContent: function () {
      if (!this.options.content) {
        return;
      }

      this.body.html(this.options.content);
    },

    /**
     sets the buttons into the footer from the config
     @private
     */
    _setFooter: function () {
      if (!$.isArray(this.options.buttons)) {
        return;
      }

      var self = this;

      // remove existing buttons
      this.footer.empty();

      $.each(this.options.buttons, function (idx, button) {
        // Create an anchor if href is provided
        var btn = button.href ? $('<a/>', {
          'class': 'button'
        }) : $('<button/>', {
          'class': 'coral-Button',
          'type': 'button'
        });

        // Add label
        btn.html(button.label);

        // attach event handler
        if (button.click === 'hide') {
          btn.attr('data-dismiss', 'modal');
        } else if ($.isFunction(button.click)) {
          btn.on('click', button.click.bind(self, {
            dialog: self
          }));
        }

        if (button.href) {
          btn.attr('href', button.href);
        }

        if (button.className) {
          btn.addClass(button.className);
        }

        self.footer.append(btn);
      });
    },

    /**
     sets the fullscreen css class
     @private
     */
    _setFullscreen: function () {
      if (this.options.fullscreen) {
        this.$element.addClass('fullscreen');
      } else {
        this.$element.removeClass('fullscreen');
      }

      // Remove margin
      this.$element.css({
        'margin-left': 0,
        'margin-top': 0
      });
    },

    /**
     @private
     @event beforeshow
     */
    _show: function () {
      var documentBody = $('body'),
        tabcapture,
        self = this;

      // ARIA: http://www.w3.org/WAI/PF/aria-practices/#dialog_modal
      // When the dialog is closed or cancelled focus should
      // return to the element in the application which had focus
      // before the dialog is invoked
      this._previousFocus = $(':focus'); //save previously focused element
      this._previousFocus.trigger('blur');

      documentBody.addClass('coral-Modal.is-open');

      // fire event before showing the modal
      this.$element.trigger('beforeshow');

      this._toggleBackdrop(true);

      // Move to the bottom of body so we're outside of any relative/absolute context
      // This allows us to know we'll always float above the backdrop

      // TODO: This doesn't actually work.  The z-index in the css saves the bacon...
      // Even though _toggleBackdrop is called before this append, the
      // backdrop gets appended to body before modal first time through
      // but is appended to body *after* the modal every time after

      if (this.options.attachToBody) {
        if (this.$element.parent('body').length === 0) {
          this.$element.appendTo(documentBody);
        }
        // ARIA
        // Hide sibling elements from assistive technologies,
        // but first store the state of any siblings already have the aria-hidden attribute
        this.$element.siblings('[aria-hidden]').each(function (index, element) {
          $(element).data('aria-hidden', $(element).attr('aria-hidden'));
        });
        this.$element.siblings().not('script, link, style').attr('aria-hidden', this.options.visible);
      }

      this.$element.attr('aria-hidden', !this.options.visible);

      // center before showing
      this.center();

      // fadeIn
      this.$element.fadeIn();

      // When a modal dialog opens focus goes to the first focusable item in the dialog
      this.$element.find(':tabbable:not(.coral-Modal-header .coral-Modal-closeButton):first').focus();

      // add tab-focusable divs to capture and forward focus to the modal dialog when page regains focus
      tabcapture = $('<div class="coral-Modal-tabcapture" tabindex="0"/>');
      tabcapture.on('focus.modal-tabcapture', function (event) {
        var tabbables = self.$element.find(':tabbable'),
          tabcaptures = $('body > .coral-Modal-tabcapture'),
          lasttabcapture = tabcaptures.last(),
          focusElem;

        if (event.currentTarget === lasttabcapture[0]) {
          focusElem = tabbables.filter(':not(.coral-Modal-header .coral-Modal-closeButton):last');
        } else {
          focusElem = tabbables.filter(':not(.coral-Modal-header .coral-Modal-closeButton):first');
        }

        if (focusElem.length === 0) {
          focusElem = self.$element;
        }

        focusElem.trigger('focus');
      })
      // this method chaining is super janky...
        .prependTo(documentBody)
        .clone(true)
        .appendTo(documentBody);

      // add escape handler
      $(document).on('keydown.modal-escape', this._escapeKeyHandler.bind(this));

      return this;
    },

    /**
     @private
     @event beforehide
     */
    _hide: function () {
      $('body').removeClass('coral-Modal.is-open')
        .find('.coral-Modal-tabcapture').off('focus.modal-tabcapture').remove();

      // remove escape handler
      $(document).off('keydown.modal-escape');

      // fire event before showing the modal
      this.$element.trigger('beforehide');

      this._toggleBackdrop(false);

      this.$element.attr('aria-hidden', !this.options.visible);

      this.$element.siblings()
        .removeAttr('aria-hidden')
        .filter(':data("aria-hidden")')
        .each(function (index, element) {
          $(element).attr('aria-hidden', $(element).data('aria-hidden'))
            .removeData('aria-hidden');
        });

      // fadeOut
      this.$element.fadeOut().trigger('blur');

      // ARIA: http://www.w3.org/WAI/PF/aria-practices/#dialog_modal
      // When the dialog is closed or cancelled focus should
      // return to the element in the application which had focus
      // before the dialog is invoked
      this._previousFocus.trigger('focus');

      return this;
    },

    /**
     centers the modal in the middle of the screen
     @returns {CUI.Modal} this, chainable
     */
    center: function () {
      var width = this.$element.outerWidth(),
        height = this.$element.outerHeight();

      if (!this.options.fullscreen) {
        this.$element.css({
          'margin-left': -(width / 2),
          'margin-top': -(height / 2)
        });
      }
    },

    /**
     toggles back drop
     @private
     @param  {Boolean} [show] true/false to force state
     */
    _toggleBackdrop: function (show) {
      if (!this.options.backdrop) {
        return;
      }

      var documentBody = $('body');

      if ((show || this.backdrop.is(':hidden')) && show !== false) {
        this.backdrop.appendTo(documentBody).fadeIn();
      }
      else {
        this.backdrop.fadeOut(function () {
          $(this).detach();
        });
      }
    },

    /**
     handler to close the dialog on escape key
     @private
     */
    _escapeKeyHandler: function (event) {
      if (event.which === 27) {
        this.hide();
      }

    }
  });

  CUI.Widget.registry.register("modal", CUI.Modal);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.Modal.init($('[data-init~=modal]', event.target));
    });

    // @deprecated
    // this differs from other components
    // rather in future we use data-init~="modal-trigger" to intialize a trigger
    // and require data-init~="modal" on the modal to indicate it is a modal
    $(document).on('click.modal.data-api', '[data-toggle="modal"]',function (e) {
      // Stop links from navigating
      // Always do preventDefault first, otherwise when exception occurs in the handler, it is not called
      e.preventDefault();

      var $trigger = $(this);

      // Get the target from data attributes
      var $target = CUI.util.getDataTarget($trigger);

      // Pass configuration based on data attributes in the triggering link
      var href = $trigger.attr('href');
      var options = $.extend({ remote: !/#/.test(href) && href }, $target.data(), $trigger.data());
      
      // If the trigger does not have focus,
      if (!$trigger.is(document.activeElement)) {
        // make sure that the trigger can accept focus,
        if (!$trigger.is(':focusable')) {
          $trigger.attr('tabindex', 0);
        }
        // then set focus to the trigger.
        // This will ensure that the modal can restore focus to the trigger when it is closed.
        $trigger.focus();
      }

      // Parse buttons
      if (typeof options.buttons === 'string') {
        options.buttons = JSON.parse(options.buttons);
      }

      // If a modal already exists, show it
      var instance = $target.data('modal');

      // Apply the options from the data attributes of the trigger
      // When the dialog is closed, focus on the button that triggered its display
      $target.modal(options);

      // Perform visibility toggle if we're not creating a new instance
      if (instance) {
        $target.data('modal').set({ visible: !instance.get('visible') });
      }
    });
  }

}(jQuery, this));

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($) {

  // Instance ID counter
  var pathbrowser_guid = 0;

  var CLASS_INPUT = 'js-coral-pathbrowser-input',
    CLASS_BUTTON = 'js-coral-pathbrowser-button',
    CLASS_COLLAPSED = 'is-collapsed',
    CLASS_DISABLED = 'is-disabled',
    CLASS_HIGHLIGHTED = 'is-highlighted',

    HTML_CRUMBS = '<nav class="coral-Crumbs"></nav>',
    HTML_PICKER_PANE_DEFAULT = [
      '<div class="coral-Pathbrowser-pickerBar">' + HTML_CRUMBS + '</div>',
      '<div class="coral-Pathbrowser-pickerPanel">',
        '<div class="coral-ColumnView"></div>',
      '</div>'
    ].join(''),
    HTML_PICKER_TABPANEL = [
      '<div class="coral-TabPanel coral-TabPanel--stacked">',
        '<nav class="coral-TabPanel-navigation">',
          '<a class="coral-TabPanel-tab is-active" data-toggle="tab"><i class="coral-Icon coral-Icon-sizeXS coral-Icon--compass"></i></a>',
        '</nav>',
        '<div class="coral-TabPanel-content">',
          '<section class="coral-TabPanel-pane is-active">' + HTML_PICKER_PANE_DEFAULT + '</section>',
        '</div>',
      '</div>',
    ].join(''),
    HTML_PICKER = [
      '<div class="coral-Pathbrowser-picker coral-Modal" id="%ID%">',
        '<div class="coral-Modal-header">',
          '<h2 class="coral-Modal-title coral-Heading coral-Heading--2"></h2>',
          '<button type="button" class="js-coral-pathbrowser-confirm coral-Button coral-Button--square coral-Button--primary" title="Confirm">',
            '<i class="coral-Icon coral-Icon-sizeXS coral-Icon--check"></i>',
          '</button>',
          '<button type="button" class="js-coral-pathbrowser-cancel coral-Button coral-Button--square coral-Button" title="Cancel">',
            '<i class="coral-Icon coral-Icon-sizeXS coral-Icon--close"></i>',
          '</button>',
        '</div>',
        '<div class="coral-Modal-body"></div>',
      '</div>'
    ].join(''),
    HTML_WAIT = '<div class="coral-Wait coral-Wait--large coral-Wait--center"></div>',

    PATH_SEPARATOR = "/";

  var Registry = function() {
    var map = {};

    return {
      register: function(key, config) {
        if (!map.hasOwnProperty(key)) {
          map[key] = [config];
        }
        else {
          map[key].push(config);
        }
      },
      get: function(key, filter) {
        var results = [];

        var res = filter("test", "test");

        if (!map.hasOwnProperty(key)) {
          return results;
        }

        if (typeof filter === 'function') {
          return $.grep(map[key], filter);
        }

        return map[key];
      }
    };
  };

  var registry = new Registry();

  CUI.PathBrowser = new Class(/** @lends CUI.PathBrowser# */{
    toString: 'PathBrowser',
    extend: CUI.Widget,

    /**
      @extends CUI.Widget
      @classdesc A component for searching and selecting paths.

      @description Creates a new path browser
      @constructs

      @param {Object} options Component options
      @param {Mixed} options.element
        jQuery selector or DOM element to use for the pathbrowser element.
      @param {Array.<String>} [options.options=empty array]
        Array of available options (will be read from &lt;select&gt; by default).
      @param {String} [options.value=""]
        Initial value for the text input field.
      @param {String} [options.rootPath="/content"]
        The root path where completion and browsing starts. Use the empty string for the repository root.
      @param {Array.<String>} [options.optionDisplayStrings=empty array]
        Array of alternate strings for display (will be read from &lt;select&gt; by default).
      @param {Mixed} [options.optionLoader=use options]
        Callback to reload options list. Can be synchronous or asynchronous. For asynchronous handling,
        use the second parameter as callback function: <code>optionLoader(string currentPath, function callback)</code>
        with <code>callback(Array resultArray)</code>.
        If type String, the function is looked up in the CUI.PathBrowser registry. See CUI.PathBrowser.register for details.
        Type String is necessary when using the data API (no Function-as-string support).
      @param {String} [options.optionLoaderRoot=use options]
        Nested key to use as root to retrieve options from the option loader result.
      @param {Mixed} [options.optionValueReader=use options]
        Custom function to call to retrieve the value from the option loader result.
        If type String, the function is looked up in the CUI.PathBrowser registry. See CUI.PathBrowser.register for details.
        type String is necessary when using the data API (no Function-as-string support).
      @param {Mixed} [options.optionTitleReader=use options]
        Custom function to call to retrieve the title from the option loader result.
        If type String, the function is looked up in the CUI.PathBrowser registry. See CUI.PathBrowser.register for details.
        Type String is necessary when using the data API (no Function-as-string support).
      @param {Boolean} [options.showTitles=true]
        <code>false</code> to prevent showing option titles.
      @param {Mixed} [options.autocompleteCallback=use options]
        Callback for autocompletion.
        If type String, the function is looked up in the CUI.PathBrowser registry. See CUI.PathBrowser.register for details.
        Type String is necessary when using the data API (no Function-as-string support).
      @param {Mixed} [options.optionRenderer=default renderer]
        Renderer for the autocompleter and the tag badges.
        If type String, the function is looked up in the CUI.PathBrowser registry. See CUI.PathBrowser.register for details.
        Type String is necessary when using the data API (no Function-as-string support).
      @param {String} [options.placeholder=null]
        A placeholder for the input field.
      @param {Number} [options.delay=200]
        Time in milliseconds on user input before starting search for autocomplete results.
      @param {String} [options.position="below"]
        Where to position the dropdown list. "above" or "below".
      @param {Boolean} [options.autoPosition=true]
        <code>false</code> to prevent auto-positioning of the dropdown if there's not enough space for the chosen {@link CUI.PathBrowser#options.position} in the window.
      @param {String} [options.pickerSrc=null]
        Remote location for fetching {@link CUI.ColumnView} columns. Must be provided to enable the picker modal.
      @param {Array.<Object>} [options.pickerAdditionalTabs=null]
        Array of tab configuration objects for initialising additional tabs in the picker modal. Tab objects are passed through to the
        internal tab panel via its addItem() function. See {@link CUI.Tabs} for more information.
      @param {Boolean} [options.pickerMultiselect=false]
        Enable multi-selection in the picker {@link CUI.ColumnView}. Only single selections handled on picker
        confirm. Therefore when using this option, it is necessary to attach event listeners to the path browser on
        "coral-pathbrowser-picker-confirm" event to receive any multi-selections.
      @param {String} [options.pickerTitle="Select path"]
        Title of the {@link CUI.Modal} dialog in the picker modal.
      @param {Mixed} [options.crumbRoot="Content"]
        Change the root crumb in the picker modal. String, Object or jQuery object can be provided.
        String sets the link text. Object allows for provision of "title", "icon", "isAvailable" and "isNavigable" properties.
      @param {Boolean} [options.rootPathValidSelection=true]
        <code>false</code> to invalidate selection of the root path in the picker modal.
      @param {String} [options.pickerValueKey="value"]
        Data attribute key to use for reading path values from picker CUI.ColumnView items.
      @param {String} [options.pickerIdKey="id"]
        Data attribute key to use for navigating to CUI.ColumnView items; ID is matched against path section tokens.
     */
    construct: function(options) {
      var opt, defaultHandler, config;
      var regOpts = ['optionLoader', 'optionValueReader', 'optionTitleReader', 'autocompleteCallback', 'optionRenderer'];
      this.guid = pathbrowser_guid += 1;

      // Read functions from registry for all registry-based options
      for (var i = 0; i < regOpts.length; i++) {
        opt = this.options[regOpts[i]];
        defaultHandler = this._getHandler(regOpts[i], 'cui.pathbrowser.' + regOpts[i].toLowerCase() + '.default');

        if (typeof opt === 'function') {
          this[regOpts[i]] = opt.bind(this); // Use the option as provided, if it is a function.
        }
        else if (typeof opt === 'string') {
          config = this._getHandler(regOpts[i], opt); // Otherwise, lookup the name against the option in the registry.
          this[regOpts[i]] = (config) ? config :
            (defaultHandler) ? defaultHandler : $.noop();
        }
        else if (defaultHandler) {
          this[regOpts[i]] = defaultHandler; // Finally, take a default if it is provided.
        }
      }

      // Apply initial value
      if (this.options.value) {
        this.set('value', this.options.value);
      }

      // Adjust DOM to our needs
      this._render();

      // Populate alternative display strings if necessary
      while (this.options.optionDisplayStrings.length < this.options.options.length) {
        this.options.optionDisplayStrings.push(this.options.options[this.options.optionDisplayStrings.length]);
      }

      this._selectlist = this.$element.find('.coral-SelectList');
      if (this._selectlist.length === 0) {
        this._selectlist = $('<ul/>', {
          'id': CUI.util.getNextId(),
          'class': 'coral-SelectList'
        }).appendTo(this.$element);
      }
      else if (!this._selectlist.attr('id')) {
        this._selectlist.attr('id', CUI.util.getNextId());
      }

      // Define input element as owner of select list; aids keyboard accessibility
      this.inputElement.attr('aria-owns', this._selectlist.attr('id'));

      this.dropdownList = new CUI.SelectList({
        element: this._selectlist,
        relatedElement: this.$element,
        autofocus: false,
        autohide: true
      });

      // Picker
      this.$button = this.$element.find("." + CLASS_BUTTON);
      this.pickerEnabled = this.$button.length !== 0 && this.options.pickerSrc;

      if (this.pickerEnabled) {
        this._constructPicker();
      }

      // Listen to property changes
      this.$element.on('change:value', this._handleValueChange.bind(this));
      this.$element.on('change:disabled', this._update.bind(this));
      this.$element.on('change:placeholder', this._update.bind(this));
      this.$element.on('change:options', this._changeOptions.bind(this));

      // Listen to events
      this.$element.on("input", "." + CLASS_INPUT, function() {
        if (this.options.disabled) {
          return;
        }
        if (this.typeTimeout) {
          clearTimeout(this.typeTimeout);
        }
        this.typeTimeout = setTimeout(this._inputChanged.bind(this), this.options.delay);
      }.bind(this));

      if (this.pickerEnabled) {
        this.$button.on("click", this._clickedPickerButton.bind(this));
        this.$picker.on("beforehide", this._beforeHidePicker.bind(this));
        this.$picker.on(PICKER_EVENT_CONFIRM, this._pickerSelectionConfirmed.bind(this));
      }

      this.$element.on("blur", "." + CLASS_INPUT, function() {
        if (this.options.disabled) {
          return;
        }
        if (this.typeTimeout) {
          clearTimeout(this.typeTimeout);
        }
        this.typeTimeout = null;
        // Set to existing selection for single term use
        if (this.selectedIndex >= 0) {
          if (this.inputElement.val() === "") {
            this.setSelectedIndex(-1);
          }
          else {
            this._update();
          }
        }
      }.bind(this));

      this.$element.on("keydown", "input", this._keyPressed.bind(this));
      this.$element.on("keyup", "input", this._keyUp.bind(this));

      this.dropdownList.on("selected", function(event) {
        var selVal = (event.selectedValue != null) ? event.selectedValue.toString() : null;

        this.dropdownList.hide(200);
        // TODO improve this
        // relative and absolute path handling
        this.setSelectedIndex(this.options.options.indexOf(selVal));
        this.inputElement.focus();
      }.bind(this));

    },

    defaults: {
      autocompleteCallback: $.noop(),
      options: [],
      optionDisplayStrings: [],
      optionLoader: $.noop(),
      optionLoaderRoot: null,
      optionValueReader: $.noop(),
      optionTitleReader: $.noop(),
      showTitles: true,
      rootPath: "/content",
      delay: 200,
      placeholder: null,
      optionRenderer: $.noop(),
      position: "below",
      autoPosition: true,
      pickerSrc: null,
      pickerAdditionalTabs: null,
      pickerTitle: "Select path",
      pickerValueKey: "value",
      pickerIdKey: "id",
      crumbRoot: "Content",
      rootPathValidSelection: true
    },

    dropdownList: null, // Reference to instance of CUI.DropdownList
    inputElement: null,
    typeTimeout: null,
    selectedIndex: -1,
    triggeredBackspace: false,

    /**
      Set the selected option index.

      @param {Number} index
        The currently selected option by its index. -1 removes any selected index.
    */
    setSelectedIndex: function(index) {
      if (index < -1 || index >= this.options.options.length) {
        return;
      }
      this.selectedIndex = index;
      this._update();
    },

    /**
      Get the index of the currently selected option.

      @returns {Number} The currently selected option by index or -1 if there is no selection.
    */
    getSelectedIndex: function() {
      return this.selectedIndex;
    },

    // Internals //

    /** @ignore */
    _changeOptions: function(event) {
      if (event.widget !== this) {
        return;
      }
      this.selectedIndex = -1;
      this._update();
    },

    /** @ignore */
    _render: function() {
      this._readDataFromMarkup();

      // If there was an select in markup: use it for generating options
      if (this.$element.find("select option").length > 0 && this.options.options.length === 0) {
        this.options.options = [];
        this.options.optionDisplayStrings = [];
        this.$element.find("select option").each(function(i, e) {
          this.options.options.push($(e).val());
          this.options.optionDisplayStrings.push($.trim($(e).text()));

          // Save selected state
          if ($(e).attr("selected")) {
            this.selectedIndex = i;
          }

        }.bind(this));
      }

      this.inputElement = this.$element.find("." + CLASS_INPUT);

      this.$element.removeClass(CLASS_HIGHLIGHTED);

      if (!this.options.placeholder) {
        this.options.placeholder = this.inputElement.attr("placeholder");
      }

      this._update();
    },

    /** @ignore */
    _readDataFromMarkup: function() {
      var defaultHandler, config;
      var attrToKeyMap = [
        {
          attr: 'data-option-loader',
          key: 'optionLoader'
        },
        {
          attr: 'data-option-value-reader',
          key: 'optionValueReader'
        },
        {
          attr: 'data-option-title-reader',
          key: 'optionTitleReader'
        },
        {
          attr: 'data-autocomplete-callback',
          key: 'autocompleteCallback'
        },
        {
          attr: 'data-option-renderer',
          key: 'optionRenderer'
        }
      ];

      for (var i = 0; i < attrToKeyMap.length; i++) {
        if (this.$element.attr(attrToKeyMap[i].attr)) {
          defaultHandler = this._getHandler(attrToKeyMap[i].key, 'cui.pathbrowser.' + attrToKeyMap[i].key.toLowerCase() + '.default');
          config = this._getHandler(attrToKeyMap[i].key, this.$element.attr(attrToKeyMap[i].attr));
          this[attrToKeyMap[i].key] = (config) ? config :
            (defaultHandler) ? defaultHandler : $.noop();
        }
      }

      if (this.$element.attr("data-option-loader-root")) {
        this.options.optionLoaderRoot = this.$element.attr("data-option-loader-root");
      }

      if (this.$element.attr("data-root-path")) {
        this.options.rootPath = this.$element.attr("data-root-path");
      }

      if (this.$element.attr("placeholder")) {
        this.options.placeholder = this.$element.attr("placeholder");
      }

      if (this.$element.attr("data-placeholder")) {
        this.options.placeholder = this.$element.attr("data-placeholder");
      }

      if (this.$element.attr("disabled") || this.$element.attr("data-disabled")) {
        this.options.disabled = true;
      }
    },

    /** @ignore */
    _handleValueChange: function(event) {
      if (this.options.value) {
        this._setInputValue(this.options.value);
      }
    },

    /** @ignore */
    _update: function() {
      if (this.options.placeholder) {
        this.inputElement.attr("placeholder", this.options.placeholder);
      }

      if (this.options.disabled) {
        this.$element.addClass(CLASS_DISABLED);
        this.inputElement.add(this.$button).prop("disabled", true);
      }
      else {
        this.$element.removeClass(CLASS_DISABLED);
        this.inputElement.add(this.$button).prop("disabled", false);
      }

      if (this.selectedIndex >= 0) {
        // Value to set is what is currently in the input field until the last slash + the option value
        var option = this.options.options[this.selectedIndex];
        if (option && option.indexOf(PATH_SEPARATOR) !== 0) {
          // Option contains a relative path
          var parentPath = "";
          var iLastSlash = this.inputElement.val().lastIndexOf(PATH_SEPARATOR);
          if (iLastSlash >= 0) {
            parentPath = this.inputElement.val().substring(0, iLastSlash + 1);
          }
          option = parentPath + option;
        }
        this._setInputValue(option, true);
      }
    },

    /** @ignore */
    _setInputValue: function(newValue, moveCursor) {
      // Using select text util to select starting from last character to last character
      // This way, the cursor is placed at the end of the input text element
      if (newValue != null) {
        this.inputElement.val(newValue);
        this.inputElement.change();
        //IE11 fix is.(":focus") triggers blur event. Replaced by this.inputElement == document.activeElement
        if (moveCursor && this.inputElement == document.activeElement) {
          CUI.util.selectText(this.inputElement, newValue.length);
        }
      }
    },

    /** @ignore */
    _keyUp: function(event) {
      var key = event.keyCode;
      if (key === 8) {
        this.triggeredBackspace = false; // Release the key event
      }
    },

    /** @ignore */
    _keyPressed: function(event) {
      var key = event.keyCode;
      if (!this.dropdownList.get('visible')) {
        //if (!this.dropdownList.isVisible()) {
        if (key === 40) {
          this._inputChanged(); // Show box now!
          event.preventDefault();
        }
      }
    },

    /** @ignore */
    _inputChanged: function() {
      var self = this;

      var searchFor = this.inputElement.val();
      if (searchFor.length > 0) {
        this.autocompleteCallback(searchFor)
          .done(
            function(results) {
              self._showAutocompleter(results);
            }
          )
          .fail(
            function() {
              // TODO: implement
            }
        )
        ;
      }
      else {
        this.dropdownList.hide();
      }
    },

    /** @ignore */
    _showAutocompleter: function(results) {
      this.dropdownList.hide();

      if ((!results) || results.length === 0) {
        return;
      }

      this._selectlist.empty();

      for (var i = 0; i < results.length; i++) {
        this._selectlist.append((this.optionRenderer)(null, results[i]));
      }

      this.dropdownList.show();
    },

    /** @ignore */
    _rebuildOptions: function(def, path, object) {
      var self = this;

      var root = CUI.util.getNested(object, self.options.optionLoaderRoot);
      if (root) {
        var newOptions = [];
        var newOptionDisplayStrings = [];
        $.each(root, function(i, v) {
          // Read the title and the value either from provided custom reader
          // or using default expected object structure
          var value;
          if (self.optionValueReader) {
            value = self.optionValueReader(v);
          }
          else {
            value = typeof v === "object" ? v.path : v;
          }
          newOptions.push(value);

          var title = "";
          if (self.optionTitleReader) {
            title = self.optionTitleReader(v);
          }
          else if (typeof v === "object") {
            title = v.title;
          }
          newOptionDisplayStrings.push(title);
        }.bind(self));

        self.options.options = newOptions;
        self.options.optionDisplayStrings = newOptionDisplayStrings;

        var filtered = self._filterOptions(path);
        def.resolve(filtered);
      }
      else {
        def.reject();
      }
    },

    /** @ignore */
    _filterOptions: function(searchFor) {
      var result = [];
      var lastSegment = searchFor.split('/');
      lastSegment = lastSegment[lastSegment.length - 1].toLowerCase();

      $.each(this.options.options, function(key, value) {
        if (value.toLowerCase().indexOf(lastSegment, 0) >= 0) {
          result.push(key);
        }
      }.bind(this));

      return result;
    },

    /** @ignore */
    _getHandler: function(key, name) {
      var filterFactory = function(comparator) {
        return function(item, index) {
          return item.name === comparator;
        };
      };

      var a = filterFactory.call(this, name);
      var config = registry.get(key, a)[0];

      return (config && typeof config['handler'] === 'function') ? config.handler.bind(this) : undefined;
    },

    /** @ignore */
    _constructPicker: function() {
      // Create the Picker .coral-Modal, if not already existing in markup
      var id = "mod-guid-" + this.guid,
        idSel = "#" + id + ".coral-Modal",
        pickerOptions;

      this.$picker = $('body').find(idSel);

      if (this.$picker.length === 0) {
        $('body').append(HTML_PICKER.replace("%ID%", id));
        this.$picker = $('body').find(idSel);
      }

      pickerOptions = $.extend({}, this.options, {
        'element': this.$picker
      });
      this.picker = new Picker(pickerOptions);
    },

    /** @ignore */
    _clickedPickerButton: function() {
      var self = this;
      var $wait;

      if (!self.options.disabled) {
        // The picker data hasn't loaded; display a loading indicator and disable button until resolution
        if (!self.picker.columnView) {
          self.$button.prop('disabled', true);
          $wait = $(HTML_WAIT).appendTo('body');
          self.picker.startup(self.inputElement.val()).always(function() {
            self.$button.prop('disabled', false);
            $wait.remove();
          });
        }
        else {
          self.picker.startup(self.inputElement.val());
        }
      }
    },

    /** @ignore */
    _beforeHidePicker: function() {
      this.pickerShown = false;
      this.inputElement.removeClass(CLASS_HIGHLIGHTED);
    },

    /** @ignore */
    _pickerSelectionConfirmed: function(event) {
      if (event.selectedValue) {
        if (this.options.options.indexOf(event.selectedValue) !== -1) {
          this.setSelectedIndex(event.selectedValue);
        }
        else {
          this.setSelectedIndex(-1);
          this._setInputValue(event.selectedValue, true);
        }
        this.inputElement.focus();
      }
    }
  });

  var PICKER_CLASS_CONFIRM = 'js-coral-pathbrowser-confirm',
    PICKER_CLASS_CANCEL = 'js-coral-pathbrowser-cancel',
    PICKER_CLASS_MODAL_BACKDROP = 'coral-Pathbrowser-picker-backdrop',
    PICKER_CLASS_MODAL_TITLE = 'coral-Modal-title',
    PICKER_CLASS_MODAL_BODY = 'coral-Modal-body',
    PICKER_CLASS_TABPANEL = 'coral-TabPanel',
    PICKER_CLASS_COLUMNVIEW = 'coral-ColumnView',
    PICKER_CLASS_COLUMNVIEW_COLUMN = 'coral-ColumnView-column',
    PICKER_CLASS_COLUMNVIEW_ITEM = 'coral-ColumnView-item',

    PICKER_EVENT_COLUMNVIEW_ITEM_SELECT = 'coral-columnview-item-select',
    PICKER_EVENT_SELECT = 'coral-pathbrowser-picker-select',
    PICKER_EVENT_CONFIRM = 'coral-pathbrowser-picker-confirm',

    PICKER_INVALID_KEY = 'invalid';

  var Picker = new Class(/** @lends Picker# */{
    toString: 'Picker',
    extend: CUI.Widget,

    // Public API //

    /**
      @extends CUI.Widget
      @classdesc Component that handles creation and interaction with the CUI.PathBrowser Picker UI.

      @constructs
      @param {Object} options
    */
    construct: function(options) {
      // Init CUI.Modal
      this.$element.modal({
        visible: false
      });
      this.modal = this.$element.data("modal");

      // Add class to manage layering above other modals (from which the picker may be launched)
      this.modal.backdrop.addClass(PICKER_CLASS_MODAL_BACKDROP);

      // Sets up picker modal body content based on whether or not additional tabs are provided
      this._hasTabs = (this.options.pickerAdditionalTabs != null);
      var $modalBody = this.$element.find('.' + PICKER_CLASS_MODAL_BODY);
      var $bodyContent = (this._hasTabs) ? $(HTML_PICKER_TABPANEL) : $(HTML_PICKER_PANE_DEFAULT);
      $modalBody.append($bodyContent);

      // Sets up internal selection data structure
      this._selection = (this._hasTabs) ? {} : [];

      // Init CUI.TabPanel
      this.$tabPanel = this.$element.find('.' + PICKER_CLASS_TABPANEL);
      this.tabPanel = new CUI.Tabs({
        element: this.$tabPanel
      });
      this._setupAdditionalTabs();

      // Init CUI.ColumnView
      this.$columnView = this.$element.find('.' + PICKER_CLASS_COLUMNVIEW);

      // Init Crumbs
      this.$crumbs = this.$element.find('.' + CRUMBS_CLASS_CRUMBS);
      this.crumbs = new Crumbs({
        'element': this.$crumbs
      });

      this._setCrumbRootHref(this.options.pickerSrc);

      // Find elements
      this.$cancel = this.$element.find('.' + PICKER_CLASS_CANCEL);
      this.$confirm = this.$element.find('.' + PICKER_CLASS_CONFIRM);

      // Event listening
      this._setupListeners();
    },

    /**
      Begins a path-picking session.

      @param {String} path
        The path to initially navigate to when the picker opens.

      @returns {jQuery.Deferred} a promise that will be accepted when picker content has loaded,
        or rejected if the data fails to load.
    */
    startup: function(path) {
      var deferred = $.Deferred(), cv,
        self = this,
        onDataLoaded = function() {
          self._renderPicker();
          self._showPicker();

          // Try different paths, until we either select a valid path or gracefully fail.
          // 1. Full path, with anchor
          self.selectPath(path).fail(function() {
            if (path.indexOf("#") != -1) {
              path = path.substring(0, path.lastIndexOf("#"));

              // 2. Path, without anchor
              self.selectPath(path).fail(function() {
                if (path.indexOf(".") != -1) {
                  path = path.substring(0, path.lastIndexOf("."));

                  // 3. Path, without anchor and extension
                  self.selectPath(path).always(function() {
                    self._buildCrumbs(self._determineCrumbs());
                  });
                }
              }).always(function() {
                self._buildCrumbs(self._determineCrumbs());
                self._updateConfirm();
              });
            }
          }).always(function() {
            self._buildCrumbs(self._determineCrumbs());
          });
        };

      // We haven't loaded initial src data, setup the CUI.ColumnView.
      if (!self.columnView) {
        cv = new CUI.ColumnView({
          'element': self.$columnView,
          'multiselect': self.options.pickerMultiselect || false
        });

        cv.setSource(self.options.pickerSrc).done(function() {
          self.columnView = cv;
          onDataLoaded();
          deferred.resolve();
          // gives focus the Column View so that arrow keys work
          self.$columnView.focus();
        }).fail(function() {
          deferred.fail();
        });
      }
      else {
        onDataLoaded();
        deferred.resolve();
        // gives focus the Column View so that arrow keys work
        self.$columnView.focus();
      }

      // Confirm action on Enter press if we have a valid selection.
      $(document).on('keypress.pathbrowser-confirm', function(event) {
        if (event.which === 13) { // Enter
          // Just take down, if the cancel button has focus
          if ($(':focus').is(this.$cancel)) {
            this._takeDown();
          }
          else if (!this.$confirm.prop('disabled')) {
            this._selectionConfirmed();
          }
        }
      }.bind(this));

      return deferred.promise();
    },

    /**
      Navigates to the CUI.ColumnView item at the path provided.

      @param {String} path
        The path to navigate to.

      @returns {jQuery.Deferred} A promise; resolved when navigation completes or rejected on error
        (full path navigation failed).
    */
    selectPath: function(path) {
      var rootPath, parts, itemFinder, dataAttr,
        deferred = $.Deferred();

      path = path.replace(/\/$/, ""); // Remove trailing slash
      rootPath = this.options.rootPath || PATH_SEPARATOR;

      if (path && (path.slice(0, rootPath.length) == rootPath)) {
        path = path.slice(rootPath.length); // Begin navigation after root path
        path = (path.charAt(0) == PATH_SEPARATOR) ? path.substr(1) : path; // Remove opening slash before splitting
        parts = path.split(PATH_SEPARATOR);
        dataAttr = this.options.pickerIdKey;

        if (parts.length) {
          var i = 0;

          itemFinder = function(columnData, $column) {
            if (i == parts.length) {
              return false;
            }

            var $item = $column.find('.' + PICKER_CLASS_COLUMNVIEW_ITEM).filter(function() {
              var data = $(this).data('data'), dataVal;

              if (data && data[dataAttr]) {
                dataVal = data[dataAttr];
              }
              else {
                dataVal = $(this).data(dataAttr);
              }

              return dataVal ? (String(dataVal) === parts[i]) : false;
            });

            i++;

            if ($item.length == 1) {
              return $item; // Select the correct item in the column
            }

            return undefined;
          };

          return this.columnView.navigate(itemFinder);
        }
        else {
          deferred.reject();
        }
      }
      else {
        deferred.reject();
      }

      return deferred;
    },

    // Internals //

    /** @ignore */
    _showPicker: function() {
      this.modal.show();
    },

    /** @ignore */
    _hidePicker: function() {
      this.modal.hide();
    },

    /** @ignore */
    _takeDown: function() {
      $(document).off('keypress.pathbrowser-confirm');
      this._hidePicker();
    },

    /** @ignore */
    _setupListeners: function() {
      var self = this;

      self.$cancel.on('click', self._takeDown.bind(self));
      self.$confirm.on('click', self._selectionConfirmed.bind(self));
      self.$columnView.on(PICKER_EVENT_COLUMNVIEW_ITEM_SELECT, self._itemSelected.bind(self));
      self.$element.on(PICKER_EVENT_SELECT, function(event) {
        var selection = (event.selectedValue) ? event.selectedValue : [];

        self._handleSelection.call(self, selection);
      });

      if (this._hasTabs) {
        this.tabPanel._getTabs().on('focus', self._updateConfirm.bind(self));
      }
    },

    /** @ignore */
    _setupAdditionalTabs: function() {
      var tabs = this.options.pickerAdditionalTabs;

      if (tabs && tabs.length > 0) {
        for (var i = 0; i < tabs.length; i++) {
          var tab = tabs[i];

          if (tab) {
            // sets the active param to avoid activating newly added panels (the default)
            tab.active = (tab.active === true);

            this.tabPanel.addItem(tab);
          }
        }
      }
    },

    /** @ignore */
    _setupCrumbListeners: function(crumb) {
      var self = this;

      $(crumb).on('click', function(event) {
        if (!($(this).hasClass(CRUMBS_MOD_UNAVAILABLE) || $(this).hasClass(CRUMBS_MOD_NONAVIGATION))) {
          var item = crumb.data('coral-columnview-item'),
            first = true, href, itemFinder, $el;

          if (item && item.item) {
            $el = item.item;
            itemFinder = function(columnData, $column) {
              if (first) { // First column in navigation only
                first = false;
                return $column.find($el).click(); // Select the correct item in the column
              }
              return undefined;
            };
          }
          else { // No item, no selection
            itemFinder = function(columnData, $column) {
              return undefined;
            };
          }

          href = $(crumb).attr('href');

          if (href) {
            self.columnView.navigate(itemFinder, href).done(function() {
              self._buildCrumbs();
            });
          }
        }

        event.preventDefault();
      });
    },

    /** @ignore */
    _itemSelected: function(event) {
      var selection = this._getSelectedValue(true);

      this.$element.trigger($.Event(PICKER_EVENT_SELECT, { "selectedValue": selection }));
      this._buildCrumbs(this._determineCrumbs());
    },

    /** @ignore */
    _enableConfirm: function (enable) {
      this.$confirm.prop('disabled', !enable);
    },

    /** @ignore */
    _updateConfirm: function () {
      var selection = this._getSelection();
      var hasSelection = (selection && selection.length > 0);
      this._enableConfirm(hasSelection);
    },

    /** @ignore */
    _setSelection: function(selection) {
      if (this._hasTabs) {
        // tabs configured - store the selection against panel id. Selections are independent
        var activePaneId = this._getActivePaneId();
        this._selection[activePaneId] = selection;
      } else {
        this._selection = selection;
      }
    },

    /** @ignore */
    _getSelection: function() {
      var selection;

      if (this._hasTabs) {
        var activePaneId = this._getActivePaneId();
        selection = this._selection[activePaneId];
      } else {
        selection = this._selection;
      }

      return selection;
    },

    /** @ignore */
    _handleSelection: function(selection) {
      this._setSelection(selection);
      this._updateConfirm();
    },

    /** @ignore */
    _getActivePaneId: function() {
      var $activePane = this.tabPanel.panelist.find('.coral-TabPanel-pane.is-active');
      return ($activePane.length > 0) ? $activePane.get(0).id : undefined;
    },

    /** @ignore */
    _selectionConfirmed: function() {
      var selection = this._getSelection();

      this.$element.trigger($.Event(PICKER_EVENT_CONFIRM, { "selectedValue": selection }));
      this._takeDown();
    },

    /** @ignore */
    _getSelectedValue: function(excludeInvalid) {
      var items = this.columnView.getSelectedItems();
      var valid = true;
      var value;

      if (items.length > 0) {
        // Single selection only
        if (items[0].data && items[0].data[this.options.pickerValueKey]) {
          value = items[0].data[this.options.pickerValueKey]; // Read value from data object
        } else if (items[0].item) {
          value = items[0].item.data(this.options.pickerValueKey); // Otherwise, try attribute
        }

        // Check validity
        if (excludeInvalid) {
          if (items[0].data && items[0].data[PICKER_INVALID_KEY]) { // Data object
            valid = false;
          } else if (items[0].item && items[0].item.data(PICKER_INVALID_KEY)) { // Attribute
            valid = false;
          }
        }
      }

      // No valid items selected, take the root path
      if (value === undefined) {
        if (this.options.rootPathValidSelection) {
          value = this.options.rootPath;
        }
      }

      if (value && valid) {
        return value;
      }
    },

    /** @ignore */
    _renderPicker: function() {
      this.$element.find('.' + PICKER_CLASS_MODAL_TITLE).text(this.options.pickerTitle);
    },

    /** @ignore */
    _resetPicker: function() {
      this.columnView.setSource(this.options.pickerSrc);
      this._updateConfirm();
      this._buildCrumbs();

      var selection = this._getSelectedValue(true);
      this.$element.trigger($.Event(PICKER_EVENT_SELECT, { "selectedValue": selection }));
    },

    /** @ignore */
    _buildCrumbs: function(crumbs) {
      this.crumbs.removeAllItems();

      // Root crumb always present, even if no crumbs are available
      var $rootCrumb = this.crumbs.addItem(this.options.crumbRoot, this.options.pickerSrc);
      $rootCrumb.on('click', function(event) {
        event.preventDefault();
        if (!($rootCrumb.hasClass(CRUMBS_MOD_UNAVAILABLE) || $rootCrumb.hasClass(CRUMBS_MOD_NONAVIGATION))) {
          this._resetPicker();
        }
      }.bind(this));

      if (crumbs) {
        $.each(crumbs, function(i, crumb) {
          var $crumb;
          if (crumb) {
            $crumb = this.crumbs.addItem(crumb);
            this._setupCrumbListeners($crumb);
          }
        }.bind(this));
      }

      this.crumbs.truncate(); // Ensure crumbs fit in container
    },

    /** @ignore */
    _determineCrumbs: function() {
      var crumbs = this.columnView.getBreadcrumbItems();
      var items = this.columnView.getSelectedItems();

      // Prior Crumbs
      $.each(crumbs, function(i, val) {
        crumbs[i] = this._getCrumbFromColumnViewItem(val, false);
      }.bind(this));

      // Final Crumb
      if (items.length > 0) {
        crumbs.push(this._getCrumbFromColumnViewItem(items[0], true));
      }

      return crumbs;
    },

    /** @ignore */
    _getCrumbFromColumnViewItem: function(item, unavailable) {
      var data = item.data,
        $el = item.item,
        crumb = $('<a></a>'), href;

      // Attach the CUI.ColumnView item to the crumb as data
      crumb.data('coral-columnview-item', item);

      crumb.toggleClass(CRUMBS_MOD_UNAVAILABLE, unavailable);

      // Link taken from parent column href
      href = $($el).closest('.' + PICKER_CLASS_COLUMNVIEW_COLUMN).data('href');

      if (href) {
        crumb.attr('href', href);

        // Set the crumb title from data if available, otherwise from element text
        if (data && data._links && data._links.self && data._links.self.title) {
          return crumb.text(data._links.self.title);
        }
        else if ($el) {
          return crumb.text($el.text().trim());
        }
      }

      return undefined;
    },

    /** @ignore */
    _setCrumbRootHref: function(href) {
      if ($.isPlainObject(this.options.crumbRoot)) {
        this.options.crumbRoot.href = href;
      }
      else if (this.options.crumbRoot && this.options.crumbRoot.jquery) {
        this.options.crumbRoot.attr('href', href);
      }
    }

    /**
      Triggered when path selection is confirmed.

      @name Picker#coral-pathbrowser-picker-confirm
      @event

      @param {Object} event
        Event object.
      @param {String} event.value
        The selected value.
    */
  });

  var CRUMBS_CLASS_CRUMBS = 'coral-Crumbs',
    CRUMBS_CLASS_CRUMBS_ITEM = 'coral-Crumbs-item',

    CRUMBS_MOD_ELLIPSIS = CRUMBS_CLASS_CRUMBS_ITEM + '--ellipsis',
    CRUMBS_MOD_UNAVAILABLE = CRUMBS_CLASS_CRUMBS_ITEM + '--unavailable',
    CRUMBS_MOD_NONAVIGATION = CRUMBS_CLASS_CRUMBS_ITEM + '--noNavigation',

    CRUMBS_HTML_ICON = '<i class="coral-Crumbs-item-icon coral-Icon"></i>',
    CRUMBS_HTML_ELLIPSIS = '<a class="' + CRUMBS_CLASS_CRUMBS_ITEM + ' ' + CRUMBS_MOD_ELLIPSIS + '" href="#"></a>',

    CRUMBS_TRUNCATE_HORIZONTAL_SPACING = 100;

  var Crumbs = new Class( /** @lends Crumbs# */ {
    toString: 'Crumbs',
    extend: CUI.Widget,

    // Public API //

    /**
      @extends CUI.Widget
      @classdesc Widget to display a series of links that know how to truncate when there's not enough space
      to show all the links.

      @constructs
      @param {Object} options
    */
    construct: function(options) {
      this._decorateElement();
      this._findOrCreateEllipsis();

      this.truncate();
    },

    /**
      Add a new crumb.

      @param {Mixed} titleOrObjectOrElement
        A crumb configuration. String, Object or jQuery object can be provided.
        String sets the link text. Object allows for provision of title, icon, isAvailable and isNavigable properties.
      @param {String} href
        Specifies the link to use, when the first argument is a string.

      @returns {jQuery} The crumb that was added.
    */
    addItem: function(titleOrObjectOrElement, href) {
      var $item = this._itemFromTitleOrObjectOrElement(titleOrObjectOrElement, href);

      this.$element.append($item);
      return $item;
    },

    /**
      Remove all crumbs and return them.

      @returns {*} All removed crumbs.
    */
    removeAllItems: function() {
      delete this._firstCrumb;
      return this.$element.children().remove().not('.' + CRUMBS_MOD_ELLIPSIS);
    },

    /**
      Truncate each item just enough to fit all crumbs. The first and last items always stay.
    */
    truncate: function() {
      var items = this.$element.children(),
        availableWidth = this.$element.width() - CRUMBS_TRUNCATE_HORIZONTAL_SPACING;

      items.removeClass(CLASS_COLLAPSED);
      this._ellipsis.remove();

      var fullWidth = Array.prototype.reduce.call(items, function(memo, v) {
        return memo += $(v).outerWidth();
      }, 0);

      if (items.length && (fullWidth > availableWidth)) {

        // Truncate each item just enough. The first and the last item always stay:
        var w = fullWidth;
        for (var i = 1, ln = items.length - 1; i < ln && w > availableWidth; i++) {
          var item = $(items[i]);
          w -= item.width();
          item.addClass(CLASS_COLLAPSED);
        }

        this._ellipsis.insertAfter(items[0]).addClass(CLASS_COLLAPSED);
      }
    },

    // Internals //

    _ellipsis: $(),

    /** @ignore */
    _decorateElement: function() {
      if (!this.$element.is('nav')) {
        throw new Error('Crumbs expects to be attached to a nav element');
      }

      this.$element.addClass(CRUMBS_CLASS_CRUMBS);
      this.$element.children().addClass(CRUMBS_CLASS_CRUMBS_ITEM);
    },

    /** @ignore */
    _findOrCreateEllipsis: function() {
      var $ellipsis = this.$element.find('.' + CRUMBS_MOD_ELLIPSIS);
      if ($ellipsis.length === 0) {
        $ellipsis = $(CRUMBS_HTML_ELLIPSIS);
      }
      this._ellipsis = $ellipsis;
    },

    /** @ignore */
    _itemFromTitleOrObjectOrElement: function(titleOrObjectOrElement, href) {
      var a1 = titleOrObjectOrElement,
        title = (typeof a1 === 'string') ? a1 : undefined,
        object = $.isPlainObject(a1) ? a1 : undefined,
        element = (a1 && a1.jquery) ? a1 : undefined,
        $item;

      if (element) {
        $item = element;
        $item.addClass(CRUMBS_CLASS_CRUMBS_ITEM);
      }
      else if (object) {
        $item = this._constructItemFromObject(object);
      }
      else {
        $item = this._constructItemFromTitleAndRef(title, href);
      }
      return $item;
    },

    /** @ignore */
    _constructItemFromTitleAndRef: function(title, href) {
      return $('<a>').
        attr('href', href).
        text(title).
        addClass(CRUMBS_CLASS_CRUMBS_ITEM);
    },

    /** @ignore */
    _constructItemFromObject: function(object) {
      var $anchor = this._constructItemFromTitleAndRef(object.title, object.href);

      if (object.hasOwnProperty('isAvailable') && !object.isAvailable) {
        $anchor.addClass(CRUMBS_MOD_UNAVAILABLE);
        $anchor.attr('tabindex', -1);
      }
      if (object.hasOwnProperty('isNavigable') && !object.isNavigable) {
        $anchor.addClass(CRUMBS_MOD_NONAVIGATION);
      }
      if (object.hasOwnProperty('icon')) {
        var $icon = $(CRUMBS_HTML_ICON);
        $icon.addClass(object.icon);
        $anchor.prepend($icon);
      }
      return $anchor;
    }
  });

  CUI.util.plugClass(CUI.PathBrowser);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function(e) {
      $("[data-init~='pathbrowser']", e.target).pathBrowser();
    });
  }

  /**
    Register an option handler.

    @example
      // Handler configuration
      var myHandlerConfig = {
        name: "cui.pathbrowser.optionrenderer.myoptionrenderer"
        handler: function(param1, param2, ...) {
          // The option handler
        }
      }

      // Usage
      CUI.PathBrowser.register("optionRenderer", myHandlerConfig);

    @param {String} key
      The option key to register the handler against.
    @param {Object} config
      The handler configuration (name and handler function).

    @static
  */
  CUI.PathBrowser.register = function(key, config) {
    registry.register(key, config);
  };

  CUI.PathBrowser.register('optionRenderer', {
    name: 'cui.pathbrowser.optionrenderer.default',
    handler: function(iterator, index) {
      var value = this.options.options[index];

      if (value.indexOf(PATH_SEPARATOR) === 0) {
        // Option contains an absolute path
        var iLastSlash = value.lastIndexOf(PATH_SEPARATOR);
        value = value.substring(iLastSlash + 1);
      }

      // Use alternate display strings if possible
      var titleMarkup = '';
      if (this.options.showTitles && this.options.optionDisplayStrings[index] && this.options.optionDisplayStrings[index].length > 0) {
        titleMarkup = ' ' + this.options.optionDisplayStrings[index];
      }

      return $("<li>", {
          "class": "coral-SelectList-item coral-SelectList-item--option",
          "data-value": value
      }).text(value + titleMarkup);
    }
  });

  CUI.PathBrowser.register('autocompleteCallback', {
    name: 'cui.pathbrowser.autocompletecallback.default',
    handler: function(path) {
      var self = this;
      var def = $.Deferred();

      // If the input value doesn't start with a slash abort autocomplete,
      // since this is not an absolute path
      if (path.indexOf('/') !== 0) {
        def.resolve([]);
        return def.promise();
      }

      // Check if the input value ends with a slash
      // If so, the options loader will be called if it exists, in order
      // to refresh the available options list.
      // Otherwise, it will just filter the options to only show the
      // matching ones in the auto completer div.

      var basePath = path.substring(0, path.lastIndexOf(PATH_SEPARATOR)) || PATH_SEPARATOR;
      if (basePath != this.lastBasePath && self.optionLoader) {
        var isCustomRoot = false;
        if (basePath === PATH_SEPARATOR) {
          // Use configured root path
          if (self.options.rootPath) {
            path = self.options.rootPath.replace(/\/$/, "");
            if (path !== "") {
              isCustomRoot = true;
            }
            else {
              path = PATH_SEPARATOR;
            }
          }
        }

        // Replace field value if the entered path was a custom root path
        if (isCustomRoot) {
          basePath = path;
          path = path + PATH_SEPARATOR;
          self._setInputValue(path);
        }

        // Make the option loader a promise to guarantee that the callback is
        // executed at the right rime
        var loader = {
          loadOptions: self.optionLoader
        };
        var loaderDef = $.Deferred();
        loaderDef.promise(loader);
        loader.done(
          function(object) {
            if ($.isFunction(object.promise)) {
              // Original function was already returning a promise
              // Bind the rebuild options on that object's 'done' method
              object.done(
                function(object) {
                  self._rebuildOptions(def, path, object);
                }
              );
            }
            else {
              // Original function was not returning a promise
              self._rebuildOptions(def, path, object);
            }
          }
        );

        // Asynch optionLoader
        var results = loader.loadOptions(basePath, function(data) {
          loaderDef.resolve(data);
        });

        //  Synch optionLoader
        if (results) loaderDef.resolve(results);

      }
      else {
        def.resolve(self._filterOptions(path));
      }

      this.lastBasePath = basePath;

      return def.promise();
    }
  });

}(window.jQuery));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

window.CUI = window.CUI || { };
CUI.imageeditor = CUI.imageeditor || {};
CUI.imageeditor.actions = {};
CUI.imageeditor.plugins = {};
CUI.imageeditor.ui = {};
CUI.imageeditor.strings = {};

CUI.imageeditor.strings['de-DE']={
  "control.toolbar.close": "Abbrechen",
  "control.toolbar.finish": "Beenden",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "Freihand",
  "crop.aspect_ratios.square": "Quadrat",
  "crop.template.removecrop": "Beschnitt entfernen",
  "crop.toolbar.confirm": "Bestätigen",
  "crop.toolbar.identifier": "Zuschneiden",
  "crop.toolbar.launch": "Beschnitt beginnen",
  "crop.toolbar.launchwithratio": "Beschnitt beginnen",
  "crop.toolbar.unlaunch": "Abbrechen",
  "flip.toolbar.horizontal": "Horizontal spiegeln",
  "flip.toolbar.vertical": "Vertikal spiegeln",
  "fullscreen.toolbar.fullscreen": "In die Vollbildansicht wechseln",
  "fullscreen.toolbar.fullscreenexit": "Vollbildansicht verlassen",
  "history.toolbar.redo": "Wiederherstellen",
  "history.toolbar.undo": "Rückgängig",
  "map.template.alt_text": "Alt-Text",
  "map.template.confirm": "Bestätigen",
  "map.template.delete": "Löschen",
  "map.template.new_tab": "Neuer Tab",
  "map.template.parent_frame": "Parent-Frame",
  "map.template.path": "Pfad",
  "map.template.path_picker": "Pfad-Picker",
  "map.template.same_tab": "Selber Tab",
  "map.template.target": "Ziel",
  "map.template.top_frame": "Top-Frame",
  "map.template.unlaunch": "Abbrechen",
  "map.toolbar.circle": "Kreisförmige Karte hinzufügen",
  "map.toolbar.confirm": "Bestätigen",
  "map.toolbar.launch": "Karte starten",
  "map.toolbar.polygon": "Polygonkarte hinzufügen",
  "map.toolbar.rectangle": "Rechteckige Karte hinzufügen",
  "map.toolbar.unlaunch": "Abbrechen",
  "rotate.toolbar.left": "Nach links drehen",
  "rotate.toolbar.right": "Nach rechts drehen",
  "zoom.toolbar.popupslider": "Zoom-Schieberegler öffnen",
  "zoom.toolbar.reset100": "Zoom zurücksetzen"
};
CUI.imageeditor.strings['en-US']={
  "control.toolbar.close": "Cancel",
  "control.toolbar.finish": "Finish",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "Free Hand",
  "crop.aspect_ratios.square": "Square",
  "crop.template.removecrop": "Remove Crop",
  "crop.toolbar.confirm": "Confirm",
  "crop.toolbar.identifier": "Crop",
  "crop.toolbar.launch": "Start Crop",
  "crop.toolbar.launchwithratio": "Start Crop",
  "crop.toolbar.unlaunch": "Cancel",
  "flip.toolbar.horizontal": "Flip Horizontally",
  "flip.toolbar.vertical": "Flip Vertically",
  "fullscreen.toolbar.fullscreen": "Enter Fullscreen",
  "fullscreen.toolbar.fullscreenexit": "Exit Fullscreen",
  "history.toolbar.redo": "Redo",
  "history.toolbar.undo": "Undo",
  "map.template.alt_text": "Alt Text",
  "map.template.confirm": "Confirm",
  "map.template.delete": "Delete",
  "map.template.new_tab": "New Tab",
  "map.template.parent_frame": "Parent Frame",
  "map.template.path": "Path",
  "map.template.path_picker": "Path Picker",
  "map.template.same_tab": "Same Tab",
  "map.template.target": "Target",
  "map.template.top_frame": "Top Frame",
  "map.template.unlaunch": "Cancel",
  "map.toolbar.circle": "Add Circular Map",
  "map.toolbar.confirm": "Confirm",
  "map.toolbar.launch": "Launch Map",
  "map.toolbar.polygon": "Add Polygon Map",
  "map.toolbar.rectangle": "Add Rectangular Map",
  "map.toolbar.unlaunch": "Cancel",
  "rotate.toolbar.left": "Rotate Left",
  "rotate.toolbar.right": "Rotate Right",
  "zoom.toolbar.popupslider": "Open Zoom Slider",
  "zoom.toolbar.reset100": "Reset Zoom"
};
CUI.imageeditor.strings['es-ES']={
  "control.toolbar.close": "Cancelar",
  "control.toolbar.finish": "Terminar",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "Manos libres",
  "crop.aspect_ratios.square": "cuadrado",
  "crop.template.removecrop": "Eliminar corte",
  "crop.toolbar.confirm": "Confirmar",
  "crop.toolbar.identifier": "Cortar",
  "crop.toolbar.launch": "Empezar a cortar",
  "crop.toolbar.launchwithratio": "Empezar a cortar",
  "crop.toolbar.unlaunch": "Cancelar",
  "flip.toolbar.horizontal": "Girar horizontalmente",
  "flip.toolbar.vertical": "Girar verticalmente",
  "fullscreen.toolbar.fullscreen": "Ir a pantalla completa",
  "fullscreen.toolbar.fullscreenexit": "Salir de la pantalla completa",
  "history.toolbar.redo": "Rehacer",
  "history.toolbar.undo": "Deshacer",
  "map.template.alt_text": "Texto alternativo",
  "map.template.confirm": "Confirmar",
  "map.template.delete": "Eliminar",
  "map.template.new_tab": "Nueva pestaña",
  "map.template.parent_frame": "Marco superior",
  "map.template.path": "Ruta",
  "map.template.path_picker": "Seleccionador de ruta",
  "map.template.same_tab": "Misma pestaña",
  "map.template.target": "Meta",
  "map.template.top_frame": "Parte superior",
  "map.template.unlaunch": "Cancelar",
  "map.toolbar.circle": "Añadir mapa circular",
  "map.toolbar.confirm": "Confirmar",
  "map.toolbar.launch": "Iniciar mapa",
  "map.toolbar.polygon": "Añadir mapa poligonal",
  "map.toolbar.rectangle": "Añadir mapa rectangular",
  "map.toolbar.unlaunch": "Cancelar",
  "rotate.toolbar.left": "Girar a la izquierda",
  "rotate.toolbar.right": "Girar a la derecha",
  "zoom.toolbar.popupslider": "Abrir zoom deslizante",
  "zoom.toolbar.reset100": "Restablecer zoom"
};
CUI.imageeditor.strings['fr-FR']={
  "control.toolbar.close": "Annuler",
  "control.toolbar.finish": "Terminer",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "Main libre",
  "crop.aspect_ratios.square": "Carré",
  "crop.template.removecrop": "Annuler le recadrage",
  "crop.toolbar.confirm": "Confirmer",
  "crop.toolbar.identifier": "Recadrer",
  "crop.toolbar.launch": "Commencer le recadrage",
  "crop.toolbar.launchwithratio": "Commencer le recadrage",
  "crop.toolbar.unlaunch": "Annuler",
  "flip.toolbar.horizontal": "Inverser horizontalement",
  "flip.toolbar.vertical": "Inverser verticalement",
  "fullscreen.toolbar.fullscreen": "Passer au mode plein écran",
  "fullscreen.toolbar.fullscreenexit": "Quitter le mode plein écran",
  "history.toolbar.redo": "Refaire",
  "history.toolbar.undo": "Annuler",
  "map.template.alt_text": "Texte alternatif",
  "map.template.confirm": "Confirmer",
  "map.template.delete": "Supprimer",
  "map.template.new_tab": "Nouvel onglet",
  "map.template.parent_frame": "Cadre parent",
  "map.template.path": "Chemin",
  "map.template.path_picker": "Sélecteur de chemin",
  "map.template.same_tab": "Même onglet",
  "map.template.target": "Cible",
  "map.template.top_frame": "Cadre supérieur",
  "map.template.unlaunch": "Annuler",
  "map.toolbar.circle": "Ajouter une carte circulaire",
  "map.toolbar.confirm": "Confirmer",
  "map.toolbar.launch": "Lancer la carte",
  "map.toolbar.polygon": "Ajouter une carte polygonale",
  "map.toolbar.rectangle": "Ajouter une carte rectangulaire",
  "map.toolbar.unlaunch": "Annuler",
  "rotate.toolbar.left": "Faire pivoter vers la gauche",
  "rotate.toolbar.right": "Faire pivoter vers la droite",
  "zoom.toolbar.popupslider": "Ouvrir le curseur du zoom",
  "zoom.toolbar.reset100": "Réinitialiser le zoom"
};
CUI.imageeditor.strings['it-IT']={
  "control.toolbar.close": "Annulla",
  "control.toolbar.finish": "Termina",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "Mano Libera",
  "crop.aspect_ratios.square": "Quadrato",
  "crop.template.removecrop": "Rimuovi Ritaglio",
  "crop.toolbar.confirm": "Conferma",
  "crop.toolbar.identifier": "Ritaglia",
  "crop.toolbar.launch": "Avvia Ritaglio",
  "crop.toolbar.launchwithratio": "Avvia Ritaglio",
  "crop.toolbar.unlaunch": "Annulla",
  "flip.toolbar.horizontal": "Inverti Orizzontalmente",
  "flip.toolbar.vertical": "Inverti Verticalmente",
  "fullscreen.toolbar.fullscreen": "Attiva Modalità Schermo Intero",
  "fullscreen.toolbar.fullscreenexit": "Disattiva Modalità Schermo Intero",
  "history.toolbar.redo": "Ripeti Ultima Operazione",
  "history.toolbar.undo": "Annulla Ultima Operazione",
  "map.template.alt_text": "Testo Alternativo",
  "map.template.confirm": "Conferma",
  "map.template.delete": "Cancella",
  "map.template.new_tab": "Nuova Scheda",
  "map.template.parent_frame": "Riquadro Principale",
  "map.template.path": "Percorso",
  "map.template.path_picker": "Selezionatore Del Percorso",
  "map.template.same_tab": "Stessa Scheda",
  "map.template.target": "Obiettivo",
  "map.template.top_frame": "Riquadro Superiore",
  "map.template.unlaunch": "Annulla",
  "map.toolbar.circle": "Aggiungi Mappa Circolare",
  "map.toolbar.confirm": "Conferma",
  "map.toolbar.launch": "Attiva Mappa",
  "map.toolbar.polygon": "Aggiungi Mappa Poligonale",
  "map.toolbar.rectangle": "Aggiungi Mappa Rettangolare",
  "map.toolbar.unlaunch": "Annulla",
  "rotate.toolbar.left": "Ruota A Sinistra",
  "rotate.toolbar.right": "Ruota A Destra",
  "zoom.toolbar.popupslider": "Apri Controllo Zoom",
  "zoom.toolbar.reset100": "Reimposta Zoom"
};
CUI.imageeditor.strings['ja-JP']={
  "control.toolbar.close": "キャンセル",
  "control.toolbar.finish": "終了",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "フリーハンド",
  "crop.aspect_ratios.square": "四角",
  "crop.template.removecrop": "切り抜きを解除",
  "crop.toolbar.confirm": "承認",
  "crop.toolbar.identifier": "切り抜き",
  "crop.toolbar.launch": "切り抜きを開始",
  "crop.toolbar.launchwithratio": "切り抜きを開始",
  "crop.toolbar.unlaunch": "キャンセル",
  "flip.toolbar.horizontal": "左右反転",
  "flip.toolbar.vertical": "上下反転",
  "fullscreen.toolbar.fullscreen": "フルスクリーンで表示",
  "fullscreen.toolbar.fullscreenexit": "フルスクリーンを解除",
  "history.toolbar.redo": "やり直す",
  "history.toolbar.undo": "元に戻す",
  "map.template.alt_text": "代替テキスト",
  "map.template.confirm": "承認",
  "map.template.delete": "削除",
  "map.template.new_tab": "新しいタブ",
  "map.template.parent_frame": "親フレーム",
  "map.template.path": "パス",
  "map.template.path_picker": "パスピッカー",
  "map.template.same_tab": "同じタブ",
  "map.template.target": "ターゲット",
  "map.template.top_frame": "トップフレーム",
  "map.template.unlaunch": "キャンセル",
  "map.toolbar.circle": "環状マップを追加",
  "map.toolbar.confirm": "承認",
  "map.toolbar.launch": "マップを表示",
  "map.toolbar.polygon": "ポリゴンマップを追加",
  "map.toolbar.rectangle": "矩形マップを追加",
  "map.toolbar.unlaunch": "キャンセル",
  "rotate.toolbar.left": "左に回転",
  "rotate.toolbar.right": "右に回転",
  "zoom.toolbar.popupslider": "ズームスライダーを開く",
  "zoom.toolbar.reset100": "ズームをリセット"
};
CUI.imageeditor.strings['ko-KR']={
  "control.toolbar.close": "취소",
  "control.toolbar.finish": "마치기",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "프리 핸드",
  "crop.aspect_ratios.square": "정사각형",
  "crop.template.removecrop": "자르기 제거",
  "crop.toolbar.confirm": "확인",
  "crop.toolbar.identifier": "자르기",
  "crop.toolbar.launch": "자르기 시작",
  "crop.toolbar.launchwithratio": "자르기 시작",
  "crop.toolbar.unlaunch": "취소",
  "flip.toolbar.horizontal": "상하 반전",
  "flip.toolbar.vertical": "좌우 반전",
  "fullscreen.toolbar.fullscreen": "전체화면 들어가기",
  "fullscreen.toolbar.fullscreenexit": "전체화면 나가기",
  "history.toolbar.redo": "다시 실행",
  "history.toolbar.undo": "실행 취소",
  "map.template.alt_text": "대체 텍스트",
  "map.template.confirm": "확인",
  "map.template.delete": "삭제",
  "map.template.new_tab": "새 탭",
  "map.template.parent_frame": "부모 프레임",
  "map.template.path": "경로",
  "map.template.path_picker": "경로 선택기",
  "map.template.same_tab": "같은 탭",
  "map.template.target": "대상",
  "map.template.top_frame": "상위 프레임",
  "map.template.unlaunch": "취소",
  "map.toolbar.circle": "순환형 지도 추가",
  "map.toolbar.confirm": "확인",
  "map.toolbar.launch": "지도 실행",
  "map.toolbar.polygon": "다각형 지도 추가",
  "map.toolbar.rectangle": "사각형 지도 추가",
  "map.toolbar.unlaunch": "취소",
  "rotate.toolbar.left": "왼쪽으로 회전",
  "rotate.toolbar.right": "오른쪽으로 회전",
  "zoom.toolbar.popupslider": "줌 슬라이더 열기",
  "zoom.toolbar.reset100": "줌 재설정"
};
CUI.imageeditor.strings['pt-BR']={
  "control.toolbar.close": "Cancelar",
  "control.toolbar.finish": "Terminar",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "Mão Livre",
  "crop.aspect_ratios.square": "Quadrado",
  "crop.template.removecrop": "Remover Corte",
  "crop.toolbar.confirm": "Confirmar",
  "crop.toolbar.identifier": "CorteÏ",
  "crop.toolbar.launch": "Começar Corte",
  "crop.toolbar.launchwithratio": "Começar Corte",
  "crop.toolbar.unlaunch": "Cancelar",
  "flip.toolbar.horizontal": "Giro Horizontal",
  "flip.toolbar.vertical": "Giro Vertical",
  "fullscreen.toolbar.fullscreen": "Inserir Tela inteira",
  "fullscreen.toolbar.fullscreenexit": "Sair de Tela inteira",
  "history.toolbar.redo": "Refazer",
  "history.toolbar.undo": "Desfazer",
  "map.template.alt_text": "Texto Alternativo",
  "map.template.confirm": "Confirmar",
  "map.template.delete": "Deletar",
  "map.template.new_tab": "Nova Tabela",
  "map.template.parent_frame": "Quadro Principal",
  "map.template.path": "Caminho",
  "map.template.path_picker": "Coletor de Caminho",
  "map.template.same_tab": "Mesma Tabela",
  "map.template.target": "Alvo",
  "map.template.top_frame": "Quadro Superior",
  "map.template.unlaunch": "Cancelar",
  "map.toolbar.circle": "Adicionar Mapa Circular",
  "map.toolbar.confirm": "Confirmar",
  "map.toolbar.launch": "Lançar Mapa",
  "map.toolbar.polygon": "Adicionar Mapa Polígono",
  "map.toolbar.rectangle": "Adicionar Mapa Retangular",
  "map.toolbar.unlaunch": "Cancelar",
  "rotate.toolbar.left": "Girar à Esquerda",
  "rotate.toolbar.right": "Girar à Direita",
  "zoom.toolbar.popupslider": "Abrir Zoom Deslizante",
  "zoom.toolbar.reset100": "Restabelecer Zoom"
};
CUI.imageeditor.strings['zh-CN']={
  "control.toolbar.close": "取消",
  "control.toolbar.finish": "完成",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "徒手",
  "crop.aspect_ratios.square": "方形",
  "crop.template.removecrop": "去除裁剪",
  "crop.toolbar.confirm": "确认",
  "crop.toolbar.identifier": "裁剪",
  "crop.toolbar.launch": "开始裁剪",
  "crop.toolbar.launchwithratio": "开始裁剪",
  "crop.toolbar.unlaunch": "取消",
  "flip.toolbar.horizontal": "水平翻转",
  "flip.toolbar.vertical": "垂直翻转",
  "fullscreen.toolbar.fullscreen": "进入全屏",
  "fullscreen.toolbar.fullscreenexit": "退出全屏",
  "history.toolbar.redo": "重做",
  "history.toolbar.undo": "撤销",
  "map.template.alt_text": "Alt 文字",
  "map.template.confirm": "确认",
  "map.template.delete": "删除",
  "map.template.new_tab": "新选项卡",
  "map.template.parent_frame": "父框架",
  "map.template.path": "路径",
  "map.template.path_picker": "路径选择器",
  "map.template.same_tab": "同一选项卡",
  "map.template.target": "目标",
  "map.template.top_frame": "顶层框架",
  "map.template.unlaunch": "取消",
  "map.toolbar.circle": "添加圆形地图",
  "map.toolbar.confirm": "确认",
  "map.toolbar.launch": "启动地图",
  "map.toolbar.polygon": "添加多边形地图",
  "map.toolbar.rectangle": "添加矩形地图",
  "map.toolbar.unlaunch": "取消",
  "rotate.toolbar.left": "向左旋转",
  "rotate.toolbar.right": "向右旋转",
  "zoom.toolbar.popupslider": "打开缩放滑块",
  "zoom.toolbar.reset100": "重置缩放"
};
CUI.imageeditor.strings['zh-TW']={
  "control.toolbar.close": "取消",
  "control.toolbar.finish": "完成",
  "crop.aspect_ratios.16_to_9": "16 : 9",
  "crop.aspect_ratios.2_to_3": "2 : 3",
  "crop.aspect_ratios.3_to_5": "3 : 5",
  "crop.aspect_ratios.free_hand": "徒手繪圖",
  "crop.aspect_ratios.square": "正方型",
  "crop.template.removecrop": "移除裁切",
  "crop.toolbar.confirm": "確認",
  "crop.toolbar.identifier": "裁切",
  "crop.toolbar.launch": "開始裁切",
  "crop.toolbar.launchwithratio": "開始裁切",
  "crop.toolbar.unlaunch": "取消",
  "flip.toolbar.horizontal": "水平翻轉",
  "flip.toolbar.vertical": "垂直翻轉",
  "fullscreen.toolbar.fullscreen": "進入全螢幕模式",
  "fullscreen.toolbar.fullscreenexit": "離開全螢幕模式",
  "history.toolbar.redo": "取消復原",
  "history.toolbar.undo": "復原",
  "map.template.alt_text": "修改文字",
  "map.template.confirm": "確認",
  "map.template.delete": "刪除",
  "map.template.new_tab": "新分頁",
  "map.template.parent_frame": "母框架",
  "map.template.path": "路徑",
  "map.template.path_picker": "路線選擇器",
  "map.template.same_tab": "同一分頁",
  "map.template.target": "目標",
  "map.template.top_frame": "最上層框架",
  "map.template.unlaunch": "取消",
  "map.toolbar.circle": "新增圓形地圖",
  "map.toolbar.confirm": "確認",
  "map.toolbar.launch": "發佈地圖",
  "map.toolbar.polygon": "新增多邊形地圖",
  "map.toolbar.rectangle": "新增矩型地圖",
  "map.toolbar.unlaunch": "取消",
  "rotate.toolbar.left": "向左旋轉",
  "rotate.toolbar.right": "向右旋轉",
  "zoom.toolbar.popupslider": "開啟縮放滑桿",
  "zoom.toolbar.reset100": "重設縮放"
};

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

    var locales = {
      /** English (U.S.) */
      'en': 'en-US',
      /** English (U.S.)*/
      'en-us': 'en-US',
      /** German (Germany)*/
      'de': 'de-DE',
      /** German (Germany)*/
      'de-de': 'de-DE',
      /** Spanish (Spain)*/
      'es': 'es-ES',
      /** Spanish (Spain)*/
      'es-es': 'es-ES',
      /** French (France)*/
      'fr': 'fr-FR',
      /** French (France)*/
      'fr-fr': 'fr-FR',
      /** Italian (Italy)*/
      'it': 'it-IT',
      /** Italian (Italy)*/
      'it-it': 'it-IT',
      /** Japanese (Japan)*/
      'ja': 'ja-JP',
      /** Japanese (Japan)*/
      'ja-jp': 'ja-JP',
      /** Korean (Korea)*/
      'ko': 'ko-KR',
      /** Korean (Korea)*/
      'ko-kr': 'ko-KR',
      /** Portuguese (Brazil) */
      'pt': 'pt-BR',
      /** Portuguese (Brazil) */
      'pt-br': 'pt-BR',
      /** Simplified Chinese */
      'zh-cn': 'zh-CN',
      /** Simplified Chinese */
      'zh-hans-cn': 'zh-CN',
      /** Simplified Chinese */
      'zh-hans': 'zh-CN',
      /** Traditional Chinese */
      'zh-tw': 'zh-TW',
      /** Traditional Chinese */
      'zh-hant-tw': 'zh-TW',
      /** Traditional Chinese */
      'zh-hant': 'zh-TW'
    };

    CUI.imageeditor.I18nProvider = new Class({

      toString: 'I18nProvider',

      construct : function () {
        var DEFAULT_LOCALE = 'en-US';
        var pageLanguage = locales[document.documentElement.lang.toLowerCase()] || document.documentElement.lang || DEFAULT_LOCALE;
        var pageLanguageSubIDs = /^(..)-?(.*)$/gi.exec(pageLanguage);

        if (typeof CUI.imageeditor.strings[pageLanguageSubIDs[0]] !== "undefined") { // handles all languages defined in locales object
          pageLanguage = pageLanguageSubIDs[0];
        }
        else { // handles languages not defined in locales object, e.g. en-GB, fr-CH, pt-PT, da, zu, etc
          pageLanguage = (typeof CUI.imageeditor.strings[locales[pageLanguageSubIDs[1]]] !== "undefined") ? locales[pageLanguageSubIDs[1]] : DEFAULT_LOCALE;
        }

        this.translations = CUI.imageeditor.strings[pageLanguage];
    },

    /**
     * Get localized string for given key.
     *
     * @param {String} localization key
     * @return {String} localized string or key, if key is unknown
     */
    get : function (key) {
      if (this.has(key)) {
        return this.translations[key];
      }

      return key;
    },

    /**
     * Test if key is known localization key
     *
     * @param {String} localization key
     * @return {Boolean}
     */
    has : function (key) {
      return this.translations.hasOwnProperty(key);
    }
  });

}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.OptionsUtils = {

    /**
     * Load options from data attributes (asynchronously in the 'options-path' case),
     * process them and start the image editor.
     * @param {CUI.ImageEditor} imageeditor The image editor
     * @param {jQuery} $editable The editable image
     * @return {Function} callback Options-processing callback
     */
    loadOptionsAndStartEditing: function (imageeditor, $editable, callback) {
      /**
       * Finalize processing of the image editor options and start
       * @param {Object} options The options to finish processing
       */
      function optionsLoaded(opts) {
        if (typeof callback === 'function') {
          opts = callback(opts);
        }

        imageeditor.start(opts);
      }

      // Options can either be supplied directly as a JSON object in a
      // data attribute or loaded from path

      var options = {},
          optionsObj  = $editable.data('options'),
          optionsPath = $editable.data('options-path');

      if ($.isPlainObject(optionsObj)) {
        optionsLoaded(optionsObj);
      }
      else if (optionsPath) {
        $.ajax({
          'url': optionsPath,
          'success': function (data) {
            options = data;
          },
          'complete': function () {
            optionsLoaded(options);
          }
        });
      }
      else {
        optionsLoaded(options);
      }
    }
  };
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var noop = function () {};

  CUI.imageeditor.TemplateProvider = new Class({

    toString: 'TemplateProvider',

    construct : function (templates) {
      this.templates = $.extend({}, CUI.imageeditor.Templates, templates);
    },

    /**
     * Get template function for given name.
     *
     * @param {String} template name
     * @return {Function} template function or
     *                    CUI.imageeditor.TemplateProvider.NOOP if name is
     *                    unknown
     */
    get : function (name) {
      if (this.has(name)) {
        return this.templates[name];
      }

      return noop;
    },

    /**
     * Test if name is a known template.
     *
     * @param {String} template name
     * @return {Boolean}
     */
    has : function (name) {
      return this.templates.hasOwnProperty(name);
    }
  });

  CUI.imageeditor.TemplateProvider.NOOP = noop;
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.Theme
   * The theme-specific constants for the image editor component.
   * @static
   * @singleton
   * @ignore
   */
  CUI.imageeditor.Theme = {

    /**
     * CSS class for elements
     * @ignore
     */
    IMAGEEDITOR_HIDDEN_CLASS: 'u-coral-hidden',

    /**
     * CSS class that is added to disabled toolbar items
     * @ignore
     */
    TOOLBARITEM_DISABLED_CLASS: 'is-disabled',

    /**
     * CSS class that is added to selected toolbar items
     * @ignore
     */
    TOOLBARITEM_SELECTED_CLASS: 'is-selected',

    /**
     * CSS class for toolbar buttons, that change the operation mode
     * @ignore
     */
    TOOLBARITEM_MODECHANGER_CLASS: 'modechanger'

  };

}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * Manages the form and its hidden fields that represent the image transformation
   * @class CUI.imageeditor.TransformResult
   * @static
   * @private
   */
  CUI.imageeditor.TransformResult = new Class({

    toString: 'TransformResult',

    /**
     * The object containing the transformation
     */
    result: null,

    /**
     * Array used to store previous result states
     *
     * @private
     */
    history: null,

    /**
     * Array used to store result states, that where rolled back using undo
     *
     * @private
     */
    future: null,

    construct: function () {
      this.result = {};
      this.history = [];
      this.future  = [];
    },

    /**
     * <p>Registers the specified field as a transformation field.</p>
     *
     * @param {String} name The transform field name
     * @return {Boolean} true on successful registration of transform field
     */
    registerTransformField: function (name) {
      if (this.result.hasOwnProperty(name)) {
        return false;
      }

      this.result[name] = null;

      return true;
    },

    /**
     * <p>Set the transformation value of a transform form field.</p>
     *
     * @param {String} name The transform field name
     * @param {Object} val The transform field value
     * @param {Boolean} storeHistory (default: true) Should this change be
     *                         stored in history
     * @return {Boolean} true on successful setting of field value
     */
    setTransformValue: function (name, val, storeHistory) {
      if (storeHistory !== false) {
        this.storeHistory();
      }

      if (this.result.hasOwnProperty(name)) {
        this.result[name] = val;
        return true;
      }
      else {
        return false;
      }
    },

    /**
     * <p>Set the transformation value of multiple transform form fields at
     * once. This creates only one history entry.<br/>Unknow object keys are
     * silently ignored.</p>
     *
     * @param {mixed} values If Object,   then key is field name, value is field
     *                                    value
     *                       If Object[], then the value of the transformation
     *                                    field is the field name and the rest
     *                                    object is value Also see result of
     *                                    toJSON for examples.
     * @param {Boolean} storeHistory (default: true) Should this change be
     *                                               stored in history
     */
    setTransformValues : function (values, storeHistory) {
      var i, name, value;

      if (storeHistory !== false) {
        this.storeHistory();
      }

      if ($.isPlainObject(values)) {
        for (name in values) {
          if (values.hasOwnProperty(name)) {
            this.setTransformValue(name, values[name], false);
          }
        }
      }
      else if ($.isArray(values)) {
        for (i = 0; i < values.length; i++) {
          value = $.extend({}, values[i]);
          name = value.transformation;
          delete value.transformation;

          if (!$.isEmptyObject(value)) {
            this.setTransformValue(name, value, false);
          }
        }
      }
    },

    /**
     * Undo last set operation
     * @return {Boolean} true if successful, false if no previous state
     *                   available
     */
    undo : function () {
      if (this.history.length) {
        this.storeHistory();
        this.future.push(this.history.pop());

        this.setTransformValues(this.history.pop(), false);

        return true;
      }
      return false;
    },

    /**
     * Redo last undo
     * @return {Boolean} true if successful, false if no previous state
     *                   available
     */
    redo : function () {
      if (this.future.length) {
        this.storeHistory();

        this.setTransformValues(this.future.pop(), false);

        return true;
      }
      return false;
    },

    /**
     * <p>Get the transformation value of a transform form field.</p>
     * @param {String} name The transform field name
     * @return {Object} transformation value of a transform form field, which
     *                  was previously set using setTransformValue.
     *                  undefined for unknown id
     */
    getTransformValue: function (name) {
      if (this.result.hasOwnProperty(name)) {
        return this.result[name];
      }
      else {
        return undefined;
      }
    },

    /**
     * Return object representation of transform result which can be used to
     * serialize using JSON.stringify()
     * @return {Object}
     */
    toJSON : function () {
      var json = [],
          name;

      for (name in this.result) {
        if (this.result.hasOwnProperty(name) &&
            $.isPlainObject(this.result[name]) &&
            !$.isEmptyObject(this.result[name])) {

          json.push($.extend(
            true,
            {transformation : name},
            this.result[name]
          ));
        }
      }

      return json;
    },

    /**
     * Store current state in history array
     *
     * @private
     */
    storeHistory: function () {
      this.history.push($.extend(true, {}, this.result));
    }
  });
}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2013 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.UIUtils = {

    getUIContainer: function ($editable) {
      $editable = $($editable);

      if ($editable.is('.imageeditor-container')) {
        return $editable;
      }

      return $editable.parents('.imageeditor-container').first();
    },

    getToolbars: function ($editableOrContainer, tbType) {
      var $container, $toolbars;

      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      $container = $editableOrContainer.hasClass('imageeditor-container') ?
          $editableOrContainer :
          CUI.imageeditor.UIUtils.getUIContainer($editableOrContainer);

      if (!$container || !$container.length) {
        return null;
      }

      $toolbars = $container.find('div[data-type="' + tbType + '"] > div.imageeditor-toolbar');

      if (!$toolbars || !$toolbars.length) {
        return null;
      }

      return $toolbars;
    },

    getToolbarContainer: function ($container, tbType) {
      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      var $tbCont = $container.find('.imageeditor-toolbars [data-type="' + tbType + '"]');

      if ($tbCont.length) {
        return $tbCont;
      }
      return $container.find('.imageeditor-toolbars');
    },

    getItem: function (ref, tbType, $container) {
      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      return $container.find('div[data-type="' + tbType + '"] ' +
          'button[data-action="' + ref + '"]');
    },

    /**
     * <p>Determines the 'clipping parent' of the specified DOM object.</p>
     * <p>The clipping parent is a DOM object that might clip the visible area of
     * the specified DOM object by specifying a suitable 'overflow' attribute.</p>
     * @param {jQuery} $dom The jQuery-wrapped DOM object
     * @return {jQuery} The clipping parent as a jQuery object; undefined if no
     *       clipping parent exists
     */
    getClippingParent: function ($dom) {
      var $clipParent, ovf, ovfX, ovfY,
          $body = $(document.body);

      while ($dom[0] !== $body[0]) {
        ovf = $dom.css('overflow');
        ovfX = $dom.css('overflowX');
        ovfY = $dom.css('overflowY');

        if ((ovfX !== 'visible') || (ovfY !== 'visible') || (ovf !== 'visible')) {
          $clipParent = $dom;
          break;
        }
        $dom = $dom.parent();
      }
      return $clipParent;
    },

    /**
     * Is the DOM element in an iFrame?
     * @param {HTMLElement} el The element to test
     * @return {HTMLElement} the parent iFrame document for the element, null if not in an iFrame
     * @private
     */
    elementInIframe: function (el) {
      var elementDocument = $(el).prop('ownerDocument'),
          theIframe = null;

      $('iframe').each(function () {
        if (this.contentDocument === elementDocument) {
          theIframe = this;
          return;
        }
      });

      return theIframe;
    },

    handleTapOrClick: function (el, handler, options) {
      options = options || {};
      var namespace = '';
      if (!options.timeout) {
        options.timeout = 300;
      }
      if (typeof options.clickIgnoredAfterTouchTimeout === 'undefined') {
        options.clickIgnoredAfterTouchTimeout = 5000; // this needs to take delays by animations into account
      }
      if (typeof options.preventIgnoredClickEventDefault === 'undefined') {
        options.preventIgnoredClickEventDefault = true;
      }
      if (typeof options.stopIgnoredClickEventImmediatePropagation === 'undefined') {
        options.stopIgnoredClickEventImmediatePropagation = true;
      }
      if (typeof options.preventTouchendDefault === 'undefined') {
        options.preventTouchendDefault = true; // avoids sending a click event later (might even go to other element)
      }
      if (typeof options.eventNamespace !== 'undefined' && options.eventNamespace) {
        if (options.eventNamespace.indexOf('.') !== 0) {
          namespace = '.' + options.eventNamespace;
        } else {
          namespace = options.eventNamespace;
        }
      }

      var statusObject = null;
      statusObject = {
        lastTouchstartTime: 0,
        lastTouchTime: 0,
        off: function() {
          el.off('click' + namespace, statusObject.clickHandler);
          el.off('touchend' + namespace, statusObject.touchendHandler);
          el.off('touchstart' + namespace, statusObject.touchstartHandler);
        }
      };

      statusObject.outerHandler = handler;
      statusObject.clickHandler = function (e) {
        var now = new Date().getTime();
        if (options.clickIgnoredAfterTouchTimeout > (now - statusObject.lastTouchTime)) {
          if (options.preventIgnoredClickEventDefault) {
            e.preventDefault();
          }
          if (options.stopIgnoredClickEventImmediatePropagation) {
            e.stopImmediatePropagation();
          }
          return; // this should have been handled as a touch event, if preventDefault wasn't called
        }
        statusObject.outerHandler.apply((e.currentTarget || {}), [e]);
      };
      statusObject.touchstartHandler = function (e) {
        var now = new Date().getTime();
        statusObject.lastTouchstartTime = now;
        statusObject.lastTouchTime = statusObject.lastTouchstartTime;
      };
      statusObject.touchendHandler = function (e) {
        var now = new Date().getTime();
        statusObject.lastTouchTime = now;
        if (options.timeout < (now - statusObject.lastTouchstartTime)) {
          return; // held on too long - no tap any more
        }
        if (options.preventTouchendDefault) {
          e.preventDefault();
        }

        statusObject.lastTouchstartTime = 0; // allow fast tapping
        statusObject.outerHandler.apply((e.currentTarget || {}), [e]);
      };

      el.on('click' + namespace, statusObject.clickHandler);
      el.on('touchstart' + namespace, statusObject.touchstartHandler);
      el.on('touchend' + namespace, statusObject.touchendHandler);
      return statusObject;
    },

    installPinchZooming : function (target, reservedNs, currentZoomGetter, zoomSetter) {
      this.togglePinchZooming(true, target, reservedNs, currentZoomGetter, zoomSetter);
    },

    togglePinchZooming : function (enable, target, reservedNs, currentZoomGetter, zoomSetter) {
      reservedNs = reservedNs || '.imageeditorzoom';
      var START = 'gesturestart' + reservedNs,
        CHANGE = 'gesturechange' + reservedNs,
        END = 'gestureend' + reservedNs,
        MIN_UPDATE_DELAY_MS = 100;

      target.off(reservedNs);
      if (enable) {
        target.on(START, function (evt) {
          var zoomFactorAtStart = currentZoomGetter(),
            lastUpdate = 0,
            openTimeout = null;

          evt.preventDefault();
          target.off(CHANGE);
          target.on(CHANGE, function (evt) {
            var scale = evt.originalEvent.scale,
              nextUpdate = 1;
            evt.preventDefault();

            if (openTimeout) {
              clearTimeout(openTimeout);
              nextUpdate = Math.max(1, MIN_UPDATE_DELAY_MS - (new Date().getTime() - lastUpdate));
            }

            openTimeout = setTimeout(function () {
                lastUpdate = new Date().getTime();
                zoomSetter(scale * zoomFactorAtStart, 'change');
                // reset timeout only after zooming finished
                openTimeout = null;
              },
              nextUpdate
            );
          });
          target.on(END, function (evt) {
            var scale = evt.originalEvent.scale;
            evt.preventDefault();

            if (openTimeout) {
              clearTimeout(openTimeout);
            }

            target.off(CHANGE);
            target.off(END);
            zoomSetter(scale * zoomFactorAtStart, 'end');
          });
        });
      }
    },

    removePinchZooming : function (target, reservedNs) {
      this.togglePinchZooming(false, target, reservedNs);
    },

    isHavingClassOrParentHavingClass: function (el, clazz) {
      if (el) {
        if (!el.hasClass) {
          el = $(el);
        }
        if (el.hasClass(clazz)) {
          return true;
        } else if (el.length) {
          return this.isHavingClassOrParentHavingClass(el.parent(), clazz);
        }
      }
      return false;
    },

    isHavingModalParent: function (el) {
      return this.isHavingClassOrParentHavingClass(el, 'coral-Modal');
    },

    /**
     * Gets page coordinates of event, also from emulated click events (Touch event coordinates returned if available).
     * @param {Object} e the event
     * @returns {{x: (Number), y: (Number)}} Page coordinates X and Y
     */
    getEventCoordinatesPageRelative : function (e) {
      if (e.originalEvent && e.originalEvent.touches) {
        return { x : e.originalEvent.touches[0].pageX, y : e.originalEvent.touches[0].pageY };
      } else {
        return { x : e.pageX, y : e.pageY };
      }
    }

  };
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.Utils = {

    defer: function (fn, ms, scope, args) {
      var callFn = fn;
      if (scope) {
        callFn = function () {
          if (args) {
            fn.apply(scope, args);
          } else {
            fn.call(scope);
          }
        };
      } else if (args) {
        callFn = function () {
          fn.apply(window, args);
        };
      }
      return window.setTimeout(callFn, ms);
    },

    onPluginCreated: function (plugin) {
      return plugin;
    },

    applyDefaults: function (obj, defaults) {
      var k, v;

      obj = obj || {};
      defaults = defaults || {};

      if (typeof(obj) === 'object') {
        for (k in defaults) {
          if (defaults.hasOwnProperty(k)) {
            v = defaults[k];
            if (v && (typeof(v) === 'object') && !CUI.imageeditor.Utils.isArray(v)) {
              obj[k] = this.applyDefaults(obj[k], v);
            } else if (typeof(obj[k]) === 'undefined') {
              obj[k] = v;
            }
          }
        }
      }
      return obj;
    },

    isArray: function (obj) {
      return $.isArray(obj);
    },

    isString: function (obj) {
      return $.isString(obj);
    },

    endsWith: function (str, toSearch) {
      if (typeof str === 'undefined' || str === null) {
        return false;
      }
      if (toSearch  === null || typeof toSearch === 'undefined') {
        return false;
      }

      if (str.length < toSearch.length) {
        return false;
      }
      return str.substring(str.length - toSearch.length) === toSearch;
    },

    apply: function (obj, config, defaults) {
      return $.extend(obj, config, defaults);
    },

    getPagePosition: function (dom) {
      var pos = $(dom).offset();
      return [ pos.left, pos.top ];
    },

    getWidth: function (dom) {
      return $(dom).width();
    },

    getHeight: function (dom) {
      return $(dom).height();
    },

    jsonDecode: function (str) {
      return $.parseJSON(str);
    }
  };
}(jQuery, this));

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function ($, window, undefined) {
  'use strict';

  var isDimension = function (valOrObject, attrName) {
    var toCheck = valOrObject;
    if (attrName) {
      if (typeof valOrObject === 'object') {
        toCheck = valOrObject[attrName];
      } else {
        return false;
      }
    }

    if (typeof toCheck === 'number' && toCheck > 0) {
      return true;
    }

    if (typeof toCheck === 'string') {
      var floatValue = parseFloat(toCheck);
      return !isNaN(floatValue) &&
        floatValue > 0 &&
        (
          ('' + floatValue) === toCheck ||
          CUI.imageeditor.Utils.endsWith(toCheck, 'px') // % not supported currently
        );
    }
    return false;

  };

  /**
   Different sizes and translations some of which are required to display image editor,
   others for understandability and testability.

   Different scale types:
   + natural: the image file dimensions as loaded
   + display: the image as scaled for display (by abiding to fixed or min/max limit options)
   + zoomed: the image as zoomed from its scaled dimensions

   @class
   @this {CUI.imageeditor.TranslationUtil}
   @constructor
   */
  CUI.imageeditor.TranslationUtil = function (options) {
    if (typeof options !== 'object') {
      throw new Error('Sizes need constructor parameter');
    }

    this.initRotation(options);

    this.flip = options.flip || {horizontal: false, vertical: false};

    this.naturalDimensionsBeforeRotation = {
      height: options.naturalHeight,
      width: options.naturalWidth
    };

    this.naturalDimensions = this.rotateDimsIfNecessary(this.naturalDimensionsBeforeRotation);

    if (options.cropOnOriginal && options.cropOnOriginal.width && options.cropOnOriginal.height) {
      this.cropOnOriginal = {
        top: options.cropOnOriginal.top || 0,
        left: options.cropOnOriginal.left || 0,
        height: options.cropOnOriginal.height,
        width: options.cropOnOriginal.width
      };
    } else {
      this.cropOnOriginal = {
        top: 0,
        left: 0,
        height: this.naturalDimensionsBeforeRotation.height,
        width: this.naturalDimensionsBeforeRotation.width
      };
    }

    this.croppedRotatedDim = this.rotateDimsIfNecessary(this.cropOnOriginal);

    this.determineScaledDimensions(options);
  };

  CUI.imageeditor.TranslationUtil.prototype.determineScaledDimensions = function (options) {
    var fixedSizes = false,
      widthScaleFactor = 1.0,
      heightScaleFactor = 1.0,
      zoomFactor = 1.0,
      previousWidthScaleFactor,
      previousHeightScaleFactor;

    // 10.13 check for fixed size (crop would need to be scaled to fit into them)
    fixedSizes = false;
    if (isDimension(options, 'fixedWidth') ||
      isDimension(options, 'fixedHeight')) {

      fixedSizes = true;
    }

    if (fixedSizes) {
      var fixedWidth = parseInt(options.fixedWidth, 10),
        fixedHeight = parseInt(options.fixedHeight, 10);

      // support one given fixed dimension, too:
      if (isNaN(fixedWidth)) {
        widthScaleFactor = heightScaleFactor = fixedHeight / this.croppedRotatedDim.height;
      } else if (isNaN(fixedHeight)) {
        widthScaleFactor = heightScaleFactor = fixedWidth / this.croppedRotatedDim.width;
      } else {
        widthScaleFactor = fixedWidth / this.croppedRotatedDim.width;
        heightScaleFactor = fixedHeight / this.croppedRotatedDim.height;
      }
    }

    // 10.16 check for min and max forced limits violated by crop - crop would need to be scaled to fit into them if necessary
    if (!fixedSizes) { // fixedSizes overrides min/max scaling

      var minDimensions = {width: -1, height: -1},
        maxDimensions = {width: -1, height: -1};

      if (isDimension(options, 'minWidth')) {
        minDimensions.width = parseInt(options.minWidth, 10);
      }
      if (isDimension(options, 'minHeight')) {
        minDimensions.height = parseInt(options.minHeight, 10);
      }

      if (isDimension(options, 'maxWidth')) {
        maxDimensions.width = parseInt(options.maxWidth, 10);
      }
      if (isDimension(options, 'maxHeight')) {
        maxDimensions.height = parseInt(options.maxHeight, 10);
      }

      var scaleToMinBy = null;
      if (minDimensions.width > 0) {
        if (minDimensions.height > 0) {
          // both given, need to determine which is dominating
          if (minDimensions.width / minDimensions.height < this.croppedRotatedDim.width / this.croppedRotatedDim.height) {
            // height dominates minimum
            scaleToMinBy = 'height';
          } else {
            scaleToMinBy = 'width';
          }
        } else {
          scaleToMinBy = 'width';
        }
      } else if (minDimensions.height > 0) {
        scaleToMinBy = 'height';
      }

      var scaleToMaxBy = null;
      if (maxDimensions.width > 0) {
        if (maxDimensions.height > 0) {
          // determine dominating dimension
          if (maxDimensions.width / maxDimensions.height < this.croppedRotatedDim.width / this.croppedRotatedDim.height) {
            // width dominates max
            scaleToMaxBy = 'width';
          } else {
            scaleToMaxBy = 'height';
          }
        } else {
          scaleToMaxBy = 'width';
        }
      } else if (maxDimensions.height > 0) {
        scaleToMaxBy = 'height';
      }

      if (scaleToMinBy) {
        if (scaleToMinBy === 'height') {
          if (minDimensions.height > this.croppedRotatedDim.height) {
            previousHeightScaleFactor = heightScaleFactor;
            heightScaleFactor = minDimensions.height / this.croppedRotatedDim.height;
            // scale with same aspect ratio:
            widthScaleFactor = heightScaleFactor / previousHeightScaleFactor * widthScaleFactor;
          }
        } else {
          if (minDimensions.width > this.croppedRotatedDim.width) {
            previousWidthScaleFactor = widthScaleFactor;
            widthScaleFactor = minDimensions.width / this.croppedRotatedDim.width;
            heightScaleFactor = widthScaleFactor / previousWidthScaleFactor * heightScaleFactor;
          }
        }
      }

      if (scaleToMaxBy) {
        if (scaleToMaxBy === 'height') {
          if (maxDimensions.height < this.croppedRotatedDim.height) {
            previousHeightScaleFactor = heightScaleFactor;
            heightScaleFactor = maxDimensions.height / this.croppedRotatedDim.height;
            widthScaleFactor = heightScaleFactor / previousHeightScaleFactor * widthScaleFactor;
          }
        } else {
          if (maxDimensions.width < this.croppedRotatedDim.width) {
            previousWidthScaleFactor = widthScaleFactor;
            widthScaleFactor = maxDimensions.width / this.croppedRotatedDim.width;
            heightScaleFactor = widthScaleFactor / previousWidthScaleFactor * heightScaleFactor;
          }
        }
      }
    }

    this.displayDimensions = {
      height: Math.round(this.croppedRotatedDim.height * heightScaleFactor),
      width: Math.round(this.croppedRotatedDim.width * widthScaleFactor)
    };

    this.fromNaturalToDisplayScaleFactors = {
      width: widthScaleFactor,
      height: heightScaleFactor
    };

    if (options.zoomFactor) {
      zoomFactor = options.zoomFactor;
    }
    this.zoomFactor = zoomFactor;

    this.zoomedDimensions = {
      height: Math.round(this.displayDimensions.height * zoomFactor),
      width: Math.round(this.displayDimensions.width * zoomFactor)
    };

    this.fromNaturalToZoomedScaleFactors = {
      width: widthScaleFactor * zoomFactor,
      height: heightScaleFactor * zoomFactor
    };

    this.fromDisplayToZoomedScaleFactors = {
      width: zoomFactor,
      height: zoomFactor
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.initRotation = function (options) {
    var rotation = null;
    if (options.rotation) {
      var rotationTest = parseInt(options.rotation, 10);
      if (!isNaN(rotationTest)) {
        rotation = rotationTest;
      }
    }

    options.rotation = rotation;

    this.rotatedByNinetyDegrees = false;
    this.rotation = 0;
    if (options.rotation) {
      this.rotation = options.rotation;

      var rotationRest = Math.abs(options.rotation % 180);
      if (rotationRest === 90) {
        this.rotatedByNinetyDegrees = true;
      }
    }
  };

  CUI.imageeditor.TranslationUtil.prototype.getDisplayDimensions = function () {
    return this.displayDimensions;
  };

  CUI.imageeditor.TranslationUtil.prototype.getNaturalDimensions = function () {
    return this.naturalDimensions;
  };

  CUI.imageeditor.TranslationUtil.prototype.getZoomedDimensions = function () {
    return this.zoomedDimensions;
  };

  CUI.imageeditor.TranslationUtil.prototype.getZoomedDimensionsBeforeRotation = function () {
    var scaleFactors = this.getFromNaturalToZoomedScaleFactors(true),
      dims = this.getNaturalDimensionsBeforeRotation();

    return {
      height: Math.round(dims.height * scaleFactors.height),
      width: Math.round(dims.width * scaleFactors.width)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getZoomedCropBeforeRotation = function () {
    var crop = this.getCropOnOriginal(),
      scaleFactors = this.getFromNaturalToZoomedScaleFactors(true);

    return {
      top: Math.round(crop.top * scaleFactors.height),
      left: Math.round(crop.left * scaleFactors.width),
      height: Math.round(crop.height * scaleFactors.height),
      width: Math.round(crop.width * scaleFactors.width)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getNaturalDimensionsBeforeRotation = function () {
    return this.naturalDimensionsBeforeRotation;
  };

  CUI.imageeditor.TranslationUtil.prototype.adaptScaleFactorsToUnrotatedImage = function (factors) {
    if (this.rotatedByNinetyDegrees) {
      return {
        width: factors.height,
        height: factors.width
      };
    }
    return factors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromNaturalToDisplayScaleFactors = function (unrotated) {
    if (unrotated) {
      return this.adaptScaleFactorsToUnrotatedImage(this.fromNaturalToDisplayScaleFactors);
    }
    return this.fromNaturalToDisplayScaleFactors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromDisplayToNaturalScaleFactors = function (unrotated) {
    var temp = this.getFromNaturalToDisplayScaleFactors(unrotated);
    return {
      width: 1/temp.width,
      height: 1/temp.height
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromNaturalToZoomedScaleFactors = function (unrotated) {
    if (unrotated) {
      return this.adaptScaleFactorsToUnrotatedImage(this.fromNaturalToZoomedScaleFactors);
    }
    return this.fromNaturalToZoomedScaleFactors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromZoomedToNaturalScaleFactors = function (unrotated) {
    var temp = this.getFromNaturalToZoomedScaleFactors(unrotated);
    return {
      width: 1/temp.width,
      height: 1/temp.height
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromDisplayToZoomedScaleFactors = function () {
    return this.fromDisplayToZoomedScaleFactors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromZoomedToDisplayScaleFactors = function () {
    return {
      width: 1/this.zoomFactor,
      height: 1/this.zoomFactor
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getCropOnOriginal = function () {
    return this.cropOnOriginal;
  };

  CUI.imageeditor.TranslationUtil.prototype.getCropOnDisplayBeforeRotation = function () {
    var onOrig = this.getCropOnOriginal();
    var scaleFactors = this.getFromNaturalToDisplayScaleFactors(true);
    var retval = {
      top: onOrig.top * scaleFactors.height,
      left: onOrig.left * scaleFactors.width,
      height: onOrig.height * scaleFactors.height,
      width: onOrig.width * scaleFactors.width
    };
    retval.right = retval.left + retval.width;
    retval.bottom = retval.top + retval.height;
    return retval;
  };

  CUI.imageeditor.TranslationUtil.prototype.getCompleteImageAfterScalingDimensions = function () {
    var naturalDims = this.getNaturalDimensions();
    var scaleFactors = this.getFromNaturalToDisplayScaleFactors();
    return {
      height: naturalDims.height * scaleFactors.height,
      width: naturalDims.width * scaleFactors.width
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateToDisplay = function (w, h, unrotated) {
    var factors = this.getFromNaturalToDisplayScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateWidthToDisplay = function (w, unrotated) {
    return Math.round(w * this.getFromNaturalToDisplayScaleFactors(unrotated).width);
  };

  CUI.imageeditor.TranslationUtil.prototype.translateHeightToDisplay = function (h, unrotated) {
    return Math.round(h * this.getFromNaturalToDisplayScaleFactors(unrotated).height);
  };

  CUI.imageeditor.TranslationUtil.prototype.translateToNatural = function (w, h, unrotated) {
    var factors = this.getFromDisplayToNaturalScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateNaturalToZoomed = function (w, h, unrotated) {
    var factors = this.getFromNaturalToZoomedScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateZoomedToNatural = function (w, h, unrotated) {
    var factors = this.getFromZoomedToNaturalScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.applyScaleFactors = function (w, h, factors) {
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translatePoints = function (points, toZoomedOrToNatural) {
    var result = [], i, point;

    for (i = 0; i < points.length; i++) {
      point = points[i];
      if (toZoomedOrToNatural === 'toZoomed') {
        point = this.translateNaturalToZoomed(point.w, point.h);
      } else {
        point = this.translateZoomedToNatural(point.w, point.h);
      }
      result.push(point);
    }

    return result;
  };

  CUI.imageeditor.TranslationUtil.prototype.zoomPoints = function (points, reverse) {
    var result = [], i, point, factors;

    if (reverse) {
      factors = this.getFromZoomedToDisplayScaleFactors();
    } else {
      factors = this.getFromDisplayToZoomedScaleFactors();
    }

    for (i = 0; i < points.length; i++) {
      point = points[i];
      point = this.applyScaleFactors(point.w, point.h, factors);
      result.push(point);
    }

    return result;
  };

  CUI.imageeditor.TranslationUtil.prototype.translateWidthToNatural = function (w, unrotated) {
    return Math.round(w * 1/this.getFromNaturalToDisplayScaleFactors(unrotated).width);
  };

  CUI.imageeditor.TranslationUtil.prototype.translateHeightToNatural = function (h, unrotated) {
    return Math.round(h * 1/this.getFromNaturalToDisplayScaleFactors(unrotated).height);
  };

  CUI.imageeditor.TranslationUtil.prototype.scaleCropToNatural = function (crop, unrotated) {

    return this.applyScaleFactorsToCrop(crop, this.getFromZoomedToNaturalScaleFactors(unrotated));
  };

  CUI.imageeditor.TranslationUtil.prototype.scaleCropToZoomed = function (crop, unrotated) {

    return this.applyScaleFactorsToCrop(crop, this.getFromNaturalToZoomedScaleFactors(unrotated));
  };

  CUI.imageeditor.TranslationUtil.prototype.applyScaleFactorsToCrop = function (crop, factors) {
    if (!crop) {
      return null;
    }

    return {
      top: Math.round(crop.top * factors.height),
      left: Math.round(crop.left * factors.width),
      height: Math.round(crop.height * factors.height),
      width: Math.round(crop.width * factors.width)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.rotateDimsIfNecessary = function (dims) {
    if (!dims) {
      return null;
    }

    return {
      height: this.rotatedByNinetyDegrees ? dims.width : dims.height,
      width: this.rotatedByNinetyDegrees ? dims.height : dims.width
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.rotateCropBy90IfNecessary = function (crop) {
    if (!crop) {
      return null;
    }

    return {
      top: this.rotatedByNinetyDegrees ? crop.left : crop.top,
      left: this.rotatedByNinetyDegrees ? crop.top : crop.left,
      height: this.rotatedByNinetyDegrees ? crop.width : crop.height,
      width: this.rotatedByNinetyDegrees ? crop.height : crop.width
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translate = function (box, zoomedOrDisplayOrNatural, result) {
    var toggle, rotation = this.rotation, flip = this.flip,
      targetDims;

    zoomedOrDisplayOrNatural = zoomedOrDisplayOrNatural || 'zoomed';
    zoomedOrDisplayOrNatural = zoomedOrDisplayOrNatural.toLowerCase();
    if (zoomedOrDisplayOrNatural === 'display') {
      targetDims = this.getDisplayDimensionsBeforeRotation();
    } else if (zoomedOrDisplayOrNatural === 'natural') {
      targetDims = this.getNaturalDimensionsBeforeRotation();
    } else {
      targetDims = this.getZoomedDimensionsBeforeRotation();
    }

    result = result || $.extend({}, box);

    rotation = rotation % 360; // [-270, 270]
    rotation = rotation + 360; // [  90, 630]
    rotation = rotation % 360; // [  90, 270]

    // change coords to point to 'new' top left
    if (box.hasOwnProperty('top') && box.hasOwnProperty('left')) {
      if (rotation % 180 === 0) {
        toggle = rotation !== 0;

        if (flip.horizontal ^ toggle) {
          result.left = targetDims.width - box.width - box.left;
        }
        else {
          result.left = box.left;
        }
        if (flip.vertical ^ toggle) {
          result.top = targetDims.height - box.height - box.top;
        }
        else {
          result.top = box.top;
        }
      }
      else {
        toggle = rotation !== 90;

        if (flip.vertical ^ toggle) {
          result.left = box.top;
        }
        else {
          result.left = targetDims.height - box.height - box.top;
        }
        if (flip.horizontal ^ toggle) {
          result.top = targetDims.width - box.width - box.left;
        }
        else {
          result.top  = box.left;
        }
      }
    }

    // switch dimensions if necessary
    if (rotation % 180 !== 0) {
      result.width = box.height;
      result.height = box.width;
    }
    else {
      result.width = box.width;
      result.height = box.height;
    }

    return result;
  };

}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Action
   * @private
   * The Action should be implemented by all imageeditor actions that cannot be handled by the
   * browser's implementation itself.
   */
  CUI.imageeditor.actions.Action = new Class({

    toString: 'Action',

    config: {},

    construct: function (editor, pluginId) {
      this._init(editor, pluginId);
    },

    _init: function (editor, actionId) {
      this.editor = editor;
      this.actionId = actionId;
    },

    notifyPluginConfig: function (config) {
      this.config = config;
    },

    isAction: function (actionStr) {
      // this method must be overridden
      return false;
    },

    // This is dead code now, but cannot remove because public API
    isUndoable: function (actionStr) {
      // this method can be overridden by actions that are actually not undoable (for
      // example undo/redo actions themselves)
      return true;
    },

    // This is dead code now, but cannot remove because public API
    requiresInitializedComponent: function (actionStr) {
      // this method can be overridden by actions that do not require an initialized
      // imageeditor component, for example for configuration, setup, etc.
      return true;
    },

    execute: function (execDef) {
      // this method must be overridden
    },

    // todo use a single parameter
    queryState: function (selectionDef, cmd) {
      return false;
    },

    toCss : function (transformResult, element, translationUtil) {
      // sub class responsibility
      return {};
    },

    /**
     * @protected
     */
    getString : function (string) {
      return this.editor.i18n.get(this.actionId + '.' + string);
    },

    /**
     * @protected
     */
    getTemplateOptions : function () {
      var self = this;

      return {
        helpers: {
          i18n : function (string) {
            return self.getString('template.' + string);
          }
        }
      };
    }
  });
}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.ActionRegistry
   * This class is used to manage actions used in image editing. Each action has a
   * respective identifier by which it can be executed
   * @private
   */
  CUI.imageeditor.actions.ActionRegistry = (function () {

    var actionRegistry = {};

    return {

      /**
       * Registers the specified class as an image editing action.
       * @param {String} action The action identifier
       * @param {Function} cls The action class (must extend
       *      {@link CUI.rte.actions.action})
       */
      register: function (action, cls) {
        actionRegistry[action] = cls;
      },

      /**
       * <p>Creates an associative array, containing instances of all currently
       * registered actions.</p>
       * @return {Object} Associative array of instantiated actions
       */
      createRegisteredActions: function (editor) {
        var action,
            registeredActions = {};

        for (action in actionRegistry) {
          if (actionRegistry.hasOwnProperty(action)) {
            registeredActions[action] = new actionRegistry[action](editor, action);
          }
        }

        return registeredActions;
      }

    };

  })();
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Crop
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Crop = new Class({

    toString: 'Crop',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (actionStr) {
      var actionStrLC = actionStr.toLowerCase();
      return (actionStrLC === 'croplaunch') ||
           (actionStrLC === 'croplaunchwithratio') ||
           (actionStrLC === 'cropunlaunch') ||
           (actionStrLC === 'cropconfirm') ||
           (actionStrLC === 'cropremovecrop');
    },

    execute: function (execDef) {
      switch (execDef.action.toLowerCase()) {
      case 'croplaunch':
        return this.launchCrop(execDef);
      case 'croplaunchwithratio':
        return this.launchCropWithRatio(execDef);
      case 'cropunlaunch':
        return this.unlaunchCrop(execDef);
      case 'cropconfirm':
        return this.confirmCrop(execDef);
      case 'cropremovecrop':
        return this.removeCrop(execDef);
      }
    },

    launchCropWithRatio : function (execDef) {
      if (this.popover && this.popover.get('visible')) {
        this.closeRatioPopover(execDef);
      }
      else {
        this.openRatioPopover(execDef);
      }
    },

    openRatioPopover : function (execDef) {
      var clickTarget, popover;

      if (!this.clickTarget) {
        clickTarget = $('<div>', {'class': 'imageeditor-clicktarget'});

        $('.imageeditor-controls').append(clickTarget);

        clickTarget.on('click', this, this.clickTargetClicked);

        this.clickTarget = clickTarget;
      }

      if (!this.popover) {
        popover = $('<div>', {'class' : 'imageeditor-popover imageeditor-toolbar-popover coral-Popover'}).
            html(this.editor.templates.get('crop-popover')({aspectRatios: execDef.value.getAspectRatios()}, this.getTemplateOptions()));

        $('.imageeditor-controls').append(popover);

        popover.trigger('cui-contentloaded');

        popover.on('click', $.proxy(this.ratioPopoverClicked, this, execDef.value));

        this.popover = new CUI.Popover({
          element: popover,
          pointFrom: 'bottom'
        });
      }

      this.clickTarget.show();
      this.popover
        .set('pointAt', execDef.ui.find('.coral-Icon--crop:visible').closest('.coral-Button'))
        .show();
    },

    closeRatioPopover : function (execDef) {
      if (this.popover) {
        this.popover.hide();
      }

      if (this.clickTarget) {
        this.clickTarget.hide();
      }
    },

    clickTargetClicked : function (e) {
      e.stopPropagation();
      setTimeout(function () {
          e.data.closeRatioPopover();
        },
        300
      );
    },

    ratioPopoverClicked : function (plugin, e) {
      this.closeRatioPopover();

      var ratioOrRemoveTrigger = $(e.target).val();

      if (ratioOrRemoveTrigger === 'removeCrop') {
        plugin.execute('removecrop');
      } else {
        plugin.execute('launch', ratioOrRemoveTrigger);
      }
    },

    launchCrop: function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
          canvas = this.getFullCanvasCrop(translationUtil),
          zoomedCanvas = null,
          selection = this.getCurrent(execDef.result, translationUtil),
          zoomedSelection = null;

      if (execDef.mode === 'fullscreen' &&
          !(selection.top    === canvas.top &&
            selection.left   === canvas.left &&
            selection.width  === canvas.width &&
            selection.height === canvas.height)
      ) {

        // Fullscreen and has seen previous selection. Open full image with
        // previous selection preselected
        //
        // canvas == full image dimensions
        // selection == previous selection, w/ aspect ratio applied
        //
        // Remove clip from element to make everything visible
        execDef.element.css('clip', '');
      }
      else {
        // Inline mode or Fullscreen without previous crop. Open crop with
        // computed preselection based on current crop
        //
        // canvas == previous selection or full image dimensions
        // selection == a bit smaller than canvas
        canvas = selection;
        selection = this.getDefaultSelection(execDef, canvas);
      }

      zoomedCanvas = translationUtil.scaleCropToZoomed(canvas, true);
      zoomedSelection = translationUtil.scaleCropToZoomed(selection, true);

      execDef.editor.togglePinchZooming(false);

      execDef.element.imageSelect({
        classPrefix: 'imageeditor-imageselect-',
        parent : execDef.ui.find('.imageeditor-controls'),

        applyTransformations : true,
        aspectRatio: execDef.value || 0,
        canvas : {
          top:    zoomedCanvas.top,
          left:   zoomedCanvas.left,
          width:  zoomedCanvas.width,
          height: zoomedCanvas.height
        },
        selection : {
          top:    zoomedSelection.top,
          left:   zoomedSelection.left,
          width:  zoomedSelection.width,
          height: zoomedSelection.height
        }
      });
    },

    unlaunchCrop: function (execDef) {
      execDef.element.imageSelect({call: 'destroy'});
      execDef.editor.togglePinchZooming(true);
      return true;
    },

    confirmCrop: function (execDef) {
      var api = execDef.element.imageSelect({instance: true}),
          selection = api.getSelection();

      this.setCurrent(execDef.result, execDef.createTranslationUtil().scaleCropToNatural(selection, true));

      return this.unlaunchCrop(execDef);
    },

    removeCrop: function (execDef) {

      this.setCurrent(execDef.result, null);
      return true;
    },

    toCss : function (result, element, translationUtil) {
      var selection = this.getCurrent(result),
          newCenter;

      if (selection) {
        selection = translationUtil.scaleCropToZoomed(selection, true);
        newCenter = this.findCenter(selection);

        return {
          'clip'         : 'rect(' + [
            selection.top,
            selection.left + selection.width,
            selection.top + selection.height,
            selection.left
          ].join('px, ') + 'px)',
          'transform-origin' : newCenter.x + 'px ' + newCenter.y + 'px'
        };
      }
    },

    /**
     * @private
     */
    findCenter : function (selection) {
      return {
        x: selection.left + Math.round(selection.width / 2),
        y: selection.top + Math.round(selection.height / 2)
      };
    },

    setCurrent : function (result, crop) {
      var value = null;

      if (crop) {
        value = {
          top: crop.top,
          left: crop.left,
          width: crop.width,
          height: crop.height
        };
      }
      result.setTransformValue('crop', value);
    },

    getCurrent : function (result, translationUtil) {
      var config = result && result.getTransformValue('crop');

      if ($.isPlainObject(config) &&
          config.hasOwnProperty('top') &&
          config.hasOwnProperty('left') &&
          config.hasOwnProperty('width') &&
          config.hasOwnProperty('height')) {

        return {
          top    : config.top,
          left   : config.left,
          width  : config.width,
          height : config.height
        };
      }
      else {
        return this.getFullCanvasCrop(translationUtil);
      }
    },

    getFullCanvasCrop: function(translationUtil) {
      var naturalDims;

      if (translationUtil) {
        naturalDims = translationUtil.getNaturalDimensionsBeforeRotation();
        return {
          top    : 0,
          left   : 0,
          width  : naturalDims.width,
          height : naturalDims.height
        };
      }
      else {
        return;
      }
    },

    /**
     * @private
     */
    getDefaultSelection : function (execDef, selection) {
      var margin,
        translationUtil = execDef.createTranslationUtil(),
        // Crop: crop is stored on original. It is displayed in the selection plugin which is itself translated by CSS.
        // So no need to translate crop here as CSS is doing it.
        // BUT: viewport is defined on the display - so need to reverse the translations done by CSS to get it on
        // original coordinates. If this is to be done correctly for all cases 2d matrix translation needs to be introduced (future?).
        viewportCropTranslated = translationUtil.rotateCropBy90IfNecessary(translationUtil.scaleCropToNatural(execDef.viewportCrop, false)),
        cropOnOriginal = translationUtil.getCropOnOriginal(),
        fullscreenMode = execDef.mode === 'fullscreen';

      margin = {
        x : viewportCropTranslated.width * 0.1,
        y : viewportCropTranslated.height * 0.1
      };

      return {
        top    : (fullscreenMode ? viewportCropTranslated.top : cropOnOriginal.top)  + margin.y,
        left   : (fullscreenMode ? viewportCropTranslated.left : cropOnOriginal.left) + margin.x,
        // margin left and right means dims shrink by 2 times its size
        width  : viewportCropTranslated.width  - 2 * margin.x,
        height : viewportCropTranslated.height - 2 * margin.y
      };
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('crop', CUI.imageeditor.actions.Crop);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Rotate
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Rotate = new Class({

    toString: 'Rotate',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (actionStr) {
      return (actionStr === 'rotateright') || (actionStr === 'rotateleft');
    },

    execute: function (execDef) {
      var angle = CUI.imageeditor.actions.Rotate.ROTATION_ANGLE,
          current = this.getCurrent(execDef.result);

      if (execDef.action === 'rotateleft') {
        angle = -angle;
      }

      angle = current + angle;

      this.setCurrent(execDef.result, angle);

      return true;
    },

    setCurrent : function (result, angle) {
      result.setTransformValue('rotate', {angle: angle});
    },

    getCurrent : function (result) {
      var config = result.getTransformValue('rotate');

      if ($.isPlainObject(config)) {
        return config.angle || 0;
      }
      return 0;
    },

    toCss : function (result, element, translationUtil) {
      return {
        transform : 'rotate(' + this.getCurrent(result) + 'deg)'
      };
    }
  });
}(jQuery, this));

/**
 * Default rotation angle (degrees)
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.imageeditor.actions.Rotate.ROTATION_ANGLE = 90;

// register action
CUI.imageeditor.actions.ActionRegistry.register('rotate', CUI.imageeditor.actions.Rotate);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Flip
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Flip = new Class({

    toString: 'Flip',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (action) {
      return (action === 'fliphorizontal') || (action === 'flipvertical');
    },

    execute: function (execDef) {
      var current = this.getCurrent(execDef.result),
          flipAxes = (execDef.rotation % 180) !== 0,
          axis;

      switch (execDef.action) {
      case 'fliphorizontal':
        axis = flipAxes ? 'vertical' : 'horizontal';
        break;
      case 'flipvertical':
        axis = flipAxes ? 'horizontal' : 'vertical';
        break;
      default:
        return false;
      }

      current[axis] = !current[axis];
      this.setCurrent(execDef.result, current);

      return true;
    },

    setCurrent : function (result, flip) {
      result.setTransformValue('flip', flip);
    },

    getCurrent : function (result) {
      var config = result.getTransformValue('flip');

      if ($.isPlainObject(config)) {
        return {
          vertical   : !!config.vertical,
          horizontal : !!config.horizontal
        };
      }
      else {
        return {
          vertical   : false,
          horizontal : false
        };
      }
    },

    toCss : function (result, element, translationUtil) {
      var current = this.getCurrent(result);

      return {
        transform: ' scaleX(' + (current.horizontal ? '-1' : '1') + ')' +
                   ' scaleY(' + (current.vertical ? '-1' : '1') + ')'
      };
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('flip', CUI.imageeditor.actions.Flip);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var serialize = function (data, form) {
    form.find('[name]').each(function () {
      var input = $(this),
          type = input.attr('type'),
          name = input.attr('name'),
          value = input.val();

      if (type === 'radio' || type === 'checkbox') {
        if (input.prop('checked')) {
          // Checkboxes work differently, if they represent multi-select. Most
          // commonly, the values would be stored in an Array.
          data[name] = value;
        }
      }
      else {
        data[name] = value;
      }
    });
  };

  var deserialize = function (data, form) {
    form.find('[name]').each(function () {
      var input = $(this),
          type = input.attr('type'),
          name = input.attr('name'),
          // Make sure, that input.attr('name') is not undefined - otherwise it
          // would not properly overwrite a previous value
          value = data[name] || '';

      if (type === 'radio' || type === 'checkbox') {
        // Checkbox and radio buttons
        //
        // Checkboxes work differently, if they represent multi-select. Most
        // commonly, the values would be stored in an Array.
        if (input.attr('value') === value) {
          input.prop('checked', true);
        }
        else {
          input.prop('checked', false);
        }
        input.change();
      }
      else {
        // Selects, text and other inputs
        input.val(value).change();

        if (input.is('select')) {
          // Inform CUI.Select about change event.
          // TODO Remove when CUI-1612 was resolved
          var select = input.closest('.coral-Select').data('select');
          if (select) {
            select._handleNativeSelect();
          }
        }
      }
    });
  };


  /**
   * @class CUI.imageeditor.actions.Map
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Map = new Class({

    toString: 'Map',

    extend: CUI.imageeditor.actions.Action,

    MIN_SIZE : 40,

    isAction: function (actionStr) {
      return (actionStr === 'maplaunch') ||
             (actionStr === 'mapunlaunch') ||
             (actionStr === 'mapconfirm') ||
             (actionStr === 'maprectangle') ||
             (actionStr === 'mapcircle') ||
             (actionStr === 'mappolygon');
    },

    execute: function (execDef) {
      switch (execDef.action) {
      case 'maplaunch':
        return this.launchMap(execDef);
      case 'mapunlaunch':
        return this.unlaunchMap(execDef);
      case 'mapconfirm':
        return this.confirmMap(execDef);

      case 'maprectangle':
        return this.startRectangleArea(execDef);
      case 'mapcircle':
        return this.startCircleArea(execDef);
      case 'mappolygon':
        return this.startPolygonArea(execDef);
      }
    },

    launchMap: function (execDef) {
      this.isActive = true;

      execDef.editor.togglePinchZooming(false);
      this.areas = this.getCurrent(execDef.result);
      this.drawAreas(execDef);

      execDef.ui.on('click.map deselect_click.map', $.proxy(this.tryToSelectAreaOrUnselect, this, execDef));
      execDef.ui.on('second_click.map', $.proxy(this.togglePopover, this, execDef));

      this.getMapCont(execDef.element).on('update.map', $.proxy(this.closePopover,  this));
    },

    unlaunchMap: function (execDef) {
      this.isActive = false;

      this.unselectCurrentArea(execDef);

      this.areas = [];
      this.drawAreas(execDef);

      execDef.ui.off('.map');
      this.getMapCont(execDef.element).off('.map');
      execDef.editor.togglePinchZooming(true);
    },

    confirmMap : function (execDef) {
      this.unselectCurrentArea(execDef);
      this.setCurrent(execDef.result, this.areas);

      this.unlaunchMap(execDef);
    },

    startRectangleArea : function (execDef) {
      this.unselectCurrentArea(execDef);

      this.currentArea = {
        alt: '',
        href: '',
        target : '',
        selection : this.getDefaultNewSelection(execDef),
        shape: 'rect'
      };

      this.selectCurrentArea(execDef);
    },

    startCircleArea : function (execDef) {
      this.unselectCurrentArea(execDef);

      this.currentArea = {
        alt: '',
        href: '',
        target : '',
        selection : this.getDefaultNewSelection(execDef),
        shape : 'circle'
      };

      this.selectCurrentArea(execDef);
    },

    startPolygonArea : function (execDef) {
      this.unselectCurrentArea(execDef);

      this.currentArea = {
        alt: '',
        href: '',
        target : '',
        points : this.getDefaultNewPoints(execDef),
        shape : 'polygon'
      };

      this.selectCurrentArea(execDef);
    },

    getDefaultNewSelection : function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
        viewportCropTranslated = translationUtil.scaleCropToNatural(execDef.viewportCrop, true),
        margin = {
          x: viewportCropTranslated.width * 0.2,
          y: viewportCropTranslated.height * 0.2
        };

      return {
        top: viewportCropTranslated.top + margin.y,
        left: viewportCropTranslated.left + margin.x,
        width: viewportCropTranslated.width - 2 * margin.x,
        height: viewportCropTranslated.height - 2 * margin.y
      };
    },

    getDefaultNewPoints : function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
        viewportCropTranslated = translationUtil.scaleCropToNatural(execDef.viewportCrop, true),
        margin = {
          x: viewportCropTranslated.width * 0.2,
          y: viewportCropTranslated.height * 0.2
        };

      return [
        {
          w: viewportCropTranslated.left + 0.5 * (viewportCropTranslated.width),
          h: viewportCropTranslated.top + margin.y
        },
        {
          w: viewportCropTranslated.left + (viewportCropTranslated.width - margin.x),
          h: viewportCropTranslated.top + (viewportCropTranslated.height - margin.y)
        },
        {
          w: viewportCropTranslated.left + margin.x,
          h: viewportCropTranslated.top + (viewportCropTranslated.height - margin.y)
        }
      ];
    },

    getCurrent : function (result) {
      var current = result.getTransformValue('map');

      if (current && current.areas) {
        return $.map(current.areas, function (a) { return $.extend(true, {}, a); });
      }
      else {
        return [];
      }
    },

    setCurrent : function (result, areas) {
      if (areas) {
        result.setTransformValue('map', {areas : areas});
      }
      else {
        // clear value
        result.setTransformValue('map', null);
      }
    },

    getMapCont : function (element) {
      return element.parent().find('.imageeditor-controls-map-areas');
    },

    drawAreas : function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
          cont = this.getMapCont(execDef.element),
          area, node, i, canvas = translationUtil.translate(translationUtil.getZoomedCropBeforeRotation(), 'zoomed'),
          selection, points, polygonTool, polygonStyling = this.getPolygonOutlineStyling(execDef);

      cont.html('');

      if (!this.areas) {
        return;
      }

      cont.css({
        width : canvas.width,
        height: canvas.height
      })
      .position({
        of: execDef.element,
        my: 'left top',
        at: 'left+' + canvas.left + ' top+' + canvas.top,
        collision: 'none'
      });



      for (i = 0; i < this.areas.length; i++) {
        area = this.areas[i];
        if (area.shape === 'polygon') {
          node = $('<canvas/>', {
            'class': 'imageeditor-map-canvas',
            'width': canvas.width,
            'height': canvas.height
          });
          node[0].width = canvas.width;
          node[0].height = canvas.height;
          points = area.points;
          points = translationUtil.translatePoints(points, 'toZoomed');
          polygonTool = node.polygon().data('polygon');
          polygonTool.paintPolygonWithPoints(node, points, polygonStyling);
          cont.append(node);

        } else {
          node = $('<div/>', {'class': 'imageeditor-controls-map-area'});
          cont.append(node);
          selection = translationUtil.scaleCropToZoomed(area.selection);

          node.css({
            top: selection.top,
            left: selection.left,
            width: selection.width,
            height: selection.height,
            borderRadius: area.shape === 'circle' ? '50%' : undefined
          });
        }

      }
    },

    /** get polygon style details via helper ghost */
    getPolygonOutlineStyling: function (execDef) {
      var $controls = $(this.getMapCont(execDef.element).parent()),
        $polygonHelper = $controls.find('.imageeditor-imagemap-polygon-helper'),
        borderWidthCss = $polygonHelper.css('border-top-width'), borderWidth = null;

      borderWidth = $('<div/>', {width: borderWidthCss}).width(); // conversion: .width() always returns pixel value

      return {
        strokeStyle: $polygonHelper.css('border-top-color'),
        lineWidth: borderWidth
      };
    },

    isCurrentlySelectedArea: function (candidateArea) {
      return this.currentImageSelect && this.currentArea === candidateArea;
    },

    tryToSelectAreaOrUnselect : function (execDef, e) {
      if (e && $(e.target).parents('.imageeditor-popover').length) {
        return;
      }
      if (e && $(e.target).parents('.imageeditor-imagemap-holder').length) {
        return;
      }

      var matches = false,
        translationUtil = execDef.createTranslationUtil(),
        polygonHelper = $('<div/>').polygon().data('polygon'),
        coords = CUI.imageeditor.UIUtils.getEventCoordinatesPageRelative(e),
        cont = this.getMapCont(execDef.element),
        contOffset = cont.offset(),
        contRelativeCoords = {
          w: coords.x - contOffset.left,
          h: coords.y - contOffset.top
        },
        candidateArea, i, translatedSelection, translatedPoints;

      // need to prevent propagation, event might target removed element, which will trigger closing of editor
      e.preventDefault();
      e.stopPropagation();

      for (i = 0; i < this.areas.length; i++) {
        candidateArea = this.areas[i];
        matches = false;

        if (candidateArea.shape === 'polygon') {
          translatedPoints = polygonHelper.pointsToVectors(translationUtil.translatePoints(candidateArea.points, 'toZoomed'));
          matches = polygonHelper.isPointInsideOrOnEdgeOfPolygon([contRelativeCoords.w, contRelativeCoords.h], translatedPoints);
        } else {
          translatedSelection = translationUtil.scaleCropToZoomed(candidateArea.selection);
          matches = polygonHelper.isCoordsInBoundingBox(translatedSelection, contRelativeCoords.w, contRelativeCoords.h);
        }

        if (matches) {
          if (!this.isCurrentlySelectedArea(candidateArea)) {
            this.createSelectionFromArea(i, execDef);
          }
          break;
        }
      }

      if (!matches) {
        // nothing here - no selection
        this.unselectCurrentArea(execDef);
      }

    },

    createSelectionFromArea : function (i, execDef) {
      var candidateArea = this.areas[i];

      this.unselectCurrentArea(execDef);

      this.currentArea = candidateArea;

      this.areas.splice(i, 1);
      this.drawAreas(execDef);

      this.selectCurrentArea(execDef);
    },

    selectCurrentArea : function (execDef) {
      // TODO: Provide proper elements/selectors instead of global ones

      var translationUtil = execDef.createTranslationUtil(),
        options;


      if (this.currentArea.shape === 'polygon') {
        options = {
          instance: true,
          classPrefix: 'imageeditor-imagemap-',
          parent: execDef.element.parent().find('.imageeditor-controls'),
          points: translationUtil.translatePoints(this.currentArea.points, 'toZoomed')
        };
        this.currentImageSelect = this.getMapCont(execDef.element).imageSelectPolygon(options);

      } else {
        options = {
          instance: true,
          classPrefix: 'imageeditor-imagemap-',
          parent: execDef.element.parent().find('.imageeditor-controls'),
          min: this.MIN_SIZE,
          selection: translationUtil.scaleCropToZoomed(this.currentArea.selection)
        };

        switch (this.currentArea.shape) {
        case 'rect':
          options.shape = 'rectangle';
          break;
        case 'circle':
          options.shape = 'ellipse';
          options.aspectRatio = 1;
          break;
        }

        this.currentImageSelect = this.getMapCont(execDef.element).imageSelect(options);
      }
    },

    unselectCurrentArea: function (execDef) {
      if (!this.currentImageSelect) {
        return;
      }

      if (this.currentArea.shape === 'polygon') {
        this.currentArea.points = execDef.createTranslationUtil().translatePoints(this.currentImageSelect.getPoints(), 'toNatural');
      } else {
        this.currentArea.selection = execDef.createTranslationUtil().scaleCropToNatural(this.currentImageSelect.getSelection());
      }

      this.areas.push(this.currentArea);

      this.removeCurrentSelection(execDef);
    },

    removeCurrentSelection : function (execDef) {
      if (!this.currentImageSelect) {
        return;
      }
      this.currentImageSelect.destroy();
      this.currentImageSelect = null;

      this.closePopover();
      this.drawAreas(execDef);
    },

    togglePopover : function (execDef) {
      if (!this.currentImageSelect) {
        return;
      }

      if (!this.currentPopover) {
        this.createPopover(execDef);
      }

      if (this.currentPopover.get('visible')) {
        this.closePopover();
      }
      else {
        this.openPopover(execDef);
      }
    },

    createPopover : function (execDef) {
      var popover, mapPopoverContext = {}, pathInputConfigured = false,
        config = $.extend({}, CUI.imageeditor.actions.Map.DEFAULT_OPTIONS, this.config);

      config.pathbrowser = $.extend({}, CUI.imageeditor.actions.Map.DEFAULT_OPTIONS.pathbrowser, config.pathbrowser);

      if (config.pathbrowser.type) {
        if (config.pathbrowser.type === 'picker') {
          mapPopoverContext.pathbrowserPicker = true;
          pathInputConfigured = true;
        } else if (config.pathbrowser.type === 'autocomplete') {
          mapPopoverContext.pathbrowserAutocomplete = true;
          pathInputConfigured = true;
        }
      }
      if (!pathInputConfigured) {
        mapPopoverContext.noPathbrowser = true;
      } else {
        mapPopoverContext.pathbrowser = $.extend({}, config.pathbrowser);
      }

      popover = $('<div>', {'class' : 'imageeditor-popover'}).html(this.editor.templates.get('map-popover')(mapPopoverContext, this.getTemplateOptions()));

      $('.imageeditor-controls').append(popover);

      var $pathbrowserEl = $($(popover).find('.pathbrowser'));
      if ($pathbrowserEl.length) {
        $pathbrowserEl.pathBrowser(mapPopoverContext.pathbrowser);
      }

      popover.trigger('cui-contentloaded');

      this.currentPopover = new CUI.Popover({
        element: popover,
        pointFrom: 'top',
        preventAutoHide: true // to stay open when pathbrowser modal is clicked
      });
    },

    updateAndGetBoundingBoxDiv: function (execDef) {
      var boundingBox = this.currentImageSelect.getBoundingBox(),
        cont = this.getMapCont(execDef.element),
        BOUNDING_BOX_CLASS = 'imageeditor-map-polygon-bounding-box',
        boundingBoxDiv;

      boundingBoxDiv = cont.find('.' + BOUNDING_BOX_CLASS);
      if (!boundingBoxDiv.length) {
        boundingBoxDiv = $('<div/>', {
          'class': BOUNDING_BOX_CLASS
        });
        boundingBoxDiv.css({
          //display: 'none',
          position: 'absolute'
        });
        cont.append(boundingBoxDiv);
      }

      boundingBoxDiv.css({
        top: boundingBox.top,
        left: boundingBox.left,
        width: boundingBox.width,
        height: boundingBox.height
      });
      return boundingBoxDiv;
    },

    openPopover : function (execDef) {
      var pointAtTarget;
      if (!this.currentPopover || !this.currentImageSelect) {
        return;
      }

      if (this.currentArea.shape === 'polygon') {
        pointAtTarget = this.updateAndGetBoundingBoxDiv(execDef);
      } else {
        pointAtTarget = this.currentImageSelect.$selection;
      }
      this.currentPopover.
        set('pointAt', pointAtTarget).
        show();

      var toolbar = this.currentPopover.get('element'),
          area = this.currentArea;

      deserialize(area, toolbar);

      toolbar.
        on('click.map', '.imageeditor-map-delete',      $.proxy(this.removeCurrentSelection, this, execDef)).
        on('click.map', '.imageeditor-map-unlaunch',    $.proxy(this.metaDataAbort, this)).
        on('click.map', '.imageeditor-map-confirm',     $.proxy(this.metaDataConfirm, this));

    },

    closePopover : function () {
      if (!this.currentPopover) {
        return;
      }

      this.currentPopover.get('element').
        off('.map').
        find(':focus').blur();

      this.closeSelect();
      this.currentPopover.hide();
    },

    metaDataConfirm : function (e) {
      if (!this.currentPopover || !this.currentArea) {
        return;
      }

      var area = this.currentArea,
          toolbar = this.currentPopover.get('element');

      serialize(area, toolbar);

      this.closePopover();
    },

    metaDataAbort : function (e) {
      this.closePopover();
    },

    closeSelect : function () {
      var $selectList = this.currentPopover.get('element').find('.coral-SelectList');
      if ($selectList.length) {
        $selectList.data('selectList').hide();
      }
    },

    reposition : function (element) {
      // reposition inactive areas
      this.getMapCont(element).position({of: element, my: 'left top', at: 'left top', collision: 'none'});

      // reposition popover
      if (this.currentPopover && this.currentPopover.get('visible')) {
        this.currentPopover.hide().show();
      }
    },

    toCss : function (result, element, translationUtil) {
      if (this.isActive) {
        this.reposition(element);
      }
    }
  });

  CUI.imageeditor.actions.Map.DEFAULT_OPTIONS = {
    pathbrowser: {
      type: null, // 'autocomplete' or 'picker'

      /* options for autocomplete and picker: */
      rootPath: '/',
      showTitles: false,
      optionLoader: function (path) {
        return [];
      },

      /* autocomplete configuration: */
      optionLoaderRoot: null, // provide property path to array in return value of optionLoader, e.g. 'results.values',
      optionValueReader: function (object) {
        return '' + object;
      },
      optionTitleReader: function (object) {
        return '' + object;
      },

      /* picker configuration: */
      pickerSrc: '/libs/wcm/core/content/common/pathbrowser/column.html' + '/' + '?predicate=hierarchyNotFile',
      pickerTitle: 'Choose a target path',
      picketCrumbRoot: {
        title: 'Root',
        icon: 'coral-Icon-home'
      }
    }
  };

}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('map', CUI.imageeditor.actions.Map);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.History
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.History = new Class({

    toString: 'History',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (action) {
      return (action === 'undo') || (action === 'redo');
    },

    execute: function (execDef) {
      switch (execDef.action) {
      case 'undo':
        execDef.result.undo();
        break;
      case 'redo':
        execDef.result.redo();
        break;
      }
      return true;
    },

    toCss : function (result, element, translationUtil) {
      return;
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('history', CUI.imageeditor.actions.History);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Fullscreen
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Fullscreen = new Class({

    toString: 'Fullscreen',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (action) {
      return (action === 'fullscreen') || (action === 'fullscreenexit');
    },

    execute: function (execDef) {
      return true;
    },

    toCss : function (result, element, translationUtil) {
      return;
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('fullscreen', CUI.imageeditor.actions.Fullscreen);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var ZOOM_NAME = 'Zoom',
    ZOOM_ID = 'zoom',
    POPUP_SLIDER_ACTION = ZOOM_ID + 'popupslider',
    RESET_100_ACTION = ZOOM_ID + 'reset100';

  /**
   * @class CUI.imageeditor.actions.Zoom
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Zoom = new Class({

    toString: ZOOM_NAME,

    extend: CUI.imageeditor.actions.Action,

    isAction: function (actionStr) {
      var actionStrLC = actionStr.toLowerCase();
      return (actionStrLC === POPUP_SLIDER_ACTION) ||
           (actionStrLC === RESET_100_ACTION);
    },

    execute: function (execDef) {
      switch (execDef.action.toLowerCase()) {
      case POPUP_SLIDER_ACTION:
        return this.popupSlider(execDef);
      case RESET_100_ACTION:
        return this.reset100(execDef);
      }
    },

    popupSlider : function (execDef) {
      if (this.popover && this.popover.get('visible')) {
        this.closeSliderPopover(execDef);
      }
      else {
        this.openSliderPopover(execDef);
      }
    },

    openSliderPopover : function (execDef) {
      var clickTarget, popover;

      if (!this.clickTarget) {
        clickTarget = $('<div>', {'class': 'imageeditor-clicktarget'});

        $('.imageeditor-controls').append(clickTarget);

        clickTarget.on('click', this, this.clickTargetClicked);

        this.clickTarget = clickTarget;
      }

      if (!this.popover) {
        popover = $('<div>', {'class' : 'imageeditor-popover imageeditor-toolbar-popover coral-Popover'}).
            html(this.editor.templates.get('zoomslider-popover')(this.getZoomLimits(execDef)));

        $('.imageeditor-controls').append(popover);

        popover.trigger('cui-contentloaded');

        this.popover = new CUI.Popover({
          element: popover,
          pointFrom: 'bottom'
        });
        this.getSlider().on('change', $.proxy(this.sliderChanged, this, execDef.value));
      }

      this.clickTarget.show();

      this.getSlider().setValue(Math.round(execDef.editor.getZoomFactor() * 100));

      this.popover
        .set('pointAt', execDef.ui.find('.coral-Icon--search:visible').closest('.coral-Button'))
        .show();
    },

    getZoomLimits : function (execDef) {
      var limitsFloat = execDef.editor.getZoomLimits();
      return {
        zoomMin: Math.round(limitsFloat[0] * 100),
        zoomMax: Math.round(limitsFloat[1] * 100)
      };
    },

    getSlider : function () {
      return $(this.popover.$element.find('div.coral-Slider')).data('slider');
    },

    closeSliderPopover : function (execDef) {
      if (this.popover) {
        this.popover.hide();
      }

      if (this.clickTarget) {
        this.clickTarget.hide();
      }
    },

    clickTargetClicked : function (e) {
      e.stopPropagation();
      setTimeout(function () {
          e.data.closeSliderPopover();
        },
        300
      );
    },

    reset100 : function (execDef) {
      execDef.editor.zoom(1);
    },

    sliderChanged : function (plugin, e) {
      var sliderVal = $(e.target).val();
      plugin.editor.zoom(sliderVal * 0.01);
    },

    toCss : function (result, element, translationUtil) {
    }
  });

  // register action
  CUI.imageeditor.actions.ActionRegistry.register(ZOOM_ID, CUI.imageeditor.actions.Zoom);

}(jQuery, this));


/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Plugin
   * <p>This class works as an interface and hence must be extended by all plugin
   * implementations.</p>
   * <p>Each plugin may provide one or more 'features', that represent the actual editing
   * action and usually map 1:1 to a UI element (for example, a toolbar button).</p>
   * <p>Plugins should not be instantiated directly, but registered with
   * {@link CUI.imageeditor.plugins.PluginRegistry} for implicit instantiation.</p>
   * @constructor
   * Creates a new Plugin.
   */
  CUI.imageeditor.plugins.Plugin = new Class({

    /**
     * @return {String[]} features that are present within the plugin
     * @protected
     */
    features: null,

    /**
     * @property {String} pluginId
     * The plugin ID
     */
    pluginId: null,

    /**
     * Back reference to the image editor the plugin is used from
     * @type CUI.ImageEditor
     * @private
     */
    editor: null,

    config: null,

    construct: function (editor, pluginId) {
      this._init(editor, pluginId);
    },

    _init: function (editor, pluginId) {
      this.editor = editor;
      this.pluginId = pluginId;
    },

    notifyPluginConfig: function (config) {
      this.config = config;
    },

    getFeatures: function () {
      return this.features;
    },

    isFeatureEnabled: function (feature) {

      if ($.inArray(feature, this.getFeatures()) === -1) {
        // Feature not present in plugin's features list - therefore not available
        return false;
      }

      if (!this.config || !this.config.features) {
        // Features not configured - default => enabled
        return true;
      }

      if ($.isArray(this.config.features)) {
        // Features configured explicitly - enabled if in array
        return $.inArray(feature, this.config.features) !== -1;
      }

      if (this.config.features === '*') {
        // Wild card - all features are enabled
        return true;
      }

      if (this.config.features === '-') {
        // Dash - All features are disabled
        return false;
      }

      // Features misconfigured - default => enabled
      return true;
    },

    initializeUI: function (toolbarBuilder) {
      // must be overridden by implementing plugins to add items to toolbar
    },

    execute: function (pluginAction, value, envOptions) {
      // must be overridden by implementing plugins to handle toolbar interactions
    },

    registerTransformFields: function (transformResult) {
      // may be overridden by implementing plugins if they need to register hidden
      // transform fields to store manipulation values
      return null;
    },

    /**
     * @protected
     */
    getString : function (string) {
      return this.editor.i18n.get(this.pluginId + '.' + string);
    },

    /**
     * @protected
     */
    getTooltip: function (action) {
      return this.getString('toolbar.' + action);
    }
  });
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.rte.plugins.PluginRegistry
   * This class is used to manage plugins available for rich text editing. Each plugin has a
   * respective identifier by which it can be referenced.
   * @private
   * @since 5.3
   */
  CUI.imageeditor.plugins.PluginRegistry = (function () {

    var pluginRegistry = { };

    return {

      /**
       * Registers the specified class as an image editing plugin.
       * @param {String} pluginId The plugin ID
       * @param {Function} cls The plugin class (must implement
       *      {@link CUI.rte.plugins.Plugin})
       */
      register: function (pluginId, cls) {
        pluginRegistry[pluginId] = cls;
      },

      /**
       * <p>Creates an associative array, containing instances of all currently registered
       * plugins.</p>
       * @return {Object} Instantiated plugins
       */
      createRegisteredPlugins: function (editor) {
        var registeredPlugins = {},
            pluginId, plugin;

        for (pluginId in pluginRegistry) {
          if (pluginRegistry.hasOwnProperty(pluginId)) {
            plugin = new pluginRegistry[pluginId](editor, pluginId);
            plugin = CUI.imageeditor.Utils.onPluginCreated(plugin);
            registeredPlugins[pluginId] = plugin;
          }
        }
        return registeredPlugins;
      }
    };
  })();
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Rotate
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image rotation as a plugin.</p>
   * <p>The plugin ID is '<b>rotate</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>rotate left</b> - adds a button to rotate image left</li>
   *   <li><b>rotate right</b> - adds a button to rotate image right</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Crop = new Class({

    toString: 'Crop',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['launch', 'launchwithratio', 'unlaunch', 'confirm'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('launch')) {
        item = toolbarBuilder.createItem('launch', this.getTooltip('launch'), this);
        toolbarBuilder.registerItem(item, 'crop');
      }

      if (this.isFeatureEnabled('launchwithratio')) {
        item = toolbarBuilder.createItem('launchwithratio', this.getTooltip('launchwithratio'), this);
        toolbarBuilder.registerItem(item, 'crop');
      }

      item = toolbarBuilder.createItem('identifier', this.getTooltip('identifier'), this);
      toolbarBuilder.registerItem(item, 'crop', CUI.imageeditor.Theme.TOOLBARITEM_SELECTED_CLASS);

      if (this.isFeatureEnabled('unlaunch')) {
        item = toolbarBuilder.createItem('unlaunch', this.getTooltip('unlaunch'), this);
        toolbarBuilder.registerItem(item, 'close');
      }

      if (this.isFeatureEnabled('confirm')) {
        item = toolbarBuilder.createItem('confirm', this.getTooltip('confirm'), this);
        toolbarBuilder.registerItem(item, 'check');
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'launch') {
        $.each(this.editor.toolbars, function (index, value) {
          value.switchToolbar(CUI.imageeditor.plugins.Crop.TOOLBAR_ID);
        });

        this.editor.relayAction('croplaunch', value);
      }
      if (pluginCommand === 'launchwithratio') {
        this.editor.relayAction('croplaunchwithratio', this);
      }
      if (pluginCommand === 'unlaunch') {
        $.each(this.editor.toolbars, function (index, value) {
          this.switchToPrimaryToolbar();
        });

        this.editor.relayAction('cropunlaunch', value);
      }
      if (pluginCommand === 'confirm') {
        $.each(this.editor.toolbars, function (index, value) {
          this.switchToPrimaryToolbar();
        });

        this.editor.relayAction('cropconfirm', value);
      }
      if (pluginCommand === 'removecrop') {

        this.editor.relayAction('cropremovecrop', value);
      }
    },

    getAspectRatios : function () {
      if ($.isPlainObject(this.config) && $.isArray(this.config.aspectRatios)) {
        // Use config, if available
        return this.config.aspectRatios;
      }

      // Else use default
      var self = this,
          ratios = CUI.imageeditor.plugins.Crop.ASPECT_RATIOS;

      return $.map(ratios, function (e) {
        return {
          ratio : e.ratio,
          name  : self.getString('aspect_ratios.' + e.name)
        };
      });
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('crop');
    }
  });
}(jQuery, this));

/**
 * Id of crop replacement toolbar
 * @static
 * @final
 * @type String
 * @private
 */
CUI.imageeditor.plugins.Crop.TOOLBAR_ID = 'crop';

CUI.imageeditor.plugins.Crop.ASPECT_RATIOS = [
  {name: 'free_hand', ratio: 0},
  {name: '2_to_3', ratio: 0.67},
  {name: '3_to_5', ratio: 0.6},
  {name: '16_to_9', ratio: 0.5625},
  {name: 'square', ratio: 1}
];

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('crop', CUI.imageeditor.plugins.Crop);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Rotate
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image rotation as a plugin.</p>
   * <p>The plugin ID is '<b>rotate</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>rotate left</b> - adds a button to rotate image left</li>
   *   <li><b>rotate right</b> - adds a button to rotate image right</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Rotate = new Class({

    toString: 'Rotate',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['left', 'right'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('left')) {
        item = toolbarBuilder.createItem('left', this.getTooltip('left'), this);
        toolbarBuilder.registerItem(item, 'rotateLeft');
      }
      if (this.isFeatureEnabled('right')) {
        item = toolbarBuilder.createItem('right', this.getTooltip('right'), this);
        toolbarBuilder.registerItem(item, 'rotateRight');
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'right') {
        this.editor.relayAction('rotateright', value);
      }
      if (pluginCommand === 'left') {
        this.editor.relayAction('rotateleft', value);
      }
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('rotate');
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('rotate', CUI.imageeditor.plugins.Rotate);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Rotate
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image rotation as a plugin.</p>
   * <p>The plugin ID is '<b>rotate</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>rotate left</b> - adds a button to rotate image left</li>
   *   <li><b>rotate right</b> - adds a button to rotate image right</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Flip = new Class({

    toString: 'Flip',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['horizontal', 'vertical'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('horizontal')) {
        item = toolbarBuilder.createItem('horizontal', this.getTooltip('horizontal'), this);
        toolbarBuilder.registerItem(item, 'reflectHorizontal');
      }
      if (this.isFeatureEnabled('vertical')) {
        item = toolbarBuilder.createItem('vertical', this.getTooltip('vertical'), this);
        toolbarBuilder.registerItem(item, 'reflectVertical');
      }
    },

    execute: function (pluginCommand, value) {
      switch (pluginCommand) {
      case 'horizontal':
        this.editor.relayAction('fliphorizontal', value);
        break;
      case 'vertical':
        this.editor.relayAction('flipvertical', value);
        break;
      }
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('flip');
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('flip', CUI.imageeditor.plugins.Flip);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Map
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image map support.</p>
   * <p>The plugin ID is '<b>map</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>launch</b> - launches the map toolbar</li>
   *   <li><b>unlaunch</b> - unlaunches the map toolbar, reopening the default one</li>
   *   <li><b>confirm</b> - stores changes, unlaunches the map toolbar, reopening the default one</li>
   *   <li><b>rectangle</b> - inits adding a rectangular map</li>
   *   <li><b>circle</b> - inits adding a cicular/ellipsoid map</li>
   *   <li><b>polygon</b> - inits adding a polygon-shaped map</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Map = new Class({

    toString: 'Map',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['launch', 'unlaunch', 'confirm', 'rectangle', 'circle', 'polygon'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('launch')) {
        item = toolbarBuilder.createItem('launch', this.getTooltip('launch'), this);
        toolbarBuilder.registerItem(item, 'imageMap');
      }

      if (this.isFeatureEnabled('rectangle')) {
        item = toolbarBuilder.createItem('rectangle', this.getTooltip('rectangle'), this);
        toolbarBuilder.registerItem(item, 'imageMapRectangle');
      }
      if (this.isFeatureEnabled('circle')) {
        item = toolbarBuilder.createItem('circle', this.getTooltip('circle'), this);
        toolbarBuilder.registerItem(item, 'imageMapCircle');
      }
      if (this.isFeatureEnabled('polygon')) {
        item = toolbarBuilder.createItem('polygon', this.getTooltip('polygon'), this);
        toolbarBuilder.registerItem(item, 'imageMapPolygon');
      }

      if (this.isFeatureEnabled('unlaunch')) {
        item = toolbarBuilder.createItem('unlaunch', this.getTooltip('unlaunch'), this);
        toolbarBuilder.registerItem(item, 'close');
      }
      if (this.isFeatureEnabled('confirm')) {
        item = toolbarBuilder.createItem('confirm', this.getTooltip('confirm'), this);
        toolbarBuilder.registerItem(item, 'check');
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'launch') {
        $.each(this.editor.toolbars, function (index, value) {
          value.switchToolbar(CUI.imageeditor.plugins.Map.TOOLBAR_ID);
        });

        this.editor.relayAction('maplaunch', value);
      }
      else if (pluginCommand === 'unlaunch' || pluginCommand === 'confirm') {
        $.each(this.editor.toolbars, function (index, value) {
          this.switchToPrimaryToolbar();
        });

        this.editor.relayAction('map' + pluginCommand, value);
      }
      else if (pluginCommand === 'rectangle') {
        this.editor.relayAction('maprectangle', value);
      }
      else if (pluginCommand === 'circle') {
        this.editor.relayAction('mapcircle', value);
      }
      else if (pluginCommand === 'polygon') {
        this.editor.relayAction('mappolygon', value);
      }
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('map', []);
    }
  });
}(jQuery, this));

/**
 * Id of crop replacement toolbar
 * @static
 * @final
 * @type String
 * @private
 */
CUI.imageeditor.plugins.Map.TOOLBAR_ID = 'map';

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('map', CUI.imageeditor.plugins.Map);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Control
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements some control functionality as a plugin.</p>
   * <p>The plugin ID is '<b>control</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>finish</b> - adds a button that dispatches a 'finish' event - confirms editing</li>
   *   <li><b>close</b> - adds a button that dispatches a 'close' event - aborts editing</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Control = new Class({

    toString: 'Control',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['close', 'finish'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('close')) {
        item = toolbarBuilder.createItem('close', this.getTooltip('close'), this);
        toolbarBuilder.registerItem(item, 'close', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }

      if (this.isFeatureEnabled('finish')) {
        item = toolbarBuilder.createItem('finish', this.getTooltip('finish'), this);
        toolbarBuilder.registerItem(item, 'check', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }
    },

    execute: function (cmd, value, env) {
      if (cmd === 'close') {
        this.editor.cancel();
      }
      else if (cmd === 'finish') {
        this.editor.finish();
      }
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('control', CUI.imageeditor.plugins.Control);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Fullscreen
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements fullscreen support.</p>
   * <p>The plugin ID is '<b>fullscreen</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>fullscreen</b> - launches full screen editing mode</li>
   *   <li><b>fullscreenexit</b> - exit full screen editing mode</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Fullscreen = new Class({

    toString: 'Fullscreen',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['fullscreen', 'fullscreenexit'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('fullscreen')) {
        item = toolbarBuilder.createItem('fullscreen', this.getTooltip('fullscreen'), this);
        toolbarBuilder.registerItem(item, 'fullScreen', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }
      if (this.isFeatureEnabled('fullscreenexit')) {
        item = toolbarBuilder.createItem('fullscreenexit', this.getTooltip('fullscreenexit'), this);
        toolbarBuilder.registerItem(item, 'fullScreenExit', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'fullscreen') {
        this.editor.switchToFullscreen();
      }
      else if (pluginCommand === 'fullscreenexit') {
        this.editor.switchToInline();
      }
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('fullscreen', CUI.imageeditor.plugins.Fullscreen);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.History
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements history support.</p>
   * <p>The plugin ID is '<b>history</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>undo</b> - reverts the previous applied transformation</li>
   *   <li><b>redo</b> - reverts the last undo</li>
   * </ul>
   */
  CUI.imageeditor.plugins.History = new Class({

    toString: 'History',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['undo', 'redo'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('undo')) {
        item = toolbarBuilder.createItem('undo', this.getTooltip('undo'), this);
        this.notifyToolbarDecorator(item);

        toolbarBuilder.registerItem(item, 'undo', CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS);
      }
      if (this.isFeatureEnabled('redo')) {
        item = toolbarBuilder.createItem('redo', this.getTooltip('redo'), this);
        this.notifyToolbarDecorator(item);

        toolbarBuilder.registerItem(item, 'redo', CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS);
      }

      this.transformResultDecorator();
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'undo') {
        this.editor.relayAction('undo', value);
      }
      if (pluginCommand === 'redo') {
        this.editor.relayAction('redo', value);
      }
    },

    transformResultDecorator: function () {
      var self = this,
        transformResultFn = CUI.imageeditor.TransformResult.prototype.setTransformValue;

      if (this.isFeatureEnabled('undo') || this.isFeatureEnabled('redo')) {
        CUI.imageeditor.TransformResult.prototype.setTransformValue = function () {
          var i;

          transformResultFn.apply(this, arguments);

          for (i = self._observeHistory['undo'].length - 1; i >= 0; i--) {
            self._observeHistory['undo'][i].toggleClass(
              CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS,
              !this.history.length
            );
          }

          for (i = self._observeHistory['redo'].length - 1; i >= 0; i--) {
            self._observeHistory['redo'][i].toggleClass(
              CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS,
              !this.future.length
            );
          }

        };
      }
    },

    notifyToolbarDecorator: function (item) {
      var notifyToolbarFn = item.notifyToolbar,
        self = this;

      // create internal storage
      this._observeHistory = this._observeHistory || {};
      this._observeHistory[item.id] = this._observeHistory[item.id] || [];

      item.notifyToolbar = function () {
        notifyToolbarFn.apply(this, arguments);

        self._observeHistory[item.id].push(this.$ui);
      };

      return item;
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('history', CUI.imageeditor.plugins.History);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var ZOOM_ID = 'zoom',
    POPUP_SLIDER = 'popupslider',
    POPUP_SLIDER_BUTTON_ICON = 'search',
    RESET_100 = 'reset100',
    RESET_100_BUTTON_ICON = 'compare';

  /**
   * @class CUI.imageeditor.plugins.Zoom
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements zoom tools manipulating the zoomFactor option of the editor.</p>
   * <p>The plugin ID is "<b>zoom</b>".</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>popupslider</b> - adds a slider to zoom from 10 - 300 %</li>
   *   <li><b>reset100</b> - adds a button to reset to 100% zoom (WYSIWYG)</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Zoom = new Class({

    toString: 'Zoom',

    extend: CUI.imageeditor.plugins.Plugin,

    features: [POPUP_SLIDER, RESET_100],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled(POPUP_SLIDER)) {
        item = toolbarBuilder.createItem(POPUP_SLIDER, this.getTooltip(POPUP_SLIDER), this);
        toolbarBuilder.registerItem(item, POPUP_SLIDER_BUTTON_ICON);
      }

      if (this.isFeatureEnabled(RESET_100)) {
        item = toolbarBuilder.createItem(RESET_100, this.getTooltip(RESET_100), this);
        toolbarBuilder.registerItem(item, RESET_100_BUTTON_ICON);
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === POPUP_SLIDER) {
        this.editor.relayAction(ZOOM_ID + POPUP_SLIDER, this);
      }
      if (pluginCommand === RESET_100) {
        this.editor.relayAction(ZOOM_ID + RESET_100, this);
      }

    },

    registerTransformFields: function (transformResult) {
    }
  });

  /**
   * Id of zoom replacement toolbar
   * @static
   * @final
   * @type String
   * @private
   */
  CUI.imageeditor.plugins.Zoom.TOOLBAR_ID = ZOOM_ID;


  // register plugin
  CUI.imageeditor.plugins.PluginRegistry.register(ZOOM_ID, CUI.imageeditor.plugins.Zoom);

}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.ui.ToolbarBuilder
   * @private
   * <p>This class is used to build toolbars from plugins.</p>
   * <p>Each toolbar consists of several groups of toolbar items.
   * Each group has a sorting index to determine its position
   * relative to other groups. Each toolbar item has a sorting index to determine its position
   * relative to other icons of the same group.</p>
   * @constructor
   * Creates a new ToolbarBuilder
   */
  CUI.imageeditor.ui.ToolbarBuilder = new Class({

    toString: 'ToolbarBuilder',

    /**
     * @private
     */
    groups: null,

    $editable: null,

    construct: function (options) {
      this.registeredItems = {};
      this.templates = options.templates;
    },

    /**
     * Create a new toolbar item
     * @param {String} id ID of the toolbar item
     * @param {String} title Title/Tooltip to be used for the toolbar item
     * @param {CUI.imageeditor.plugins.Plugin} plugin The plugin the toolbar item belongs to
     * @return {CUI.imageeditor.ui.ToolbarItem} The toolbar item
     */
    createItem: function (id, title, plugin) {
      return new CUI.imageeditor.ui.ToolbarItem(id, title, plugin);
    },

    /**
     * Registers toolbar item in the correct group at the correct position.
     * @param {String} groupId ID of the group the item belongs to
     * @param {Number} groupSort Group sorting index
     * @param {CUI.imageeditor.ui.ToolbarItem} item Toolbar item to add
     * @param {Number} itemSort Item sorting index
     */
    registerItem : function (item, iconClass, additionalClasses) {
      item = $.extend({}, item, {
        icon : iconClass,
        addClasses : additionalClasses
      });

      this.registeredItems[item.action] = item;
    },

    /**
     * Create the abstracted toolbar
     * @return {CUI.imageeditor.ui.Toolbar} The toolbar
     * @ignore
     */
    createToolbar: function (options, toolbarType) {
      var toolbar,
          $editable = options.$editable,
          $toolbars,
          uiOptions = this.getUIOptions(options, toolbarType),
          i;

      if (!toolbarType) { throw new Error('ArgumentError - missing toolbar type'); }
      if (!uiOptions) { return null; }

      // Get the toolbars for this toolbar type
      $toolbars = CUI.imageeditor.UIUtils.getToolbars($editable, toolbarType);

      // Build toolbar if it doesn't exist
      if (!$toolbars || $toolbars.length === 0) {
        this._buildToolbar($editable, uiOptions, toolbarType);
      }

      // Use the newly created toolbar
      toolbar = new CUI.imageeditor.ui.Toolbar($editable, toolbarType);

      // Allow elements to notify toolbar
      for (i in this.registeredItems) {
        if (this.registeredItems.hasOwnProperty(i)) {
          this.registeredItems[i].notifyToolbar(toolbar);
        }
      }

      return toolbar;
    },



    /**
     * Build the $toolbar and append it to the $ui
     * @param {jQuery} $editable The jQuery editable (canvas) element
     * @param {Object} items Toolbar items
     * @param {Object} options All widget options
     * @private
     */
    _buildToolbar: function ($editable, uiOptions, toolbarType) {
      var toolbarTpl = this.templates.get('toolbar'),
          itemTemplate = this.templates.get('toolbar-item'),
          replacementToolbars = [];

      // Get the item options definitions
      replacementToolbars = [];

      // Build replacement toolbars
      var replacementToolbarDefs = uiOptions.replacementToolbars,
          ref, items;

      for (ref in replacementToolbarDefs) {
        if (replacementToolbarDefs.hasOwnProperty(ref)) {
          items = replacementToolbarDefs[ref];

          // Support for
          //   replacementToolbars : {
          //      crop: ['crop#identifier', ...],
          //      map:  ['map#rectangle', ...]
          //   }
          // as well as
          //   replacementToolbars : {
          //      crop: {
          //        ref : 'crop',
          //        items: ['crop#identifier', ...]
          //      },
          //      map: {
          //        ref: 'map',
          //        items: ['map#rectangle', ...]
          //      }
          //   }
          replacementToolbars.push(toolbarTpl({
            'ref': items.ref || ref,
            'toolbarItems': this.getToolbarItemHTML(items.items || items, itemTemplate)
          }));
        }
      }


      // Build the toolbar-collection
      var $toolbar = $(this.templates.get('toolbars')({
        'type': toolbarType,
        'toolbar': toolbarTpl({
          'ref': 'primary',
          'toolbarItems': this.getToolbarItemHTML(uiOptions.toolbar, itemTemplate)
        }),
        'replacementToolbars': replacementToolbars
      }));

      // Select the toolbar container to append to
      var $ui = CUI.imageeditor.UIUtils.getUIContainer($editable);
      var $toolbarContainer = CUI.imageeditor.UIUtils.getToolbarContainer($ui, toolbarType);

      $($toolbarContainer).append($toolbar);
    },


    /**
     * @private
     */
    // todo - this is the wrong place for this - should be part of a general options/config object + accessor/getter
    getUIOptions: function (options, tbType) {
      if (options && options.ui) {
        return options.ui[tbType];
      } else {
        return CUI.imageeditor.ui.DEFAULT_OPTIONS[tbType];
      }
    },

    /**
     * @private
     */
    getToolbarItemHTML : function (toolbarItemConfig, itemTemplate) {
      var i, items, item, toolbarLayout;

      if ($.isArray(toolbarItemConfig)) {
        if (!$.isArray(toolbarItemConfig[0])) {
          // plain config - everthing should be placed on the left-hand side
          toolbarLayout = {
            left: toolbarItemConfig,
            right: []
          };
        } else {
          // old style array of arrays:
          toolbarLayout = {
            left: toolbarItemConfig[0],
            right: toolbarItemConfig.length > 1 ? toolbarItemConfig[1] : []
          };
        }
      } else {
        toolbarLayout = {
          left: toolbarItemConfig.left ? toolbarItemConfig.left : [],
          right: toolbarItemConfig.right ? toolbarItemConfig.right : []
        };
        if (!$.isArray(toolbarItemConfig.left) || !$.isArray(toolbarItemConfig.right)) {
          throw new Error('Argument error: Expecting object {left:[], right:[]}');
        }
      }

      items = {left: [], right: []};
      for (i = 0; i < toolbarLayout.left.length; i++) {
        item = this.registeredItems[toolbarLayout.left[i]];
        if (item) {
          items.left.push($.trim(itemTemplate(item)));
        }
      }
      for (i = 0; i < toolbarLayout.right.length; i++) {
        item = this.registeredItems[toolbarLayout.right[i]];
        if (item) {
          items.right.push($.trim(itemTemplate(item)));
        }
      }

      return items;
    }
  });
}(jQuery, this));

CUI.imageeditor.ui.DEFAULT_OPTIONS = {
  'inline': {
    'toolbar': [
      'crop#launch',
      'rotate#left',
      'rotate#right',
      'flip#vertical',
      'flip#horizontal',
      'history#undo',
      'history#redo',
      'fullscreen#fullscreen',
      'control#close'
    ],
    'replacementToolbars': {
      'crop': [
        'crop#identifier',
        'crop#unlaunch',
        'crop#confirm'
      ]
    }
  },
  'fullscreen': {
    'toolbar': {
      'left': [
        'crop#launchwithratio',
        'rotate#left',
        'rotate#right',
        'flip#vertical',
        'flip#horizontal',
        'map#launch',
        'zoom#reset100',
        'zoom#popupslider'
      ],
      'right': [
        'history#undo',
        'history#redo',
        'fullscreen#fullscreenexit'
      ]
    },
    'replacementToolbars': {
      'crop': {
        'left': [
          'crop#identifier'
        ],
        'right': [
          'crop#unlaunch',
          'crop#confirm'
        ]
      },
      'map': {
        'left': [
          'map#rectangle',
          'map#circle',
          'map#polygon'
        ],
        'right': [
          'map#unlaunch',
          'map#confirm'
        ]
      }
    }
  }
};

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2013 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.ui.Toolbar = new Class({

    toString: 'Toolbar',

    $ui: null,

    $editable: null,

    $container: null,

    $toolbars: null,

    construct: function ($editable, tbType) {
      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      this.tbType = tbType;
      this.$editable = $editable;
      this.$ui = CUI.imageeditor.UIUtils.getUIContainer(this.$editable);
      this.$container = CUI.imageeditor.UIUtils.getToolbarContainer(this.$ui, tbType);
      this.$toolbars = CUI.imageeditor.UIUtils.getToolbars(this.$editable, this.tbType);
      this.autoSetToolbarWidths();
      this.switchToPrimaryToolbar();
    },

    autoSetToolbarWidths: function () {
      var self = this;

      this.$toolbars.each(function () {
        var tbId = $(this).data('id');

        if (tbId !== undefined) {
          self.autoSetToolbarWidth(tbId);
        }
      });
    },

    autoSetToolbarWidth: function (tbId) {
      this.showToolbar(tbId);
      this.setToolbarWidth(tbId, this.calcToolbarWidth(tbId));
      this.hideToolbar(tbId);
    },

    setToolbarWidth: function (tbID, width) {
      var $tb = this.getToolbar(tbID);

      if ($tb !== null) {
        $tb.width(width);
      }
    },

    calcToolbarWidth: function (tbId) {
      var $tb = this.getToolbar(tbId),
          width = 0;

      $tb.children().each(function () {
        width += $(this).outerWidth(true);
      });

      return width;
    },

    show: function () {
      this.$container.addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
    },

    hide: function () {
      this.$container.addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
    },

    isHidden: function () {
      return (this.$container.hasClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS));
    },

    getContainer: function () {
      return this.$container;
    },

    getToolbar: function (tbId) {
      var tb = null;

      this.$toolbars.each(function () {
        if ($(this).data('id') === tbId) {
          tb = $(this);
          return;
        }
      });
      return tb;
    },

    getToolbars: function () {
      return this.$toolbars;
    },

    switchToPrimaryToolbar: function () {
      this.switchToolbar(CUI.imageeditor.ui.Toolbar.PRIMARY_TOOLBAR_ID);
    },

    switchToolbar: function (tbId) {
      this.hideToolbars();
      this.showToolbar(tbId);
    },

    showToolbar: function (tbId) {
      var tb = this.getToolbar(tbId);

      if (tb !== null) {
        $(tb).removeClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
      }
    },

    hideToolbar: function (tbId) {
      var tb = this.getToolbar(tbId);

      if (tb !== null) {
        $(tb).addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
      }
    },

    hideToolbars: function () {
      this.$toolbars.each(function () {
        $(this).addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
      });
    },

    startEditing: function () {
      this.show();
    },

    finishEditing: function () {
      this.hide();
    }
  });
}(jQuery, this));

/**
 * Id of the primary toolbar
 * @static
 * @final
 * @type String
 * @private
 */
CUI.imageeditor.ui.Toolbar.PRIMARY_TOOLBAR_ID = 'primary';

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.ui.ToolbarItem = new Class({

    toString: 'ToolbarItem',

    $ui: null,

    id: null,

    plugin: null,

    title: null,

    toolbar: null,

    construct: function (id, title, plugin) {
      this._init.apply(this, arguments);
    },

    _init: function (id, title, plugin) {
      this.id = id;
      this.title = title;
      this.plugin = plugin;
      this.action = this.plugin.pluginId + '#' + this.id;
    },

    /**
     * Add this toolbar element to the toolbar
     * @param {CUI.imageeditor.ui.Toolbar} The toolbar
     * @ignore
     */
    notifyToolbar: function (toolbar) {
      var self = this, $cont = null;

      this.toolbar = toolbar;
      $cont = $(toolbar.getContainer());
      this.$ui = $cont.find('button[data-action="' + this.action + '"]');
      this.tapOrClickHandler = CUI.imageeditor.UIUtils.handleTapOrClick(this.$ui, function (e) {
        e.stopImmediatePropagation();
        if (!self.$ui.hasClass(CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS)) {
          self.plugin.execute(self.id);
        }
        this.blur();
      },
      {
        eventNamespace: 'imageeditor-handler'
      });
    },

    createToolbarDef: function () {
      return {
        'id': this.id,
        'element': this
      };
    },

    destroy: function () {
      if (this.tapOrClickHandler) {
        this.tapOrClickHandler.off();
      }
    }
  });
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2015 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* jshint eqeqeq: true, immed: true, latedef: true, newcap: true, noarg: true,
          sub: true, undef: true, boss: true, eqnull: true, browser: true,
          smarttabs: true */
/* global jQuery */
jQuery.fn.polygon = (function ($) {
    'use strict';

    var isN = function (n) {
        return !isNaN(n);
    };

    var Polygon = function ($element, options) {
        this.$element = $element;

        this.loadOpts(options);
    };

    Polygon.prototype.defaults = {
        points: []
    };

    Polygon.prototype.loadOpts = function (options) {
        this.options = $.extend({}, this.defaults, options);

      if (this.options.points) {
        this.points = this.readPoints(this.options.points);
      }
    };

    Polygon.prototype.readPoints = function (rawPoints) {
      var result = [], i, point, parsed;

      if (rawPoints && rawPoints.length) {
        for (i = 0; i < rawPoints.length; i++) {
          point = rawPoints[i];
          if (isN(point.w) && isN(point.h)) {
            parsed = {
              w: parseInt(point.w, 10),
              h: parseInt(point.h, 10)
            };
            result.push(parsed);
          }
        }
      }
      return result;
    };

    Polygon.prototype.clearCanvas = function (optionalCanvas) {
      var canvas = this.getCanvas(optionalCanvas),
        drawCtxt = this.get2dContext(optionalCanvas);

      drawCtxt.clearRect(0, 0, canvas.width, canvas.height);
    };

    Polygon.prototype.get2dContext = function (optional$Canvas) {
      return this.getCanvas(optional$Canvas).getContext('2d');
    };

    Polygon.prototype.getCanvas = function (optional$Canvas) {
      var canvas = this.$element;

      if (optional$Canvas) {
        canvas = optional$Canvas;
      }

      return canvas.length ? canvas[0] : canvas;
    };

    Polygon.prototype.paintPolygon = function (options) {
      this.paintPolygonWithPoints(null, null, options);
    };

    Polygon.prototype.paintPolygonWithPoints = function (canvas, points, options) {
      canvas = this.getCanvas(canvas);
      var drawCtxt = this.get2dContext(canvas),
        paintedOne = false, point, i;

      points = points || this.points;

      options = $.extend({
        strokeStyle: '#000',
        fillStyle: null,
        lineWidth: 1,
        lineJoin: 'round'
      }, options);

      if (points && points.length) {
        drawCtxt.beginPath();
        point = points[0];
        drawCtxt.moveTo(point.w, point.h);
        paintedOne = true;

        for (i = 1; i < points.length; i++) {
          point = points[i];
          drawCtxt.lineTo(point.w, point.h);
        }
        drawCtxt.closePath();
      }
      if (paintedOne) {
        if (options.strokeStyle) {
          drawCtxt.lineWidth = options.lineWidth;
          drawCtxt.strokeStyle = options.strokeStyle;
          drawCtxt.lineJoin = options.lineJoin;
          drawCtxt.stroke();
        }
        if (options.fillStyle) {
          drawCtxt.fillStyle = options.fillStyle;
          drawCtxt.fill();
        }
      }
    };

    Polygon.prototype.getPoints = function () {
        return this.points.slice();
    };

    Polygon.prototype.setPoints = function (points) {
      this.points = points;
    };

    /**
     * Checks if point is inside or on the boundary of the bounding box.
     * @param optionalPointsOrRect either use these or create bb from points of this polygon
     * @param w to check
     * @param h to check
     * @returns {boolean} result
     */
    Polygon.prototype.isCoordsInBoundingBox = function (optionalPointsOrRect, w, h) {
      var boundingBox = null;

      if (optionalPointsOrRect && typeof(optionalPointsOrRect.left) !== 'undefined') {
        boundingBox = optionalPointsOrRect;
      } else {
        boundingBox = this.getBoundingBox(optionalPointsOrRect);
      }

      return w >= boundingBox.left && w <= (boundingBox.left + boundingBox.width) &&
        h >= boundingBox.top && h <= (boundingBox.top + boundingBox.height);
    };

    Polygon.prototype.getBoundingBox = function (optionalPoints) {
      var points = optionalPoints || this.points,
        boundingBox = {
          top: Number.MAX_VALUE,
          bottom: Number.MIN_VALUE,
          left: Number.MAX_VALUE,
          right: Number.MIN_VALUE
        }, i, point;

      if (!points || points.length < 1) {
        throw new Error('Cannot define bounding box if there are no points, handle this case differently');
      }

      for (i = 0; i < points.length; i++) {
        point = points[i];
        if (point.w < boundingBox.left) {
          boundingBox.left = point.w;
        }
        if (point.w > boundingBox.right) {
          boundingBox.right = point.w;
        }

        if (point.h < boundingBox.top) {
          boundingBox.top = point.h;
        }
        if (point.h > boundingBox.bottom) {
          boundingBox.bottom = point.h;
        }
      }

      boundingBox.width = boundingBox.right - boundingBox.left;
      boundingBox.height = boundingBox.bottom - boundingBox.top;

      return boundingBox;
    };

  /**
   * Builds on the fact that to be inside of a polygon a line cutting parallel to
   * the x axis from -inf to the point must intersect polygon an uneven num.
   *
   * Stability: Limited to components of vectors >-60,000,000 and <60,000,000. Multiplies vector components and
   * adds the results, so stability is rapidly lost for vectors whose components become too big.
   *
   * @param pointVector
   * @param polygonPointsAsVectors
   * @returns {boolean}
   */
    Polygon.prototype.isPointInsideOrOnEdgeOfPolygon = function (pointVector, polygonPointsAsVectors) {
      var currSegment, intersectionCount, intersectionResult, prevPoint, i,
        testLineSegment = [[-60000000, pointVector[1]], pointVector]; // stability lost if components of vectors become too large

      if (!polygonPointsAsVectors || polygonPointsAsVectors.length < 3) {
        return false;
      }

      intersectionCount = 0;
      prevPoint = polygonPointsAsVectors[polygonPointsAsVectors.length -1];
      for (i = 0; i < polygonPointsAsVectors.length; i++) {
        currSegment = [prevPoint, polygonPointsAsVectors[i]];
        if (this.isPointOnLineSegment(pointVector, currSegment[0], currSegment[1])) {
          return true; // otherwise result will be inside hits only
        }

        intersectionResult = this.intersectSegments(testLineSegment, currSegment);
        if (intersectionResult != null) {
          intersectionCount++;
        }
        prevPoint = polygonPointsAsVectors[i];
      }

      return intersectionCount > 0 && intersectionCount % 2 === 1;
    };

    /**
     *
     * @param segmentAVectors segment defined by two edge vertexes
     * @param segmentBVectors segment defined by two edge vertexes
     * @return null if no intersection, segment if segments share a part or are equal else the intersection point as vector
     */
    Polygon.prototype.intersectSegments = function (segmentAVectors, segmentBVectors) {
      var a = segmentAVectors[0], b = segmentAVectors[1], c = segmentBVectors[0], d = segmentBVectors[1],
        intersection = this.intersectLines(segmentAVectors, segmentBVectors);

      if (intersection == null) {
        return null;
      }

      if (intersection === true) {
        if (this.isWithin(c, a, d)) {
          if (this.isWithin(c, b, d)) {
            return [a, b];
          } else {
            if (this.isWithin(a, c, b)) {
              return [a, c];
            } else {
              return [a, d];
            }
          }
        } else if (this.isWithin(c, b, d)) {
          if (this.isWithin(a, c, b)) {
            return [b, c];
          } else {
            return [b, d];
          }
        } else if (this.isWithin(a, c, b)) {
          if (this.isWithin(a, d, b)) {
            return [c, d];
          } else {
            if (this.isWithin(c, a, d)) {
              return [c, a];
            } else {
              return [c, b];
            }
          }
        } else if (this.isWithin(a, d, b)) {
          if (this.isWithin(c, a, d)) {
            return [a, d];
          } else {
            return [b, d];
          }
        } else {
          return null;
        }

      } else {
        if (this.isPointOnLineSegment(intersection, segmentAVectors[0], segmentAVectors[1]) &&
          this.isPointOnLineSegment(intersection, segmentBVectors[0], segmentBVectors[1])) {

          return intersection;
        }
        return null;
      }
    };

    /**
     *
     * @param lineA line composed of two point vectors on the line
     * @param lineB line composed of two point vectors on the line
     * @return null if no intersection, true if same line (parallel lines) else the intersection point as vector
     */
    Polygon.prototype.intersectLines = function (lineAVectors, lineBVectors) {
      if (lineAVectors.length !== 2 || lineBVectors.length !== 2) {
        throw new Error("Arguments invalid: Please pass 2 arrays of two vectors each");
      }
      var a = lineAVectors[0], b = lineAVectors[1],
        c = lineBVectors[0], d = lineBVectors[1],
        v = [b[0]-a[0], b[1]-a[1]], // v = b - a
        w = [d[0]-c[0], d[1]-c[1]], // w = d - c
        x2, // c + x2 * w = t1;
        dividend, divisor,
        t1, t2,
        vIsZero = this.vectorsEqual(v, [0, 0]),
        wIsZero = this.vectorsEqual(w, [0, 0]);

      // check for point cases (no line passed, just two equal vectors: point)
      if (vIsZero) {
        if (wIsZero) {
          if (this.vectorsEqual(a, c)) {
            return a;
          } else {
            return null;
          }
        } else {
          if (this.isThreePointsOnOneLine(c, d, a)) {
            return a;
          } else {
            return null;
          }
        }
      }
      if (wIsZero) {
        if (this.isThreePointsOnOneLine(a, b, c)) {
          return c;
        } else {
          return null;
        }
      }

      if ((v[0] === 0 && w[0] === 0) ||
        (v[1] === 0 && w[1] === 0) ||
        this.floatsEqual(v[0] / w[0], v[1] / w[1])) {

        // lines parallel
        if (this.isThreePointsOnOneLine(a, b, c)) {
          return true;
        } else {
          return null;
        }
      }

      dividend = v[0]*(a[1] - c[1]) + v[1]*(c[0] - a[0]);
      divisor = v[0] * w[1] - v[1] * w[0];
      x2 = dividend / divisor;

      t1 = c[0] + x2*w[0];
      t2 = c[1] + x2*w[1];

      return [t1, t2];
    };

    /**
     * Points are vectors here: array with 2 entries.
     *
     * @param point to check for nearness to segments
     * @param lineSegments array of two-point arrays. Segments are given by their ending points
     */
    Polygon.prototype.filterLineSegmentsNextToPointAndSortByDistance = function (point, lineSegments) {
      var result = [], i, current, projection, orthoProjectingVector;

      for (i = 0; i < lineSegments.length; i++) {
        current = lineSegments[i];
        projection = this.projectPointOntoLine(point, current[0], current[1]);
        if (this.isPointOnLineSegment(projection, current[0], current[1])) {
          orthoProjectingVector = [projection[0] - point[0], projection[1] - point[1]];
          result.push({
            line: current,
            projection: projection,
            distance: this.vectorNorm(orthoProjectingVector)
          });
        }
      }

      result.sort(function (a, b) { return a.distance - b.distance; });
      return result;
    };

    /**
     * Points are vectors here: array with 2 entries.
     *
     * @param p point to project
     * @param l1 point on line defined by l1 and l2. If l1 == l2 vector from p to l1 is returned
     * @param l2 see l1
     * @return the vector from p to X, point on line (defined by l1,l2), or vector from p to l1 if l1 == l2.
     *  Do p + returnedVector to get the projection point on line (defined by l1,l2)
     */
    Polygon.prototype.projectPointOntoLine = function (p, l1, l2) {
      var lineSlope, // slope of line through l1 and l2
        o, // vector orthogonal to lineSlope
        x; // stretch factor for slope vector, which when added to l1 points to the searched projection point on line

      if (l1[0] === l2[0] && l1[1] === l2[1]) {
        // special case, no line, only point given. Project to point ; )
        return [
          l1[0] - p[0],
          l1[1] - p[1]
        ];
      }

      lineSlope = [l1[0]-l2[0], l1[1]-l2[1]];
      if (lineSlope[1] === 0) {
        o = [0.0, 1.0];
      } else {
        o = [1.0, (-1.0 * (lineSlope[0] / lineSlope[1]))];
      }

      x = ( o[1]*( l1[0] - p[0] ) + o[0]*( p[1] - l1[1] ) ) / //
          ( o[0]*lineSlope[1] - o[1]*lineSlope[0] );

      return [
        l1[0] + x*lineSlope[0],
        l1[1] + x*lineSlope[1]
      ];
    };

    Polygon.prototype.isPointOnLineSegment = function (p, l1, l2) {
      if (this.isThreePointsOnOneLine(p, l1, l2)) {
        if (l1[0] !== l2[0]) {
          return this.isWithin(l1[0], p[0], l2[0]);
        } else {
          return this.isWithin(l1[1], p[1], l2[1]);
        }
      }
      return false;
    };

    /**
     * Implementation is using multiplication, so stability is lost for big inputs (vectors with a component >60,000,000).
     */
    Polygon.prototype.isThreePointsOnOneLine = function (p1, p2, p3) {
      return this.floatsEqual((p2[0] - p1[0]) * (p3[1] - p1[1]), (p3[0] - p1[0]) * (p2[1] - p1[1]));
    };

    Polygon.prototype.isWithin = function (side1, middle, side2) {
      return (side1 <= middle) && (middle <= side2) ||
        (side2 <= middle) && (middle <= side1);
    };

    Polygon.prototype.floatsEqual = function (a, b, relativeError) {
      if (typeof(relativeError) === 'undefined') {
        relativeError = 0.000000001;
      }
      if (a === b) {
        return true;
      }
      return Math.abs((a - b) / b) <= relativeError;
    };

    Polygon.prototype.vectorNorm = function (vector) {
      return Math.sqrt(this.dotProduct(vector, vector));
    };

    /**
     * Also called scalar product.
     */
    Polygon.prototype.dotProduct = function (a, b) {
      var sum = 0, i;
      if (a.length !== b.length) {
        throw new Exception('a and b have differing length');
      }

      for (i = 0; i < a.length; i++) {
        sum = sum + a[i] * b[i];
      }
      return sum;
    };

    Polygon.prototype.pointsToVectors = function (p) {
      var resultArr, i;
      if (typeof(p) === 'object') {
        if (typeof(p.length) !== 'undefined') {
          resultArr = [];
          for (i = 0; i < p.length; i++) {
            resultArr.push(this.pointsToVectors(p[i]));
          }
          return resultArr;
        }
        if (typeof(p.w) !== 'undefined') {
          return [p.w, p.h];
        } else {
          return [p.x, p.y];
        }
      }
      return;
    };

    Polygon.prototype.vectorsEqual = function (a, b) {
      var i;
      if (a.length !== b.length) {
        return false;
      }

      for (i = 0; i < a.length; i++) {
        if (!this.floatsEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    };

    Polygon.prototype.pointsToLineSegmentsWithVectors = function (points) {
      var i, vectors = this.pointsToVectors(points),
        result = [], singleLine;

      if ((!vectors) || vectors.length < 2) {
        return [];
      }

      if (vectors.length === 2) {
        result.push([vectors[0], vectors[1]]);
        return result;
      }

      for (i = 1; i < vectors.length; i++) {
        result.push([vectors[i-1], vectors[i]]);
      }
      result.push([ vectors[vectors.length-1], vectors[0] ]);
      return result;
    };

    var ctor = function (options) {
        options = options || {};
        this.each(function () {
            var el = $(this), instance = el.data('polygon');

            if (options.call) {
                if (instance) {
                    instance[options.call].call(instance, options);
                }
            }
            else if (!instance) {
                instance = new Polygon(el, options);
                el.data('polygon', instance);
            }
            else {
                instance.loadOpts(options);
            }
        });

        if (options && options.instance) {
            return this.eq(0).data('polygon');
        }
        else {
            return this;
        }
    };

    return ctor;
})(jQuery);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* jshint eqeqeq: true, immed: true, latedef: true, newcap: true, noarg: true,
          sub: true, undef: true, boss: true, eqnull: true, browser: true,
          smarttabs: true */
/* global jQuery */
jQuery.fn.imageSelect = (function ($) {
    'use strict';

    var EVENT = {
        NAMESPACE : '.imageSelect'
    };

    // Events that are consumed
    EVENT.CLICK  = 'click'              + EVENT.NAMESPACE;
    EVENT.RESIZE = 'resize'             + EVENT.NAMESPACE;

    EVENT.MOUSEDOWN = 'touchstart'  + EVENT.NAMESPACE + ' ' +
                      'mousedown'   + EVENT.NAMESPACE;
    EVENT.MOUSEUP   = 'touchend'    + EVENT.NAMESPACE + ' ' +
                      'touchcancel' + EVENT.NAMESPACE + ' ' +
                      'mouseup'     + EVENT.NAMESPACE;
    EVENT.MOUSEMOVE = 'touchmove'   + EVENT.NAMESPACE + ' ' +
                      'mousemove'   + EVENT.NAMESPACE;

    // Events that are emitted
    EVENT.OPEN   = 'open';
    EVENT.CLOSE  = 'close';
    EVENT.UPDATE = 'update';
    EVENT.SECOND_CLICK = 'second_click';



    var SELECTION_BORDER = 2, // see CSS rule .image-select-selection
        UPDATE_INTERVAL = 50,
        SUPPORTED_SHAPES = ['rectangle', 'ellipse'];


    var isN = function (n) {
        return !isNaN(n);
    };

    var preventDefaultAndPropagation = function (e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
    };

    /**
     * Gets page coordinates of event. Touch event coordinates returned if available.
     * @param {Object} e the event
     * @returns {{x: (Number), y: (Number)}} Page coordinates X and Y
     * @private
     */
    var _getEventCoordinates = function (e) {
        if (e.originalEvent.touches) {
            return { x : e.originalEvent.touches[0].pageX, y : e.originalEvent.touches[0].pageY };
        }
        else {
            return { x : e.pageX, y : e.pageY };
        }
    };

    var moveSelectionIntoCanvas = function (selection, canvas, min, aspectRatio) {
        // Reduce dimension to be smaller or equal to canvas dimensions
        selection.width  = Math.min(canvas.width, selection.width);
        selection.height = Math.min(canvas.height, selection.height);

        if (typeof(min) !== 'undefined') {
          selection.width = Math.max(min.width, selection.width);
          selection.height = Math.max(min.height, selection.height);
        }

        // Fix aspect ratio
        if (typeof(aspectRatio) !== 'undefined' && aspectRatio !== 0) {
            if (selection.height > Math.round(selection.width * aspectRatio)) {
                selection.height = Math.floor(selection.width * aspectRatio);
            }
            else {
                selection.width = Math.floor(selection.height / aspectRatio);
            }
        }

        // Move selection away from edge, until it is inside canvas
        selection.left = Math.max(canvas.left, selection.left);
        selection.left = Math.min(canvas.left + canvas.width - selection.width,
                                  selection.left);
        selection.top = Math.max(canvas.top, selection.top);
        selection.top = Math.min(canvas.top + canvas.height - selection.height,
                                 selection.top);

        return selection;
    };

    // matrix may contain scientific floats on chrome, which chrome doesn't accept, example: 'matrix(6.12323399573677e-17, 1, -1, 6.12323399573677e-17, 0, 0)'
    var MATRIX   = /matrix\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 6 numbers
        MATRIX3D = /matrix3d\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 16 numbers
        i = function (s) {
          var number = parseFloat(s);
          if (isNaN(number)) {
            throw new Error('Number is not a float');
          }
          return Math.round(number);
        };

    var get2by2MatrixFromElement = function (element) {
        var matrixStr = $(element).css('transform'),
            match;

        try {
          match = matrixStr.match(MATRIX);
          if (match) {
              /**
               * TODO: Find out why this is not the way, I would expect it to be.
               *
               * Based on documentation and my understanding, the matrix should be
               *
               *     i(match[1]) i(match[3])
               *     i(match[2]) i(match[4])
               *
               * This would also be similar to the 3d version below.
               *
               * BUT, it does not yield the expected results. Instead the
               * following one works just as desired. Therefore I am using that
               * one -- although I do not know why.
               */
              return [
                  [i(match[1]), i(match[2])],
                  [i(match[3]), i(match[4])]
              ];
          }

          match = matrixStr.match(MATRIX3D);
          if (match) {
              return [
                  [i(match[1]), i(match[5])],
                  [i(match[2]), i(match[6])]
              ];
          }
          else if (matrixStr === 'none') {
              return [
                  [1, 0],
                  [0, 1]
              ];
          }
        } catch (e) {
          // logged below
        }

        if (window.console && window.console.log) {
            window.console.log('ImageEditor: Could not parse matrix string', matrixStr);
        }

        return [
            [1, 0],
            [0, 1]
        ];
    };
    var applyMatrixToCoordinates = function (matrix, point) {
        if (matrix.length !== 2 ||
            matrix[0].length !== 2 ||
            matrix[1].length !== 2) {
            throw new Error('Expecting 2x2 matrix');
        }
        if (point.x === undefined || point.y === undefined) {
            throw new Error('Expecting point to be object like {x: 0, y: 0}');
        }

        return $.extend({}, point, {
            x : point.x * matrix[0][0] + point.y * matrix[0][1],
            y : point.x * matrix[1][0] + point.y * matrix[1][1]
        });
    };
    // chrome returns currently (v38) scientific notation for very small numbers, but doesn't accept it. So nullify this.
    var normalizeMatrixForChrome = function (matrixStr) {
      try {
        var outerMatch = matrixStr.match(/matrix\(([^)]+)\)/);
        if (outerMatch) {
          var inner = outerMatch[1];
          var numbers = inner.split(/, ?/);
          var normalizedNumbers = [];
          for (var i = 0; i < numbers.length; i++) {
            var current = numbers[i];
            if (current.indexOf('e') > -1 || current.indexOf('E') > -1) {
              var parsed = parseFloat(current);
              if (isNaN(parsed)) {
                throw new Error('Not a number: \'' + current + '\'');
              }

              normalizedNumbers.push('' + parsed.toFixed(19)); // toFixed limited to 20

            } else {
              normalizedNumbers.push(current);
            }
          }
          return 'matrix(' + normalizedNumbers.join(', ') + ')';
        }

      } catch (e) {
        // ignored
      }

      return matrixStr;
    };


    var ImageSelection = function ($element, options) {
        this.$element = $element;

        this.open(options);
    };

    ImageSelection.prototype.defaults = {
        classPrefix : 'image-select-', // {String} The prefix for css classes applied to UI elements.
        parent      : null,            // {Mixed} parent element to append UI controls to. jQuery Object, selector or HTMLElement. Otherwise, adds controls after element.
        min         : 40,              // {Number} Minimum width/height of selection
        selection   : null             // {Object} Set an initial selection area and shape.
    };

    ImageSelection.prototype.init = function (options) {
        this.options = $.extend({}, this.defaults, options);

        this.matrix = get2by2MatrixFromElement(this.$element);

        this.canvas = this.options.canvas || this.canvas || {
            top    : 0,
            left   : 0,
            width  : this.$element.width(),
            height : this.$element.height()
        };

        this.readSelectionFromOptions();
        this.readAspectRatioFromOptions();

        moveSelectionIntoCanvas(this.selection, this.canvas, this.min, this.aspectRatio);
    };

    ImageSelection.prototype.readSelectionFromOptions = function () {
        if ($.inArray(this.options.shape, SUPPORTED_SHAPES) === -1) {
            this.shape = SUPPORTED_SHAPES[0];
        }
        else {
            this.shape = this.options.shape;
        }

        var sel = this.options.selection;

        if (sel && isN(sel.top) && isN(sel.height) && isN(sel.left) && isN(sel.width)) {
            this.selection = {
                top    : parseInt(sel.top, 10),
                left   : parseInt(sel.left, 10),
                width  : parseInt(sel.width, 10),
                height : parseInt(sel.height, 10)
            };
        }
        else {
            this.selection = this.selection || {
                top    : this.canvas.top  + 50,
                left   : this.canvas.left + 50,
                width  : this.canvas.width  - 100,
                height : this.canvas.height - 100
            };
        }
    };

    ImageSelection.prototype.readAspectRatioFromOptions = function () {
        var MIN_SIZE = this.options.min;

        if (this.options.aspectRatio) {
            this.aspectRatio = parseFloat(this.options.aspectRatio);
        }
        if (!this.aspectRatio) { // includes NaN and undefined, also 0, but who cares
            this.aspectRatio = 0;
        }
        this.fixedAspectRatio = (this.aspectRatio !== 0);

        if (this.fixedAspectRatio) {
            if (this.aspectRatio > 1) {
                this.min = {
                    width : MIN_SIZE,
                    height: MIN_SIZE * this.aspectRatio
                };
            }
            else {
                this.min = {
                    width : MIN_SIZE / this.aspectRatio,
                    height: MIN_SIZE
                };
            }
        }
        else {
            this.min = {
                width : MIN_SIZE,
                height: MIN_SIZE
            };
        }
    };

    ImageSelection.prototype.cssClass = function (name) {
        return this.options.classPrefix + name;
    };

    ImageSelection.prototype.createDiv = function (name) {
        return $('<div>').addClass(this.cssClass(name));
    };

    ImageSelection.prototype.buildUI = function () {
        this.$holder = this.createDiv('holder').css({
            width  : this.$element.width(),
            height : this.$element.height()
        }).addClass(this.cssClass(this.shape));

        this.$backdrop = this.createDiv('backdrop').css({
            width  : this.canvas.width,
            height : this.canvas.height,
            top    : this.canvas.top,
            left   : this.canvas.left
        });
        this.$holder.append(this.$backdrop);


        this.$selection = this.createDiv('selection');
        this.$holder.append(this.$selection);

        this.handleDragging(this.$selection, this.handleCenter);


        if (this.shape === 'rectangle') {
            // Add Guidelines
            var verticalGuideline = this.createDiv('guideline').
                    addClass(this.cssClass('guideline-vertical'));
            this.$selection.append(verticalGuideline);

            var horizontalGuideline = this.createDiv('guideline').
                    addClass(this.cssClass('guideline-horizontal'));
            this.$selection.append(horizontalGuideline);

            if (!this.fixedAspectRatio) {
                this.createHandle({top : '0',    left : '50%' }, this.handleTop);
                this.createHandle({top : '50%',  left : '100%'}, this.handleRight);
                this.createHandle({top : '100%', left : '50%' }, this.handleBottom);
                this.createHandle({top : '50%',  left : '0'   }, this.handleLeft);
            }
            this.createHandle({top : '0',    left : '100%'}, this.handleTopRight);
            this.createHandle({top : '100%', left : '100%'}, this.handleBottomRight);
            this.createHandle({top : '100%', left : '0'   }, this.handleBottomLeft);
            this.createHandle({top : '0',    left : '0'   }, this.handleTopLeft);
        }
        else if (this.shape === 'ellipse') {
            this.createHandle({top : '86%', left : '86%'}, this.handleBottomRight);
        }

        this.updateUI(false);

        if (this.options.parent) {
            $(this.options.parent).append(this.$holder);
        }
        else {
            this.$element.after(this.$holder);
        }

        this.repositionUI();
        if (this.options.applyTransformations) {
            this.applyTransformationsToUI();
        }

        this.$element.trigger(EVENT.OPEN, this);

        this.$backdrop.on(EVENT.CLICK, preventDefaultAndPropagation);
        this.$selection.on(EVENT.CLICK, this, preventDefaultAndPropagation);
        $(window).on(EVENT.RESIZE, this, this.repositionUI);
    };

    ImageSelection.prototype.repositionUI = function (e) {
        var self = e ? e.data : this;

        self.$holder.position({of: self.$element, at: 'center', my: 'center'});
    };

    ImageSelection.prototype.applyTransformationsToUI = function (e) {
        var normalizedTransform = normalizeMatrixForChrome(this.$element.css('transform'));
        this.$holder.css({
            'transform'         : normalizedTransform,
            '-webkit-transform' : normalizedTransform
        });

        // Apply margin to position correctly on rotated images
        if (applyMatrixToCoordinates(this.matrix, {x: 1, y: 0}).x === 0) {

            var diff = (this.$element.width() - this.$element.height()) / 2;

            this.$holder.css({
                'margin-top'    : + diff,
                'margin-right'  : - diff,
                'margin-bottom' : + diff,
                'margin-left'   : - diff
            });
        }
    };

    ImageSelection.prototype.ensureSelectionIsInReasonableBounds = function (selection) {
        selection.width  = Math.max(this.min.width, selection.width);
        selection.width  = Math.min(this.canvas.width, selection.width);

        selection.height = Math.max(this.min.height, selection.height);
        selection.height = Math.min(this.canvas.height, selection.height);

        selection.top    = Math.max(this.canvas.top, selection.top);
        selection.top    = Math.min((this.canvas.top + this.canvas.height) - selection.height, selection.top);

        selection.left   = Math.max(this.canvas.left, selection.left);
        selection.left   = Math.min((this.canvas.left + this.canvas.width) - selection.width, selection.left);
    };

    ImageSelection.prototype.enforceAspectRatio = function (selection, fixer) {
        if (!this.fixedAspectRatio) {
            return selection;
        }

        if (selection.height > Math.round(selection.width * this.aspectRatio)) {
            selection.height = Math.floor(selection.width * this.aspectRatio);
        }
        else {
            selection.width = Math.floor(selection.height / this.aspectRatio);
        }

        if (fixer) {
            fixer.call(this);
        }

        return selection;
    };

    ImageSelection.prototype.updateUI = function (notify) {
        if (
                this.previousSelection &&
                this.previousSelection.top    === this.selection.top &&
                this.previousSelection.left   === this.selection.left &&
                this.previousSelection.width  === this.selection.width &&
                this.previousSelection.height === this.selection.height
            ) {
            // Avoid repositioning if nothing happened
            return;
        }

        if (this.$backdrop) {
            this.$backdrop.css({
                'border-top-width'    : this.selection.top - this.canvas.top,
                'border-right-width'  : (this.canvas.left + this.canvas.width) - (this.selection.left + this.selection.width),
                'border-bottom-width' : (this.canvas.top + this.canvas.height) - (this.selection.top + this.selection.height),
                'border-left-width'   : this.selection.left - this.canvas.left
            });
        }

        if (this.$selection) {
            this.$selection.css({
                'top'    : this.selection.top  - SELECTION_BORDER + 'px',
                'left'   : this.selection.left - SELECTION_BORDER + 'px',
                'width'  : this.selection.width + 'px',
                'height' : this.selection.height + 'px'
            });
        }

        this.previousSelection = $.extend({}, this.selection);

        if (notify !== false) {
            // Notify consumers about our updated selection
            this.$element.trigger(EVENT.UPDATE, this.getSelection());
        }
    };

    ImageSelection.prototype.createHandle = function (css, handler) {
        var handle = this.createDiv('handle').css(css);

        this.$selection.append(handle);
        this.handleDragging(handle, handler);
    };

    ImageSelection.prototype.handleDragging = function (element, handler) {
        var self = this;

        element.on(EVENT.MOUSEDOWN, function (e) {
            if (e.which !== 1 /* LEFT CLICK */ && e.which !== 0 /* TOUCH */) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();

            var memo = {},
                baseEventCoords = _getEventCoordinates(e),
                baseSelection = $.extend({}, self.selection);

            $('body')
                .on(EVENT.MOUSEMOVE, function (e) {
                    // prevent default - mainly to avoid scroll, which would happen
                    // on touch devices
                    e.preventDefault();

                    var currEventCoords = _getEventCoordinates(e);

                    memo.x = currEventCoords.x - baseEventCoords.x;
                    memo.y = currEventCoords.y - baseEventCoords.y;

                    // Use timeout to avoid too many UI updates
                    if (!memo.timeout) {
                        memo.timeout = setTimeout(function () {
                            delete memo.timeout;
                            memo.moved = true;
                            self.handleDrag(
                                applyMatrixToCoordinates(self.matrix, memo),
                                baseSelection,
                                handler);
                        }, UPDATE_INTERVAL);
                    }
                })
                .one(EVENT.MOUSEUP, function () {
                    $(this).off(EVENT.MOUSEMOVE)
                      // .one only to show intention. That alone doesn't work on touch devices because touch
                      // and mouse events are triggered and one will only delete one of them, leading to more than one execution.
                      // (mind that EVENT.MOUSEUP references more than one event. See definition).
                      .off(EVENT.MOUSEUP);

                    self.showAllHandles();

                    if (!memo.moved) {
                        self.$element.trigger(EVENT.SECOND_CLICK, self);
                    }
                });

            self.hideOtherHandles(element);
        });
    };

    ImageSelection.prototype.hideOtherHandles = function (handle) {
        this.$selection.find('.' + this.cssClass('handle')).
                        not(handle).addClass(this.cssClass('handle-other'));

        handle.addClass(this.cssClass('handle-selected'));
    };

    ImageSelection.prototype.showAllHandles = function () {
        this.$selection.find('.' + this.cssClass('handle')).
                        removeClass(this.cssClass('handle-other')).
                        removeClass(this.cssClass('handle-selected'));
    };


    ImageSelection.prototype.handleDrag = function (change, baseSelection, handler) {
        var selection = handler.call(this, change, baseSelection);

        if (selection) {
            // update selection
            this.selection.top    = Math.round(selection.top);
            this.selection.left   = Math.round(selection.left);
            this.selection.width  = Math.round(selection.width);
            this.selection.height = Math.round(selection.height);

            this.updateUI();
        }
    };

    ImageSelection.prototype.handleTop = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // move upper bar, change height, keep lower bar
        selection.top = selection.top + change.y;
        selection.top = Math.max(this.canvas.top, selection.top);
        selection.top = Math.min(baseSelection.top + baseSelection.height - this.min.height, selection.top);

        selection.height = baseSelection.top + selection.height - selection.top;

        return selection;
    };

    ImageSelection.prototype.handleTopRight = function (change, baseSelection) {
        var selection = this.handleTop(change, this.handleRight(change, baseSelection));

        this.enforceAspectRatio(selection, function () {
            selection.top = baseSelection.top - (selection.height - baseSelection.height);
        });

        return selection;
    };

    ImageSelection.prototype.handleRight = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // keep upper bar, change width, change lower bar
        selection.width = selection.width + change.x;
        selection.width = Math.max(this.min.width, selection.width);
        selection.width = Math.min((this.canvas.left + this.canvas.width) - baseSelection.left, selection.width);

        return selection;
    };

    ImageSelection.prototype.handleBottomRight = function (change, baseSelection) {
        var selection = this.handleBottom(change, this.handleRight(change, baseSelection));

        this.enforceAspectRatio(selection);

        return selection;
    };

    ImageSelection.prototype.handleBottom = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // keep upper bar, change height, change lower bar
        selection.height = selection.height + change.y;
        selection.height = Math.max(this.min.height, selection.height);
        selection.height = Math.min((this.canvas.top + this.canvas.height) - baseSelection.top, selection.height);

        return selection;
    };

    ImageSelection.prototype.handleBottomLeft = function (change, baseSelection) {
        var selection = this.handleBottom(change, this.handleLeft(change, baseSelection));

        this.enforceAspectRatio(selection, function () {
            selection.left = baseSelection.left - (selection.width - baseSelection.width);
        });

        return selection;
    };

    ImageSelection.prototype.handleLeft = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // move upper bar, change width, keep lower bar
        selection.left = selection.left + change.x;
        selection.left = Math.max(this.canvas.left, selection.left);
        selection.left = Math.min(baseSelection.left + baseSelection.width - this.min.width, selection.left);

        selection.width = baseSelection.left + selection.width - selection.left;

        return selection;
    };

    ImageSelection.prototype.handleTopLeft = function (change, baseSelection) {
        var selection = this.handleTop(change, this.handleLeft(change, baseSelection));

        this.enforceAspectRatio(selection, function () {
            selection.left = baseSelection.left - (selection.width - baseSelection.width);
            selection.top = baseSelection.top - (selection.height - baseSelection.height);
        });

        return selection;
    };

    ImageSelection.prototype.handleCenter = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // move upper bar, keep height, move lower bar
        selection.top = selection.top + change.y;
        selection.top = Math.max(this.canvas.top, selection.top);
        selection.top = Math.min((this.canvas.top + this.canvas.height) - baseSelection.height, selection.top);

        // move upper bar, keep width, move lower bar
        selection.left = selection.left + change.x;
        selection.left = Math.max(this.canvas.left, selection.left);
        selection.left = Math.min((this.canvas.left + this.canvas.width) - baseSelection.width, selection.left);

        return selection;
    };


    ImageSelection.prototype.destroyUI = function () {
        $(window).off(EVENT.RESIZE);

        if (this.$holder !== undefined) {
            this.$holder.off(EVENT.CLICK);
            this.$holder.remove();
        }

        delete this.$holder;
        delete this.$backdrop;
        delete this.$selection;
        delete this.previousSelection;
    };

    ImageSelection.prototype.open = function (options) {
        options = options || {};

        if (this.opened) {
            this.destroyUI();
        }

        this.init(options);
        this.buildUI();

        this.opened = true;
    };

    // Hide/Close the plugin, but keep it available for future use
    ImageSelection.prototype.close = function () {
        if (this.opened) {
            this.destroyUI();
            this.opened = false;
            this.$element.trigger(EVENT.CLOSE, this);
        }
    };

    // Permanentely remove the plugin
    ImageSelection.prototype.destroy = function () {
        this.close();
        this.$element.data('image-select', null);
    };

    ImageSelection.prototype.getSelection = function () {
        return {
            // corner coordinates
            top         : this.selection.top,
            left        : this.selection.left,

            // dimensions
            width       : this.selection.width,
            height      : this.selection.height
        };
    };

    var ctor = function (options) {
        options = options || {};
        this.each(function () {
            var el = $(this), instance = el.data('image-select');

            if (options.call) {
                if (instance) {
                    instance[options.call].call(instance, options);
                }
            }
            else if (!instance) {
                instance = new ImageSelection(el, options);
                el.data('image-select', instance);
            }
            else {
                instance.open(options);
            }
        });

        if (options && options.instance) {
            return this.eq(0).data('image-select');
        }
        else {
            return this;
        }
    };

    ctor.moveSelectionIntoCanvas = moveSelectionIntoCanvas;

    return ctor;
})(jQuery);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* jshint eqeqeq: true, immed: true, latedef: true, newcap: true, noarg: true,
          sub: true, undef: true, boss: true, eqnull: true, browser: true,
          smarttabs: true */
/* global jQuery */
jQuery.fn.imageSelectPolygon = (function ($) {
    'use strict';

    var EVENT = {
        NAMESPACE : '.imageSelect'
    };

    // Events that are consumed
    EVENT.CLICK  = 'click'              + EVENT.NAMESPACE;
    EVENT.RESIZE = 'resize'             + EVENT.NAMESPACE;

    EVENT.MOUSEDOWN = 'touchstart'  + EVENT.NAMESPACE + ' ' +
                      'mousedown'   + EVENT.NAMESPACE;
    EVENT.MOUSEUP   = 'touchend'    + EVENT.NAMESPACE + ' ' +
                      'touchcancel' + EVENT.NAMESPACE + ' ' +
                      'mouseup'     + EVENT.NAMESPACE;
    EVENT.MOUSEMOVE = 'touchmove'   + EVENT.NAMESPACE + ' ' +
                      'mousemove'   + EVENT.NAMESPACE;

    // Events that are emitted
    EVENT.OPEN   = 'open';
    EVENT.CLOSE  = 'close';
    EVENT.UPDATE = 'update';
    EVENT.SECOND_CLICK = 'second_click';
    EVENT.DESELECT_CLICK = 'deselect_click';

    var IGNORE_EMULATED_CLICKS_TIME_MS = 20;

    var SELECTION_BORDER = 2, // see CSS rule .image-select-selection
        UPDATE_INTERVAL = 50,
        SUPPORTED_SHAPES = ['polygon'];


    var isN = function (n) {
        return !isNaN(n);
    };

    var preventDefaultAndPropagation = function (e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
    };

    /**
     * Gets page coordinates of event. Touch event coordinates returned if available.
     * @param {Object} e the event
     * @returns {{x: (Number), y: (Number)}} Page coordinates X and Y
     * @private
     */
    var _getEventCoordinates = function (e) {
        if (e.originalEvent.touches) {
            return { x : e.originalEvent.touches[0].pageX, y : e.originalEvent.touches[0].pageY };
        }
        else {
            return { x : e.pageX, y : e.pageY };
        }
    };

    /**
     * Copied from jquery-image-select.js - to make this independent of the other.
     */
    var moveSelectionIntoCanvas = function (selection, canvas, min, aspectRatio) {
        // Reduce dimension to be smaller or equal to canvas dimensions
        selection.width  = Math.min(canvas.width, selection.width);
        selection.height = Math.min(canvas.height, selection.height);

        if (typeof(min) !== 'undefined') {
          selection.width = Math.max(min.width, selection.width);
          selection.height = Math.max(min.height, selection.height);
        }

        // Fix aspect ratio
        if (typeof(aspectRatio) !== 'undefined' && aspectRatio !== 0) {
            if (selection.height > Math.round(selection.width * aspectRatio)) {
                selection.height = Math.floor(selection.width * aspectRatio);
            }
            else {
                selection.width = Math.floor(selection.height / aspectRatio);
            }
        }

        // Move selection away from edge, until it is inside canvas
        selection.left = Math.max(canvas.left, selection.left);
        selection.left = Math.min(canvas.left + canvas.width - selection.width,
                                  selection.left);
        selection.top = Math.max(canvas.top, selection.top);
        selection.top = Math.min(canvas.top + canvas.height - selection.height,
                                 selection.top);

        return selection;
    };

    // matrix may contain scientific floats on chrome, which chrome doesn't accept, example: 'matrix(6.12323399573677e-17, 1, -1, 6.12323399573677e-17, 0, 0)'
    var MATRIX   = /matrix\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 6 numbers
        MATRIX3D = /matrix3d\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 16 numbers
        i = function (s) {
          var number = parseFloat(s);
          if (isNaN(number)) {
            throw new Error('Number is not a float');
          }
          return Math.round(number);
        };

    var get2by2MatrixFromElement = function (element) {
        var matrixStr = $(element).css('transform'),
            match;

        try {
          match = matrixStr.match(MATRIX);
          if (match) {
              /**
               * TODO: Find out why this is not the way, I would expect it to be.
               *
               * Based on documentation and my understanding, the matrix should be
               *
               *     i(match[1]) i(match[3])
               *     i(match[2]) i(match[4])
               *
               * This would also be similar to the 3d version below.
               *
               * BUT, it does not yield the expected results. Instead the
               * following one works just as desired. Therefore I am using that
               * one -- although I do not know why.
               */
              return [
                  [i(match[1]), i(match[2])],
                  [i(match[3]), i(match[4])]
              ];
          }

          match = matrixStr.match(MATRIX3D);
          if (match) {
              return [
                  [i(match[1]), i(match[5])],
                  [i(match[2]), i(match[6])]
              ];
          }
          else if (matrixStr === 'none') {
              return [
                  [1, 0],
                  [0, 1]
              ];
          }
        } catch (e) {
          // logged below
        }

        if (window.console && window.console.log) {
            window.console.log('ImageEditor: Could not parse matrix string', matrixStr);
        }

        return [
            [1, 0],
            [0, 1]
        ];
    };
    var applyMatrixToCoordinates = function (matrix, point) {
        if (matrix.length !== 2 ||
            matrix[0].length !== 2 ||
            matrix[1].length !== 2) {
            throw new Error('Expecting 2x2 matrix');
        }
        if (point.x === undefined || point.y === undefined) {
            throw new Error('Expecting point to be object like {x: 0, y: 0}');
        }

        return $.extend({}, point, {
            x : point.x * matrix[0][0] + point.y * matrix[0][1],
            y : point.x * matrix[1][0] + point.y * matrix[1][1]
        });
    };
    // chrome returns currently (v38) scientific notation for very small numbers, but doesn't accept it. So nullify this.
    var normalizeMatrixForChrome = function (matrixStr) {
      try {
        var outerMatch = matrixStr.match(/matrix\(([^)]+)\)/);
        if (outerMatch) {
          var inner = outerMatch[1];
          var numbers = inner.split(/, ?/);
          var normalizedNumbers = [];
          for (var i = 0; i < numbers.length; i++) {
            var current = numbers[i];
            if (current.indexOf('e') > -1 || current.indexOf('E') > -1) {
              var parsed = parseFloat(current);
              if (isNaN(parsed)) {
                throw new Error('Not a number: \'' + current + '\'');
              }

              normalizedNumbers.push('' + parsed.toFixed(19)); // toFixed limited to 20

            } else {
              normalizedNumbers.push(current);
            }
          }
          return 'matrix(' + normalizedNumbers.join(', ') + ')';
        }

      } catch (e) {
        // ignored
      }

      return matrixStr;
    };


    var ImageSelection = function ($element, options) {
        this.$element = $element;

        this.open(options);
    };

    ImageSelection.prototype.defaults = {
        classPrefix : 'image-select-', // {String} The prefix for css classes applied to UI elements.
        parent      : null,            // {Mixed} parent element to append UI controls to. jQuery Object, selector or HTMLElement. Otherwise, adds controls after element.
        min         : 40,              // {Number} Minimum width/height of selection
        points      : []               // {Array} of {w:int, h:int} for the polygon
    };

    ImageSelection.prototype.init = function (options) {
        this._ignoreHolderClickUntil = null;
        this.distanceFromLineForAddPointDetection = 10;
        this.options = $.extend({}, this.defaults, options);

        this.matrix = get2by2MatrixFromElement(this.$element);

        this.canvas = this.options.canvas || this.canvas || {
            top    : 0,
            left   : 0,
            width  : this.$element.width(),
            height : this.$element.height()
        };

        this.readSelectionFromOptions();

    };

    ImageSelection.prototype.readSelectionFromOptions = function () {
        if ($.inArray(this.options.shape, SUPPORTED_SHAPES) === -1) {
            this.shape = SUPPORTED_SHAPES[0];
        }
        else {
            this.shape = this.options.shape;
        }

        var points = this.readPoints(this.options.points);

        if (points && points.length) {
            this.points = points;
        }
        else {
            this.points = this.points || [
              {
                w: this.canvas.left + Math.round(this.canvas.width*0.5),
                h: this.canvas.top + Math.round(this.canvas.height*1.0/3)
              },
              {
                w: this.canvas.left + Math.round(this.canvas.width*2.0/3),
                h: this.canvas.top + Math.round(this.canvas.height*2.0/3)
              },
              {
                w: this.canvas.left + Math.round(this.canvas.width*1.0/3),
                h: this.canvas.top + Math.round(this.canvas.height*2.0/3)
              }
            ];
        }
    };

    ImageSelection.prototype.readPoints = function (rawPoints) {
      var result = [], i, point, parsed;

      if (rawPoints && rawPoints.length) {
        for (i = 0; i < rawPoints.length; i++) {
          point = rawPoints[i];
          if (isN(point.w) && isN(point.h)) {
            parsed = {
              w: parseInt(point.w, 10),
              h: parseInt(point.h, 10)
            };
            result.push(parsed);
          }
        }
      }
      return result;
    };

    ImageSelection.prototype.cssClass = function (name) {
        return this.options.classPrefix + name;
    };

    ImageSelection.prototype.createDiv = function (name) {
        return $('<div>').addClass(this.cssClass(name));
    };

    ImageSelection.prototype.buildUI = function () {
        var self = this,
          helperGhost = this.createDiv('polygon-helper').css({
          });

        this.$holder = this.createDiv('holder').css({
            width  : this.$element.width(),
            height : this.$element.height()
        }).addClass(this.cssClass(this.shape));

        // ghost used to get certain css values/colors used during canvas painting
        this.$holder.append(helperGhost);

        this.$drawCanvas = $('<canvas/>').css({
            width  : this.canvas.width + 'px',
            height : this.canvas.height + 'px',
            top    : this.canvas.top,
            left   : this.canvas.left
        });
        this.$drawCanvas[0].height = this.canvas.height;
        this.$drawCanvas[0].width = this.canvas.width;
        this.$holder.append(this.$drawCanvas);
        this.polygonTool = this.$drawCanvas.polygon().data('polygon');


        this.movePolygonIntoCanvas();
        this.updateUI(false);

        if (this.options.parent) {
            $(this.options.parent).append(this.$holder);
        }
        else {
            this.$element.after(this.$holder);
        }

        // install listeners after attachment to DOM
        this.handleDragging(this.$drawCanvas, function (change, basePoints) {
          self.updatePoints(change, basePoints);
        });

        this.$holder.on('click', function (e) {
          if (self._ignoreHolderClickUntil && new Date().getTime() <= self._ignoreHolderClickUntil) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            self._ignoreHolderClickUntil = null;
          }
        });

        this.repositionUI();
        if (this.options.applyTransformations) {
            this.applyTransformationsToUI();
        }

        this.$element.trigger(EVENT.OPEN, this);

        $(window).on(EVENT.RESIZE, this, this.repositionUI);
    };

    ImageSelection.prototype.repositionUI = function (e) {
        var self = e ? e.data : this;

        self.$holder.position({of: self.$element, at: 'center', my: 'center'});
    };

    ImageSelection.prototype.applyTransformationsToUI = function (e) {
        var normalizedTransform = normalizeMatrixForChrome(this.$element.css('transform'));
        this.$holder.css({
            'transform'         : normalizedTransform,
            '-webkit-transform' : normalizedTransform
        });

        // Apply margin to position correctly on rotated images
        if (applyMatrixToCoordinates(this.matrix, {x: 1, y: 0}).x === 0) {

            var diff = (this.$element.width() - this.$element.height()) / 2;

            this.$holder.css({
                'margin-top'    : + diff,
                'margin-right'  : - diff,
                'margin-bottom' : + diff,
                'margin-left'   : - diff
            });
        }
    };

    ImageSelection.prototype.ensureSelectionIsInReasonableBounds = function (selection) {
        selection.width  = Math.max(this.min.width, selection.width);
        selection.width  = Math.min(this.canvas.width, selection.width);

        selection.height = Math.max(this.min.height, selection.height);
        selection.height = Math.min(this.canvas.height, selection.height);

        selection.top    = Math.max(this.canvas.top, selection.top);
        selection.top    = Math.min((this.canvas.top + this.canvas.height) - selection.height, selection.top);

        selection.left   = Math.max(this.canvas.left, selection.left);
        selection.left   = Math.min((this.canvas.left + this.canvas.width) - selection.width, selection.left);
    };

    ImageSelection.prototype.updateUI = function (notify) {
      if (!this.$holder) {
        // happens on IE9, ui already gone
        return;
      }
      var self = this, i, notifyCopy = notify,
        $polygonHelper = this.$holder.find('.' + this.cssClass('polygon-helper')),
        borderWidthCss = $polygonHelper.css('border-top-width'), borderWidth = null;
      // TODO update the other parts of the UI (before backdrop border was resized here)

      borderWidth = $('<div/>', {width: borderWidthCss}).width(); // conversion: .width() always returns pixel value

      var polygonOptions = {
        strokeStyle: $polygonHelper.css('border-top-color'),
        fillStyle: $polygonHelper.css('background-color'),
        lineWidth: borderWidth
      };

      if (borderWidth == null || borderWidth < 1) {
        // need a re-update, elements not yet styled, so attach them safely to DOM first
        notify = false;
        setTimeout(function () {
          self.updateUI(notifyCopy);
        }, 10);
      }

      this.polygonTool.clearCanvas();
      this.polygonTool.paintPolygonWithPoints(this.$drawCanvas, this.points, polygonOptions);

      // only repaint handles if necessary - important to allow dragging to work
      if (this.points.length !== this.getAllHandles().length) {
        this.removeAllHandles();
        if (this.points && this.points.length) {
          for (i = 0; i < this.points.length; i++) {
            this.createHandle(i);
          }
        }
      }

      if (notify !== false) {
          // Notify consumers about our updated selection
          // FIXME send complete shape selection with getSelection()
          this.$element.trigger(EVENT.UPDATE, this.points);
      }
    };

    ImageSelection.prototype.createHandle = function (pointIndex) {
        var handle, self = this,
          originalPoint = this.points[pointIndex];

        handle = this.createDiv('handle').css({top: originalPoint.h, left: originalPoint.w});

        this.$holder.append(handle);
        this.handleDragging(handle, function (change, basePoints) {
          self.updatePoint(change, basePoints, pointIndex);
        });
    };

    ImageSelection.prototype.removeAllHandles = function () {
        this.getAllHandles().remove();
    };

    ImageSelection.prototype.getAllHandles = function () {
      return this.$holder.find('.' + this.cssClass('handle'));
    };

    ImageSelection.prototype.isHandleOrHasHandleParent = function (el) {
      var cssClass = this.cssClass('handle'),
        $el = $(el);
      return $el.hasClass(cssClass) ||
        $el.parents('.' + cssClass).length > 0;
    };

    ImageSelection.prototype.handleDragging = function (element, handler) {
        var self = this;

        element.on(EVENT.MOUSEDOWN, function (e) {
            if (e.which !== 1 /* LEFT CLICK */ && e.which !== 0 /* TOUCH */) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            var memo = {},
                baseEventCoords = _getEventCoordinates(e),
                basePoints = self.points.slice(),
                isStartedOnHandle = self.isHandleOrHasHandleParent(e.target),
                isStartedOnPolygon = self.isPageCoordsOnPolygon(baseEventCoords);

            if (isStartedOnHandle || isStartedOnPolygon) {
              $('body')
                .on(EVENT.MOUSEMOVE, function (e) {
                    // prevent default - mainly to avoid scroll, which would happen
                    // on touch devices
                    e.preventDefault();

                    var currEventCoords = _getEventCoordinates(e);

                    memo.x = currEventCoords.x - baseEventCoords.x;
                    memo.y = currEventCoords.y - baseEventCoords.y;

                    // Use timeout to avoid too many UI updates
                    if (!memo.timeout) {
                        memo.timeout = setTimeout(function () {
                            delete memo.timeout;
                            memo.moved = true;
                            self.handleDrag(
                                applyMatrixToCoordinates(self.matrix, memo),
                                basePoints,
                                handler);
                        }, UPDATE_INTERVAL);
                    }
                });
            }
            $('body')
                .one(EVENT.MOUSEUP, function (e) {
                    var closestLineSegmentResult;
                    $(this).off(EVENT.MOUSEMOVE)
                      // .one only to show intention. That alone doesn't work on touch devices because touch
                      // and mouse events are triggered and one will only delete one of them, leading to more than one execution.
                      // (mind that EVENT.MOUSEUP references more than one event. See definition).
                      .off(EVENT.MOUSEUP);

                    // ios has no pageX/Y on touchend
                    if (typeof(e.pageX) === 'undefined') {
                      e.pageX = baseEventCoords.x;
                      e.pageY = baseEventCoords.y;
                    }

                    self.showAllHandles();

                    if (!memo.moved) {
                      if (isStartedOnHandle) {
                        self.$element.trigger(EVENT.SECOND_CLICK, self);
                      } else {
                        closestLineSegmentResult = self.getClosestLineSegmentResult(self.pageToRelative(e.pageX, e.pageY));
                        if (closestLineSegmentResult && closestLineSegmentResult.distance < self.distanceFromLineForAddPointDetection) {
                          self.addPoint(closestLineSegmentResult.projection, closestLineSegmentResult.line);
                          self.updateUI();
                        } else {
                          if (isStartedOnPolygon) {
                            self.$element.trigger(EVENT.SECOND_CLICK, self);
                          } else {
                            self.$element.trigger($.Event(EVENT.DESELECT_CLICK, {
                              originalEvent: e,
                              pageX: e.pageX,
                              pageY: e.pageY
                            }));
                          }
                        }
                      }
                    }

                    // cannot prevent generation/emulation of click event (on chrome, safari), so:
                    self._ignoreHolderClickUntil = new Date().getTime() + IGNORE_EMULATED_CLICKS_TIME_MS;
                });

            self.hideOtherHandles(element);
        });
    };

    ImageSelection.prototype.hideOtherHandles = function (handle) {
        this.$holder.find('.' + this.cssClass('handle')).
                        not(handle).addClass(this.cssClass('handle-other'));

        handle.addClass(this.cssClass('handle-selected'));
    };

    ImageSelection.prototype.showAllHandles = function () {
        this.$holder.find('.' + this.cssClass('handle')).
                        removeClass(this.cssClass('handle-other')).
                        removeClass(this.cssClass('handle-selected'));
    };

    ImageSelection.prototype.handleDrag = function (change, basePoints, handler) {
        handler.call(this, change, basePoints);

        this.updateUI();
    };

    ImageSelection.prototype.pageToRelative = function (pageX, pageY) {
      var holderOffset = this.$holder.offset();

      return {
        w: pageX - holderOffset.left,
          h: pageY - holderOffset.top
      };
    };

    ImageSelection.prototype.vectorToPoint = function (pointAsVector) {
      return {
        w: pointAsVector[0],
        h: pointAsVector[1]
      };
    };

    ImageSelection.prototype.addPoint = function (pointAsVector, lineSegmentAsVectors) {
      var i, current, newPointPosition = null, next, previous,
        vectors = this.polygonTool.pointsToVectors(this.points),
        newPoint = this.vectorToPoint(pointAsVector) ;

      if (this.points.length < 2) {
        this.points.push(newPoint);
        return;
      }
      if (!lineSegmentAsVectors) {
        this.points.push(newPoint);
        return;
      }

      for (i = 0; i < vectors.length; i++) {
        current = vectors[i];
        if (this.polygonTool.vectorsEqual(current, lineSegmentAsVectors[0])) {

          // now it's either previous or next
          if (i === vectors.length - 1) {
            next = 0;
          } else {
            next = i + 1;
          }
          if (this.polygonTool.vectorsEqual(vectors[next], lineSegmentAsVectors[1])) {
            newPointPosition = next;
            break;
          }

          if (i === 0) {
            previous = vectors.length - 1;
          } else {
            previous = i - 1;
          }
          if (this.polygonTool.vectorsEqual(vectors[previous], lineSegmentAsVectors[1])) {
            newPointPosition = previous;
            break;
          }
        }
      }

      if (newPointPosition == null) {
        this.points.push(newPoint);
      } else {
        this.points.splice(next, 0, newPoint);
      }
    };

    ImageSelection.prototype.updatePoints = function (change, basePoints) {
      var i;
      for (i = 0; i<basePoints.length; i++) {
        this.updatePoint(change, basePoints, i);
      }
    };

    ImageSelection.prototype.updatePoint = function (change, basePoints, pointIndex) {
      var canvasPos = this.$drawCanvas.position(), point = basePoints[pointIndex],
        handle;

      if (point) {
        point = {
          w: Math.round(point.w + change.x),
          h: Math.round(point.h + change.y)
        };
        point.h = Math.max(canvasPos.top, point.h);
        point.h = Math.min(canvasPos.top + this.$drawCanvas.height(), point.h);
        point.w = Math.max(canvasPos.left, point.w);
        point.w = Math.min(canvasPos.left + this.$drawCanvas.width(), point.w);
        this.points[pointIndex] = point;

        handle = $(this.getAllHandles()[pointIndex]);
        handle.css({top: point.h, left: point.w});
      }
      return point;
    };

    ImageSelection.prototype.destroyUI = function () {
        $(window).off(EVENT.RESIZE);

        if (this.$holder !== undefined) {
            this.$holder.off(EVENT.CLICK);
            this.$holder.remove();
        }

        delete this.$holder;
        delete this.$drawCanvas;
        delete this.$selection;
    };

    ImageSelection.prototype.open = function (options) {
        options = options || {};

        if (this.opened) {
            this.destroyUI();
        }

        this.init(options);
        this.buildUI();

        this.opened = true;
    };

    // Hide/Close the plugin, but keep it available for future use
    ImageSelection.prototype.close = function () {
        if (this.opened) {
            this.destroyUI();
            this.opened = false;
            this.$element.trigger(EVENT.CLOSE, this);
        }
    };

    // Permanentely remove the plugin
    ImageSelection.prototype.destroy = function () {
        this.close();
        this.$element.data('image-select', null);
    };

    ImageSelection.prototype.getPoints = function () {
        return this.points.slice();
    };

    ImageSelection.prototype.getClosestLineSegmentResult = function (p) {
      var pAsVector = this.polygonTool.pointsToVectors(p),
        sortedSegments = this.polygonTool.filterLineSegmentsNextToPointAndSortByDistance(pAsVector,
        this.polygonTool.pointsToLineSegmentsWithVectors(this.points));

      if (sortedSegments.length) {
        return sortedSegments[0];
      }
      return null;
    };

    ImageSelection.prototype.isPageCoordsOnPolygon = function (point) {
      var holderRelativeCoords;
      if (typeof(point.x) !== 'undefined') {
        point = {
          w: point.x,
          h: point.y
        };
      }

      holderRelativeCoords = this.pageToRelative(point.w, point.h);

      return this.polygonTool.isPointInsideOrOnEdgeOfPolygon([holderRelativeCoords.w, holderRelativeCoords.h],
        this.polygonTool.pointsToVectors(this.points));
    };

    ImageSelection.prototype.getBoundingBox = function () {
      return this.polygonTool.getBoundingBox(this.points);
    };

    /**
     * Goal is to strive to keep the form of the polygon intact.
     * @returns {*}
     */
    ImageSelection.prototype.movePolygonIntoCanvas = function () {
      var boundingBox = this.polygonTool.getBoundingBox(this.points),
        movedBoundingBox = moveSelectionIntoCanvas($.extend({}, boundingBox), this.canvas),
        moveOffset = {
          left: movedBoundingBox.left - boundingBox.left,
          top: movedBoundingBox.top - boundingBox.top
        },
        scaleFactors = {
          width: movedBoundingBox.width/boundingBox.width,
          height: movedBoundingBox.height/boundingBox.height
        },
        i, point;

      for (i = 0; i < this.points.length; i++) {
        point = this.points[i];
        // Move polygon into canvas
        point.w = point.w + moveOffset.left;
        point.h = point.h + moveOffset.top;

        // scale it to fit
        point.w = movedBoundingBox.left + (point.w - movedBoundingBox.left)*scaleFactors.width;
        point.h = movedBoundingBox.top + (point.h - movedBoundingBox.top)*scaleFactors.height
      }

    };

    var ctor = function (options) {
        options = options || {};
        this.each(function () {
            var el = $(this), instance = el.data('image-select');

            if (options.call) {
                if (instance) {
                    instance[options.call].call(instance, options);
                }
            }
            else if (!instance) {
                instance = new ImageSelection(el, options);
                el.data('image-select', instance);
            }
            else {
                instance.open(options);
            }
        });

        if (options && options.instance) {
            return this.eq(0).data('image-select');
        }
        else {
            return this;
        }
    };

    return ctor;
})(jQuery);

/*!

 handlebars v1.3.0

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
/* exported Handlebars */
var Handlebars = (function() {
// handlebars/safe-string.js
var __module4__ = (function() {
  "use strict";
  var __exports__;
  // Build out our basic SafeString type
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = function() {
    return "" + this.string;
  };

  __exports__ = SafeString;
  return __exports__;
})();

// handlebars/utils.js
var __module3__ = (function(__dependency1__) {
  "use strict";
  var __exports__ = {};
  /*jshint -W004 */
  var SafeString = __dependency1__;

  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr] || "&amp;";
  }

  function extend(obj, value) {
    for(var key in value) {
      if(Object.prototype.hasOwnProperty.call(value, key)) {
        obj[key] = value[key];
      }
    }
  }

  __exports__.extend = extend;var toString = Object.prototype.toString;
  __exports__.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  var isFunction = function(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  __exports__.isFunction = isFunction;
  var isArray = Array.isArray || function(value) {
    return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
  };
  __exports__.isArray = isArray;

  function escapeExpression(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof SafeString) {
      return string.toString();
    } else if (!string && string !== 0) {
      return "";
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!possible.test(string)) { return string; }
    return string.replace(badChars, escapeChar);
  }

  __exports__.escapeExpression = escapeExpression;function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  __exports__.isEmpty = isEmpty;
  return __exports__;
})(__module4__);

// handlebars/exception.js
var __module5__ = (function() {
  "use strict";
  var __exports__;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var line;
    if (node && node.firstLine) {
      line = node.firstLine;

      message += ' - ' + line + ':' + node.firstColumn;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    if (line) {
      this.lineNumber = line;
      this.column = node.firstColumn;
    }
  }

  Exception.prototype = new Error();

  __exports__ = Exception;
  return __exports__;
})();

// handlebars/base.js
var __module2__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;

  var VERSION = "1.3.0";
  __exports__.VERSION = VERSION;var COMPILER_REVISION = 4;
  __exports__.COMPILER_REVISION = COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '>= 1.0.0'
  };
  __exports__.REVISION_CHANGES = REVISION_CHANGES;
  var isArray = Utils.isArray,
      isFunction = Utils.isFunction,
      toString = Utils.toString,
      objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials) {
    this.helpers = helpers || {};
    this.partials = partials || {};

    registerDefaultHelpers(this);
  }

  __exports__.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: logger,
    log: log,

    registerHelper: function(name, fn, inverse) {
      if (toString.call(name) === objectType) {
        if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
        Utils.extend(this.helpers, name);
      } else {
        if (inverse) { fn.not = inverse; }
        this.helpers[name] = fn;
      }
    },

    registerPartial: function(name, str) {
      if (toString.call(name) === objectType) {
        Utils.extend(this.partials,  name);
      } else {
        this.partials[name] = str;
      }
    }
  };

  function registerDefaultHelpers(instance) {
    instance.registerHelper('helperMissing', function(arg) {
      if(arguments.length === 2) {
        return undefined;
      } else {
        throw new Exception("Missing helper: '" + arg + "'");
      }
    });

    instance.registerHelper('blockHelperMissing', function(context, options) {
      var inverse = options.inverse || function() {}, fn = options.fn;

      if (isFunction(context)) { context = context.call(this); }

      if(context === true) {
        return fn(this);
      } else if(context === false || context == null) {
        return inverse(this);
      } else if (isArray(context)) {
        if(context.length > 0) {
          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        return fn(context);
      }
    });

    instance.registerHelper('each', function(context, options) {
      var fn = options.fn, inverse = options.inverse;
      var i = 0, ret = "", data;

      if (isFunction(context)) { context = context.call(this); }

      if (options.data) {
        data = createFrame(options.data);
      }

      if(context && typeof context === 'object') {
        if (isArray(context)) {
          for(var j = context.length; i<j; i++) {
            if (data) {
              data.index = i;
              data.first = (i === 0);
              data.last  = (i === (context.length-1));
            }
            ret = ret + fn(context[i], { data: data });
          }
        } else {
          for(var key in context) {
            if(context.hasOwnProperty(key)) {
              if(data) { 
                data.key = key; 
                data.index = i;
                data.first = (i === 0);
              }
              ret = ret + fn(context[key], {data: data});
              i++;
            }
          }
        }
      }

      if(i === 0){
        ret = inverse(this);
      }

      return ret;
    });

    instance.registerHelper('if', function(conditional, options) {
      if (isFunction(conditional)) { conditional = conditional.call(this); }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function(conditional, options) {
      return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
    });

    instance.registerHelper('with', function(context, options) {
      if (isFunction(context)) { context = context.call(this); }

      if (!Utils.isEmpty(context)) return options.fn(context);
    });

    instance.registerHelper('log', function(context, options) {
      var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
      instance.log(level, context);
    });
  }

  var logger = {
    methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

    // State enum
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 3,

    // can be overridden in the host environment
    log: function(level, obj) {
      if (logger.level <= level) {
        var method = logger.methodMap[level];
        if (typeof console !== 'undefined' && console[method]) {
          console[method].call(console, obj);
        }
      }
    }
  };
  __exports__.logger = logger;
  function log(level, obj) { logger.log(level, obj); }

  __exports__.log = log;var createFrame = function(object) {
    var obj = {};
    Utils.extend(obj, object);
    return obj;
  };
  __exports__.createFrame = createFrame;
  return __exports__;
})(__module3__, __module5__);

// handlebars/runtime.js
var __module6__ = (function(__dependency1__, __dependency2__, __dependency3__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;
  var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = COMPILER_REVISION;

    if (compilerRevision !== currentRevision) {
      if (compilerRevision < currentRevision) {
        var runtimeVersions = REVISION_CHANGES[currentRevision],
            compilerVersions = REVISION_CHANGES[compilerRevision];
        throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
              "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
      } else {
        // Use the embedded version info since the runtime doesn't know about this revision yet
        throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
              "Please update your runtime to a newer version ("+compilerInfo[1]+").");
      }
    }
  }

  __exports__.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

  function template(templateSpec, env) {
    if (!env) {
      throw new Exception("No environment passed to template");
    }

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as psuedo-supported APIs.
    var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
      var result = env.VM.invokePartial.apply(this, arguments);
      if (result != null) { return result; }

      if (env.compile) {
        var options = { helpers: helpers, partials: partials, data: data };
        partials[name] = env.compile(partial, { data: data !== undefined }, env);
        return partials[name](context, options);
      } else {
        throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
      }
    };

    // Just add water
    var container = {
      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,
      programs: [],
      program: function(i, fn, data) {
        var programWrapper = this.programs[i];
        if(data) {
          programWrapper = program(i, fn, data);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = program(i, fn);
        }
        return programWrapper;
      },
      merge: function(param, common) {
        var ret = param || common;

        if (param && common && (param !== common)) {
          ret = {};
          Utils.extend(ret, common);
          Utils.extend(ret, param);
        }
        return ret;
      },
      programWithDepth: env.VM.programWithDepth,
      noop: env.VM.noop,
      compilerInfo: null
    };

    return function(context, options) {
      options = options || {};
      var namespace = options.partial ? options : env,
          helpers,
          partials;

      if (!options.partial) {
        helpers = options.helpers;
        partials = options.partials;
      }
      var result = templateSpec.call(
            container,
            namespace, context,
            helpers,
            partials,
            options.data);

      if (!options.partial) {
        env.VM.checkRevision(container.compilerInfo);
      }

      return result;
    };
  }

  __exports__.template = template;function programWithDepth(i, fn, data /*, $depth */) {
    var args = Array.prototype.slice.call(arguments, 3);

    var prog = function(context, options) {
      options = options || {};

      return fn.apply(this, [context, options.data || data].concat(args));
    };
    prog.program = i;
    prog.depth = args.length;
    return prog;
  }

  __exports__.programWithDepth = programWithDepth;function program(i, fn, data) {
    var prog = function(context, options) {
      options = options || {};

      return fn(context, options.data || data);
    };
    prog.program = i;
    prog.depth = 0;
    return prog;
  }

  __exports__.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
    var options = { partial: true, helpers: helpers, partials: partials, data: data };

    if(partial === undefined) {
      throw new Exception("The partial " + name + " could not be found");
    } else if(partial instanceof Function) {
      return partial(context, options);
    }
  }

  __exports__.invokePartial = invokePartial;function noop() { return ""; }

  __exports__.noop = noop;
  return __exports__;
})(__module3__, __module5__, __module2__);

// handlebars.runtime.js
var __module1__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var base = __dependency1__;

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)
  var SafeString = __dependency2__;
  var Exception = __dependency3__;
  var Utils = __dependency4__;
  var runtime = __dependency5__;

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  var create = function() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = SafeString;
    hb.Exception = Exception;
    hb.Utils = Utils;

    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };

    return hb;
  };

  var Handlebars = create();
  Handlebars.create = create;

  __exports__ = Handlebars;
  return __exports__;
})(__module2__, __module4__, __module5__, __module3__, __module6__);

// handlebars/compiler/ast.js
var __module7__ = (function(__dependency1__) {
  "use strict";
  var __exports__;
  var Exception = __dependency1__;

  function LocationInfo(locInfo){
    locInfo = locInfo || {};
    this.firstLine   = locInfo.first_line;
    this.firstColumn = locInfo.first_column;
    this.lastColumn  = locInfo.last_column;
    this.lastLine    = locInfo.last_line;
  }

  var AST = {
    ProgramNode: function(statements, inverseStrip, inverse, locInfo) {
      var inverseLocationInfo, firstInverseNode;
      if (arguments.length === 3) {
        locInfo = inverse;
        inverse = null;
      } else if (arguments.length === 2) {
        locInfo = inverseStrip;
        inverseStrip = null;
      }

      LocationInfo.call(this, locInfo);
      this.type = "program";
      this.statements = statements;
      this.strip = {};

      if(inverse) {
        firstInverseNode = inverse[0];
        if (firstInverseNode) {
          inverseLocationInfo = {
            first_line: firstInverseNode.firstLine,
            last_line: firstInverseNode.lastLine,
            last_column: firstInverseNode.lastColumn,
            first_column: firstInverseNode.firstColumn
          };
          this.inverse = new AST.ProgramNode(inverse, inverseStrip, inverseLocationInfo);
        } else {
          this.inverse = new AST.ProgramNode(inverse, inverseStrip);
        }
        this.strip.right = inverseStrip.left;
      } else if (inverseStrip) {
        this.strip.left = inverseStrip.right;
      }
    },

    MustacheNode: function(rawParams, hash, open, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "mustache";
      this.strip = strip;

      // Open may be a string parsed from the parser or a passed boolean flag
      if (open != null && open.charAt) {
        // Must use charAt to support IE pre-10
        var escapeFlag = open.charAt(3) || open.charAt(2);
        this.escaped = escapeFlag !== '{' && escapeFlag !== '&';
      } else {
        this.escaped = !!open;
      }

      if (rawParams instanceof AST.SexprNode) {
        this.sexpr = rawParams;
      } else {
        // Support old AST API
        this.sexpr = new AST.SexprNode(rawParams, hash);
      }

      this.sexpr.isRoot = true;

      // Support old AST API that stored this info in MustacheNode
      this.id = this.sexpr.id;
      this.params = this.sexpr.params;
      this.hash = this.sexpr.hash;
      this.eligibleHelper = this.sexpr.eligibleHelper;
      this.isHelper = this.sexpr.isHelper;
    },

    SexprNode: function(rawParams, hash, locInfo) {
      LocationInfo.call(this, locInfo);

      this.type = "sexpr";
      this.hash = hash;

      var id = this.id = rawParams[0];
      var params = this.params = rawParams.slice(1);

      // a mustache is an eligible helper if:
      // * its id is simple (a single part, not `this` or `..`)
      var eligibleHelper = this.eligibleHelper = id.isSimple;

      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      this.isHelper = eligibleHelper && (params.length || hash);

      // if a mustache is an eligible helper but not a definite
      // helper, it is ambiguous, and will be resolved in a later
      // pass or at runtime.
    },

    PartialNode: function(partialName, context, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type         = "partial";
      this.partialName  = partialName;
      this.context      = context;
      this.strip = strip;
    },

    BlockNode: function(mustache, program, inverse, close, locInfo) {
      LocationInfo.call(this, locInfo);

      if(mustache.sexpr.id.original !== close.path.original) {
        throw new Exception(mustache.sexpr.id.original + " doesn't match " + close.path.original, this);
      }

      this.type = 'block';
      this.mustache = mustache;
      this.program  = program;
      this.inverse  = inverse;

      this.strip = {
        left: mustache.strip.left,
        right: close.strip.right
      };

      (program || inverse).strip.left = mustache.strip.right;
      (inverse || program).strip.right = close.strip.left;

      if (inverse && !program) {
        this.isInverse = true;
      }
    },

    ContentNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "content";
      this.string = string;
    },

    HashNode: function(pairs, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "hash";
      this.pairs = pairs;
    },

    IdNode: function(parts, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "ID";

      var original = "",
          dig = [],
          depth = 0;

      for(var i=0,l=parts.length; i<l; i++) {
        var part = parts[i].part;
        original += (parts[i].separator || '') + part;

        if (part === ".." || part === "." || part === "this") {
          if (dig.length > 0) {
            throw new Exception("Invalid path: " + original, this);
          } else if (part === "..") {
            depth++;
          } else {
            this.isScoped = true;
          }
        } else {
          dig.push(part);
        }
      }

      this.original = original;
      this.parts    = dig;
      this.string   = dig.join('.');
      this.depth    = depth;

      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

      this.stringModeValue = this.string;
    },

    PartialNameNode: function(name, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "PARTIAL_NAME";
      this.name = name.original;
    },

    DataNode: function(id, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "DATA";
      this.id = id;
    },

    StringNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "STRING";
      this.original =
        this.string =
        this.stringModeValue = string;
    },

    IntegerNode: function(integer, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "INTEGER";
      this.original =
        this.integer = integer;
      this.stringModeValue = Number(integer);
    },

    BooleanNode: function(bool, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "BOOLEAN";
      this.bool = bool;
      this.stringModeValue = bool === "true";
    },

    CommentNode: function(comment, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "comment";
      this.comment = comment;
    }
  };

  // Must be exported as an object rather than the root of the module as the jison lexer
  // most modify the object to operate properly.
  __exports__ = AST;
  return __exports__;
})(__module5__);

// handlebars/compiler/parser.js
var __module9__ = (function() {
  "use strict";
  var __exports__;
  /* jshint ignore:start */
  /* Jison generated parser */
  var handlebars = (function(){
  var parser = {trace: function trace() { },
  yy: {},
  symbols_: {"error":2,"root":3,"statements":4,"EOF":5,"program":6,"simpleInverse":7,"statement":8,"openInverse":9,"closeBlock":10,"openBlock":11,"mustache":12,"partial":13,"CONTENT":14,"COMMENT":15,"OPEN_BLOCK":16,"sexpr":17,"CLOSE":18,"OPEN_INVERSE":19,"OPEN_ENDBLOCK":20,"path":21,"OPEN":22,"OPEN_UNESCAPED":23,"CLOSE_UNESCAPED":24,"OPEN_PARTIAL":25,"partialName":26,"partial_option0":27,"sexpr_repetition0":28,"sexpr_option0":29,"dataName":30,"param":31,"STRING":32,"INTEGER":33,"BOOLEAN":34,"OPEN_SEXPR":35,"CLOSE_SEXPR":36,"hash":37,"hash_repetition_plus0":38,"hashSegment":39,"ID":40,"EQUALS":41,"DATA":42,"pathSegments":43,"SEP":44,"$accept":0,"$end":1},
  terminals_: {2:"error",5:"EOF",14:"CONTENT",15:"COMMENT",16:"OPEN_BLOCK",18:"CLOSE",19:"OPEN_INVERSE",20:"OPEN_ENDBLOCK",22:"OPEN",23:"OPEN_UNESCAPED",24:"CLOSE_UNESCAPED",25:"OPEN_PARTIAL",32:"STRING",33:"INTEGER",34:"BOOLEAN",35:"OPEN_SEXPR",36:"CLOSE_SEXPR",40:"ID",41:"EQUALS",42:"DATA",44:"SEP"},
  productions_: [0,[3,2],[3,1],[6,2],[6,3],[6,2],[6,1],[6,1],[6,0],[4,1],[4,2],[8,3],[8,3],[8,1],[8,1],[8,1],[8,1],[11,3],[9,3],[10,3],[12,3],[12,3],[13,4],[7,2],[17,3],[17,1],[31,1],[31,1],[31,1],[31,1],[31,1],[31,3],[37,1],[39,3],[26,1],[26,1],[26,1],[30,2],[21,1],[43,3],[43,1],[27,0],[27,1],[28,0],[28,2],[29,0],[29,1],[38,1],[38,2]],
  performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

  var $0 = $$.length - 1;
  switch (yystate) {
  case 1: return new yy.ProgramNode($$[$0-1], this._$); 
  break;
  case 2: return new yy.ProgramNode([], this._$); 
  break;
  case 3:this.$ = new yy.ProgramNode([], $$[$0-1], $$[$0], this._$);
  break;
  case 4:this.$ = new yy.ProgramNode($$[$0-2], $$[$0-1], $$[$0], this._$);
  break;
  case 5:this.$ = new yy.ProgramNode($$[$0-1], $$[$0], [], this._$);
  break;
  case 6:this.$ = new yy.ProgramNode($$[$0], this._$);
  break;
  case 7:this.$ = new yy.ProgramNode([], this._$);
  break;
  case 8:this.$ = new yy.ProgramNode([], this._$);
  break;
  case 9:this.$ = [$$[$0]];
  break;
  case 10: $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; 
  break;
  case 11:this.$ = new yy.BlockNode($$[$0-2], $$[$0-1].inverse, $$[$0-1], $$[$0], this._$);
  break;
  case 12:this.$ = new yy.BlockNode($$[$0-2], $$[$0-1], $$[$0-1].inverse, $$[$0], this._$);
  break;
  case 13:this.$ = $$[$0];
  break;
  case 14:this.$ = $$[$0];
  break;
  case 15:this.$ = new yy.ContentNode($$[$0], this._$);
  break;
  case 16:this.$ = new yy.CommentNode($$[$0], this._$);
  break;
  case 17:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 18:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 19:this.$ = {path: $$[$0-1], strip: stripFlags($$[$0-2], $$[$0])};
  break;
  case 20:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 21:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 22:this.$ = new yy.PartialNode($$[$0-2], $$[$0-1], stripFlags($$[$0-3], $$[$0]), this._$);
  break;
  case 23:this.$ = stripFlags($$[$0-1], $$[$0]);
  break;
  case 24:this.$ = new yy.SexprNode([$$[$0-2]].concat($$[$0-1]), $$[$0], this._$);
  break;
  case 25:this.$ = new yy.SexprNode([$$[$0]], null, this._$);
  break;
  case 26:this.$ = $$[$0];
  break;
  case 27:this.$ = new yy.StringNode($$[$0], this._$);
  break;
  case 28:this.$ = new yy.IntegerNode($$[$0], this._$);
  break;
  case 29:this.$ = new yy.BooleanNode($$[$0], this._$);
  break;
  case 30:this.$ = $$[$0];
  break;
  case 31:$$[$0-1].isHelper = true; this.$ = $$[$0-1];
  break;
  case 32:this.$ = new yy.HashNode($$[$0], this._$);
  break;
  case 33:this.$ = [$$[$0-2], $$[$0]];
  break;
  case 34:this.$ = new yy.PartialNameNode($$[$0], this._$);
  break;
  case 35:this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0], this._$), this._$);
  break;
  case 36:this.$ = new yy.PartialNameNode(new yy.IntegerNode($$[$0], this._$));
  break;
  case 37:this.$ = new yy.DataNode($$[$0], this._$);
  break;
  case 38:this.$ = new yy.IdNode($$[$0], this._$);
  break;
  case 39: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2]; 
  break;
  case 40:this.$ = [{part: $$[$0]}];
  break;
  case 43:this.$ = [];
  break;
  case 44:$$[$0-1].push($$[$0]);
  break;
  case 47:this.$ = [$$[$0]];
  break;
  case 48:$$[$0-1].push($$[$0]);
  break;
  }
  },
  table: [{3:1,4:2,5:[1,3],8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],25:[1,15]},{1:[3]},{5:[1,16],8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],25:[1,15]},{1:[2,2]},{5:[2,9],14:[2,9],15:[2,9],16:[2,9],19:[2,9],20:[2,9],22:[2,9],23:[2,9],25:[2,9]},{4:20,6:18,7:19,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,8],22:[1,13],23:[1,14],25:[1,15]},{4:20,6:22,7:19,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,8],22:[1,13],23:[1,14],25:[1,15]},{5:[2,13],14:[2,13],15:[2,13],16:[2,13],19:[2,13],20:[2,13],22:[2,13],23:[2,13],25:[2,13]},{5:[2,14],14:[2,14],15:[2,14],16:[2,14],19:[2,14],20:[2,14],22:[2,14],23:[2,14],25:[2,14]},{5:[2,15],14:[2,15],15:[2,15],16:[2,15],19:[2,15],20:[2,15],22:[2,15],23:[2,15],25:[2,15]},{5:[2,16],14:[2,16],15:[2,16],16:[2,16],19:[2,16],20:[2,16],22:[2,16],23:[2,16],25:[2,16]},{17:23,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:29,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:30,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:31,21:24,30:25,40:[1,28],42:[1,27],43:26},{21:33,26:32,32:[1,34],33:[1,35],40:[1,28],43:26},{1:[2,1]},{5:[2,10],14:[2,10],15:[2,10],16:[2,10],19:[2,10],20:[2,10],22:[2,10],23:[2,10],25:[2,10]},{10:36,20:[1,37]},{4:38,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,7],22:[1,13],23:[1,14],25:[1,15]},{7:39,8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,6],22:[1,13],23:[1,14],25:[1,15]},{17:23,18:[1,40],21:24,30:25,40:[1,28],42:[1,27],43:26},{10:41,20:[1,37]},{18:[1,42]},{18:[2,43],24:[2,43],28:43,32:[2,43],33:[2,43],34:[2,43],35:[2,43],36:[2,43],40:[2,43],42:[2,43]},{18:[2,25],24:[2,25],36:[2,25]},{18:[2,38],24:[2,38],32:[2,38],33:[2,38],34:[2,38],35:[2,38],36:[2,38],40:[2,38],42:[2,38],44:[1,44]},{21:45,40:[1,28],43:26},{18:[2,40],24:[2,40],32:[2,40],33:[2,40],34:[2,40],35:[2,40],36:[2,40],40:[2,40],42:[2,40],44:[2,40]},{18:[1,46]},{18:[1,47]},{24:[1,48]},{18:[2,41],21:50,27:49,40:[1,28],43:26},{18:[2,34],40:[2,34]},{18:[2,35],40:[2,35]},{18:[2,36],40:[2,36]},{5:[2,11],14:[2,11],15:[2,11],16:[2,11],19:[2,11],20:[2,11],22:[2,11],23:[2,11],25:[2,11]},{21:51,40:[1,28],43:26},{8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,3],22:[1,13],23:[1,14],25:[1,15]},{4:52,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,5],22:[1,13],23:[1,14],25:[1,15]},{14:[2,23],15:[2,23],16:[2,23],19:[2,23],20:[2,23],22:[2,23],23:[2,23],25:[2,23]},{5:[2,12],14:[2,12],15:[2,12],16:[2,12],19:[2,12],20:[2,12],22:[2,12],23:[2,12],25:[2,12]},{14:[2,18],15:[2,18],16:[2,18],19:[2,18],20:[2,18],22:[2,18],23:[2,18],25:[2,18]},{18:[2,45],21:56,24:[2,45],29:53,30:60,31:54,32:[1,57],33:[1,58],34:[1,59],35:[1,61],36:[2,45],37:55,38:62,39:63,40:[1,64],42:[1,27],43:26},{40:[1,65]},{18:[2,37],24:[2,37],32:[2,37],33:[2,37],34:[2,37],35:[2,37],36:[2,37],40:[2,37],42:[2,37]},{14:[2,17],15:[2,17],16:[2,17],19:[2,17],20:[2,17],22:[2,17],23:[2,17],25:[2,17]},{5:[2,20],14:[2,20],15:[2,20],16:[2,20],19:[2,20],20:[2,20],22:[2,20],23:[2,20],25:[2,20]},{5:[2,21],14:[2,21],15:[2,21],16:[2,21],19:[2,21],20:[2,21],22:[2,21],23:[2,21],25:[2,21]},{18:[1,66]},{18:[2,42]},{18:[1,67]},{8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,4],22:[1,13],23:[1,14],25:[1,15]},{18:[2,24],24:[2,24],36:[2,24]},{18:[2,44],24:[2,44],32:[2,44],33:[2,44],34:[2,44],35:[2,44],36:[2,44],40:[2,44],42:[2,44]},{18:[2,46],24:[2,46],36:[2,46]},{18:[2,26],24:[2,26],32:[2,26],33:[2,26],34:[2,26],35:[2,26],36:[2,26],40:[2,26],42:[2,26]},{18:[2,27],24:[2,27],32:[2,27],33:[2,27],34:[2,27],35:[2,27],36:[2,27],40:[2,27],42:[2,27]},{18:[2,28],24:[2,28],32:[2,28],33:[2,28],34:[2,28],35:[2,28],36:[2,28],40:[2,28],42:[2,28]},{18:[2,29],24:[2,29],32:[2,29],33:[2,29],34:[2,29],35:[2,29],36:[2,29],40:[2,29],42:[2,29]},{18:[2,30],24:[2,30],32:[2,30],33:[2,30],34:[2,30],35:[2,30],36:[2,30],40:[2,30],42:[2,30]},{17:68,21:24,30:25,40:[1,28],42:[1,27],43:26},{18:[2,32],24:[2,32],36:[2,32],39:69,40:[1,70]},{18:[2,47],24:[2,47],36:[2,47],40:[2,47]},{18:[2,40],24:[2,40],32:[2,40],33:[2,40],34:[2,40],35:[2,40],36:[2,40],40:[2,40],41:[1,71],42:[2,40],44:[2,40]},{18:[2,39],24:[2,39],32:[2,39],33:[2,39],34:[2,39],35:[2,39],36:[2,39],40:[2,39],42:[2,39],44:[2,39]},{5:[2,22],14:[2,22],15:[2,22],16:[2,22],19:[2,22],20:[2,22],22:[2,22],23:[2,22],25:[2,22]},{5:[2,19],14:[2,19],15:[2,19],16:[2,19],19:[2,19],20:[2,19],22:[2,19],23:[2,19],25:[2,19]},{36:[1,72]},{18:[2,48],24:[2,48],36:[2,48],40:[2,48]},{41:[1,71]},{21:56,30:60,31:73,32:[1,57],33:[1,58],34:[1,59],35:[1,61],40:[1,28],42:[1,27],43:26},{18:[2,31],24:[2,31],32:[2,31],33:[2,31],34:[2,31],35:[2,31],36:[2,31],40:[2,31],42:[2,31]},{18:[2,33],24:[2,33],36:[2,33],40:[2,33]}],
  defaultActions: {3:[2,2],16:[2,1],50:[2,42]},
  parseError: function parseError(str, hash) {
      throw new Error(str);
  },
  parse: function parse(input) {
      var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      this.lexer.setInput(input);
      this.lexer.yy = this.yy;
      this.yy.lexer = this.lexer;
      this.yy.parser = this;
      if (typeof this.lexer.yylloc == "undefined")
          this.lexer.yylloc = {};
      var yyloc = this.lexer.yylloc;
      lstack.push(yyloc);
      var ranges = this.lexer.options && this.lexer.options.ranges;
      if (typeof this.yy.parseError === "function")
          this.parseError = this.yy.parseError;
      function popStack(n) {
          stack.length = stack.length - 2 * n;
          vstack.length = vstack.length - n;
          lstack.length = lstack.length - n;
      }
      function lex() {
          var token;
          token = self.lexer.lex() || 1;
          if (typeof token !== "number") {
              token = self.symbols_[token] || token;
          }
          return token;
      }
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
              }
              action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                  expected = [];
                  for (p in table[state])
                      if (this.terminals_[p] && p > 2) {
                          expected.push("'" + this.terminals_[p] + "'");
                      }
                  if (this.lexer.showPosition) {
                      errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                      errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
              }
          }
          if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
          case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0)
                      recovering--;
              } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
              }
              break;
          case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
              if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                  return r;
              }
              if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
          case 3:
              return true;
          }
      }
      return true;
  }
  };


  function stripFlags(open, close) {
    return {
      left: open.charAt(2) === '~',
      right: close.charAt(0) === '~' || close.charAt(1) === '~'
    };
  }

  /* Jison generated lexer */
  var lexer = (function(){
  var lexer = ({EOF:1,
  parseError:function parseError(str, hash) {
          if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
          } else {
              throw new Error(str);
          }
      },
  setInput:function (input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
          if (this.options.ranges) this.yylloc.range = [0,0];
          this.offset = 0;
          return this;
      },
  input:function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
          } else {
              this.yylloc.last_column++;
          }
          if (this.options.ranges) this.yylloc.range[1]++;

          this._input = this._input.slice(1);
          return ch;
      },
  unput:function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length-1);
          this.matched = this.matched.substr(0, this.matched.length-1);

          if (lines.length-1) this.yylineno -= lines.length-1;
          var r = this.yylloc.range;

          this.yylloc = {first_line: this.yylloc.first_line,
            last_line: this.yylineno+1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
                this.yylloc.first_column - len
            };

          if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
      },
  more:function () {
          this._more = true;
          return this;
      },
  less:function (n) {
          this.unput(this.match.slice(n));
      },
  pastInput:function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },
  upcomingInput:function () {
          var next = this.match;
          if (next.length < 20) {
              next += this._input.substr(0, 20-next.length);
          }
          return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
      },
  showPosition:function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c+"^";
      },
  next:function () {
          if (this.done) {
              return this.EOF;
          }
          if (!this._input) this.done = true;

          var token,
              match,
              tempMatch,
              index,
              col,
              lines;
          if (!this._more) {
              this.yytext = '';
              this.match = '';
          }
          var rules = this._currentRules();
          for (var i=0;i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;
                  if (!this.options.flex) break;
              }
          }
          if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines) this.yylineno += lines.length;
              this.yylloc = {first_line: this.yylloc.last_line,
                             last_line: this.yylineno+1,
                             first_column: this.yylloc.last_column,
                             last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
              if (this.done && this._input) this.done = false;
              if (token) return token;
              else return;
          }
          if (this._input === "") {
              return this.EOF;
          } else {
              return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                      {text: "", token: null, line: this.yylineno});
          }
      },
  lex:function lex() {
          var r = this.next();
          if (typeof r !== 'undefined') {
              return r;
          } else {
              return this.lex();
          }
      },
  begin:function begin(condition) {
          this.conditionStack.push(condition);
      },
  popState:function popState() {
          return this.conditionStack.pop();
      },
  _currentRules:function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
      },
  topState:function () {
          return this.conditionStack[this.conditionStack.length-2];
      },
  pushState:function begin(condition) {
          this.begin(condition);
      }});
  lexer.options = {};
  lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {


  function strip(start, end) {
    return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng-end);
  }


  var YYSTATE=YY_START
  switch($avoiding_name_collisions) {
  case 0:
                                     if(yy_.yytext.slice(-2) === "\\\\") {
                                       strip(0,1);
                                       this.begin("mu");
                                     } else if(yy_.yytext.slice(-1) === "\\") {
                                       strip(0,1);
                                       this.begin("emu");
                                     } else {
                                       this.begin("mu");
                                     }
                                     if(yy_.yytext) return 14;
                                   
  break;
  case 1:return 14;
  break;
  case 2:
                                     this.popState();
                                     return 14;
                                   
  break;
  case 3:strip(0,4); this.popState(); return 15;
  break;
  case 4:return 35;
  break;
  case 5:return 36;
  break;
  case 6:return 25;
  break;
  case 7:return 16;
  break;
  case 8:return 20;
  break;
  case 9:return 19;
  break;
  case 10:return 19;
  break;
  case 11:return 23;
  break;
  case 12:return 22;
  break;
  case 13:this.popState(); this.begin('com');
  break;
  case 14:strip(3,5); this.popState(); return 15;
  break;
  case 15:return 22;
  break;
  case 16:return 41;
  break;
  case 17:return 40;
  break;
  case 18:return 40;
  break;
  case 19:return 44;
  break;
  case 20:// ignore whitespace
  break;
  case 21:this.popState(); return 24;
  break;
  case 22:this.popState(); return 18;
  break;
  case 23:yy_.yytext = strip(1,2).replace(/\\"/g,'"'); return 32;
  break;
  case 24:yy_.yytext = strip(1,2).replace(/\\'/g,"'"); return 32;
  break;
  case 25:return 42;
  break;
  case 26:return 34;
  break;
  case 27:return 34;
  break;
  case 28:return 33;
  break;
  case 29:return 40;
  break;
  case 30:yy_.yytext = strip(1,2); return 40;
  break;
  case 31:return 'INVALID';
  break;
  case 32:return 5;
  break;
  }
  };
  lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/,/^(?:[\s\S]*?--\}\})/,/^(?:\()/,/^(?:\))/,/^(?:\{\{(~)?>)/,/^(?:\{\{(~)?#)/,/^(?:\{\{(~)?\/)/,/^(?:\{\{(~)?\^)/,/^(?:\{\{(~)?\s*else\b)/,/^(?:\{\{(~)?\{)/,/^(?:\{\{(~)?&)/,/^(?:\{\{!--)/,/^(?:\{\{![\s\S]*?\}\})/,/^(?:\{\{(~)?)/,/^(?:=)/,/^(?:\.\.)/,/^(?:\.(?=([=~}\s\/.)])))/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}(~)?\}\})/,/^(?:(~)?\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=([~}\s)])))/,/^(?:false(?=([~}\s)])))/,/^(?:-?[0-9]+(?=([~}\s)])))/,/^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/,/^(?:\[[^\]]*\])/,/^(?:.)/,/^(?:$)/];
  lexer.conditions = {"mu":{"rules":[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],"inclusive":false},"emu":{"rules":[2],"inclusive":false},"com":{"rules":[3],"inclusive":false},"INITIAL":{"rules":[0,1,32],"inclusive":true}};
  return lexer;})()
  parser.lexer = lexer;
  function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
  })();__exports__ = handlebars;
  /* jshint ignore:end */
  return __exports__;
})();

// handlebars/compiler/base.js
var __module8__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var parser = __dependency1__;
  var AST = __dependency2__;

  __exports__.parser = parser;

  function parse(input) {
    // Just return if an already-compile AST was passed in.
    if(input.constructor === AST.ProgramNode) { return input; }

    parser.yy = AST;
    return parser.parse(input);
  }

  __exports__.parse = parse;
  return __exports__;
})(__module9__, __module7__);

// handlebars/compiler/compiler.js
var __module10__ = (function(__dependency1__) {
  "use strict";
  var __exports__ = {};
  var Exception = __dependency1__;

  function Compiler() {}

  __exports__.Compiler = Compiler;// the foundHelper register will disambiguate helper lookup from finding a
  // function in a context. This is necessary for mustache compatibility, which
  // requires that context functions in blocks are evaluated by blockHelperMissing,
  // and then proceed as if the resulting value was provided to blockHelperMissing.

  Compiler.prototype = {
    compiler: Compiler,

    disassemble: function() {
      var opcodes = this.opcodes, opcode, out = [], params, param;

      for (var i=0, l=opcodes.length; i<l; i++) {
        opcode = opcodes[i];

        if (opcode.opcode === 'DECLARE') {
          out.push("DECLARE " + opcode.name + "=" + opcode.value);
        } else {
          params = [];
          for (var j=0; j<opcode.args.length; j++) {
            param = opcode.args[j];
            if (typeof param === "string") {
              param = "\"" + param.replace("\n", "\\n") + "\"";
            }
            params.push(param);
          }
          out.push(opcode.opcode + " " + params.join(" "));
        }
      }

      return out.join("\n");
    },

    equals: function(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i],
            otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {
          return false;
        }
        for (var j = 0; j < opcode.args.length; j++) {
          if (opcode.args[j] !== otherOpcode.args[j]) {
            return false;
          }
        }
      }

      len = this.children.length;
      if (other.children.length !== len) {
        return false;
      }
      for (i = 0; i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }

      return true;
    },

    guid: 0,

    compile: function(program, options) {
      this.opcodes = [];
      this.children = [];
      this.depths = {list: []};
      this.options = options;

      // These changes will propagate to the other compiler components
      var knownHelpers = this.options.knownHelpers;
      this.options.knownHelpers = {
        'helperMissing': true,
        'blockHelperMissing': true,
        'each': true,
        'if': true,
        'unless': true,
        'with': true,
        'log': true
      };
      if (knownHelpers) {
        for (var name in knownHelpers) {
          this.options.knownHelpers[name] = knownHelpers[name];
        }
      }

      return this.accept(program);
    },

    accept: function(node) {
      var strip = node.strip || {},
          ret;
      if (strip.left) {
        this.opcode('strip');
      }

      ret = this[node.type](node);

      if (strip.right) {
        this.opcode('strip');
      }

      return ret;
    },

    program: function(program) {
      var statements = program.statements;

      for(var i=0, l=statements.length; i<l; i++) {
        this.accept(statements[i]);
      }
      this.isSimple = l === 1;

      this.depths.list = this.depths.list.sort(function(a, b) {
        return a - b;
      });

      return this;
    },

    compileProgram: function(program) {
      var result = new this.compiler().compile(program, this.options);
      var guid = this.guid++, depth;

      this.usePartial = this.usePartial || result.usePartial;

      this.children[guid] = result;

      for(var i=0, l=result.depths.list.length; i<l; i++) {
        depth = result.depths.list[i];

        if(depth < 2) { continue; }
        else { this.addDepth(depth - 1); }
      }

      return guid;
    },

    block: function(block) {
      var mustache = block.mustache,
          program = block.program,
          inverse = block.inverse;

      if (program) {
        program = this.compileProgram(program);
      }

      if (inverse) {
        inverse = this.compileProgram(inverse);
      }

      var sexpr = mustache.sexpr;
      var type = this.classifySexpr(sexpr);

      if (type === "helper") {
        this.helperSexpr(sexpr, program, inverse);
      } else if (type === "simple") {
        this.simpleSexpr(sexpr);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('blockValue');
      } else {
        this.ambiguousSexpr(sexpr, program, inverse);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('ambiguousBlockValue');
      }

      this.opcode('append');
    },

    hash: function(hash) {
      var pairs = hash.pairs, pair, val;

      this.opcode('pushHash');

      for(var i=0, l=pairs.length; i<l; i++) {
        pair = pairs[i];
        val  = pair[1];

        if (this.options.stringParams) {
          if(val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode('getContext', val.depth || 0);
          this.opcode('pushStringParam', val.stringModeValue, val.type);

          if (val.type === 'sexpr') {
            // Subexpressions get evaluated and passed in
            // in string params mode.
            this.sexpr(val);
          }
        } else {
          this.accept(val);
        }

        this.opcode('assignToHash', pair[0]);
      }
      this.opcode('popHash');
    },

    partial: function(partial) {
      var partialName = partial.partialName;
      this.usePartial = true;

      if(partial.context) {
        this.ID(partial.context);
      } else {
        this.opcode('push', 'depth0');
      }

      this.opcode('invokePartial', partialName.name);
      this.opcode('append');
    },

    content: function(content) {
      this.opcode('appendContent', content.string);
    },

    mustache: function(mustache) {
      this.sexpr(mustache.sexpr);

      if(mustache.escaped && !this.options.noEscape) {
        this.opcode('appendEscaped');
      } else {
        this.opcode('append');
      }
    },

    ambiguousSexpr: function(sexpr, program, inverse) {
      var id = sexpr.id,
          name = id.parts[0],
          isBlock = program != null || inverse != null;

      this.opcode('getContext', id.depth);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      this.opcode('invokeAmbiguous', name, isBlock);
    },

    simpleSexpr: function(sexpr) {
      var id = sexpr.id;

      if (id.type === 'DATA') {
        this.DATA(id);
      } else if (id.parts.length) {
        this.ID(id);
      } else {
        // Simplified ID for `this`
        this.addDepth(id.depth);
        this.opcode('getContext', id.depth);
        this.opcode('pushContext');
      }

      this.opcode('resolvePossibleLambda');
    },

    helperSexpr: function(sexpr, program, inverse) {
      var params = this.setupFullMustacheParams(sexpr, program, inverse),
          name = sexpr.id.parts[0];

      if (this.options.knownHelpers[name]) {
        this.opcode('invokeKnownHelper', params.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new Exception("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
      } else {
        this.opcode('invokeHelper', params.length, name, sexpr.isRoot);
      }
    },

    sexpr: function(sexpr) {
      var type = this.classifySexpr(sexpr);

      if (type === "simple") {
        this.simpleSexpr(sexpr);
      } else if (type === "helper") {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },

    ID: function(id) {
      this.addDepth(id.depth);
      this.opcode('getContext', id.depth);

      var name = id.parts[0];
      if (!name) {
        this.opcode('pushContext');
      } else {
        this.opcode('lookupOnContext', id.parts[0]);
      }

      for(var i=1, l=id.parts.length; i<l; i++) {
        this.opcode('lookup', id.parts[i]);
      }
    },

    DATA: function(data) {
      this.options.data = true;
      if (data.id.isScoped || data.id.depth) {
        throw new Exception('Scoped data references are not supported: ' + data.original, data);
      }

      this.opcode('lookupData');
      var parts = data.id.parts;
      for(var i=0, l=parts.length; i<l; i++) {
        this.opcode('lookup', parts[i]);
      }
    },

    STRING: function(string) {
      this.opcode('pushString', string.string);
    },

    INTEGER: function(integer) {
      this.opcode('pushLiteral', integer.integer);
    },

    BOOLEAN: function(bool) {
      this.opcode('pushLiteral', bool.bool);
    },

    comment: function() {},

    // HELPERS
    opcode: function(name) {
      this.opcodes.push({ opcode: name, args: [].slice.call(arguments, 1) });
    },

    declare: function(name, value) {
      this.opcodes.push({ opcode: 'DECLARE', name: name, value: value });
    },

    addDepth: function(depth) {
      if(depth === 0) { return; }

      if(!this.depths[depth]) {
        this.depths[depth] = true;
        this.depths.list.push(depth);
      }
    },

    classifySexpr: function(sexpr) {
      var isHelper   = sexpr.isHelper;
      var isEligible = sexpr.eligibleHelper;
      var options    = this.options;

      // if ambiguous, we can possibly resolve the ambiguity now
      if (isEligible && !isHelper) {
        var name = sexpr.id.parts[0];

        if (options.knownHelpers[name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }

      if (isHelper) { return "helper"; }
      else if (isEligible) { return "ambiguous"; }
      else { return "simple"; }
    },

    pushParams: function(params) {
      var i = params.length, param;

      while(i--) {
        param = params[i];

        if(this.options.stringParams) {
          if(param.depth) {
            this.addDepth(param.depth);
          }

          this.opcode('getContext', param.depth || 0);
          this.opcode('pushStringParam', param.stringModeValue, param.type);

          if (param.type === 'sexpr') {
            // Subexpressions get evaluated and passed in
            // in string params mode.
            this.sexpr(param);
          }
        } else {
          this[param.type](param);
        }
      }
    },

    setupFullMustacheParams: function(sexpr, program, inverse) {
      var params = sexpr.params;
      this.pushParams(params);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      if (sexpr.hash) {
        this.hash(sexpr.hash);
      } else {
        this.opcode('emptyHash');
      }

      return params;
    }
  };

  function precompile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
    }

    options = options || {};
    if (!('data' in options)) {
      options.data = true;
    }

    var ast = env.parse(input);
    var environment = new env.Compiler().compile(ast, options);
    return new env.JavaScriptCompiler().compile(environment, options);
  }

  __exports__.precompile = precompile;function compile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
    }

    options = options || {};

    if (!('data' in options)) {
      options.data = true;
    }

    var compiled;

    function compileInput() {
      var ast = env.parse(input);
      var environment = new env.Compiler().compile(ast, options);
      var templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
      return env.template(templateSpec);
    }

    // Template is only compiled on first use and cached after that point.
    return function(context, options) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, options);
    };
  }

  __exports__.compile = compile;
  return __exports__;
})(__module5__);

// handlebars/compiler/javascript-compiler.js
var __module11__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__;
  var COMPILER_REVISION = __dependency1__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency1__.REVISION_CHANGES;
  var log = __dependency1__.log;
  var Exception = __dependency2__;

  function Literal(value) {
    this.value = value;
  }

  function JavaScriptCompiler() {}

  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function(parent, name /* , type*/) {
      var wrap,
          ret;
      if (parent.indexOf('depth') === 0) {
        wrap = true;
      }

      if (/^[0-9]+$/.test(name)) {
        ret = parent + "[" + name + "]";
      } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
        ret = parent + "." + name;
      }
      else {
        ret = parent + "['" + name + "']";
      }

      if (wrap) {
        return '(' + parent + ' && ' + ret + ')';
      } else {
        return ret;
      }
    },

    compilerInfo: function() {
      var revision = COMPILER_REVISION,
          versions = REVISION_CHANGES[revision];
      return "this.compilerInfo = ["+revision+",'"+versions+"'];\n";
    },

    appendToBuffer: function(string) {
      if (this.environment.isSimple) {
        return "return " + string + ";";
      } else {
        return {
          appendToBuffer: true,
          content: string,
          toString: function() { return "buffer += " + string + ";"; }
        };
      }
    },

    initializeBuffer: function() {
      return this.quotedString("");
    },

    namespace: "Handlebars",
    // END PUBLIC API

    compile: function(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options || {};

      log('debug', this.environment.disassemble() + "\n\n");

      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        programs: [],
        environments: [],
        aliases: { }
      };

      this.preamble();

      this.stackSlot = 0;
      this.stackVars = [];
      this.registers = { list: [] };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];

      this.compileChildren(environment, options);

      var opcodes = environment.opcodes, opcode;

      this.i = 0;

      for(var l=opcodes.length; this.i<l; this.i++) {
        opcode = opcodes[this.i];

        if(opcode.opcode === 'DECLARE') {
          this[opcode.name] = opcode.value;
        } else {
          this[opcode.opcode].apply(this, opcode.args);
        }

        // Reset the stripNext flag if it was not set by this operation.
        if (opcode.opcode !== this.stripNext) {
          this.stripNext = false;
        }
      }

      // Flush any trailing content that might be pending.
      this.pushSource('');

      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new Exception('Compile completed with content left on stack');
      }

      return this.createFunctionContext(asObject);
    },

    preamble: function() {
      var out = [];

      if (!this.isChild) {
        var namespace = this.namespace;

        var copies = "helpers = this.merge(helpers, " + namespace + ".helpers);";
        if (this.environment.usePartial) { copies = copies + " partials = this.merge(partials, " + namespace + ".partials);"; }
        if (this.options.data) { copies = copies + " data = data || {};"; }
        out.push(copies);
      } else {
        out.push('');
      }

      if (!this.environment.isSimple) {
        out.push(", buffer = " + this.initializeBuffer());
      } else {
        out.push("");
      }

      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = out;
    },

    createFunctionContext: function(asObject) {
      var locals = this.stackVars.concat(this.registers.list);

      if(locals.length > 0) {
        this.source[1] = this.source[1] + ", " + locals.join(", ");
      }

      // Generate minimizer alias mappings
      if (!this.isChild) {
        for (var alias in this.context.aliases) {
          if (this.context.aliases.hasOwnProperty(alias)) {
            this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];
          }
        }
      }

      if (this.source[1]) {
        this.source[1] = "var " + this.source[1].substring(2) + ";";
      }

      // Merge children
      if (!this.isChild) {
        this.source[1] += '\n' + this.context.programs.join('\n') + '\n';
      }

      if (!this.environment.isSimple) {
        this.pushSource("return buffer;");
      }

      var params = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"];

      for(var i=0, l=this.environment.depths.list.length; i<l; i++) {
        params.push("depth" + this.environment.depths.list[i]);
      }

      // Perform a second pass over the output to merge content when possible
      var source = this.mergeSource();

      if (!this.isChild) {
        source = this.compilerInfo()+source;
      }

      if (asObject) {
        params.push(source);

        return Function.apply(this, params);
      } else {
        var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\n  ' + source + '}';
        log('debug', functionSource + "\n\n");
        return functionSource;
      }
    },
    mergeSource: function() {
      // WARN: We are not handling the case where buffer is still populated as the source should
      // not have buffer append operations as their final action.
      var source = '',
          buffer;
      for (var i = 0, len = this.source.length; i < len; i++) {
        var line = this.source[i];
        if (line.appendToBuffer) {
          if (buffer) {
            buffer = buffer + '\n    + ' + line.content;
          } else {
            buffer = line.content;
          }
        } else {
          if (buffer) {
            source += 'buffer += ' + buffer + ';\n  ';
            buffer = undefined;
          }
          source += line + '\n  ';
        }
      }
      return source;
    },

    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function() {
      this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      var params = ["depth0"];
      this.setupParams(0, params);

      this.replaceStack(function(current) {
        params.splice(1, 0, current);
        return "blockHelperMissing.call(" + params.join(", ") + ")";
      });
    },

    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function() {
      this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      var params = ["depth0"];
      this.setupParams(0, params);

      var current = this.topStack();
      params.splice(1, 0, current);

      this.pushSource("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
    },

    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      }
      if (this.stripNext) {
        content = content.replace(/^\s+/, '');
      }

      this.pendingContent = content;
    },

    // [strip]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Removes any trailing whitespace from the prior content node and flags
    // the next operation for stripping if it is a content node.
    strip: function() {
      if (this.pendingContent) {
        this.pendingContent = this.pendingContent.replace(/\s+$/, '');
      }
      this.stripNext = 'strip';
    },

    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function() {
      // Force anything that is inlined onto the stack so we don't have duplication
      // when we examine local
      this.flushInline();
      var local = this.popStack();
      this.pushSource("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
      if (this.environment.isSimple) {
        this.pushSource("else { " + this.appendToBuffer("''") + " }");
      }
    },

    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function() {
      this.context.aliases.escapeExpression = 'this.escapeExpression';

      this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
    },

    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function(depth) {
      if(this.lastContext !== depth) {
        this.lastContext = depth;
      }
    },

    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function(name) {
      this.push(this.nameLookup('depth' + this.lastContext, name, 'context'));
    },

    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function() {
      this.pushStackLiteral('depth' + this.lastContext);
    },

    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function() {
      this.context.aliases.functionType = '"function"';

      this.replaceStack(function(current) {
        return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
      });
    },

    // [lookup]
    //
    // On stack, before: value, ...
    // On stack, after: value[name], ...
    //
    // Replace the value on the stack with the result of looking
    // up `name` on `value`
    lookup: function(name) {
      this.replaceStack(function(current) {
        return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, 'context');
      });
    },

    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function() {
      this.pushStackLiteral('data');
    },

    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function(string, type) {
      this.pushStackLiteral('depth' + this.lastContext);

      this.pushString(type);

      // If it's a subexpression, the string result
      // will be pushed after this opcode.
      if (type !== 'sexpr') {
        if (typeof string === 'string') {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },

    emptyHash: function() {
      this.pushStackLiteral('{}');

      if (this.options.stringParams) {
        this.push('{}'); // hashContexts
        this.push('{}'); // hashTypes
      }
    },
    pushHash: function() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = {values: [], types: [], contexts: []};
    },
    popHash: function() {
      var hash = this.hash;
      this.hash = this.hashes.pop();

      if (this.options.stringParams) {
        this.push('{' + hash.contexts.join(',') + '}');
        this.push('{' + hash.types.join(',') + '}');
      }

      this.push('{\n    ' + hash.values.join(',\n    ') + '\n  }');
    },

    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function(string) {
      this.pushStackLiteral(this.quotedString(string));
    },

    // [push]
    //
    // On stack, before: ...
    // On stack, after: expr, ...
    //
    // Push an expression onto the stack
    push: function(expr) {
      this.inlineStack.push(expr);
      return expr;
    },

    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function(value) {
      this.pushStackLiteral(value);
    },

    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },

    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function(paramSize, name, isRoot) {
      this.context.aliases.helperMissing = 'helpers.helperMissing';
      this.useRegister('helper');

      var helper = this.lastHelper = this.setupHelper(paramSize, name, true);
      var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');

      var lookup = 'helper = ' + helper.name + ' || ' + nonHelper;
      if (helper.paramsInit) {
        lookup += ',' + helper.paramsInit;
      }

      this.push(
        '('
          + lookup
          + ',helper '
            + '? helper.call(' + helper.callParams + ') '
            + ': helperMissing.call(' + helper.helperMissingParams + '))');

      // Always flush subexpressions. This is both to prevent the compounding size issue that
      // occurs when the code has to be duplicated for inlining and also to prevent errors
      // due to the incorrect options object being passed due to the shared register.
      if (!isRoot) {
        this.flushInline();
      }
    },

    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(helper.name + ".call(" + helper.callParams + ")");
    },

    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function(name, helperCall) {
      this.context.aliases.functionType = '"function"';
      this.useRegister('helper');

      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);

      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

      var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');
      var nextStack = this.nextStack();

      if (helper.paramsInit) {
        this.pushSource(helper.paramsInit);
      }
      this.pushSource('if (helper = ' + helperName + ') { ' + nextStack + ' = helper.call(' + helper.callParams + '); }');
      this.pushSource('else { helper = ' + nonHelper + '; ' + nextStack + ' = typeof helper === functionType ? helper.call(' + helper.callParams + ') : helper; }');
    },

    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function(name) {
      var params = [this.nameLookup('partials', name, 'partial'), "'" + name + "'", this.popStack(), "helpers", "partials"];

      if (this.options.data) {
        params.push("data");
      }

      this.context.aliases.self = "this";
      this.push("self.invokePartial(" + params.join(", ") + ")");
    },

    // [assignToHash]
    //
    // On stack, before: value, hash, ...
    // On stack, after: hash, ...
    //
    // Pops a value and hash off the stack, assigns `hash[key] = value`
    // and pushes the hash back onto the stack.
    assignToHash: function(key) {
      var value = this.popStack(),
          context,
          type;

      if (this.options.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }

      var hash = this.hash;
      if (context) {
        hash.contexts.push("'" + key + "': " + context);
      }
      if (type) {
        hash.types.push("'" + key + "': " + type);
      }
      hash.values.push("'" + key + "': (" + value + ")");
    },

    // HELPERS

    compiler: JavaScriptCompiler,

    compileChildren: function(environment, options) {
      var children = environment.children, child, compiler;

      for(var i=0, l=children.length; i<l; i++) {
        child = children[i];
        compiler = new this.compiler();

        var index = this.matchExistingProgram(child);

        if (index == null) {
          this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
          index = this.context.programs.length;
          child.index = index;
          child.name = 'program' + index;
          this.context.programs[index] = compiler.compile(child, options, this.context);
          this.context.environments[index] = child;
        } else {
          child.index = index;
          child.name = 'program' + index;
        }
      }
    },
    matchExistingProgram: function(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return i;
        }
      }
    },

    programExpression: function(guid) {
      this.context.aliases.self = "this";

      if(guid == null) {
        return "self.noop";
      }

      var child = this.environment.children[guid],
          depths = child.depths.list, depth;

      var programParams = [child.index, child.name, "data"];

      for(var i=0, l = depths.length; i<l; i++) {
        depth = depths[i];

        if(depth === 1) { programParams.push("depth0"); }
        else { programParams.push("depth" + (depth - 1)); }
      }

      return (depths.length === 0 ? "self.program(" : "self.programWithDepth(") + programParams.join(", ") + ")";
    },

    register: function(name, val) {
      this.useRegister(name);
      this.pushSource(name + " = " + val + ";");
    },

    useRegister: function(name) {
      if(!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },

    pushStackLiteral: function(item) {
      return this.push(new Literal(item));
    },

    pushSource: function(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent)));
        this.pendingContent = undefined;
      }

      if (source) {
        this.source.push(source);
      }
    },

    pushStack: function(item) {
      this.flushInline();

      var stack = this.incrStack();
      if (item) {
        this.pushSource(stack + " = " + item + ";");
      }
      this.compileStack.push(stack);
      return stack;
    },

    replaceStack: function(callback) {
      var prefix = '',
          inline = this.isInline(),
          stack,
          createdStack,
          usedLiteral;

      // If we are currently inline then we want to merge the inline statement into the
      // replacement statement via ','
      if (inline) {
        var top = this.popStack(true);

        if (top instanceof Literal) {
          // Literals do not need to be inlined
          stack = top.value;
          usedLiteral = true;
        } else {
          // Get or create the current stack name for use by the inline
          createdStack = !this.stackSlot;
          var name = !createdStack ? this.topStackName() : this.incrStack();

          prefix = '(' + this.push(name) + ' = ' + top + '),';
          stack = this.topStack();
        }
      } else {
        stack = this.topStack();
      }

      var item = callback.call(this, stack);

      if (inline) {
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push('(' + prefix + item + ')');
      } else {
        // Prevent modification of the context depth variable. Through replaceStack
        if (!/^stack/.test(stack)) {
          stack = this.nextStack();
        }

        this.pushSource(stack + " = (" + prefix + item + ");");
      }
      return stack;
    },

    nextStack: function() {
      return this.pushStack();
    },

    incrStack: function() {
      this.stackSlot++;
      if(this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
      return this.topStackName();
    },
    topStackName: function() {
      return "stack" + this.stackSlot;
    },
    flushInline: function() {
      var inlineStack = this.inlineStack;
      if (inlineStack.length) {
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            this.pushStack(entry);
          }
        }
      }
    },
    isInline: function() {
      return this.inlineStack.length;
    },

    popStack: function(wrapped) {
      var inline = this.isInline(),
          item = (inline ? this.inlineStack : this.compileStack).pop();

      if (!wrapped && (item instanceof Literal)) {
        return item.value;
      } else {
        if (!inline) {
          if (!this.stackSlot) {
            throw new Exception('Invalid stack pop');
          }
          this.stackSlot--;
        }
        return item;
      }
    },

    topStack: function(wrapped) {
      var stack = (this.isInline() ? this.inlineStack : this.compileStack),
          item = stack[stack.length - 1];

      if (!wrapped && (item instanceof Literal)) {
        return item.value;
      } else {
        return item;
      }
    },

    quotedString: function(str) {
      return '"' + str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
        .replace(/\u2029/g, '\\u2029') + '"';
    },

    setupHelper: function(paramSize, name, missingParams) {
      var params = [],
          paramsInit = this.setupParams(paramSize, params, missingParams);
      var foundHelper = this.nameLookup('helpers', name, 'helper');

      return {
        params: params,
        paramsInit: paramsInit,
        name: foundHelper,
        callParams: ["depth0"].concat(params).join(", "),
        helperMissingParams: missingParams && ["depth0", this.quotedString(name)].concat(params).join(", ")
      };
    },

    setupOptions: function(paramSize, params) {
      var options = [], contexts = [], types = [], param, inverse, program;

      options.push("hash:" + this.popStack());

      if (this.options.stringParams) {
        options.push("hashTypes:" + this.popStack());
        options.push("hashContexts:" + this.popStack());
      }

      inverse = this.popStack();
      program = this.popStack();

      // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`
      if (program || inverse) {
        if (!program) {
          this.context.aliases.self = "this";
          program = "self.noop";
        }

        if (!inverse) {
          this.context.aliases.self = "this";
          inverse = "self.noop";
        }

        options.push("inverse:" + inverse);
        options.push("fn:" + program);
      }

      for(var i=0; i<paramSize; i++) {
        param = this.popStack();
        params.push(param);

        if(this.options.stringParams) {
          types.push(this.popStack());
          contexts.push(this.popStack());
        }
      }

      if (this.options.stringParams) {
        options.push("contexts:[" + contexts.join(",") + "]");
        options.push("types:[" + types.join(",") + "]");
      }

      if(this.options.data) {
        options.push("data:data");
      }

      return options;
    },

    // the params and contexts arguments are passed in arrays
    // to fill in
    setupParams: function(paramSize, params, useRegister) {
      var options = '{' + this.setupOptions(paramSize, params).join(',') + '}';

      if (useRegister) {
        this.useRegister('options');
        params.push('options');
        return 'options=' + options;
      } else {
        params.push(options);
        return '';
      }
    }
  };

  var reservedWords = (
    "break else new var" +
    " case finally return void" +
    " catch for switch while" +
    " continue function this with" +
    " default if throw" +
    " delete in try" +
    " do instanceof typeof" +
    " abstract enum int short" +
    " boolean export interface static" +
    " byte extends long super" +
    " char final native synchronized" +
    " class float package throws" +
    " const goto private transient" +
    " debugger implements protected volatile" +
    " double import public let yield"
  ).split(" ");

  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

  for(var i=0, l=reservedWords.length; i<l; i++) {
    compilerWords[reservedWords[i]] = true;
  }

  JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
    if(!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)) {
      return true;
    }
    return false;
  };

  __exports__ = JavaScriptCompiler;
  return __exports__;
})(__module2__, __module5__);

// handlebars.js
var __module0__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var Handlebars = __dependency1__;

  // Compiler imports
  var AST = __dependency2__;
  var Parser = __dependency3__.parser;
  var parse = __dependency3__.parse;
  var Compiler = __dependency4__.Compiler;
  var compile = __dependency4__.compile;
  var precompile = __dependency4__.precompile;
  var JavaScriptCompiler = __dependency5__;

  var _create = Handlebars.create;
  var create = function() {
    var hb = _create();

    hb.compile = function(input, options) {
      return compile(input, options, hb);
    };
    hb.precompile = function (input, options) {
      return precompile(input, options, hb);
    };

    hb.AST = AST;
    hb.Compiler = Compiler;
    hb.JavaScriptCompiler = JavaScriptCompiler;
    hb.Parser = Parser;
    hb.parse = parse;

    return hb;
  };

  Handlebars = create();
  Handlebars.create = create;

  __exports__ = Handlebars;
  return __exports__;
})(__module1__, __module7__, __module8__, __module10__, __module11__);

  return __module0__;
})();

this["CUI"] = this["CUI"] || {};
this["CUI"]["imageeditor"] = this["CUI"]["imageeditor"] || {};
this["CUI"]["imageeditor"]["Templates"] = this["CUI"]["imageeditor"]["Templates"] || {};

this["CUI"]["imageeditor"]["Templates"]["crop-popover"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <button class=\"coral-Button popover-button\" name=\"aspectRatio\" value=\""
    + escapeExpression(((stack1 = depth0.ratio),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">"
    + escapeExpression(((stack1 = depth0.name),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</button><br/>\n  ";
  return buffer;
  }

  buffer += "<div class=\"coral-Popover-content imageeditor-popover-content\">\n  <button class=\"coral-Button popover-button\" name=\"aspectRatio\" value=\"removeCrop\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "removecrop", options) : helperMissing.call(depth0, "i18n", "removecrop", options)))
    + "</button><br/>\n  ";
  stack2 = helpers.each.call(depth0, depth0.aspectRatios, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["imageeditor"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"imageeditor-container\">\n  <div class=\"imageeditor-toolbars icongroup\"></div>\n  <div class=\"imageeditor-controls\">\n    <div class=\"imageeditor-imagemap-polygon-helper\"></div>\n    <div class=\"imageeditor-controls-map-areas\"></div>\n  </div>\n</div>\n";
  });

this["CUI"]["imageeditor"]["Templates"]["map-popover"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += "\n    <input class=\"coral-Textfield\" name=\"href\" type=\"url\" placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path", options) : helperMissing.call(depth0, "i18n", "path", options)))
    + "\" />\n  ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += "\n    <span class=\"coral-PathBrowser pathbrowser\" data-placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path", options) : helperMissing.call(depth0, "i18n", "path", options)))
    + "\" data-root-path=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.pathbrowser),stack1 == null || stack1 === false ? stack1 : stack1.rootPath)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n      <span class=\"coral-InputGroup\">\n        <input class=\"coral-InputGroup-input js-coral-pathbrowser-input coral-Textfield\" type=\"text\" name=\"href\">\n        <span class=\"coral-InputGroup-button\">\n          <button class=\"coral-Button coral-Button--secondary coral-Button--square js-coral-pathbrowser-button\" type=\"button\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path_picker", options) : helperMissing.call(depth0, "i18n", "path_picker", options)))
    + "\">\n            <i class=\"coral-Icon coral-Icon--sizeS coral-Icon--folderSearch\"></i>\n          </button>\n        </span>\n      </span>\n    </span>\n  ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, options;
  buffer += "\n    <span class=\"coral-DecoratedTextfield pathbrowser\" data-placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path", options) : helperMissing.call(depth0, "i18n", "path", options)))
    + "\" data-root-path=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.pathbrowser),stack1 == null || stack1 === false ? stack1 : stack1.rootPath)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n      <input class=\"js-coral-pathbrowser-input coral-Textfield\" type=\"text\" name=\"href\">\n    </span>\n  ";
  return buffer;
  }

  buffer += "<div class=\"imageeditor-map-toolbar toolbar\">\n  ";
  stack1 = helpers['if'].call(depth0, depth0.noPathbrowser, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, depth0.pathbrowserPicker, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, depth0.pathbrowserAutocomplete, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  <input class=\"coral-Textfield\" name=\"alt\" type=\"text\" placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "alt_text", options) : helperMissing.call(depth0, "i18n", "alt_text", options)))
    + "\" />\n  <span class=\"coral-Select\" data-init=\"select\">\n    <button class=\"coral-Select-button coral-MinimalButton\" type=\"button\">\n      <span class=\"coral-Select-button-text\"></span>\n    </button>\n    <select class=\"coral-Select-select\" name=\"target\">\n      <option value=\"\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "target", options) : helperMissing.call(depth0, "i18n", "target", options)))
    + "</option>\n      <option value=\"_self\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "same_tab", options) : helperMissing.call(depth0, "i18n", "same_tab", options)))
    + "</option>\n      <option value=\"_blank\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "new_tab", options) : helperMissing.call(depth0, "i18n", "new_tab", options)))
    + "</option>\n      <option value=\"_parent\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "parent_frame", options) : helperMissing.call(depth0, "i18n", "parent_frame", options)))
    + "</option>\n      <option value=\"_top\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "top_frame", options) : helperMissing.call(depth0, "i18n", "top_frame", options)))
    + "</option>\n    </select>\n  </span>\n  <span class=\"actions\">\n    <button class=\"coral-Button coral-Button--square coral-Button--warning imageeditor-map-delete\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "delete", options) : helperMissing.call(depth0, "i18n", "delete", options)))
    + "\">\n      <i class=\"coral-Icon coral-Icon--delete\"></i>\n    </button>\n    <button class=\"coral-Button coral-Button--square imageeditor-map-unlaunch\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "unlaunch", options) : helperMissing.call(depth0, "i18n", "unlaunch", options)))
    + "\">\n      <i class=\"coral-Icon coral-Icon--close\"></i>\n    </button>\n    <button class=\"coral-Button coral-Button--square coral-Button--primary imageeditor-map-confirm\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "confirm", options) : helperMissing.call(depth0, "i18n", "confirm", options)))
    + "\">\n      <i class=\"coral-Icon coral-Icon--check\"></i>\n    </button>\n  </span>\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["toolbar-item"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<button data-action=\"";
  if (stack1 = helpers.action) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.action; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (stack1 = helpers.title) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"\n        class=\"coral-Button coral-Button--quiet coral-Button--square ";
  if (stack1 = helpers.addClasses) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.addClasses; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">\n  <i class=\"coral-Icon coral-Icon--";
  if (stack1 = helpers.icon) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.icon; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"></i>\n</button>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["toolbar"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "\n      <div class=\"imageeditor-toolbar-"
    + escapeExpression(((stack1 = ((stack1 = data),stack1 == null || stack1 === false ? stack1 : stack1.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-hand-side\">\n        ";
  stack2 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program3(depth0,data) {
  
  var stack1;
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

  buffer += "<div data-id=\"";
  if (stack1 = helpers.ref) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.ref; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"imageeditor-toolbar\">\n  ";
  stack1 = helpers.each.call(depth0, depth0.toolbarItems, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["toolbars"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  buffer += "<div data-type=\"";
  if (stack1 = helpers.type) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.type; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">\n  ";
  if (stack1 = helpers.toolbar) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.toolbar; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers.each.call(depth0, depth0.replacementToolbars, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["zoomslider-popover"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"coral-Popover-content imageeditor-popover-content\">\n  <div class=\"coral-Slider popover-slider\" data-init=\"slider\">\n    <input type=\"range\" value=\"100\" min=\"";
  if (stack1 = helpers.zoomMin) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.zoomMin; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" max=\"";
  if (stack1 = helpers.zoomMax) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.zoomMax; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" step=\"1\">\n  </div>\n</div>\n";
  return buffer;
  });
/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, CSSRule, undefined) {
  'use strict';

  var eventOutsideOfEditor = function (e) {
    return $(e.target).closest('.imageeditor-container').length === 0;
  };

  var translate = function (rotation, flip, element, box, result) {
    var toggle;

    result = result || $.extend({}, box);

    rotation = rotation % 360; // [-270, 270]
    rotation = rotation + 360; // [  90, 630]
    rotation = rotation % 360; // [  90, 270]

    // change coords to point to 'new' top left
    if (box.hasOwnProperty('top') && box.hasOwnProperty('left')) {
      if (rotation % 180 === 0) {
        toggle = rotation !== 0;

        if (flip.horizontal ^ toggle) {
          result.left = element.width - box.width - box.left;
        }
        else {
          result.left = box.left;
        }
        if (flip.vertical ^ toggle) {
          result.top = element.height - box.height - box.top;
        }
        else {
          result.top = box.top;
        }
      }
      else {
        toggle = rotation !== 90;

        if (flip.vertical ^ toggle) {
          result.left = box.top;
        }
        else {
          result.left = element.height - box.height - box.top;
        }
        if (flip.horizontal ^ toggle) {
          result.top = element.width - box.width - box.left;
        }
        else {
          result.top  = box.left;
        }
      }
    }

    // switch dimensions if necessary
    if (rotation % 180 !== 0) {
      result.width = box.height;
      result.height = box.width;
    }
    else {
      result.width = box.width;
      result.height = box.height;
    }

    return result;
  };

  var isIosVersion7 = function() {
    if (navigator && navigator.userAgent) {
      return (/.*OS 7.{0,4} like Mac OS X.*/).test(navigator.userAgent);
    }
  };


  CUI.ImageEditor = new Class(/** @lends CUI.ImageEditor# */{
    toString: 'ImageEditor',

    extend: CUI.Widget,

    CSS_LAYOUT_CONSTRAINTS: {
      'min-height': 'minHeight',
      'min-width': 'minWidth',
      'max-height': 'maxHeight',
      'max-width': 'maxWidth'
      // don't include width and height here as they are often set without the intention of influencing the editor.
    },

    ZOOM_MIN: 0.1,
    ZOOM_MAX: 3,

    /**
     * Associative array of registered actions; values of type
     * {@link CUI.imageeditor.actions.Action}
     * @private
     * @type Object
     */
    registeredActions: null,

    /**
     * Associative array of registered plugins; values of type
     * {@link CUI.imageeditor.plugins.Plugin}
     * @private
     * @type Object
     */
    registeredPlugins: null,

    defaults: {}, // todo - in use?

    /**
     * The context of the editable element
     * @private
     * @type Object
     */
    elementContext: {},

    /**
     * The imageeditor user interface
     * @private
     * @type Object
     */
    $ui: {},

    /**
     * @extends CUI.Widget
     * @classdesc Adds image editing options toolbar to an image element. Options include cropping, rotation, flipping and masking.
     *
     * <h2 class='line'>Examples</h2>
     *
     * <h3>Default</h3>
     * <img id='myImage' src='http://example.com/images/sponge.png'/>
     *
     * @example
     * <caption>Instantiate with Class</caption>
     * var imageEditor = new CUI.ImageEditor({
     *     element: '#myImage'
     * });
     *
     * @example
     * <caption>Instantiate with jQuery</caption>
     * $('#myImage').imageEditor({
     *     todo - add example options
     * });
     *
     * @description Creates a new image editor
     * @constructs
     *
     * @param  {Object} options Component options
     */
    construct: function (options) {
      this.options = options || {};
      this.i18n = new CUI.imageeditor.I18nProvider();
    },

    // Plugin configuration
    // ----------------------------------------------------------

    /**
     *
     * @param {Object} config The config object to be used for configuration
     * @private
     */
    configurePluginsAndActions: function (config) {
      var pluginConfig = config.plugins || {},
          plugin;

      for (var pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          plugin = this.registeredPlugins[pluginId];

          plugin.notifyPluginConfig(pluginConfig[pluginId]);
        }
      }
      for (var actionId in this.registeredActions) {
        if (this.registeredActions.hasOwnProperty(actionId)) {
          plugin = this.registeredActions[actionId];

          plugin.notifyPluginConfig(pluginConfig[actionId]);
        }
      }
    },

    /**
     * <p>Registers a UI-related event handler.</P>
     * <p>Currently the following events are supported:</p>
     * <ul>
     *   <li>updatestate - signals a selection state change</li>
     *   <li>preventdrop - signals that drag & drop on the text component should be
     *     temporarily disabled</li>
     *   <li>reactivatedrop - signals that drag & drop on the text component should be
     *     reactivated</li>
     *   <li>enablesourceedit - signals that source edit mode is requested</li>
     *   <li>disablesourceedit - signals that WYSIWYG edit mode is requested</li>
     *   <li>dialogshow - signals that a dependent dialog has been shown</li>
     *   <li>dialoghide - signals that a dependent dialog has been hidden</li>
     * </ul>
     * @param {String} eventName Event name (see doc for supported values)
     * @param {Function} fn Event handler function
     * @param {Object} scope Scope for fn
     * @private
     */
    bindUIListener: function (eventName, fn, scope) {
      fn = scope ? $.proxy(fn, scope) : fn;

      this.$ui.on(eventName, fn);
    },

    isAnimated : function () {
      return !!this._isAnimated;
    },

    toggleAnimation : function (enable) {
      this._isAnimated = enable;
      // Calling position() to ensure, that the browser is properly
      // positioning all elements, before transitions are activated or
      // deactivated
      if (this.$element) {
        this.$element.position();
        this.$element.toggleClass('imageeditor-editable-animate', enable);
      }
      if (this.$ui) {
        this.$ui.position();
        this.$ui.toggleClass('imageeditor-container-animate', enable);

        if (this.$ui.copy) {
          this.$ui.copy.position();
          this.$ui.copy.toggleClass('imageeditor-editable-copy-animate', enable);
        }
      }
    },

    withoutAnimation : function (callback) {
      if (!this.isAnimated()) {
        return callback.call(this);
      }

      var result;

      this.toggleAnimation(false);

      result = callback.call(this);

      this.toggleAnimation(true);

      return result;
    },
    // User interface --------------------------------------------------------------------

    /**
     * Start editing
     * @param {Object} options The image editor options
     */
    start: function (options) {
      options = options || {};

      this.setupTemplates(options.templates);

      this.setupElementContext();

      this._zoomFactor = options.zoomFactor;
      if (!this._zoomFactor) {
        this._zoomFactor = this.options.zoomFactor;
      }
      if (!this._zoomFactor) {
        this._zoomFactor = 1.0;
      }

      this.createUI();
      if (this.preferCopy()) {
        this.options.image = $(this.options.image);
        this.$ui.copy = this.options.image.addClass('imageeditor-editable-copy');
      }
      else {
        this.$ui.copy = this.$element.clone().addClass('imageeditor-editable-copy');
      }

      this.$ui.copy.css('margin', 0);

      this.$ui.prepend(this.$ui.copy);

      // Register actions
      this.registeredActions = CUI.imageeditor.actions.ActionRegistry.createRegisteredActions(this);

      // Register and configure plugins
      this.registeredPlugins = CUI.imageeditor.plugins.PluginRegistry.createRegisteredPlugins(this);
      this.configurePluginsAndActions(options);

      // Create transform result which stores current state of editing
      this.transformResult = this.createTransformResult(options.result);

      // Overlay img with editing UI
      this.installUI();

      // Create the toolbar
      this.createToolbar(options);

      if (this.options.mode === 'fullscreen') {
        this.switchToFullscreen();
      }
      else {
        this.switchToInline();
      }

      // Eventing
      this.setupEventHandling();

      // Everything ready, trigger an edit start event
      this.$element.trigger('editing-start');
    },

    preferCopy : function () {
      if (this.options.image && $(this.options.image).length) {
        this.preferCopy = function () { return true; };
      }
      else {
        this.preferCopy = function () { return false; };
      }
      return this.preferCopy();
    },

    /**
     * cancel editing
     */
    cancel: function () {
      this.destroyEventHandling();
      this.destroyUI();
      this.$element.trigger('editing-cancelled');
    },

    /**
     * Finish editing
     */
    finish: function () {
      this.destroyEventHandling();
      this.destroyUI();
      this.$element.trigger('editing-finished', {result: this.transformResult.toJSON()});
    },

    /**
     * Calculate the natural size of an HTML image element
     * @param {HTMLElement} img The image element to test
     * @return {Object} The dimension object
     *
     * TODO maybe dead code - anybody using this externally?
     */
    getImageNaturalSize: function (img) {
      var $img = img,
          dim = {},
          tempImage = new Image();

      tempImage.src = $img.attr('src');

      dim.w = tempImage.width;
      dim.h = tempImage.height;

      return dim;
    },

    // Toolbar building
    // ----------------------------------------------------------

    /**
     * Create the toolbar
     * @param {Object} options (optional) options
     */
    createToolbar: function (options) {
      var pluginId, plugin, toolbar,
          toolbarBuilder = this.createToolbarBuilder();

      options = $.extend({}, {'$editable': this.$ui}, options);

      // Give plugins chance to register toolbar items
      for (pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          plugin = this.registeredPlugins[pluginId];
          plugin.initializeUI(toolbarBuilder, options);
        }
      }

      // Create the abstracted toolbar
      this.toolbars = {};
      this.$ui.toolbars = {};


      toolbar = toolbarBuilder.createToolbar(options, 'inline');
      if (toolbar) {
        this.toolbars.inline = toolbar;
        this.$ui.toolbars.inline = this.toolbars.inline.getToolbars();
      }

      toolbar = toolbarBuilder.createToolbar(options, 'fullscreen');
      if (toolbar) {
        this.toolbars.fullscreen = toolbar;
        this.$ui.toolbars.fullscreen = this.toolbars.fullscreen.getToolbars();
      }
    },

    getToolbarHeight: function () {
      var max = 0,
        maxSearcher = function (idx, v) {
          var height = $(v).height();
          if (height > max) {
            max = height;
          }
        };

      this.$ui.find('.imageeditor-toolbar').each(maxSearcher);
      return max;
    },

    /**
     * Create an instance of {@link CUI.imageeditor.ui.ToolbarBuilder}
     * @return {CUI.imageeditor.ui.ToolbarBuilder} The toolbar builder instance to be used
     */
    createToolbarBuilder: function () {
      return new CUI.imageeditor.ui.ToolbarBuilder({templates: this.templates});
    },

    // Transformation result
    // ----------------------------------------------------------

    /**
     * Creates an instance of {@link CUI.imageeditor.TransformResult}.
     * Expects this.registeredPlugins to be setup.
     *
     * @return {TransformResult}
     *
     * @private
     **/
    createTransformResult: function (initialSettings) {
      var pluginId, plugin,
          result = new CUI.imageeditor.TransformResult(),
          plugins = this.registeredPlugins;

      // Each plugin has the opportunity to register its own transform fields
      for (pluginId in plugins) {
        if (plugins.hasOwnProperty(pluginId)) {
          plugin = plugins[pluginId];
          plugin.registerTransformFields(result);
        }
      }

      if (initialSettings) {
        result.setTransformValues(initialSettings, false);
      }

      return result;
    },

    // Event handling
    // ----------------------------------------------------------

    setupEventHandling: function () {
      var self = this;

      // Out of area clicks
      this.$element.parents('body').add(document.body).on('tap.imageeditor-ooa click.imageeditor-ooa', function (e) {
        if (eventOutsideOfEditor(e) && !CUI.imageeditor.UIUtils.isHavingModalParent(e.target)) {
          self.finish();
        }
      });

      // Reposition UI on window resize
      $(window).on('resize.imageeditor orientationchange.imageeditor', function () {
        self.withoutAnimation(function () {
          self.updatePreview();
        });
      });

      // Listen for close requests and prompt a finish
      this.bindUIListener('requestclose', this.finish, this);
    },

    destroyEventHandling: function () {
      this.$element.parents('body').add(document.body).off('.imageeditor-ooa');
      $(window).off('.imageeditor');
    },

    // Form submission logic
    // ----------------------------------------------------------

    submit: function () {
      // todo - handle form submission
      $.ajax({
        type: 'POST',
        url:  'action',
        data: JSON.stringify(this.transformResult.toJSON()),
        success: function () {
          // todo
        },
        error: function () {
          // todo
        }
      });
    },

    // User interface utilities
    // ----------------------------------------------------------

    /**
     * Build the basic UI with placeholders/containers for interaction
     * elements.
     *
     * Needs this.$element to be present
     * Sets this.$ui
     * @private
     */
    createUI : function () {
      var uiTpl = this.templates.get('imageeditor');

      this.$ui = $(uiTpl({}));

      // Apply themeing
      if (this.options.theme === 'dark') {
        this.$ui.attr('data-theme', 'dark');
        this.$ui.addClass('coral--dark');
      }
      else {
        this.$ui.removeAttr('data-theme');
        this.$ui.removeClass('coral--dark');
      }
    },

    getMode : function () {
      return (this.$ui.attr('data-mode') === 'fullscreen') ? 'fullscreen' : 'inline';
    },

    setMode : function (mode) {
      if (mode === 'fullscreen') {
        this.switchToFullscreen();
      }
      else if (mode === 'inline') {
        this.switchToInline();
      }
    },

    switchToFullscreen : function (ignoreOptions) {
      if (!this.toolbars.fullscreen && !ignoreOptions) {
        return this.switchToInline(true);
      }

      this.$ui.attr('data-mode', 'fullscreen');
      this.togglePinchZooming(true);
      this.withoutAnimation(function () {
        this.updatePreview();
        this.scaleToFitForFullscreen();
      });
    },

    switchToInline : function (ignoreOptions) {
      if (!this.toolbars.inline && !ignoreOptions) {
        return this.switchToFullscreen(true);
      }

      this.$ui.attr('data-mode', 'inline');
      this.togglePinchZooming(false);
      this.withoutAnimation(function () {
        // update the element in pageflow so as to reflow page depending on eventual changes:
        this.$element.css(this.createTranslationUtil().getZoomedDimensions());
        this.updatePreview();
      });
    },


    installStylesheet : function () {
      var theirDoc, theirStyleElement, theirStyleSheet, i, j, rules, rule,
          myStyle,
          REGEXP = /\.imageeditor-editable(-animate)?/;

      theirDoc = this.$element.parents('html').get(0).parentNode;

      if (theirDoc.getElementById('imageeditor-editable-stylesheet')) {
        return;
      }

      theirStyleElement = theirDoc.createElement('style');
      theirStyleElement.id = 'imageeditor-editable-stylesheet';
      theirDoc.getElementsByTagName('head')[0].appendChild(theirStyleElement);

      for (i = 0; i < theirDoc.styleSheets.length; i++) {
        if (theirDoc.styleSheets[i].ownerNode === theirStyleElement) {
          theirStyleSheet = theirDoc.styleSheets[i];
          break;
        }
      }

      if (document.styleSheets !== null && theirStyleSheet !== null) {
        for (i = 0; i < document.styleSheets.length; i++) {
          myStyle = document.styleSheets[i];
          // Accessing cssRules throws a Security Exception in FF
          // under certain conditions. This should be handled more
          // gracefully, but I could not come up with a proper
          // workaround.
          try { rules = myStyle.cssRules; } catch (e) { continue; }

          if (rules !== null) {
            for (j = 0; j < rules.length; j++) {
              rule = rules[j];
              if (rule.type === CSSRule.STYLE_RULE && REGEXP.test(rule.selectorText)) {
                theirStyleSheet.insertRule(rule.cssText, theirStyleSheet.cssRules.length);
              }
            }
          }
        }
      }
    },

    /**
     * Overlay img with editing UI
     */
    installUI : function () {
      var dimensions;

      if (this.options.parent) {
        $(this.options.parent).append(this.$ui);
      }
      else {
        this.$element.after(this.$ui);
      }

      this.$clipParent = CUI.imageeditor.UIUtils.getClippingParent(this.$ui);
      this.uiClipped = (this.$clipParent !== undefined);

      this.$element.addClass('imageeditor-editable');

      // FIXME: Best effort - using whichever dimensions work. Ideally we
      // would wait until the copy was loaded. User can specify dimensions also via options.overrides.naturalHeight/Width
      if (this.preferCopy()) {
        dimensions = {
          width: this.$ui.copy.width(),
          height: this.$ui.copy.height()
        };
      }
      else {
        dimensions = {
          width: this.$element.width(),
          height: this.$element.height()
        };
      }

      if (this.options.overrides && this.options.overrides.naturalHeight && this.options.overrides.naturalWidth) {
        dimensions = {
          height: this.options.overrides.naturalHeight,
          width: this.options.overrides.naturalWidth
        };
      }

      this._naturalDimensions = dimensions;
      this.$ui.copy.data('imageeditor-dimensions', dimensions);
      this._layoutConstraints = {
        'max-width': this.$ui.copy.css('max-width'),
        'max-height': this.$ui.copy.css('max-height'),
        'min-width': this.$ui.copy.css('min-width'),
        'min-height': this.$ui.copy.css('min-height')
      };

      this.$element.css(this.getBaseCssPropertiesForElement());
      this.$ui.copy.css('margin', 0); // set here because baseCssProperties are also used as a base to add margin-left etc.
      this.$ui.copy.css(this.getBaseCssPropertiesForCopy());

      // start with something, will be reset later to required size:
      this.$ui.css({
        height : dimensions.height + 'px',
        width  : dimensions.width + 'px'
      });

      if (this.elementContext.iframe !== null) {
        this.installStylesheet();
      }

      this.toggleAnimation(true);
    },

    /**
     * Place the editing UI over the original element
     */
    positionUI : function (using) {
      var fixPositionForIframe = $.proxy(function (position, data) {
        /**
         * Available coordinates:
         *
         *    this.$ui.offset({top: data.element.top, left: data.element.left});
         * or
         *    this.$ui.css(position);
         *
         */

        if (this.elementContext.iframe) {
          var iframe = $(this.elementContext.iframe);
          var iOffset = $(this.elementContext.iframe).offset();

          // TODO: This approach is incomplete. It only works as long as the
          // iframe and this.$ui have the same offsetParent() - I think.
          // Also needs verification in WCM context.
          position.left += iOffset.left + parseInt(iframe.css('border-left-width'), 10);
          position.top  += iOffset.top  + parseInt(iframe.css('border-top-width'),  10);
        }

        // Make sure the toolbar is visible on screen by offsetting the position
        position.top = Math.max(position.top, this.$ui.toolbars.inline.height());

        if ($.isFunction(using)) {
          using.call(this, position);
        }
        else {
          this.$ui.css(position);
        }
      }, this);

      this.$ui.position({
        using      : fixPositionForIframe,
        of         : this.$element,
        my         : 'left top',
        at         : 'left top',
        collision  : 'none'
      });
    },

    togglePinchZooming : function (enable) {
      var self = this,
        ZOOM_NS = '.imageeditorzoom';

      CUI.imageeditor.UIUtils.removePinchZooming(self.$ui, ZOOM_NS);
      if (enable) {
        CUI.imageeditor.UIUtils.installPinchZooming(self.$ui, ZOOM_NS,
          function () {
            return self.getZoomFactor();
          },
          function (newFactor, changeOrEnd) {

            if (changeOrEnd === 'change') {
              self.zoom(newFactor, false);
            } else {
              self.zoom(newFactor, true); // animate last move
            }
          }
        );
      }
    },

    getBaseCssPropertiesForCopy : function () {
      var translationUtil = this.createTranslationUtil(),
        dimensions = translationUtil.getZoomedDimensionsBeforeRotation();

      return {
        'max-width': '9999px',
        'max-height': '9999px',
        'min-width': '0px',
        'min-height': '0px',
        'height': '' + dimensions.height + 'px',
        'width': '' + dimensions.width + 'px',
        'clip': 'rect(0px, ' +
                dimensions.width + 'px, ' +
                dimensions.height + 'px, 0px)',
        'transform-origin': '50% 50%',
        'transform': 'scale(1)'
      };
    },

    getBaseCssPropertiesForElement : function () {
      var dimensions = this.createTranslationUtil().getZoomedDimensionsBeforeRotation();

      return {
        width  : dimensions.width,
        height : dimensions.height
      };
    },

    /**
     * Destroy the UI
     */
    destroyUI: function () {
      var dimensions = this.$ui.copy.data('imageeditor-dimensions');

      this.$ui.remove();

      this.toggleAnimation(false);
      this.$element.removeClass('imageeditor-editable');
      this.$element.css(dimensions);
    },

    /**
     * Sets up the context of the editable element.
     */
    setupElementContext: function () {
      this.elementContext = this.elementContext || {};
      this.elementContext.iframe = CUI.imageeditor.UIUtils.elementInIframe(this.$element);

      if (this.elementContext.iframe === null) {
        this.elementContext.win = window;
        this.elementContext.doc = document;
      }
      else {
        this.elementContext.win = this.elementContext.iframe.contentWindow;
        this.elementContext.doc = this.elementContext.iframe.contentWindow.document;
      }
    },

    // Actions
    // ----------------------------------------------------------

    /**
     * @private
     */
    getCustomAction: function (action) {
      var actn, actionToCheck,
          customAction = this.registeredActions[action];

      if (customAction) {
        return customAction;
      }
      for (actn in this.registeredActions) {
        actionToCheck = this.registeredActions[actn];
        if (actionToCheck.isAction(action)) {
          return actionToCheck;
        }
      }
      return null;
    },

    /**
     * Executes an editor action on the image and performs necessary focus and
     * toolbar updates. Actions that are not supported by a specific browser are emulated
     * accordingly. <b>This should only be called after the editor is initialized.</b>
     * @param {String} action The action
     * @param {Object} value (optional) The value to pass to the action (defaults to null)
     */
    relayAction: function (action, value) {
      CUI.imageeditor.Utils.defer(function () {
        this.execAction(action, value);
      }, 10, this);
    },

    /**
     * Executes an editor action directly. For visual actions, you
     * should use {@link #relayAction} instead. Actions that are not supported by a specific
     * browser are emulated accordingly. <b>This method should only be called after the
     * editor is initialized. Otherwise, it will return immediately if the action is not
     * explicitly flagged for use in uninitialized state.</b>
     * @param {String} action The action
     * @param {Object} value (optional) The value to pass to the action (defaults to null)
     */
    execAction: function (action, value){
      // check if a custom action has to be used instead of browser's implementation
      var customAction = this.getCustomAction(action),
        self = this,
        execRet, execOptions,
        rotation   = this.getRotation(),
        dimensions = this.getImageDisplayDimensions(),
        toolbarHeight = this.getToolbarHeight(),
        viewportCrop = this.getViewportCrop(),
        canvas     = this.getCrop(),
        flip       = this.getFlip();

      delete canvas.right;
      delete canvas.bottom;

      execOptions = {
        action     : action,
        value      : value,
        element    : this.$ui.copy,
        editor     : this,
        ui         : this.$ui,
        result     : this.transformResult,
        mode       : this.getMode(),

        dimensions : dimensions,
        viewportCrop: viewportCrop,
        toolbarHeight: toolbarHeight,
        canvas     : canvas,
        rotation   : rotation,
        flip       : flip,

        translate  : function (box) {
          return translate(rotation, flip, dimensions, box);
        },

        createTranslationUtil : function () {
          return self.createTranslationUtil();
        }
      };

      if (customAction) {
        execRet = customAction.execute(execOptions);
      }

      if (execRet) {
        this.updatePreview();
      }

      return execRet;
    },

    /**
     * @returns {{width: number, height: number}}
     */
    getViewportCrop : function () {
      var hiddenByToolbar,
        translationUtil = this.createTranslationUtil(),
        fullscreenUiDims = {
          top: 0,
          left: 0,
          width: this.$ui.width(),
          height: this.$ui.height()
        },
        $window = $(window),
        pageUiDims,
        imageDimsRotated = translationUtil.rotateDimsIfNecessary(translationUtil.getZoomedCropBeforeRotation()),
        toolbarHeight = this.getMode() === 'fullscreen' ? this.getToolbarHeight() : 0,
        imageOnPage, translatedCrop, imageOffset, imageViewport;

      if (this.getMode() === 'inline') {
        translatedCrop = translationUtil.translate( translationUtil.getZoomedCropBeforeRotation());
        imageOffset = this.$ui.copy.offset();
        imageOnPage = {
          left: imageOffset.left + translatedCrop.left,
          top: imageOffset.top + translatedCrop.top,
          width: translatedCrop.width,
          height: translatedCrop.height
        };
        pageUiDims = {
          top: $window.scrollTop(),
          left: $window.scrollLeft(),
          width: $window.width(),
          height: $window.height()
        };
        imageViewport = {
          left: Math.max(pageUiDims.left, imageOnPage.left),
          top: Math.max(pageUiDims.top, imageOnPage.top),
          right: Math.min(pageUiDims.left + pageUiDims.width, imageOnPage.left + imageOnPage.width),
          bottom: Math.min(pageUiDims.top + pageUiDims.height, imageOnPage.top + imageOnPage.height)
        };
        imageViewport = {
          left: Math.max(0, imageViewport.left - imageOnPage.left),
          top: Math.max(0, imageViewport.top - imageOnPage.top),
          width: Math.max(0, imageViewport.right - imageViewport.left),
          height: Math.max(0, imageViewport.bottom - imageViewport.top)
        };

      } else {
        // fullscreen mode:
        imageViewport = {
          width: Math.min(imageDimsRotated.width, fullscreenUiDims.width),
          height: Math.min(imageDimsRotated.height, fullscreenUiDims.height - toolbarHeight)
        };
        if (imageViewport.width < imageDimsRotated.width) {
          imageViewport.left = (imageDimsRotated.width - imageViewport.width)/2;
        } else {
          imageViewport.left = 0;
        }

        if (imageViewport.height < imageDimsRotated.height) {
          hiddenByToolbar = Math.max(0, Math.min(toolbarHeight, imageDimsRotated.height - imageViewport.height));
          imageViewport.top = hiddenByToolbar + (imageDimsRotated.height - imageViewport.height - hiddenByToolbar)/2;
        } else {
          imageViewport.top = 0;
        }
      }

      return imageViewport;
    },

    /**
     * The size of the image on the ui including zoom - not taking into account crop. This
     * is different from natural, display and zoom sizes.
     */
    getImageDisplayDimensions : function (rotated) {
      return {
        width : this.$ui.copy.width(),
        height : this.$ui.copy.height()
      };
    },

    createTranslationUtil : function () {
      var options = $.extend({}, this.options);

      options.flip = this.getFlip();
      options.rotation = this.getRotation();
      options.zoomFactor = this.getMode() === 'inline' ? 1.0 : this.getZoomFactor();
      options.naturalWidth = this._naturalDimensions.width;
      options.naturalHeight = this._naturalDimensions.height;
      options.cropOnOriginal = this.getCrop();

      if (!this.availableButNotFalse(options, 'ignoreCssLayoutConstraints')) {
        this.copyIfAvailable(options, this._layoutConstraints, this.CSS_LAYOUT_CONSTRAINTS);
      }
      this.copyIfAvailable(options, this.options, this.CSS_LAYOUT_CONSTRAINTS);
      this.copyIfAvailable(options, this.options, {'width': 'fixedWidth', 'height': 'fixedHeight'});

      return new CUI.imageeditor.TranslationUtil(options);
    },

    copyIfAvailable : function (target, src, namesMapping) {
      var toSet = null, key, targetName;

      if (!$.isPlainObject(namesMapping)) {
        namesMapping = {namesMapping: namesMapping};
      }

      for (key in namesMapping) {
        if (!namesMapping.hasOwnProperty(key)) {
          continue;
        }
        targetName = namesMapping[key];
        if (!targetName) {
          targetName = key;
        }

        toSet = src[key];
        if (!toSet) {
          toSet = src[key.toLowerCase()];
        }
        if (!toSet) {
          toSet = src[targetName];
        }
        if (!toSet) {
          toSet = src[targetName.toLowerCase()];
        }

        if (toSet) {
          target[targetName] = toSet;
        }
      }
    },

    availableButNotFalse: function (obj, propertyName) {
      var value = obj[propertyName];
      if (!obj) {
        return false;
      }
      if (obj.hasOwnProperty(propertyName)) {
        value = obj[propertyName];
        if (typeof value === 'string' &&
          value.toLowerCase() in ['no', 'false']) {
          return false;
        }
        return true;
      } else {
        return false;
      }
    },

    getCssPropertiesForCopy : function () {
      var css = this.getBaseCssPropertiesForCopy(),
          translationUtil = this.createTranslationUtil(),
          cssPart, name, attr;

      for (name in this.registeredActions) {
        if (this.registeredActions.hasOwnProperty(name)) {

          cssPart = this.registeredActions[name].toCss(this.transformResult, this.$ui.copy, translationUtil);

          if (!cssPart) {
            continue;
          }

          for (attr in cssPart) {
            if (cssPart.hasOwnProperty(attr)) {

              if (attr === 'transform') {
                // transforms are stacked
                css[attr] += ' ' + cssPart[attr];
              }
              else {
                css[attr] = cssPart[attr];
              }

            }
          }
        }
      }

      return css;
    },

    getCrop : function () {
      var crop;

      if (this.registeredActions.crop) {
        crop = this.registeredActions.crop.getCurrent(this.transformResult);
      }

      if (!crop) {
        var baseDimensions = this._naturalDimensions;

        crop = {
          top    : 0,
          left   : 0,
          width  : baseDimensions.width,
          height : baseDimensions.height
        };
      }

      return crop;
    },

    getRotation : function () {
      var rotate;

      if (this.registeredActions.rotate) {
        rotate = this.registeredActions.rotate.getCurrent(this.transformResult);
      }

      if (isNaN(rotate)) {
        rotate = 0;
      }

      return rotate;
    },

    getFlip : function () {
      var flip;

      if (this.registeredActions.flip) {
        flip = this.registeredActions.flip.getCurrent(this.transformResult);
      }

      if (!flip) {
        flip = {
          horizontal : false,
          vertical   : false
        };
      }

      return flip;
    },

    getZoomFactor : function () {
      return this._zoomFactor;
    },

    getZoomLimits : function () {
      return [this.ZOOM_MIN, this.ZOOM_MAX];
    },

    /**
     * Zoom the picture (fullscreen only).
     * @param newZoomFactor {number} 1 is 100%, 0.5 is 50%, 2 is 200%
     * @param animate {boolean} if true then normal animation will be used, else animation will be disabled
     */
    zoom : function (newZoomFactor, animate) {
      var limitedFactor = Math.min(this.ZOOM_MAX, Math.max(this.ZOOM_MIN, newZoomFactor)),
        self = this;

      // limit to steps of 1 % or 0.01:
      limitedFactor = Math.round(limitedFactor * 100) /100.0;

      if (limitedFactor !== this._zoomFactor) {
        this._zoomFactor = limitedFactor;
        if (animate) {
          this.updatePreview();
        } else {
          this.withoutAnimation(function () {
            self.updatePreview();
          });
        }
      }
    },

    getCssPropertiesForElement : function (css) {
      var translationUtil = this.createTranslationUtil(),
          baseDimensions = translationUtil.getZoomedDimensionsBeforeRotation(),
          dimensions = {},
          crop = translationUtil.getZoomedCropBeforeRotation(),
          rotation = this.getRotation();

      dimensions.width  = crop.width;
      dimensions.height = crop.height;

      css['margin-top']  = - crop.top;
      css['margin-right']  = - (baseDimensions.width - (crop.left + crop.width));
      css['margin-bottom'] = - (baseDimensions.height - (crop.top + crop.height));
      css['margin-left']   = - crop.left;

      if (rotation % 180 !== 0) {
        // switch dimensions
        var height = dimensions.width;
        dimensions.width = dimensions.height;
        dimensions.height = height;

        // move copy appropiately
        var change = (dimensions.width - dimensions.height) / 2;

        css['margin-left']   += change;
        css['margin-right']  += change;
        css['margin-top']  -= change;
        css['margin-bottom'] -= change;
      }

      if (this.getMode() === 'fullscreen') {
        css['margin-top']  -= Math.floor(dimensions.height / 2);
        css['margin-right']  -= Math.floor(dimensions.width  / 2);
        css['margin-bottom'] -= Math.floor(dimensions.height / 2);
        css['margin-left']   -= Math.floor(dimensions.width  / 2);
      }

      return dimensions;
    },

    getCssPropertiesForContainer : function (newDimensions) {
      if (this.getMode() === 'fullscreen') {
        return this.getCssPropertiesForContainerFullscreen(newDimensions);
      }
      else {
        return this.getCssPropertiesForContainerInline(newDimensions);
      }
    },

    getCssPropertiesForContainerFullscreen : function (newDimensions) {
      return {
        left: '',
        top : ''
      };
    },

    getCssPropertiesForContainerInline : function (newDimensions) {
      var newPosition,
        oldDimensions = {
          width : this.$element.width(),
          height: this.$element.height()
        };

      this.withoutAnimation(function () {
        this.$element.css(newDimensions);

        this.positionUI(function (position) { newPosition = position; });

        this.$element.css(oldDimensions);
      });

      return newPosition;
    },

    updatePreview : function () {
      var cssForCopy = this.getCssPropertiesForCopy(),
          cssForElem = this.getCssPropertiesForElement(cssForCopy),
          cssForCont = this.getCssPropertiesForContainer(cssForElem);

      this.$element.css(cssForElem);
      // TODO remove this iOS 7-specific workaround when we stop to support iOS 7
      if (isIosVersion7()) {
        this.updateClipForIosV7(cssForCopy);
      } else {
        this.$ui.copy.css(cssForCopy);
      }
      this.$ui.css(cssForCont);
    },

    scaleToFitForFullscreen : function () {
      var viewcrop = this.getViewportCrop(),
        translationUtil = this.createTranslationUtil(),
        zoomedCrop = translationUtil.translate(translationUtil.getZoomedCropBeforeRotation(), 'zoomed'),
        factor = 1.0, factorTemp;

      if (zoomedCrop.width > viewcrop.width) {
        factor = viewcrop.width / zoomedCrop.width;
      }

      if (zoomedCrop.height > viewcrop.height) {
        factorTemp = viewcrop.height / zoomedCrop.height;
        if (factorTemp < factor) {
          factor = factorTemp;
        }
      }

      this.zoom(this.getZoomFactor() * factor, true);
    },

    updateClipForIosV7 : function (cssForCopy) {
      // CQ-25204 - iOS 7 not hiding overflow areas on clip update without animation
      var copy = this.$ui.copy;
      var clipToSet = cssForCopy.clip || '';
      var currentClip = copy.css('clip');
      if (clipToSet.replace(/, ?/g,' ') === currentClip || (clipToSet === 'rect(0px, 0px, 0px, 0px)' && currentClip === 'auto')) {

        copy.css(cssForCopy);
      } else {
        cssForCopy['clip'] = 'rect(0px, 0px, 0px, 0px);';
        copy.css(cssForCopy);
        setTimeout(function() {
          // this has to happen with an animation
          copy.css('clip', clipToSet);
        }, 1000); // cannot be too short or the bug appears
      }
    },

    /**
     * Allows setting up a custom template provider, if the `start()` template
     * option is not flexible enough.
     *
     * Be sure, to call this before `start()` is called. Otherwise, it may not
     * be possible to override all templates.
     *
     * @param {Object} templates HashMap with template name as key and template
     *                           function as value
     *                        or CUI.imageeditor.TemplateProvider instance
     *                        or else - the default templates will be used
     */
    setupTemplates : function (templates) {
      if (templates && $.isFunction(templates.get)) {
        this.templates = templates;
      }
      else if ($.isPlainObject(templates)) {
        this.templates = new CUI.imageeditor.TemplateProvider(templates);
      }
      else if (!this.templates) {
        this.templates = new CUI.imageeditor.TemplateProvider();
      }
    }
  });

  // Register jQuery plugin
  CUI.util.plugClass(CUI.ImageEditor, 'imageEditor', function (imageeditor) {
    CUI.imageeditor.OptionsUtils.loadOptionsAndStartEditing(imageeditor, $(this));
  });

  // Data API
  if (CUI.options.dataAPI) {
    $(function () {
      $(document.body).on('click.imageeditor.data-api', 'img[data-editable="true"],img[data-editable=""]',
        function (e) {
          if (eventOutsideOfEditor(e) && !CUI.imageeditor.UIUtils.isHavingModalParent(e.target)) {
            $(this).imageEditor();
          }
        });
    });
  }
}(jQuery, this, window.CSSRule));

(function ($, window, undefined) {

  var CLASS_PANE_LIST = 'coral-TabPanel-content',
      CLASS_TAB_LIST = 'coral-TabPanel-navigation',

      SELECTOR_TAB_LIST = '.' + CLASS_TAB_LIST,
      SELECTOR_PANE_LIST = '.' + CLASS_PANE_LIST;

  CUI.Tabs = new Class(/** @lends CUI.Tabs# */{
    toString: 'Tabs',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc A group of tabs.
     *
     * @description Creates a new tab panel
     * @constructs
     *
     * @param  {Object} options Component options
     * @param  {Mixed} options.element jQuery selector or DOM element to use for panel
     * @param  {String} [options.type=""] Style type of the tabs. Can be
     * "stacked", "nav", or left blank (infers the default type).
     * @param  {Number} [options.active=0] index of active tab
     */
    construct: function (options) {

      this.tablist = this._findOrCreateTabList();
      this.panelist = this._findOrCreatePaneList();

      this._applyOptions();

      // set up listeners for change events
      this.$element.on('change:type', this._setType.bind(this));
      this.$element.on('change:active', this._setActive.bind(this));
    },

    defaults: {},

    // Note: the white tabs variant is deprecated, and will be removed in a future release
    // See https://issues.adobe.com/browse/CUI-1156 and https://issues.adobe.com/browse/CUI-1154
    DEFAULT_VARIANT_KEY: 'default',

    VARIANT_TYPES: [
      'default',
      'stacked',
      'nav'
    ],

    VARIANT_CLASS_MAPPING: {
      'default': '',
      'stacked': 'coral-TabPanel--stacked',
      'nav': 'coral-TabPanel--large'
    },

    /**
     * Disables a tab
     * @param  {jQuery} tab
     * @return {jQuery} this, chainable
     */
    setDisabled: function (tab, switcher) {
      var hop = switcher || false;

      tab.toggleClass('is-disabled', hop)
        .prop('aria-disabled', hop);
      return this;
    },

    /**
     * Enables a tab
     * @param  {jQuery} tab
     * @return {jQuery} this, chainable
     */
    setEnabled: function (tab) {
      return this.setDisabled(tab, true);
    },

    /**
     * Adds a tab and associated panel.
     *
     * @param {Object} [options] Tab options.
     * @param {String|HTMLElement|jQuery} [options.tabContent] Content to be
     * used inside the tab. This can be an HTML string, a DOM node,
     * or a jQuery object. This content will be wrapped by an
     * internally-created element that will serve as the tab.
     * @param {String|HTMLElement|jQuery} [options.panelContent] Content to be
     * used inside the panel. This can be an HTML string, a DOM node,
     * or a jQuery object. This content will be wrapped by an internally-created
     * element that will serve as the panel. This is not intended to be
     * used when options.panelURL is defined.
     * @param {String} [options.panelURL] A URL from which to asynchronously
     * load the panel content when the tab is activated. This is not intended
     * to be used when options.panelContent is defined.
     * @param {String} [options.panelID] An ID to be applied to the
     * internally-created panel. If one is not provided, a unique ID will be
     * generated for the panel.
     * @param {Number} [options.index] The index at which the tab should be
     * added. If no index is provided, the tab will be added as the last
     * tab.
     * @param {Boolean} [options.enabled=true] Whether the tab should be
     * enabled (disabled tabs cannot be selected).
     * @param {Boolean} [options.active=true] Whether the tab should be
     * immediately activated/selected. In other words, its panel will be
     * immediately visible and panels for other tabs will be hidden.
     *
     * @return {String} The ID of the panel. If options.panelID was defined,
     * this will be the same value. If options.panelID was not defined,
     * this will be an internally-generated, unique ID.
     */
    addItem: function(options) {
      var tabs = this._getTabs();

      options = $.extend({
        tabContent: '',
        panelContent: '',
        panelID: undefined,
        panelURL: undefined,
        index: tabs.length,
        enabled: true,
        active: true
      }, options);

      var $panel = $('<section class="coral-TabPanel-pane"/>').append(options.panelContent);

      if (options.panelID !== undefined) {
        $panel.attr('id', options.panelID);
      }

      var $tab = $('<a class="coral-TabPanel-tab" data-toggle="tab"/>').append(options.tabContent);

      if (options.panelURL !== undefined) {
        $tab.attr('href', options.panelURL);
      }

      // Confine the index to valid values.
      var index = Math.min(Math.max(options.index, 0), tabs.length);

      if (index === 0) {
        this.tablist.prepend($tab);
        this.panelist.prepend($panel);
      } else {
        tabs.eq(index - 1).after($tab);
        this._getPanels().eq(index - 1).after($panel);
      }

      if (!options.enabled) {
        $tab.addClass('is-disabled');
      }

      this._makeTabsAccessible($tab);

      if (options.active && options.enabled) {
        this._activateTab($tab, true);
      }

      return $panel.attr('id');
    },

    /**
     * Removes a tab and associated panel. If the tab being removed is
     * the active tab, the nearest enabled tab will be activated.
     * @param {Number} index The index of the tab to remove.
     */
    removeItem: function(indexOrID) {
      var $tabs = this._getTabs(),
        $panels = this._getPanels(),
        $tab, $panel;

      if (typeof indexOrID === 'number') {
        $tab = $tabs.eq(indexOrID);
        $panel = $panels.eq(indexOrID);
      } else if (typeof indexOrID === 'string') {
        $tab = $tabs.filter('[aria-controls="' + indexOrID + '"]');
        $panel = $panels.filter('#' + indexOrID);
      }

      if (!$tab || !$panel) {
        return;
      }

      if ($tab.hasClass('is-active')) {
        var ENABLED_TAB_SELECTOR = '.coral-TabPanel-tab[data-toggle="tab"]:not(.is-disabled)';

        var $tabToActivate = $tab.nextAll(ENABLED_TAB_SELECTOR).first();

        if ($tabToActivate.length === 0) {
          $tabToActivate = $tab.prevAll(ENABLED_TAB_SELECTOR).first();
        }

        if ($tabToActivate.length === 1) {
          this._activateTab($tabToActivate, true);
        }
      }

      $panel.remove();
      $tab.remove();
    },

    /** Internals **/

    // finds or creates the container for the tabs
    /** @ignore **/
    _findOrCreateTabList: function() {
      var element = this.$element.find(SELECTOR_TAB_LIST);
      if (element.length === 0) {
        element = $('<nav>')
            .addClass(CLASS_TAB_LIST)
            .prependTo(this.$element);
      }
      return element;
    },

    // finds or creates the container for the panes that are being
    // switched be the tabs
    /** @ignore **/
    _findOrCreatePaneList: function() {
      var element = this.$element.find(SELECTOR_PANE_LIST);
      if (element.length === 0) {
        element = $('<div>')
            .addClass(CLASS_PANE_LIST)
            .appendTo(this.$element);
      }
      return element;
    },

    // sets all options
    /** @ignore */
    _applyOptions: function () {
      var activeTab = this._getTabs().filter('.is-active');

      // ensure the type is set correctly
      if (this.options.type) {
        this._setType(this.options.type);
      }

      // init tab switch
      this._initTabswitch();

      // accessibility
      this._makeAccessible();

      // set an active tab if there is non flagged as active
      if (activeTab.length === 0) {
        this._setActive(this.options.active || 0);
      } else {
        // call the activation logic
        // in case the initial tab has remote content
        this._activateTab(activeTab, true);
      }
    },

    /**
     * @return {jQuery} All tabs.
     * @private
     * @ignore
     */
    _getTabs: function() {
      return this.tablist.find('> .coral-TabPanel-tab[data-toggle="tab"]');
    },

    /**
     * @return {jQuery} All panels.
     * @private
     * @ignore
     */
    _getPanels: function() {
      return this.panelist.children('.coral-TabPanel-pane');
    },

    // Set a certain tab (by index) as active
    // * @param  {Number} index of the tab to make active
    /** @ignore */
    _setActive: function (idx) {
      idx = $.isNumeric(idx) ? idx : this.options.active;
      var activeTab = this._getTabs().eq(idx);
      // Activate the tab, but don't focus
      this._activateTab(activeTab, true);
    },

    // sets the type of the tabs
    // @param  {String} type of the tabs: 'default', 'nav', 'stacked'
    /** @ignore */
    _setType: function (type) {

      var that = this,
          classValue = $.type(type) === 'string' ? type : this.options.type;

      // applies the variant if the class type i
      if (this.VARIANT_TYPES.indexOf(classValue) > -1 && this.VARIANT_CLASS_MAPPING[classValue] !== undefined) {


        // gets all the class mappings
        var vals = Object.keys(this.VARIANT_CLASS_MAPPING).map(function (key) {
            return that.VARIANT_CLASS_MAPPING[key];
        });
        // removes any additional class
        this.$element.removeClass(vals.join(' '));

        // adds the new type variant
        this.$element.addClass(this.VARIANT_CLASS_MAPPING[classValue]);
      }
    },

    // activates the given tab
    /** @ignore */
    _activateTab: function (tab, noFocus) {
      var href = tab.attr('href'),
        activeClass = 'is-active',
        tabs = this._getTabs(),
        panels = this._getPanels(),
        panel;

      // do not allow to enable disabled tabs
      if (tab.hasClass('is-disabled')) {
        tab.blur(); // ensure disabled tabs do not receive focus
        return false;
      }

      // get panel based on aria control attribute
      panel = panels.filter('#' + tab.attr('aria-controls'));

      // supposed to be remote url
      if (href && href.charAt(0) !== '#') {
        panel.loadWithSpinner(href);
      }

      tabs.removeClass(activeClass).attr({
        'aria-selected': false,
        'tabindex': -1 // just the active one is able to tabbed
      });
      panels.removeClass(activeClass).attr({
        'aria-hidden': true
      });

      tab.addClass(activeClass).attr({
        'aria-selected': true,
        'tabindex': 0 // just the active one is able to tabbed
      });
      panel.addClass(activeClass).attr({
        'aria-hidden': false
      });

      if (!noFocus) {
        tab.trigger('focus');
      }
    }, // _activateTab

    // add the switching functionality
    /** @ignore */
    _initTabswitch: function () {
      var self = this,
        sel = '> .coral-TabPanel-navigation > .coral-TabPanel-tab[data-toggle="tab"]';

      this.$element.on('click', sel,function (event) {
        var tab = $(event.currentTarget);

        // prevent the default anchor
        event.preventDefault();

        self._activateTab(tab);
      });
    }, // _initTabswitch

    // adds some accessibility attributes and features
    // http://www.w3.org/WAI/PF/aria-practices/#tabpanel
    /** @ignore */
    _makeAccessible: function () {
      this._makeTabsAccessible();
      this._makeTablistAccessible();
    }, // _makeAccessible

    /**
     * Adds accessibility attributes and features for the tabs.
     * @private
     * @ignore
     */
    _makeTabsAccessible: function($tabs) {
      var $panels = this._getPanels();
      $tabs = $tabs || this._getTabs();

      // set tab props
      $tabs.each(function (i, e) {
        var $tab = $(e),
          $panel = $panels.eq($tab.index()),
          id = $panel.attr('id') || CUI.util.getNextId();

        var tabAttrs = {
          'role': 'tab',
          'tabindex': -1,
          'aria-selected': false,
          'aria-controls': id,
          'aria-disabled': $tab.hasClass('is-disabled')
        };

        if (!$tab.attr('href')) {
          // Mainly so the cursor turns the mouse into a hand
          // on hover.
          tabAttrs.href = '#';
        }

        $tab.attr(tabAttrs);

        $panel.attr({
          'id': id,
          'role': 'tabpanel',
          'aria-hidden': true
        });
      });
    },

    /**
     * Adds accessibility attributes and features for the tab list.
     * @private
     * @ignore
     */
    _makeTablistAccessible: function() {
      // init the key handling for tabs
      var self = this,
          tabSelector = '> [role="tab"]';

      // the nav around the tabs has a tablist role
      this.tablist.attr('role', 'tablist');

      // keyboard handling
      this.tablist.on('keydown', tabSelector, function (event) {
        // enables keyboard support

        var elem = $(event.currentTarget),
          tabs = $(event.delegateTarget)
            .find(tabSelector)
            .not('[aria-disabled="true"]'), // ignore disabled tabs
          focusElem = elem,
          keymatch = true,
          idx = tabs.index(elem);

        switch (event.which) {
          case 33: //page up
          case 37: //left arrow
          case 38: //up arrow
            focusElem = idx - 1 > -1 ? tabs[idx - 1] : tabs[tabs.length - 1];
            break;
          case 34: //page down
          case 39: //right arrow
          case 40: //down arrow
            focusElem = idx + 1 < tabs.length ? tabs[idx + 1] : tabs[0];
            break;
          case 36: //home
            focusElem = tabs[0];
            break;
          case 35: //end
            focusElem = tabs[tabs.length - 1];
            break;
          default:
            keymatch = false;
            break;
        }

        if (keymatch) { // if a key matched then we set the currently focused element
          event.preventDefault();
          self._activateTab($(focusElem));
        }
      });
    }
  });

  CUI.Widget.registry.register("tabs", CUI.Tabs);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.Tabs.init($('[data-init~=tabs]', event.target));
    });
  }

}(jQuery, this));
