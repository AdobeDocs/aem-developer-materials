<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14) on Wed Dec 06 14:36:20 UTC 2023 -->
<title>com.google.common.eventbus (The Adobe Experience Manager SDK 2023.12.14538.20231205T165334Z-231100)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2023-12-06">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.google.common.eventbus (The Adobe Experience Manager SDK 2023.12.14538.20231205T165334Z-231100)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<main role="main">
<div class="header">
<h1 title="Package" class="title">Package&nbsp;com.google.common.eventbus</h1>
</div>
<div class="contentContainer">
<section role="region"><a id="package.description">
<!--   -->
</a>
<div class="block">The EventBus allows publish-subscribe-style communication between components
 without requiring the components to explicitly register with one another
 (and thus be aware of each other).  It is designed exclusively to replace
 traditional Java in-process event distribution using explicit registration.
 It is <em>not</em> a general-purpose publish-subscribe system, nor is it
 intended for interprocess communication.
 
 <p>See the Guava User Guide article on <a href="http://code.google.com/p/guava-libraries/wiki/EventBusExplained">
 <code>EventBus</code></a>.

 <h2>One-Minute Guide</h2>

 <p>Converting an existing EventListener-based system to use the EventBus is
 easy.

 <h3>For Listeners</h3>
 <p>To listen for a specific flavor of event (say, a CustomerChangeEvent)...
 <ul>
 <li><strong>...in traditional Java events:</strong> implement an interface
     defined with the event &mdash; such as CustomerChangeEventListener.</li>
 <li><strong>...with EventBus:</strong> create a method that accepts
     CustomerChangeEvent as its sole argument, and mark it with the
     <a href="Subscribe.html" title="annotation in com.google.common.eventbus"><code>Subscribe</code></a> annotation.</li>
 </ul>

 <p>To register your listener methods with the event producers...
 <ul>
 <li><strong>...in traditional Java events:</strong> pass your object to each
     producer's <code>registerCustomerChangeEventListener</code> method.  These
     methods are rarely defined in common interfaces, so in addition to
     knowing every possible producer, you must also know its type.</li>
 <li><strong>...with EventBus:</strong> pass your object to the
     <a href="EventBus.html#register(java.lang.Object)"><code>EventBus.register(Object)</code></a> method on an
     EventBus.  You'll need to
     make sure that your object shares an EventBus instance with the event
     producers.</li>
 </ul>

 <p>To listen for a common event supertype (such as EventObject or Object)...
 <ul>
 <li><strong>...in traditional Java events:</strong> not easy.</li>
 <li><strong>...with EventBus:</strong> events are automatically dispatched to
     listeners of any supertype, allowing listeners for interface types
     or "wildcard listeners" for Object.</li>
 </ul>

 <p>To listen for and detect events that were dispatched without listeners...
 <ul>
 <li><strong>...in traditional Java events:</strong> add code to each
     event-dispatching method (perhaps using AOP).</li>
 <li><strong>...with EventBus:</strong> subscribe to <a href="DeadEvent.html" title="class in com.google.common.eventbus"><code>DeadEvent</code></a>.  The
     EventBus will notify you of any events that were posted but not
     delivered.  (Handy for debugging.)</li>
 </ul>

 <h3>For Producers</h3>
 <p>To keep track of listeners to your events...
 <ul>
 <li><strong>...in traditional Java events:</strong> write code to manage
     a list of listeners to your object, including synchronization, or use a
     utility class like EventListenerList.</li>
 <li><strong>...with EventBus:</strong> EventBus does this for you.</li>
 </ul>

 <p>To dispatch an event to listeners...
 <ul>
 <li><strong>...in traditional Java events:</strong> write a method to
     dispatch events to each event listener, including error isolation and
     (if desired) asynchronicity.</li>
 <li><strong>...with EventBus:</strong> pass the event object to an EventBus's
     <a href="EventBus.html#post(java.lang.Object)"><code>EventBus.post(Object)</code></a> method.</li>
 </ul>

 <h2>Glossary</h2>

 <p>The EventBus system and code use the following terms to discuss event
 distribution:
 <dl>
 <dt>Event</dt><dd>Any object that may be <em>posted</em> to a bus.</dd>
 <dt>Subscribing</dt><dd>The act of registering a <em>listener</em> with an
     EventBus, so that its <em>handler methods</em> will receive events.</dd>
 <dt>Listener</dt><dd>An object that wishes to receive events, by exposing
     <em>handler methods</em>.</dt>
 <dt>Handler method</dt><dd>A public method that the EventBus should use to
     deliver <em>posted</em> events.  Handler methods are marked by the
     <a href="Subscribe.html" title="annotation in com.google.common.eventbus"><code>Subscribe</code></a> annotation.</dd>
 <dt>Posting an event</dt><dd>Making the event available to any
     <em>listeners</em> through the EventBus.</dt>
 </dl>

 <h2>FAQ</h2>
 <h3>Why must I create my own Event Bus, rather than using a singleton?</h3>

 <p>The Event Bus doesn't specify how you use it; there's nothing stopping your
 application from having separate EventBus instances for each component, or
 using separate instances to separate events by context or topic.  This also
 makes it trivial to set up and tear down EventBus objects in your tests.

 <p>Of course, if you'd like to have a process-wide EventBus singleton,
 there's nothing stopping you from doing it that way.  Simply have your
 container (such as Guice) create the EventBus as a singleton at global scope
 (or stash it in a static field, if you're into that sort of thing).

 <p>In short, the EventBus is not a singleton because we'd rather not make
 that decision for you.  Use it how you like.

 <h3>Why use an annotation to mark handler methods, rather than requiring the
 listener to implement an interface?</h3>
 <p>We feel that the Event Bus's <code>@Subscribe</code> annotation conveys your
 intentions just as explicitly as implementing an interface (or perhaps more
 so), while leaving you free to place event handler methods wherever you wish
 and give them intention-revealing names.

 <p>Traditional Java Events use a listener interface which typically sports
 only a handful of methods -- typically one.  This has a number of
 disadvantages:
 <ul>
   <li>Any one class can only implement a single response to a given event.
   <li>Listener interface methods may conflict.
   <li>The method must be named after the event (e.g. <code>
       handleChangeEvent</code>), rather than its purpose (e.g. <code>
       recordChangeInJournal</code>).
   <li>Each event usually has its own interface, without a common parent
       interface for a family of events (e.g. all UI events).
 </ul>

 <p>The difficulties in implementing this cleanly has given rise to a pattern,
 particularly common in Swing apps, of using tiny anonymous classes to
 implement event listener interfaces.

 <p>Compare these two cases: <pre>
   class ChangeRecorder {
     void setCustomer(Customer cust) {
       cust.addChangeListener(new ChangeListener() {
         void customerChanged(ChangeEvent e) {
           recordChange(e.getChange());
         }
       };
     }
   }

   // Class is typically registered by the container.
   class EventBusChangeRecorder {
     &#064;Subscribe void recordCustomerChange(ChangeEvent e) {
       recordChange(e.getChange());
     }
   }</pre>

 <p>The intent is actually clearer in the second case: there's less noise code,
 and the event handler has a clear and meaningful name.

 <h3>What about a generic <code>Handler&lt;T&gt;</code> interface?</h3>
 <p>Some have proposed a generic <code>Handler&lt;T&gt;</code> interface for EventBus
 listeners.  This runs into issues with Java's use of type erasure, not to
 mention problems in usability.

 <p>Let's say the interface looked something like the following: <pre>   <code>
   interface Handler&lt;T&gt; {
     void handleEvent(T event);
   }</code></pre>

 <p>Due to erasure, no single class can implement a generic interface more than
 once with different type parameters.  This is a giant step backwards from
 traditional Java Events, where even if <code>actionPerformed</code> and <code>
 keyPressed</code> aren't very meaningful names, at least you can implement both
 methods!

 <h3>Doesn't EventBus destroy static typing and eliminate automated
 refactoring support?</h3>
 <p>Some have freaked out about EventBus's <code>register(Object)</code> and <code>
 post(Object)</code> methods' use of the <code>Object</code> type.

 <p><code>Object</code> is used here for a good reason: the Event Bus library
 places no restrictions on the types of either your event listeners (as in
 <code>register(Object)</code>) or the events themselves (in <code>post(Object)</code>).

 <p>Event handler methods, on the other hand, must explicitly declare their
 argument type -- the type of event desired (or one of its supertypes).  Thus,
 searching for references to an event class will instantly find all handler
 methods for that event, and renaming the type will affect all handler methods
 within view of your IDE (and any code that creates the event).

 <p>It's true that you can rename your <code>@Subscribed</code> event handler
 methods at will; Event Bus will not stop this or do anything to propagate the
 rename because, to Event Bus, the names of your handler methods are
 irrelevant.  Test code that calls the methods directly, of course, will be
 affected by your renaming -- but that's what your refactoring tools are for.

 <h3>What happens if I <code>register</code> a listener without any handler
 methods?</h3>
 <p>Nothing at all.

 <p>The Event Bus was designed to integrate with containers and module
 systems, with Guice as the prototypical example.  In these cases, it's
 convenient to have the container/factory/environment pass <i>every</i>
 created object to an EventBus's <code>register(Object)</code> method.

 <p>This way, any object created by the container/factory/environment can
 hook into the system's event model simply by exposing handler methods.

 <h3>What Event Bus problems can be detected at compile time?</h3>
 <p>Any problem that can be unambiguously detected by Java's type system.  For
 example, defining a handler method for a nonexistent event type.

 <h3>What Event Bus problems can be detected immediately at registration?</h3>
 <p>Immediately upon invoking <code>register(Object)</code> , the listener being
 registered is checked for the <i>well-formedness</i> of its handler methods.
 Specifically, any methods marked with <code>@Subscribe</code> must take only a
 single argument.

 <p>Any violations of this rule will cause an <code>IllegalArgumentException</code>
 to be thrown.

 <p>(This check could be moved to compile-time using APT, a solution we're
 researching.)

 <h3>What Event Bus problems may only be detected later, at runtime?</h3>
 <p>If a component posts events with no registered listeners, it <i>may</i>
 indicate an error (typically an indication that you missed a
 <code>@Subscribe</code> annotation, or that the listening component is not loaded).

 <p>(Note that this is <i>not necessarily</i> indicative of a problem.  There
 are many cases where an application will deliberately ignore a posted event,
 particularly if the event is coming from code you don't control.)

 <p>To handle such events, register a handler method for the <code>DeadEvent</code>
 class.  Whenever EventBus receives an event with no registered handlers, it
 will turn it into a <code>DeadEvent</code> and pass it your way -- allowing you to
 log it or otherwise recover.

 <h3>How do I test event listeners and their handler methods?</h3>
 <p>Because handler methods on your listener classes are normal methods, you can
 simply call them from your test code to simulate the EventBus.</div>
</section>
<ul class="blockList">
<li class="blockList">
<table class="typeSummary">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="AsyncEventBus.html" title="class in com.google.common.eventbus">AsyncEventBus</a></th>
<td class="colLast">Deprecated.
<div class="deprecationComment">The Google Guava Core Libraries are deprecated and will not be part of the AEM SDK after April 2023</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="DeadEvent.html" title="class in com.google.common.eventbus">DeadEvent</a></th>
<td class="colLast">Deprecated.
<div class="deprecationComment">The Google Guava Core Libraries are deprecated and will not be part of the AEM SDK after April 2023</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="EventBus.html" title="class in com.google.common.eventbus">EventBus</a></th>
<td class="colLast">Deprecated.
<div class="deprecationComment">The Google Guava Core Libraries are deprecated and will not be part of the AEM SDK after April 2023</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary">
<caption><span>Annotation Types Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Annotation Type</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="AllowConcurrentEvents.html" title="annotation in com.google.common.eventbus">AllowConcurrentEvents</a></th>
<td class="colLast">
<div class="block">Marks an event handling method as being thread-safe.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="Subscribe.html" title="annotation in com.google.common.eventbus">Subscribe</a></th>
<td class="colLast">
<div class="block">Marks a method as an event handler, as used by
 <code>AnnotatedHandlerFinder</code> and <a href="EventBus.html" title="class in com.google.common.eventbus"><code>EventBus</code></a>.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &copy; 2010 - 2023 Adobe. All Rights Reserved</small></p>
</footer>
</body>
</html>
